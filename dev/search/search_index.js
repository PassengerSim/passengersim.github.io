var __index = {"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "index.html", "title": "Home", "text": ""}, {"location": "API/index.html", "title": "PassengerSim API", "text": "<p>The main <code>passengersim</code> package includes configuration and analysis tools.  It is freely available for use.</p> <p>The <code>passengersim.core</code> sub-package is only available to authorized users.</p>"}, {"location": "API/contrast.html", "title": "Contrasting Results", "text": ""}, {"location": "API/contrast.html#passengersim.contrast.ForecastOfT", "title": "ForecastOfT  <code>module-attribute</code>", "text": "<pre><code>ForecastOfT = Literal['mu', 'sigma', 'closed', 'adj_price']\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast", "title": "Contrast", "text": "<p>               Bases: <code>dict</code></p> Source code in <code>passengersim/contrast.py</code> <pre><code>class Contrast(dict):\n    def apply(\n        self,\n        func: Callable,\n        axis: int | Literal[\"index\", \"columns\", \"rows\"] = 0,\n        warn_if_missing: bool = False,\n    ) -&gt; pd.DataFrame | pd.Series:\n        data = {}\n        for k, v in self.items():\n            if v is not None:\n                data[k] = func(v)\n            else:\n                if warn_if_missing:\n                    warnings.warn(f\"no data found for {k!r}\", stacklevel=2)\n        try:\n            return pd.concat(data, axis=axis, names=[\"source\"])\n        except TypeError:\n            return pd.Series(data).rename_axis(index=\"source\")\n\n    def __getattr__(self, attr):\n        if attr.startswith(\"fig_\"):\n            g = globals()\n            if attr in g:\n                return partial(g[attr], self)\n                # return lambda *a, **k: g[attr](self, *a, **k)\n        raise AttributeError(attr)\n\n    def __dir__(self):\n        x = set(super().__dir__())\n        x |= {g for g in globals() if g.startswith(\"fig_\")}\n        return sorted(x)\n\n    def write_report(self, filename: str, **kwargs) -&gt; pathlib.Path:\n        from passengersim.reporting.contrast import to_html\n\n        return to_html(self, filename, **kwargs)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.__dir__", "title": "__dir__", "text": "<pre><code>__dir__()\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def __dir__(self):\n    x = set(super().__dir__())\n    x |= {g for g in globals() if g.startswith(\"fig_\")}\n    return sorted(x)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.__getattr__", "title": "__getattr__", "text": "<pre><code>__getattr__(attr)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def __getattr__(self, attr):\n    if attr.startswith(\"fig_\"):\n        g = globals()\n        if attr in g:\n            return partial(g[attr], self)\n            # return lambda *a, **k: g[attr](self, *a, **k)\n    raise AttributeError(attr)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.apply", "title": "apply", "text": "<pre><code>apply(\n    func: Callable,\n    axis: int | Literal[\"index\", \"columns\", \"rows\"] = 0,\n    warn_if_missing: bool = False,\n) -&gt; DataFrame | Series\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def apply(\n    self,\n    func: Callable,\n    axis: int | Literal[\"index\", \"columns\", \"rows\"] = 0,\n    warn_if_missing: bool = False,\n) -&gt; pd.DataFrame | pd.Series:\n    data = {}\n    for k, v in self.items():\n        if v is not None:\n            data[k] = func(v)\n        else:\n            if warn_if_missing:\n                warnings.warn(f\"no data found for {k!r}\", stacklevel=2)\n    try:\n        return pd.concat(data, axis=axis, names=[\"source\"])\n    except TypeError:\n        return pd.Series(data).rename_axis(index=\"source\")\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.write_report", "title": "write_report", "text": "<pre><code>write_report(filename: str, **kwargs) -&gt; Path\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def write_report(self, filename: str, **kwargs) -&gt; pathlib.Path:\n    from passengersim.reporting.contrast import to_html\n\n    return to_html(self, filename, **kwargs)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.MultiContrast", "title": "MultiContrast", "text": "<p>               Bases: <code>dict</code></p> Source code in <code>passengersim/contrast.py</code> <pre><code>class MultiContrast(dict):\n    def __getattr__(self, attr):\n        if attr.startswith(\"fig_\"):\n            g = globals()\n            if attr in g:\n                alter_defaults = {}\n                if attr in [\n                    \"fig_carrier_revenues\",\n                    \"fig_carrier_yields\",\n                    \"fig_carrier_total_bookings\",\n                    \"fig_carrier_load_factors\",\n                ]:\n                    alter_defaults[\"width\"] = 300\n\n                def fig_func(*args, **kwargs):\n                    figs = {}\n                    kwargs.update(alter_defaults)\n                    report = kwargs.pop(\"report\", None)\n                    trace = kwargs.pop(\"trace\", None)\n                    if trace:\n                        raise NotImplementedError(\"trace not implemented\")\n                    for k, v in self.items():\n                        if v is not None:\n                            figs[k] = partial(g[attr], v)(*args, **kwargs)\n                    fig, title = self._hconcat(figs)\n                    if report:\n                        report.add_figure(title=title, fig=fig)\n                    return fig\n\n                return fig_func\n        raise AttributeError(attr)\n\n    def __dir__(self):\n        x = set(super().__dir__())\n        x |= {g for g in globals() if g.startswith(\"fig_\")}\n        return sorted(x)\n\n    @staticmethod\n    def _hconcat(charts: dict[str, alt.Chart]) -&gt; tuple[alt.HConcatChart, str]:\n        if not charts:\n            raise ValueError(\"no charts to concatenate\")\n        queue = []\n        title = \"\"\n        for k, c in charts.items():\n            if c is None:\n                warnings.warn(f\"no data found for {k!r}\", stacklevel=2)\n                continue\n            config = c._kwds.get(\"config\", alt.Undefined)\n            c._kwds[\"config\"] = alt.Undefined\n            title = c._kwds.get(\"title\", \"\")\n            c._kwds[\"title\"] = f\"{k} {title}\"\n            queue.append(c)\n        if not queue:\n            raise ValueError(\"no charts to concatenate\")\n        result = alt.hconcat(*queue)\n        result._kwds[\"config\"] = config\n        return result, title\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.MultiContrast.__dir__", "title": "__dir__", "text": "<pre><code>__dir__()\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def __dir__(self):\n    x = set(super().__dir__())\n    x |= {g for g in globals() if g.startswith(\"fig_\")}\n    return sorted(x)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.MultiContrast.__getattr__", "title": "__getattr__", "text": "<pre><code>__getattr__(attr)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def __getattr__(self, attr):\n    if attr.startswith(\"fig_\"):\n        g = globals()\n        if attr in g:\n            alter_defaults = {}\n            if attr in [\n                \"fig_carrier_revenues\",\n                \"fig_carrier_yields\",\n                \"fig_carrier_total_bookings\",\n                \"fig_carrier_load_factors\",\n            ]:\n                alter_defaults[\"width\"] = 300\n\n            def fig_func(*args, **kwargs):\n                figs = {}\n                kwargs.update(alter_defaults)\n                report = kwargs.pop(\"report\", None)\n                trace = kwargs.pop(\"trace\", None)\n                if trace:\n                    raise NotImplementedError(\"trace not implemented\")\n                for k, v in self.items():\n                    if v is not None:\n                        figs[k] = partial(g[attr], v)(*args, **kwargs)\n                fig, title = self._hconcat(figs)\n                if report:\n                    report.add_figure(title=title, fig=fig)\n                return fig\n\n            return fig_func\n    raise AttributeError(attr)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_bid_price_history", "title": "fig_bid_price_history", "text": "<pre><code>fig_bid_price_history(\n    summaries,\n    *,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df: bool = False,\n    title: str | None = \"Bid Price History\",\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_bid_price_history(\n    summaries,\n    *,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df: bool = False,\n    title: str | None = \"Bid Price History\",\n):\n    if cap is None:\n        bp_mean = \"bid_price_mean\"\n    elif cap == \"some\":\n        bp_mean = \"some_cap_bid_price_mean\"\n    elif cap == \"zero\":\n        bp_mean = \"zero_cap_bid_price_mean\"\n    else:\n        raise ValueError(f\"cap={cap!r} not in ['some', 'zero', None]\")\n\n    if not isinstance(by_carrier, str) and show_stdev:\n        raise NotImplementedError(\n            \"contrast.fig_bid_price_history with show_stdev requires \"\n            \"looking at a single carrier (set `by_carrier`)\"\n        )\n    df = _assemble(\n        summaries,\n        \"bid_price_history\",\n        by_carrier=by_carrier,\n        show_stdev=show_stdev,\n        cap=cap,\n    )\n    if raw_df:\n        return df\n\n    line_encoding = dict(\n        x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n        y=alt.Y(bp_mean, title=\"Bid Price\"),\n        color=\"source:N\",\n    )\n    chart = alt.Chart(df)\n    fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n    if show_stdev:\n        area_encoding = dict(\n            x=alt.X(\"days_prior:Q\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"),\n            y2=alt.Y2(\"bid_price_upper:Q\", title=\"Bid Price\"),\n            color=\"source:N\",\n        )\n        bound = chart.mark_area(\n            opacity=0.1,\n            interpolate=\"step-before\",\n        ).encode(**area_encoding)\n        bound_line = chart.mark_line(\n            opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\"\n        ).encode(\n            x=alt.X(\"days_prior:Q\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            color=\"source:N\",\n        )\n        top_line = bound_line.encode(y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"))\n        bottom_line = bound_line.encode(y=alt.Y(\"bid_price_upper:Q\", title=\"Bid Price\"))\n        fig = fig + bound + top_line + bottom_line\n    if not isinstance(by_carrier, str):\n        fig = fig.properties(height=125, width=225).facet(facet=\"carrier:N\", columns=2)\n        if title:\n            fig = fig.properties(title=title)\n    else:\n        if title:\n            title = f\"{title} ({by_carrier})\"\n            fig = fig.properties(title=title)\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_bookings_by_timeframe", "title": "fig_bookings_by_timeframe", "text": "<pre><code>fig_bookings_by_timeframe(\n    summaries: dict[str, SummaryTables],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df=False,\n    source_labels: bool = False,\n    ratio: str | bool = False,\n) -&gt; Chart | DataFrame\n</code></pre> <p>Generate a figure contrasting bookings by timeframe for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            <p>One or more SummaryTables to compare. The keys of this dictionary are the text names used to label the \"source\" for each set of data in the figure.</p> </li> <li> <code>by_carrier</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>Whether to differentiate carriers by colors (the default) or give the name of a particular carrier as a string to filter the results shown in the figure to only that one carrier.</p> </li> <li> <code>by_class</code>               (<code>bool or str</code>, default:                   <code>False</code> )           \u2013            <p>Whether to differentiate booking class by colors (the default) or give the name of a particular booking class as a string to filter the results shown in the figure to only that one booking class.</p> </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Set to true to return the raw dataframe used to generate the figure, instead of the figure itself.</p> </li> <li> <code>source_labels</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Write source labels above the columns of the figure. Source labels are also available as tool tips, but if the figure is being shared as an image without tooltips, the source labels may make it easier to interpret.</p> </li> <li> <code>ratio</code>               (<code>str or bool</code>, default:                   <code>False</code> )           \u2013            <p>Compute ratios against a reference point and display them in tooltips.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>report</code>               (<code>Reporter</code>)           \u2013            <p>Giving a reporter for this keyword only argument allow you to automatically append this figure to the report (in addition to returning it for display or other processing).</p> </li> <li> <code>trace</code>               (<code>ExcelWriter or (ExcelWriter, str)</code>)           \u2013            <p>Write the raw dataframe backing this figure to the Excel workbook.</p> </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_bookings_by_timeframe(\n    summaries: dict[str, SummaryTables],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df=False,\n    source_labels: bool = False,\n    ratio: str | bool = False,\n) -&gt; alt.Chart | pd.DataFrame:\n    \"\"\"\n    Generate a figure contrasting bookings by timeframe for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n        One or more SummaryTables to compare. The keys of this dictionary are the\n        text names used to label the \"source\" for each set of data in the figure.\n    by_carrier : bool or str, default True\n        Whether to differentiate carriers by colors (the default) or give the name\n        of a particular carrier as a string to filter the results shown in the\n        figure to only that one carrier.\n    by_class : bool or str, default False\n        Whether to differentiate booking class by colors (the default) or give the\n        name of a particular booking class as a string to filter the results shown\n        in the figure to only that one booking class.\n    raw_df : bool, default False\n        Set to true to return the raw dataframe used to generate the figure, instead\n        of the figure itself.\n    source_labels : bool, default False\n        Write source labels above the columns of the figure. Source labels are also\n        available as tool tips, but if the figure is being shared as an image without\n        tooltips, the source labels may make it easier to interpret.\n    ratio : str or bool, default False\n        Compute ratios against a reference point and display them in tooltips.\n\n    Other Parameters\n    ----------------\n    report : xmle.Reporter, optional\n        Giving a reporter for this keyword only argument allow you to automatically\n        append this figure to the report (in addition to returning it for display\n        or other processing).\n    trace : pd.ExcelWriter or (pd.ExcelWriter, str), optional\n        Write the raw dataframe backing this figure to the Excel workbook.\n    \"\"\"\n    if by_carrier is True and by_class is True:\n        raise NotImplementedError(\"comparing by both class and carrier is messy\")\n    df = _assemble(\n        summaries, \"bookings_by_timeframe\", by_carrier=by_carrier, by_class=by_class\n    )\n    source_order = list(summaries.keys())\n\n    title = \"Bookings by Timeframe\"\n    if by_class is True:\n        title = \"Bookings by Timeframe and Booking Class\"\n    title_annot = []\n    if isinstance(by_carrier, str):\n        title_annot.append(by_carrier)\n    if isinstance(by_class, str):\n        title_annot.append(f\"Class {by_class}\")\n    if title_annot:\n        title = f\"{title} ({', '.join(title_annot)})\"\n\n    against = source_order[0]\n    ratio_tooltips = ()\n    if ratio:\n        if isinstance(ratio, str):\n            against = ratio\n        idx = list(\n            {\"source\", \"carrier\", \"segment\", \"days_prior\", \"booking_class\"}\n            &amp; set(df.columns)\n        )\n        df_ = df.set_index(idx)\n        ratios = df_.div(df_.query(f\"source == '{against}'\").droplevel(\"source\")) - 1.0\n        ratios.columns = [\"ratio\"]\n        df = df.join(ratios, on=idx)\n        ratio_tooltips = (alt.Tooltip(\"ratio:Q\", title=f\"vs {against}\", format=\".3%\"),)\n\n    if raw_df:\n        df.attrs[\"title\"] = title\n        return df\n\n    if by_class:\n        if isinstance(by_class, str):\n            color = alt.Color(\"source:N\", title=\"Source\", sort=source_order).title(\n                \"Source\"\n            )\n            tooltips = ()\n        else:\n            color = alt.Color(\"booking_class:N\").title(\"Booking Class\")\n            tooltips = (alt.Tooltip(\"booking_class\", title=\"Booking Class\"),)\n        chart = alt.Chart(df.sort_values(\"source\", ascending=False))\n        chart_1 = chart.mark_bar().encode(\n            color=color,\n            x=alt.X(\"days_prior:O\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n            y=alt.Y(\"bookings\", stack=True),\n            tooltip=[\n                alt.Tooltip(\"source:N\", title=\"Source\"),\n                alt.Tooltip(\"segment\", title=\"Passenger Segment\"),\n                *tooltips,\n                alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                alt.Tooltip(\"bookings\", format=\".2f\"),\n                *ratio_tooltips,\n            ],\n        )\n        chart_2 = chart.mark_text(\n            color=\"#616161\",\n            yOffset=-2,\n            angle=270,\n            fontSize=8,\n            baseline=\"middle\",\n            align=\"left\",\n        ).encode(\n            text=alt.Text(\"source:N\", title=\"Source\"),\n            x=alt.X(\"days_prior:O\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n            # shape=alt.Shape(\"source:N\", title=\"Source\", sort=source_order),\n            y=alt.Y(\"sum(bookings)\", title=None),\n        )\n        return (\n            ((chart_1 + chart_2) if source_labels else chart_1)\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"segment:N\", title=\"Passenger Segment\"),\n                title=title,\n            )\n        )\n    elif by_carrier is True:\n        return (\n            alt.Chart(df.sort_values(\"source\", ascending=False))\n            .mark_bar()\n            .encode(\n                color=alt.Color(\"carrier:N\").title(\"Carrier\"),\n                x=alt.X(\"days_prior:O\")\n                .scale(reverse=True)\n                .title(\"Days Prior to Departure\"),\n                xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n                y=alt.Y(\"bookings\", stack=True),\n                tooltip=[\n                    alt.Tooltip(\"source:N\", title=\"Source\"),\n                    alt.Tooltip(\"segment\", title=\"Passenger Segment\"),\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                    alt.Tooltip(\"bookings\", format=\".2f\"),\n                    *ratio_tooltips,\n                ],\n            )\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"segment:N\", title=\"Passenger Segment\"),\n                title=title,\n            )\n        )\n    else:\n        return (\n            alt.Chart(df.sort_values(\"source\", ascending=False), title=title)\n            .mark_line()\n            .encode(\n                color=alt.Color(\"source:N\", title=\"Source\", sort=source_order),\n                x=alt.X(\"days_prior:O\")\n                .scale(reverse=True)\n                .title(\"Days Prior to Departure\"),\n                y=\"bookings\",\n                strokeDash=alt.StrokeDash(\"segment\").title(\"Passenger Segment\"),\n                strokeWidth=alt.StrokeWidth(\n                    \"source:N\", title=\"Source\", sort=source_order\n                ),\n                tooltip=[\n                    alt.Tooltip(\"source:N\", title=\"Source\"),\n                    alt.Tooltip(\"segment\", title=\"Passenger Segment\"),\n                    alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                    alt.Tooltip(\"bookings\", format=\".2f\"),\n                    *ratio_tooltips,\n                ],\n            )\n            .properties(\n                width=500,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_load_factors", "title": "fig_carrier_load_factors", "text": "<pre><code>fig_carrier_load_factors(\n    summaries: dict[str, SummaryTables],\n    raw_df: bool = False,\n    load_measure: Literal[\n        \"sys_lf\", \"avg_leg_lf\"\n    ] = \"sys_lf\",\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n)\n</code></pre> <p>Generate a figure contrasting carrier load factors for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>load_measure</code>               (<code>(sys_lf, avg_leg_lf)</code>, default:                   <code>'sys_lf'</code> )           \u2013            </li> <li> <code>orient</code>               (<code>(h, v)</code>, default:                   <code>'h'</code> )           \u2013            </li> <li> <code>ratio</code>               (<code>bool or str</code>, default:                   <code>\"all\"</code> )           \u2013            <p>Add tooltip(s) giving the percentage change of each carrier's load factor to the load factor of the same carrier in the other summaries.  Can be the key giving a specific summary to compare against, or 'all' to compare against all other summaries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_load_factors(\n    summaries: dict[str, SummaryTables],\n    raw_df: bool = False,\n    load_measure: Literal[\"sys_lf\", \"avg_leg_lf\"] = \"sys_lf\",\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n):\n    \"\"\"\n    Generate a figure contrasting carrier load factors for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n    raw_df : bool, default False\n    load_measure : {'sys_lf', 'avg_leg_lf'}, default 'sys_lf'\n    orient : {'h', 'v'}, default 'h'\n    ratio : bool or str, default \"all\"\n        Add tooltip(s) giving the percentage change of each carrier's load factor\n        to the load factor of the same carrier in the other summaries.  Can be\n        the key giving a specific summary to compare against, or 'all' to\n        compare against all other summaries.\n\n\n    Returns\n    -------\n    alt.Chart or pd.DataFrame\n    \"\"\"\n    measure_name = {\n        \"sys_lf\": \"System Load Factor\",\n        \"avg_leg_lf\": \"Leg Load factor\",\n    }.get(load_measure, \"Load Factor\")\n    df = _assemble(summaries, \"carrier_load_factors\", load_measure=load_measure)\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = f\"Carrier {measure_name}s\"\n        return df\n    return _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=load_measure,\n        measure_name=measure_name,\n        measure_format=\".2f\",\n        orient=orient,\n        title=f\"Carrier {measure_name}s\",\n        ratio=ratio,\n        ratio_all=(ratio == \"all\"),\n        width=width,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_local_share", "title": "fig_carrier_local_share", "text": "<pre><code>fig_carrier_local_share(\n    summaries,\n    load_measure: Literal[\n        \"bookings\", \"leg_pax\"\n    ] = \"bookings\",\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n)\n</code></pre> <p>Generate a figure contrasting carrier local shares for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>orient</code>               (<code>(h, v)</code>, default:                   <code>'h'</code> )           \u2013            </li> <li> <code>ratio</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>Add tooltip(s) giving the percentage change of each carrier's local share to the local share of the same carrier in the other summaries.  Can be the key giving a specific summary to compare against, or 'all' to compare against all other summaries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_local_share(\n    summaries,\n    load_measure: \"Literal['bookings', 'leg_pax']\" = \"bookings\",\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n):\n    \"\"\"\n    Generate a figure contrasting carrier local shares for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n    raw_df : bool, default False\n    orient : {'h', 'v'}, default 'h'\n    ratio : bool or str, default True\n        Add tooltip(s) giving the percentage change of each carrier's local share\n        to the local share of the same carrier in the other summaries.  Can be\n        the key giving a specific summary to compare against, or 'all' to\n        compare against all other summaries.\n\n    Returns\n    -------\n    alt.Chart or pd.DataFrame\n    \"\"\"\n    measure_name = (\n        \"Local Percent of Bookings\"\n        if load_measure == \"bookings\"\n        else \"Local Percent of Leg Passengers\"\n    )\n    m = \"local_pct_bookings\" if load_measure == \"bookings\" else \"local_pct_leg_pax\"\n    df = _assemble(summaries, \"carrier_local_share\", load_measure=load_measure)\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier RASM\"\n        return df\n    return _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=m,\n        measure_name=measure_name,\n        measure_format=\".2f\",\n        orient=orient,\n        title=f\"Carrier {measure_name}\",\n        ratio=ratio,\n        ratio_all=(ratio == \"all\"),\n        width=width,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_rasm", "title": "fig_carrier_rasm", "text": "<pre><code>fig_carrier_rasm(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n)\n</code></pre> <p>Generate a figure contrasting carrier RASM for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>orient</code>               (<code>(h, v)</code>, default:                   <code>'h'</code> )           \u2013            </li> <li> <code>ratio</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>Add tooltip(s) giving the percentage change of each carrier's yield to the yield of the same carrier in the other summaries.  Can be the key giving a specific summary to compare against, or 'all' to compare against all other summaries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_rasm(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n):\n    \"\"\"\n    Generate a figure contrasting carrier RASM for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n    raw_df : bool, default False\n    orient : {'h', 'v'}, default 'h'\n    ratio : bool or str, default True\n        Add tooltip(s) giving the percentage change of each carrier's yield\n        to the yield of the same carrier in the other summaries.  Can be\n        the key giving a specific summary to compare against, or 'all' to\n        compare against all other summaries.\n\n    Returns\n    -------\n    alt.Chart or pd.DataFrame\n    \"\"\"\n    df = _assemble(summaries, \"carrier_rasm\")\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier RASM\"\n        return df\n    return _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=\"rasm\",\n        measure_name=\"Revenue per Available Seat Mile\",\n        measure_format=\"$.4f\",\n        orient=orient,\n        title=\"Carrier Revenue per Available Seat Mile (RASM)\",\n        ratio=ratio,\n        ratio_all=(ratio == \"all\"),\n        width=width,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_revenues", "title": "fig_carrier_revenues", "text": "<pre><code>fig_carrier_revenues(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n)\n</code></pre> <p>Generate a figure contrasting carrier revenues for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>orient</code>               (<code>(h, v)</code>, default:                   <code>'h'</code> )           \u2013            </li> <li> <code>ratio</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>Add tooltip(s) giving the percentage change of each carrier's revenue to the revenue of the same carrier in the other summaries.  Can be the key giving a specific summary to compare against, or 'all' to compare against all other summaries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_revenues(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n):\n    \"\"\"\n    Generate a figure contrasting carrier revenues for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n    raw_df : bool, default False\n    orient : {'h', 'v'}, default 'h'\n    ratio : bool or str, default True\n        Add tooltip(s) giving the percentage change of each carrier's revenue\n        to the revenue of the same carrier in the other summaries.  Can be\n        the key giving a specific summary to compare against, or 'all' to\n        compare against all other summaries.\n\n    Returns\n    -------\n    alt.Chart or pd.DataFrame\n    \"\"\"\n    df = _assemble(summaries, \"carrier_revenues\")\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Revenues\"\n        return df\n    return _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=\"avg_rev\",\n        measure_name=\"Revenue ($)\",\n        measure_format=\"$.4s\",\n        orient=orient,\n        title=\"Carrier Revenues\",\n        ratio=ratio,\n        ratio_all=(ratio == \"all\"),\n        width=width,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_total_bookings", "title": "fig_carrier_total_bookings", "text": "<pre><code>fig_carrier_total_bookings(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n)\n</code></pre> <p>Generate a figure contrasting carrier total bookings for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>orient</code>               (<code>(h, v)</code>, default:                   <code>'h'</code> )           \u2013            </li> <li> <code>ratio</code>               (<code>bool or str</code>, default:                   <code>\"all\"</code> )           \u2013            <p>Add tooltip(s) giving the percentage change of each carrier's bookings to the bookings of the same carrier in the other summaries.  Can be the key giving a specific summary to compare against, or 'all' to compare against all other summaries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_total_bookings(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n):\n    \"\"\"\n    Generate a figure contrasting carrier total bookings for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n    raw_df : bool, default False\n    orient : {'h', 'v'}, default 'h'\n    ratio : bool or str, default \"all\"\n        Add tooltip(s) giving the percentage change of each carrier's bookings\n        to the bookings of the same carrier in the other summaries.  Can be\n        the key giving a specific summary to compare against, or 'all' to\n        compare against all other summaries.\n\n    Returns\n    -------\n    alt.Chart or pd.DataFrame\n    \"\"\"\n\n    df = _assemble(summaries, \"carrier_total_bookings\")\n    # correct for variable name differences; the \"avg_sold\" column\n    # is called \"sold\" in some older summaries\n    if \"sold\" in df.columns:\n        if \"avg_sold\" in df.columns:\n            df[\"avg_sold\"] = df[\"avg_sold\"].fillna(df[\"sold\"])\n            df = df.drop(columns=\"sold\")\n        else:\n            df = df.rename(columns={\"sold\": \"avg_sold\"})\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Total Bookings\"\n        return df\n    return _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=\"avg_sold\",\n        measure_name=\"Bookings\",\n        measure_format=\".4s\",\n        orient=orient,\n        title=\"Carrier Total Bookings\",\n        ratio=ratio,\n        ratio_all=(ratio == \"all\"),\n        width=width,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_yields", "title": "fig_carrier_yields", "text": "<pre><code>fig_carrier_yields(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n)\n</code></pre> <p>Generate a figure contrasting carrier yields for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>orient</code>               (<code>(h, v)</code>, default:                   <code>'h'</code> )           \u2013            </li> <li> <code>ratio</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>Add tooltip(s) giving the percentage change of each carrier's yield to the yield of the same carrier in the other summaries.  Can be the key giving a specific summary to compare against, or 'all' to compare against all other summaries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_yields(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n):\n    \"\"\"\n    Generate a figure contrasting carrier yields for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n    raw_df : bool, default False\n    orient : {'h', 'v'}, default 'h'\n    ratio : bool or str, default True\n        Add tooltip(s) giving the percentage change of each carrier's yield\n        to the yield of the same carrier in the other summaries.  Can be\n        the key giving a specific summary to compare against, or 'all' to\n        compare against all other summaries.\n\n    Returns\n    -------\n    alt.Chart or pd.DataFrame\n    \"\"\"\n\n    df = _assemble(summaries, \"carrier_yields\")\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Yields\"\n        return df\n    return _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=\"yield\",\n        measure_name=\"Yield ($)\",\n        measure_format=\"$.4f\",\n        orient=orient,\n        title=\"Carrier Yields\",\n        ratio=ratio,\n        ratio_all=(ratio == \"all\"),\n        width=width,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_demand_to_come", "title": "fig_demand_to_come", "text": "<pre><code>fig_demand_to_come(\n    summaries: Contrast,\n    func: Literal[\"mean\", \"std\"]\n    | list[Literal[\"mean\", \"std\"]] = \"mean\",\n    *,\n    raw_df=False,\n    title: str | None = \"Demand to Come\",\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_demand_to_come(\n    summaries: Contrast,\n    func: Literal[\"mean\", \"std\"] | list[Literal[\"mean\", \"std\"]] = \"mean\",\n    *,\n    raw_df=False,\n    title: str | None = \"Demand to Come\",\n):\n    def dtc_seg(s):\n        if s is None:\n            return pd.DataFrame(columns=[\"segment\"])\n        sum_on = []\n        if \"orig\" in s.index.names:\n            sum_on.append(\"orig\")\n        if \"dest\" in s.index.names:\n            sum_on.append(\"dest\")\n        if sum_on:\n            s = s.groupby(s.index.names.difference(sum_on)).sum()\n        return s\n\n    def get_values(s, which=\"mean\"):\n        if isinstance(s, SummaryTables):\n            result = getattr(s, \"demand_to_come_summary\", None)\n            if result is None:\n                result = dtc_seg(s.demand_to_come).groupby(\"segment\", observed=False)\n                result = result.mean() if which == \"mean\" else result.std()\n                result = result.stack()\n                return result\n            else:\n                if which == \"mean\":\n                    return result[\"mean_future_demand\"]\n                elif which == \"std\":\n                    return result[\"stdev_future_demand\"]\n                else:\n                    raise ValueError(f\"which must be in [mean, std] not {which}\")\n        elif isinstance(s, SimTabDemandToCome):\n            result = s.demand_to_come_summary\n            if which == \"mean\":\n                return result[\"mean_future_demand\"]\n            elif which == \"std\":\n                return result[\"stdev_future_demand\"]\n            else:\n                raise ValueError(f\"which must be in [mean, std] not {which}\")\n\n    if isinstance(func, list):\n        if raw_df:\n            raise NotImplementedError\n        fig = fig_demand_to_come(summaries, func[0], raw_df=raw_df, title=None)\n        for f in func[1:]:\n            fig |= fig_demand_to_come(summaries, f, raw_df=raw_df, title=None)\n        if title:\n            fig = fig.properties(title=title)\n        return fig\n\n    if func == \"mean\":\n        y_title = \"Mean Demand to Come\"\n        demand_to_come_by_segment = summaries.apply(\n            lambda s: get_values(s, \"mean\"), axis=1, warn_if_missing=True\n        )\n        demand_to_come_by_segment.index.names = [\"segment\", \"days_prior\"]\n        df = demand_to_come_by_segment.stack().rename(\"dtc\").reset_index()\n    elif func == \"std\":\n        y_title = \"Std Dev Demand to Come\"\n        demand_to_come_by_segment = summaries.apply(\n            lambda s: get_values(s, \"std\"), axis=1, warn_if_missing=True\n        )\n        demand_to_come_by_segment.index.names = [\"segment\", \"days_prior\"]\n        df = demand_to_come_by_segment.stack().rename(\"dtc\").reset_index()\n    else:\n        raise ValueError(f\"func must be in [mean, std] not {func}\")\n    if raw_df:\n        return df\n    fig = (\n        alt.Chart(df)\n        .mark_line()\n        .encode(\n            x=alt.X(\"days_prior:O\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            y=alt.Y(\"dtc:Q\").title(y_title),\n            color=\"segment:N\",\n            strokeDash=\"source:N\",\n        )\n    )\n    if title:\n        fig = fig.properties(title=title)\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_displacement_history", "title": "fig_displacement_history", "text": "<pre><code>fig_displacement_history(\n    summaries,\n    *,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    raw_df: bool = False,\n    title: str | None = \"Displacement Cost History\",\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_displacement_history(\n    summaries,\n    *,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    raw_df: bool = False,\n    title: str | None = \"Displacement Cost History\",\n):\n    if not isinstance(by_carrier, str) and show_stdev:\n        raise NotImplementedError(\n            \"contrast.fig_displacement_history with show_stdev requires \"\n            \"looking at a single carrier (set `by_carrier`)\"\n        )\n    df = _assemble(\n        summaries,\n        \"displacement_history\",\n        by_carrier=by_carrier,\n        show_stdev=show_stdev,\n    )\n    if raw_df:\n        return df\n\n    line_encoding = dict(\n        x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n        y=alt.Y(\"displacement_mean\", title=\"Displacement Cost\"),\n        color=\"source:N\",\n    )\n    chart = alt.Chart(df)\n    fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n    if show_stdev:\n        area_encoding = dict(\n            x=alt.X(\"days_prior:Q\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            y=alt.Y(\"displacement_lower:Q\", title=\"Displacement Cost\"),\n            y2=alt.Y2(\"displacement_upper:Q\", title=\"Displacement Cost\"),\n            color=\"source:N\",\n        )\n        bound = chart.mark_area(\n            opacity=0.1,\n            interpolate=\"step-before\",\n        ).encode(**area_encoding)\n        bound_line = chart.mark_line(\n            opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\"\n        ).encode(\n            x=alt.X(\"days_prior:Q\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            color=\"source:N\",\n        )\n        top_line = bound_line.encode(\n            y=alt.Y(\"displacement_lower:Q\", title=\"Displacement Cost\")\n        )\n        bottom_line = bound_line.encode(\n            y=alt.Y(\"displacement_upper:Q\", title=\"Displacement Cost\")\n        )\n        fig = fig + bound + top_line + bottom_line\n    if not isinstance(by_carrier, str):\n        fig = fig.properties(height=125, width=225).facet(facet=\"carrier:N\", columns=2)\n        if title:\n            fig = fig.properties(title=title)\n    else:\n        if title:\n            title = f\"{title} ({by_carrier})\"\n            fig = fig.properties(title=title)\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_fare_class_mix", "title": "fig_fare_class_mix", "text": "<pre><code>fig_fare_class_mix(\n    summaries, raw_df=False, label_threshold=0.06\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_fare_class_mix(summaries, raw_df=False, label_threshold=0.06):\n    df = _assemble(summaries, \"fare_class_mix\")\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Fare Class Mix\"\n        return df\n    import altair as alt\n\n    label_threshold_value = (\n        df.groupby([\"carrier\", \"source\"]).avg_sold.sum().max() * label_threshold\n    )\n    chart = alt.Chart(df).transform_calculate(\n        halfsold=\"datum.avg_sold / 2.0\",\n    )\n    bars = chart.mark_bar().encode(\n        x=alt.X(\"source:N\", title=\"Source\", sort=source_order),\n        y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n        color=\"booking_class\",\n        tooltip=[\n            \"source\",\n            \"booking_class\",\n            alt.Tooltip(\"avg_sold\", format=\".2f\"),\n        ],\n    )\n    text = chart.mark_text(dx=0, dy=3, color=\"white\", baseline=\"top\").encode(\n        x=alt.X(\"source:N\", title=\"Source\", sort=source_order),\n        y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n        text=alt.Text(\"avg_sold:Q\", format=\".2f\"),\n        opacity=alt.condition(\n            f\"datum.avg_sold &lt; {label_threshold_value:.3f}\",\n            alt.value(0),\n            alt.value(1),\n        ),\n        order=alt.Order(\"booking_class:N\", sort=\"descending\"),\n    )\n    return (\n        (bars + text)\n        .properties(\n            width=200,\n            height=300,\n        )\n        .facet(\n            column=alt.Column(\"carrier:N\", title=\"Carrier\"),\n            title=\"Carrier Fare Class Mix\",\n        )\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_leg_forecasts", "title": "fig_leg_forecasts", "text": "<pre><code>fig_leg_forecasts(\n    summaries,\n    raw_df=False,\n    by_leg_id=None,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"]\n    | list[Literal[\"mu\", \"sigma\"]] = \"mu\",\n    agg_booking_classes: bool = False,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_leg_forecasts(\n    summaries,\n    raw_df=False,\n    by_leg_id=None,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"] | list[Literal[\"mu\", \"sigma\"]] = \"mu\",\n    agg_booking_classes: bool = False,\n):\n    if isinstance(of, list):\n        if raw_df:\n            raise NotImplementedError\n        fig = fig_leg_forecasts(\n            summaries,\n            by_leg_id=by_leg_id,\n            by_class=by_class,\n            of=of[0],\n            agg_booking_classes=agg_booking_classes,\n        )\n        for of_ in of[1:]:\n            fig |= fig_leg_forecasts(\n                summaries,\n                by_leg_id=by_leg_id,\n                by_class=by_class,\n                of=of_,\n                agg_booking_classes=agg_booking_classes,\n            )\n        title = f\"Leg Forecasts {by_leg_id}\"\n        try:\n            if by_leg_id:\n                first_summary = next(iter(summaries.values()))\n                leg_def = first_summary.legs.loc[by_leg_id]\n                title += f\": {leg_def['carrier']} {leg_def['flt_no']}\"\n                title += f\" ({leg_def['orig']}-{leg_def['dest']})\"\n        except Exception:\n            raise\n        return fig.properties(title=title)\n    df = _assemble(\n        summaries, \"leg_forecasts\", by_leg_id=by_leg_id, by_class=by_class, of=of\n    )\n    color = \"booking_class:N\"\n    if isinstance(by_class, str):\n        color = \"source:N\"\n    if agg_booking_classes or not by_class:\n        color = \"source:N\"\n        if of == \"mu\":\n            df = (\n                df.groupby([\"source\", \"leg_id\", \"days_prior\"])\n                .forecast_mean.sum()\n                .reset_index()\n            )\n        elif of == \"sigma\":\n\n            def sum_sigma(x):\n                return np.sqrt(sum(x**2))\n\n            df = (\n                df.groupby([\"source\", \"leg_id\", \"days_prior\"])\n                .forecast_stdev.apply(sum_sigma)\n                .reset_index()\n            )\n    if raw_df:\n        df.attrs[\"title\"] = \"Average Leg Forecasts\"\n        return df\n    return _fig_forecasts(\n        df,\n        facet_on=\"flt_no\" if not isinstance(by_leg_id, int) else None,\n        y=\"forecast_mean\" if of == \"mu\" else \"forecast_stdev\",\n        y_title=\"Mean Demand Forecast\" if of == \"mu\" else \"Std Dev Demand Forecast\",\n        color=color,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_path_forecasts", "title": "fig_path_forecasts", "text": "<pre><code>fig_path_forecasts(\n    summaries,\n    raw_df=False,\n    by_path_id=None,\n    path_names: dict | None = None,\n    agg_booking_classes: bool = False,\n    by_class: bool | str = True,\n    of: ForecastOfT | list[ForecastOfT] = \"mu\",\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_path_forecasts(\n    summaries,\n    raw_df=False,\n    by_path_id=None,\n    path_names: dict | None = None,\n    agg_booking_classes: bool = False,\n    by_class: bool | str = True,\n    of: ForecastOfT | list[ForecastOfT] = \"mu\",\n):\n    if isinstance(of, list):\n        if raw_df:\n            df = {\n                _of: fig_path_forecasts(\n                    summaries,\n                    by_path_id=by_path_id,\n                    path_names=path_names,\n                    by_class=by_class,\n                    of=of[0],\n                    raw_df=raw_df,\n                )\n                for _of in of\n            }\n            return pd.concat(df, axis=0, names=[\"measurement\"]).reset_index(0)\n        fig = fig_path_forecasts(\n            summaries,\n            by_path_id=by_path_id,\n            path_names=path_names,\n            by_class=by_class,\n            of=of[0],\n        )\n        for of_ in of[1:]:\n            fig |= fig_path_forecasts(\n                summaries,\n                by_path_id=by_path_id,\n                path_names=path_names,\n                by_class=by_class,\n                of=of_,\n            )\n        if by_path_id:\n            title = f\"Path {by_path_id} Forecasts\"\n        else:\n            title = \"Path Forecasts\"\n        try:\n            if by_path_id:\n                first_summary = next(iter(summaries.values()))\n                path_def = first_summary.paths.loc[by_path_id]\n                title += f\" ({path_def['orig']}~{path_def['dest']})\"\n                for leg_id in first_summary.path_legs.query(\n                    f\"path_id == {by_path_id}\"\n                ).leg_id:\n                    leg_def = first_summary.legs.loc[leg_id]\n                    title += (\n                        f\", {leg_def['carrier']} {leg_def['flt_no']} \"\n                        f\"({leg_def['orig']}-{leg_def['dest']})\"\n                    )\n        except Exception:\n            raise\n        return fig.properties(title=title)\n    df = _assemble(\n        summaries, \"path_forecasts\", by_path_id=by_path_id, of=of, by_class=by_class\n    )\n    list(summaries.keys())\n    if path_names is not None:\n        df[\"path_id\"] = df[\"path_id\"].apply(lambda x: path_names.get(x, str(x)))\n    color = \"booking_class:N\"\n    if isinstance(by_class, str):\n        color = \"source:N\"\n    if agg_booking_classes:\n        if of == \"mu\":\n            df = (\n                df.groupby([\"source\", \"path_id\", \"days_prior\"])\n                .forecast_mean.sum()\n                .reset_index()\n            )\n        elif of == \"sigma\":\n\n            def sum_sigma(x):\n                return np.sqrt(sum(x**2))\n\n            df = (\n                df.groupby([\"source\", \"path_id\", \"days_prior\"])\n                .forecast_stdev.apply(sum_sigma)\n                .reset_index()\n            )\n        elif of == \"closed\":\n            df = (\n                df.groupby([\"source\", \"path_id\", \"days_prior\"])\n                .forecast_closed_in_tf.mean()\n                .reset_index()\n            )\n    if raw_df:\n        if of == \"mu\":\n            df.attrs[\"title\"] = \"Average Path Forecast Means\"\n        elif of == \"sigma\":\n            df.attrs[\"title\"] = \"Average Path Forecast Standard Deviations\"\n        elif of == \"closed\":\n            df.attrs[\"title\"] = \"Average Path Forecast Closed in Timeframe\"\n        return df\n    if of == \"mu\":\n        y = \"forecast_mean\"\n        y_title = \"Mean Demand Forecast\"\n    elif of == \"sigma\":\n        y = \"forecast_stdev\"\n        y_title = \"Std Dev Demand Forecast\"\n    elif of == \"closed\":\n        y = \"forecast_closed_in_tf\"\n        y_title = \"Mean Time Frame Closed of Demand Forecast\"\n    elif of == \"adj_price\":\n        y = \"adjusted_price\"\n        y_title = \"Mean Adjusted Fare\"\n    else:\n        raise NotImplementedError\n\n    # use ordinal data type for DCP labels unless\n    # the underlying data is daily, then use Q\n    rrd_ntype = \"O\"\n    if len(df[\"days_prior\"].value_counts()) &gt; 30:\n        rrd_ntype = \"Q\"\n    return _fig_forecasts(\n        df,\n        facet_on=\"path_id\" if not isinstance(by_path_id, int) else None,\n        y=y,\n        y_title=y_title,\n        color=color,\n        rrd_ntype=rrd_ntype,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_segmentation_by_timeframe", "title": "fig_segmentation_by_timeframe", "text": "<pre><code>fig_segmentation_by_timeframe(\n    summaries: dict[str, SummaryTables],\n    metric: Literal[\"bookings\", \"revenue\"],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df=False,\n    source_labels: bool = False,\n    ratio: str | bool = False,\n) -&gt; Chart | DataFrame\n</code></pre> <p>Generate a figure contrasting segmentation by timeframe for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            <p>One or more SummaryTables to compare. The keys of this dictionary are the text names used to label the \"source\" for each set of data in the figure.</p> </li> <li> <code>metric</code>               (<code>(bookings, revenue)</code>, default:                   <code>'bookings'</code> )           \u2013            <p>The metric to display for the segmentation.</p> </li> <li> <code>by_carrier</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>Whether to differentiate carriers by colors (the default) or give the name of a particular carrier as a string to filter the results shown in the figure to only that one carrier.</p> </li> <li> <code>by_class</code>               (<code>bool or str</code>, default:                   <code>False</code> )           \u2013            <p>Whether to differentiate booking class by colors (the default) or give the name of a particular booking class as a string to filter the results shown in the figure to only that one booking class.</p> </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Set to true to return the raw dataframe used to generate the figure, instead of the figure itself.</p> </li> <li> <code>source_labels</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Write source labels above the columns of the figure. Source labels are also available as tool tips, but if the figure is being shared as an image without tooltips, the source labels may make it easier to interpret.</p> </li> <li> <code>ratio</code>               (<code>str or bool</code>, default:                   <code>False</code> )           \u2013            <p>Compute ratios against a reference point and display them in tooltips.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>report</code>               (<code>Reporter</code>)           \u2013            <p>Giving a reporter for this keyword only argument allow you to automatically append this figure to the report (in addition to returning it for display or other processing).</p> </li> <li> <code>trace</code>               (<code>ExcelWriter or (ExcelWriter, str)</code>)           \u2013            <p>Write the raw dataframe backing this figure to the Excel workbook.</p> </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_segmentation_by_timeframe(\n    summaries: dict[str, SummaryTables],\n    metric: Literal[\"bookings\", \"revenue\"],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df=False,\n    source_labels: bool = False,\n    ratio: str | bool = False,\n) -&gt; alt.Chart | pd.DataFrame:\n    \"\"\"\n    Generate a figure contrasting segmentation by timeframe for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n        One or more SummaryTables to compare. The keys of this dictionary are the\n        text names used to label the \"source\" for each set of data in the figure.\n    metric : {'bookings', 'revenue'}\n        The metric to display for the segmentation.\n    by_carrier : bool or str, default True\n        Whether to differentiate carriers by colors (the default) or give the name\n        of a particular carrier as a string to filter the results shown in the\n        figure to only that one carrier.\n    by_class : bool or str, default False\n        Whether to differentiate booking class by colors (the default) or give the\n        name of a particular booking class as a string to filter the results shown\n        in the figure to only that one booking class.\n    raw_df : bool, default False\n        Set to true to return the raw dataframe used to generate the figure, instead\n        of the figure itself.\n    source_labels : bool, default False\n        Write source labels above the columns of the figure. Source labels are also\n        available as tool tips, but if the figure is being shared as an image without\n        tooltips, the source labels may make it easier to interpret.\n    ratio : str or bool, default False\n        Compute ratios against a reference point and display them in tooltips.\n\n    Other Parameters\n    ----------------\n    report : xmle.Reporter, optional\n        Giving a reporter for this keyword only argument allow you to automatically\n        append this figure to the report (in addition to returning it for display\n        or other processing).\n    trace : pd.ExcelWriter or (pd.ExcelWriter, str), optional\n        Write the raw dataframe backing this figure to the Excel workbook.\n    \"\"\"\n    if by_carrier is True and by_class is True:\n        raise NotImplementedError(\"comparing by both class and carrier is messy\")\n    df = _assemble(\n        summaries,\n        \"segmentation_by_timeframe\",\n        metric=metric,\n        by_carrier=by_carrier,\n        by_class=by_class,\n    )\n    source_order = list(summaries.keys())\n\n    title = f\"{metric.title()} by Timeframe\"\n    if by_class is True:\n        title = f\"{metric.title()} by Timeframe and Booking Class\"\n    title_annot = []\n    if isinstance(by_carrier, str):\n        title_annot.append(by_carrier)\n    if isinstance(by_class, str):\n        title_annot.append(f\"Class {by_class}\")\n    if title_annot:\n        title = f\"{title} ({', '.join(title_annot)})\"\n\n    against = source_order[0]\n    ratio_tooltips = ()\n    if ratio:\n        if isinstance(ratio, str):\n            against = ratio\n        idx = list(\n            {\"source\", \"carrier\", \"segment\", \"days_prior\", \"booking_class\"}\n            &amp; set(df.columns)\n        )\n        df_ = df.set_index(idx)\n        ratios = df_.div(df_.query(f\"source == '{against}'\").droplevel(\"source\")) - 1.0\n        ratios.columns = [\"ratio\"]\n        df = df.join(ratios, on=idx)\n        ratio_tooltips = (alt.Tooltip(\"ratio:Q\", title=f\"vs {against}\", format=\".3%\"),)\n\n    if raw_df:\n        df.attrs[\"title\"] = title\n        return df\n\n    if by_class:\n        if isinstance(by_class, str):\n            color = alt.Color(\"source:N\", title=\"Source\", sort=source_order).title(\n                \"Source\"\n            )\n            tooltips = ()\n        else:\n            color = alt.Color(\"booking_class:N\").title(\"Booking Class\")\n            tooltips = (alt.Tooltip(\"booking_class\", title=\"Booking Class\"),)\n        chart = alt.Chart(df.sort_values(\"source\", ascending=False))\n        chart_1 = chart.mark_bar().encode(\n            color=color,\n            x=alt.X(\"days_prior:O\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n            y=alt.Y(metric, stack=True),\n            tooltip=[\n                alt.Tooltip(\"source:N\", title=\"Source\"),\n                alt.Tooltip(\"segment\", title=\"Passenger Type\"),\n                *tooltips,\n                alt.Tooltip(\"days_prior\", title=\"Days Prior\"),\n                alt.Tooltip(metric, format=\".2f\"),\n                *ratio_tooltips,\n            ],\n        )\n        chart_2 = chart.mark_text(\n            color=\"#616161\",\n            yOffset=-2,\n            angle=270,\n            fontSize=8,\n            baseline=\"middle\",\n            align=\"left\",\n        ).encode(\n            text=alt.Text(\"source:N\", title=\"Source\"),\n            x=alt.X(\"days_prior:O\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n            # shape=alt.Shape(\"source:N\", title=\"Source\", sort=source_order),\n            y=alt.Y(f\"sum({metric})\", title=None),\n        )\n        return (\n            ((chart_1 + chart_2) if source_labels else chart_1)\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"segment:N\", title=\"Passenger Type\"),\n                title=title,\n            )\n        )\n    elif by_carrier is True:\n        return (\n            alt.Chart(df.sort_values(\"source\", ascending=False))\n            .mark_bar()\n            .encode(\n                color=alt.Color(\"carrier:N\").title(\"Carrier\"),\n                x=alt.X(\"days_prior:O\")\n                .scale(reverse=True)\n                .title(\"Days Prior to Departure\"),\n                xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n                y=alt.Y(metric, stack=True, title=metric.title()),\n                tooltip=[\n                    alt.Tooltip(\"source:N\", title=\"Source\"),\n                    alt.Tooltip(\"segment\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\"days_prior\", title=\"Days Prior\"),\n                    alt.Tooltip(metric, format=\".2f\"),\n                    *ratio_tooltips,\n                ],\n            )\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"segment:N\", title=\"Passenger Type\"),\n                title=title,\n            )\n        )\n    else:\n        return (\n            alt.Chart(df.sort_values(\"source\", ascending=False), title=title)\n            .mark_line()\n            .encode(\n                color=alt.Color(\"source:N\", title=\"Source\", sort=source_order),\n                x=alt.X(\"days_prior:O\")\n                .scale(reverse=True)\n                .title(\"Days Prior to Departure\"),\n                y=metric,\n                strokeDash=alt.StrokeDash(\"segment\").title(\"Passenger Type\"),\n                strokeWidth=alt.StrokeWidth(\n                    \"source:N\", title=\"Source\", sort=source_order\n                ),\n                tooltip=[\n                    alt.Tooltip(\"source:N\", title=\"Source\"),\n                    alt.Tooltip(\"segment\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"days_prior\", title=\"Days Prior\"),\n                    alt.Tooltip(metric, format=\".2f\"),\n                    *ratio_tooltips,\n                ],\n            )\n            .properties(\n                width=500,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n</code></pre>"}, {"location": "API/simulation.html", "title": "Simulation", "text": ""}, {"location": "API/simulation.html#passengersim.driver.Simulation", "title": "Simulation", "text": "<p>               Bases: <code>BaseSimulation</code>, <code>CallbackMixin</code></p> Source code in <code>passengersim/driver.py</code> <pre><code>class Simulation(BaseSimulation, CallbackMixin):\n    def __init__(\n        self,\n        config: Config,\n        output_dir: pathlib.Path | None = None,\n    ):\n        revalidate(config)\n        super().__init__(config, output_dir)\n        if config.simulation_controls.write_raw_files:\n            try:\n                from passengersim_core.utils import FileWriter\n            except ImportError:\n                self.file_writer = None\n            else:\n                self.file_writer = FileWriter.FileWriter(output_dir)\n        else:\n            self.file_writer = None\n        self.db_writer = None\n        self.dcp_list = [63, 56, 49, 42, 35, 31, 28, 24, 21, 17, 14, 10, 7, 5, 3, 1, 0]\n        self.classes = []\n        self.fare_sales_by_dcp = defaultdict(int)\n        self.fare_sales_by_carrier_dcp = defaultdict(int)\n        self.fare_details_sold = defaultdict(int)\n        self.fare_details_sold_business = defaultdict(int)\n        self.fare_details_revenue = defaultdict(float)\n        self.demand_multiplier = 1.0\n        self.capacity_multiplier = 1.0\n        self.airports = {}\n        self.choice_models = {}\n        self.frat5curves = {}\n        self.load_factor_curves = {}\n        self.todd_curves = {}\n        self.debug = False\n        self.update_frequency = None\n        self.random_generator = passengersim.core.Generator(42)\n        self.sample_done_callback = lambda n, n_total: None\n        self.choice_set_file = None\n        self.choice_set_obs = 0\n        self.segmentation_data_by_timeframe: dict[int, pd.DataFrame] = {}\n        \"\"\"Bookings and revenue segmentation by timeframe.\n\n        The key is the trial number, and the value is a DataFrame with a\n        breakdown of bookings and revenue by timeframe, customer segment,\n        carrier, and booking class.\n        \"\"\"\n\n        self.bid_price_traces: dict[int, Any] = {}\n        \"\"\"Bid price traces for each carrier.\n\n        The key is the trial number, and the value is a dictionary with\n        carrier names as keys and bid price traces as values.\"\"\"\n\n        self.displacement_traces: dict[int, Any] = {}\n        \"\"\"Displacement cost traces for each carrier.\n\n        The key is the trial number, and the value is a dictionary with\n        carrier names as keys and displacement cost traces as values.\"\"\"\n\n        self._fare_restriction_mapping = {}\n        \"\"\"Mapping of fare restriction names to restriction numbers.\"\"\"\n\n        self._fare_restriction_list = []\n        \"\"\"List of fare restriction names in the order they were added.\"\"\"\n\n        self._initialize(config)\n        if not config.db:\n            self.cnx = database.Database()\n        else:\n            self.cnx = database.Database(\n                engine=config.db.engine,\n                filename=config.db.filename,\n                pragmas=config.db.pragmas,\n                commit_count_delay=config.db.commit_count_delay,\n            )\n        if self.cnx.is_open:\n            database.tables.create_table_leg_defs(self.cnx._connection, self.sim.legs)\n            database.tables.create_table_fare_defs(self.cnx._connection, self.sim.fares)\n            database.tables.create_table_fare_restriction_defs(\n                self.cnx._connection, self._fare_restriction_list\n            )\n            database.tables.create_table_path_defs(self.cnx._connection, self.sim.paths)\n            if config.db != \":memory:\":\n                self.cnx.save_configs(config)\n\n        self.callback_data = CallbackData()\n        \"\"\"Data stored from callbacks.\n\n        This allows a user to store arbitrary data during a simulation using callbacks,\n        and access it later.\n        \"\"\"\n\n    @property\n    def _sim(self) -&gt; SimulationEngine:\n        return self.sim\n\n    @property\n    def base_time(self) -&gt; int:\n        \"\"\"\n        The base time for the simulation, in seconds since the epoch.\n        \"\"\"\n        return self.sim.base_time\n\n    @property\n    def snapshot_filters(self) -&gt; list[SnapshotFilter] | None:\n        try:\n            sim = self.sim\n        except AttributeError:\n            return None\n        return sim.snapshot_filters\n\n    @snapshot_filters.setter\n    def snapshot_filters(self, x: list[SnapshotFilter]):\n        try:\n            sim = self.sim\n        except AttributeError as err:\n            raise ValueError(\n                \"sim not initialized, cannot set snapshot_filters\"\n            ) from err\n        sim.snapshot_filters = x\n\n    def _initialize(self, config: Config):\n        self._init_sim_and_parms(config)\n        self._init_circuity(config)\n        self._init_rm_systems(config)\n        self._init_todd_curves(config)\n        self._init_choice_models(config)\n        self._init_frat5_curves(config)\n        self._init_load_factor_curves(config)\n        self._init_carriers(config)\n        self._init_booking_curves(config)\n        self._init_airports(config)\n        self._init_demands(config)\n        self._init_fares(config)\n        logger.info(\"Connecting markets\")\n        self.sim.connect_markets()\n        self.db_writer = DbWriter(\"db\", config, self.sim)\n\n    def _init_sim_and_parms(self, config):\n        logger.info(\"Initializing simulation engine parameters\")\n        self.sim = passengersim.core.SimulationEngine(name=config.scenario)\n        self.sim.config = config\n        self.sim.random_generator = self.random_generator\n        self.sim.snapshot_filters = config.snapshot_filters\n        for pname, pvalue in config.simulation_controls:\n            if pname == \"demand_multiplier\":\n                self.demand_multiplier = pvalue\n            elif pname == \"capacity_multiplier\":\n                self.capacity_multiplier = pvalue\n            elif pname == \"write_raw_files\":\n                self.write_raw_files = pvalue\n            elif pname == \"random_seed\":\n                self.random_generator.seed(pvalue)\n            elif pname == \"update_frequency\":\n                self.update_frequency = pvalue\n            elif pname == \"capture_choice_set_file\":\n                if len(pvalue) &gt; 0:\n                    self.sim.set_parm(\"capture_choice_set\", 1)\n                    self.choice_set_file = open(pvalue, \"w\")\n                    cols = self.sim.choice_set_columns()\n                    tmp = \",\".join(cols)\n                    print(tmp, file=self.choice_set_file)\n            elif pname == \"capture_choice_set_obs\":\n                self.choice_set_obs = pvalue\n\n            # These parameters are not used directly in the core, but leave them listed\n            # for now to not break config files reading\n            elif pname in [\n                \"base_date\",\n                \"capture_competitor_data\",\n                \"dcp_hour\",\n                \"double_capacity_until\",\n                \"dwm_lite\",\n                \"show_progress_bar\",\n                \"simple_k_factor\",\n                \"timeframe_demand_allocation\",\n                \"tot_z_factor\",\n                \"allow_unused_restrictions\",\n            ]:\n                pass\n            else:\n                self.sim.set_parm(pname, float(pvalue))\n        for pname, pvalue in config.simulation_controls.model_extra.items():\n            print(f\"extra simulation setting: {pname} = \", float(pvalue))\n            self.sim.set_parm(pname, float(pvalue))\n\n        # There is a default array of DCPs, we'll override it with the data from the\n        # input file (if available)\n        if len(config.dcps) &gt; 0:\n            self.dcps = []\n            for dcp_index, days_prior in enumerate(config.dcps):\n                self.sim.add_dcp(dcp_index, days_prior)\n                self.dcps.append(days_prior)\n            # We need to add the last DCP, which is always 0, if not already in the list\n            if self.dcps[-1] != 0:\n                self.sim.add_dcp(len(self.dcps), 0)\n                self.dcps.append(0)\n\n    def _init_circuity(self, config):\n        logger.info(\"Initializing circuity rules\")\n        for rule in config.circuity_rules:\n            # Flatten the object into a dictionary,\n            # SimulationEngine will iterate over it\n            self.sim.add_circuity_rule(dict(rule))\n\n    def _init_rm_system(self, rm_name: str, rm_system: RmSystemConfig, config: Config):\n        from passengersim_core.carrier.rm_system import Rm_System\n\n        logger.info(\"Initializing RM system %s\", rm_name)\n        x = self.rm_systems[rm_name] = Rm_System(rm_name)\n        x.availability_control = rm_system.availability_control\n        for process_name, process in rm_system.processes.items():\n            step_list = [s._factory() for s in process]\n            for s in step_list:\n                s.use_config(config)\n            x.add_process(process_name, step_list)\n\n    def _init_rm_systems(self, config):\n        self.rm_systems = {}\n        for rm_name, rm_system in config.rm_systems.items():\n            self._init_rm_system(rm_name, rm_system, config)\n\n    def _init_todd_curves(self, config):\n        logger.info(\"Initializing TODD curves\")\n        for todd_name, todd in config.todd_curves.items():\n            dwm = DecisionWindow(todd_name)\n            if todd.k_factor:\n                dwm.k_factor = todd.k_factor\n            if todd.min_distance:\n                dwm.min_distance = todd.min_distance\n            if todd.early_dep:\n                dwm.early_dep_offset = todd.early_dep[\"offset\"]\n                dwm.early_dep_offset = todd.early_dep[\"offset\"]\n                dwm.early_dep_slope = todd.early_dep[\"slope\"]\n                dwm.early_dep_beta = todd.early_dep[\"beta\"]\n            if todd.late_arr:\n                dwm.late_arr_offset = todd.late_arr[\"offset\"]\n                dwm.late_arr_slope = todd.late_arr[\"slope\"]\n                dwm.late_arr_beta = todd.late_arr[\"beta\"]\n            if todd.replanning:\n                dwm.replanning_alpha = todd.replanning[0]\n                dwm.replanning_beta = todd.replanning[1]\n            if todd.probabilities:\n                dwm.dwm_tod = list(todd.probabilities.values())\n            self.todd_curves[todd_name] = dwm\n\n    def _get_fare_restriction_num(\n        self, restriction_name: str, *, ignore_when_missing: bool = False\n    ):\n        r = str(restriction_name).casefold()\n        if r not in self._fare_restriction_mapping:\n            if ignore_when_missing:\n                return None\n            self._fare_restriction_mapping[r] = len(self._fare_restriction_mapping) + 1\n            self._fare_restriction_list.append(r)\n        return self._fare_restriction_mapping[r]\n\n    def parse_restriction_flags(self, restriction_flags: int) -&gt; list[str]:\n        \"\"\"Convert restriction flags to a tuple of restriction names.\"\"\"\n        result = []\n        rest_num = 1\n        rest_names = self._fare_restriction_list\n        while restriction_flags:\n            if restriction_flags &amp; 1:\n                result.append(rest_names[rest_num - 1])\n            rest_num += 1\n            restriction_flags &gt;&gt;= 1\n        return result\n\n    def get_restriction_name(self, restriction_num: int) -&gt; str:\n        \"\"\"Convert restriction number to a restriction name.\"\"\"\n        if restriction_num &lt; 1:\n            raise IndexError(restriction_num)\n        return self._fare_restriction_list[restriction_num - 1]\n\n    def _init_choice_models(self, config):\n        logger.info(\"Initializing choice models\")\n        for cm_name, cm in config.choice_models.items():\n            x = passengersim.core.ChoiceModel(\n                cm_name, cm.kind, random_generator=self.random_generator\n            )\n            for pname, pvalue in cm:\n                if pname in (\"kind\", \"name\") or pvalue is None:\n                    continue\n\n                if pname == \"todd_curve\":\n                    tmp_dwm = self.todd_curves[pvalue]\n                    x.add_dwm(tmp_dwm)\n                elif pname == \"restrictions\":\n                    for rname, rvalue in pvalue.items():\n                        restriction_num = self._get_fare_restriction_num(rname)\n                        if isinstance(rvalue, list | tuple):\n                            x.add_restriction(restriction_num, *rvalue)\n                        else:\n                            x.add_restriction(restriction_num, rvalue)\n                elif isinstance(pvalue, list | tuple):\n                    x.add_parm(pname, *pvalue)\n                else:\n                    x.add_parm(pname, pvalue)\n            self.choice_models[cm_name] = x\n\n    def _init_frat5_curves(self, config):\n        logger.info(\"Initializing Frat5 curves\")\n        for f5_name, f5_data in config.frat5_curves.items():\n            f5 = Frat5(f5_name)\n            # ensure that the curve is sorted in descending order by days prior\n            sorted_days_prior = reversed(sorted(f5_data.curve.keys()))\n            for days_prior in sorted_days_prior:\n                val = f5_data.curve[days_prior]\n                f5.add_vals(val)\n            f5.max_cap = f5_data.max_cap\n            self.sim.add_frat5(f5)\n            self.frat5curves[f5_name] = f5\n\n    def _init_load_factor_curves(self, config):\n        logger.info(\"Initializing load factor curves\")\n        for lf_name, lf_curve in config.load_factor_curves.items():\n            self.load_factor_curves[lf_name] = lf_curve\n\n    def _init_carriers(self, config: Config):\n        logger.info(\"Initializing carriers\")\n        self.carriers_dict = {}\n        for carrier_name, carrier_config in config.carriers.items():\n            try:\n                rm_sys = self.rm_systems[carrier_config.rm_system]\n            except KeyError:\n                config._load_std_rm_system(carrier_config.rm_system)\n                self._init_rm_system(\n                    carrier_config.rm_system,\n                    config.rm_systems[carrier_config.rm_system],\n                    config,\n                )\n                rm_sys = self.rm_systems[carrier_config.rm_system]\n            availability_control = rm_sys.availability_control\n            carrier = passengersim.core.Carrier(carrier_name, availability_control)\n            self.carriers_dict[carrier_name] = carrier\n            carrier.rm_system = self.rm_systems[carrier_config.rm_system]\n            carrier.truncation_rule = carrier_config.truncation_rule\n            carrier.history_length = carrier_config.history_length\n            carrier.cp_algorithm = carrier_config.cp_algorithm\n            carrier.cp_quantize = carrier_config.cp_quantize\n            carrier.cp_scale = carrier_config.cp_scale\n            carrier.cp_record = carrier_config.cp_record\n            if carrier_config.cp_elasticity is not None:\n                carrier.cp_elasticity = carrier_config.cp_elasticity\n            frat5_name = carrier_config.frat5\n            if not frat5_name:\n                frat5_name = config.rm_systems[carrier_config.rm_system].frat5\n            if frat5_name is not None and frat5_name != \"\":\n                # We want a deep copy of the Frat5 curve,\n                # in case two carriers are using the same curve,\n                # and we want to adjust one of them using ML\n                try:\n                    f5_data = config.frat5_curves[frat5_name]\n                except KeyError:\n                    config._load_std_frat5(frat5_name)\n                    f5_data = config.frat5_curves[frat5_name]\n                f5 = Frat5(f5_data.name)\n                for _dcp, val in f5_data.curve.items():\n                    f5.add_vals(val)\n                if carrier_config.fare_adjustment_scale is not None:\n                    f5.fare_adjustment_scale = carrier_config.fare_adjustment_scale\n                carrier.frat5 = f5\n            if (\n                carrier_config.load_factor_curve is not None\n                and carrier_config.load_factor_curve != \"\"\n            ):\n                lfc = self.load_factor_curves[carrier_config.load_factor_curve]\n                carrier.load_factor_curve = lfc\n\n            for anc_code, anc_price in carrier_config.ancillaries.items():\n                anc = Ancillary(anc_code, anc_price, 0)\n                carrier.add_ancillary(anc)\n\n            self.sim.add_carrier(carrier)\n\n        self.classes = config.classes\n        self.init_rm = {}  # TODO\n\n    def _init_airports(self, config: Config):\n        logger.info(\"Initializing airports\")\n        # Load the places into Airport objects.  We use lat/lon to get\n        # great circle distance, and this also has the MCT data\n        for code, p in config.places.items():\n            assert isinstance(p, passengersim.config.Place)\n            a = Airport(code, p.label)\n            a.latitude, a.longitude = p.lat, p.lon\n            if p.country is not None:\n                a.country = p.country\n            if p.state is not None:\n                a.state = p.state\n            if p.mct is not None:\n                assert isinstance(p.mct, passengersim.config.MinConnectTime)\n                a.mct_dd = p.mct.domestic_domestic\n                a.mct_di = p.mct.domestic_international\n                a.mct_id = p.mct.international_domestic\n                a.mct_ii = p.mct.international_international\n            self.airports[code] = a\n            self.sim.add_airport(a)\n\n    def _init_booking_curves(self, config):\n        logger.info(\"Initializing booking curves\")\n        self.curves = {}\n        for curve_name, curve_config in config.booking_curves.items():\n            bc = passengersim.core.BookingCurve(curve_name)\n            bc.random_generator = self.random_generator\n            # ensure that the curve is sorted in descending order by days prior\n            sorted_days_prior = reversed(sorted(curve_config.curve.keys()))\n            for days_prior in sorted_days_prior:\n                pct = curve_config.curve[days_prior]\n                bc.add_dcp(days_prior, pct)\n            self.curves[curve_name] = bc\n\n        # It got more complex with cabins and buckets, so now it's in a separate method\n        self._initialize_leg_cabin_bucket(config)\n\n    def _init_demands(self, config):\n        logger.info(\"Initializing demands\")\n        markets = {}\n        market_multipliers = {}\n        for mkt_config in config.markets:\n            market_multipliers[f\"{mkt_config.orig}~{mkt_config.dest}\"] = (\n                mkt_config.demand_multiplier\n            )\n        # This simulates PODS' favored carrier logic.  The CALP values are\n        # all set to 1.0 in all their networks, so hard-coded fo now but\n        # we can load from YAML in the future if we need to\n        if len(config.carriers) &gt; 0:\n            prob = 1.0 / len(config.carriers)\n            calp = {cxr_name: prob for cxr_name in config.carriers.keys()}\n        else:\n            calp = {}\n        for dmd_config in config.demands:\n            mkt_ident = f\"{dmd_config.orig}~{dmd_config.dest}\"\n            if mkt_ident not in markets:\n                mkt = passengersim.core.Market(dmd_config.orig, dmd_config.dest)\n                markets[mkt_ident] = mkt\n            else:\n                mkt = markets[mkt_ident]\n            dmd = passengersim.core.Demand(segment=dmd_config.segment, market=mkt)\n            dmd.base_demand = (\n                dmd_config.base_demand\n                * self.demand_multiplier\n                * market_multipliers.get(mkt_ident, 1.0)\n            )\n            dmd.price = dmd_config.reference_fare\n            dmd.reference_fare = dmd_config.reference_fare\n            if dmd_config.distance &gt; 0.01:\n                dmd.distance = dmd_config.distance\n            elif dmd.orig in self.airports and dmd.dest in self.airports:\n                dmd.distance = get_mileage(self.airports, dmd.orig, dmd.dest)\n\n            # Get the choice model name to use for this demand.\n            model_name = dmd_config.choice_model or dmd_config.segment\n            cm = self.choice_models.get(model_name, None)\n            if cm is not None:\n                dmd.add_choice_model(cm)\n            else:\n                raise ValueError(\n                    f\"Choice model {model_name} not found for demand {dmd}\"\n                )\n            if dmd_config.curve:\n                curve_name = str(dmd_config.curve).strip()\n                curve = self.curves[curve_name]\n                dmd.add_curve(curve)\n            if dmd_config.todd_curve in self.todd_curves:\n                dmd.add_dwm(self.todd_curves[dmd_config.todd_curve])\n            if dmd_config.group_sizes is not None:\n                dmd.add_group_sizes(dmd_config.group_sizes)\n            dmd.prob_saturday_night = dmd_config.prob_saturday_night\n            dmd.prob_num_days = dmd_config.prob_num_days\n            dmd.prob_favored_carrier = calp\n            self.sim.add_demand(dmd)\n            if self.debug:\n                print(f\"Added demand: {dmd}, base_demand = {dmd.base_demand}\")\n        # Hold PyObjects for markets in a dictionary in order to avoid duplicates\n        self._markets = {k: v for k, v in self.markets.items()}\n\n    def _init_fares(self, config: Config):\n        logger.info(\"Initializing fares\")\n        # self.fares = []\n        disable_ap = config.simulation_controls.disable_ap\n\n        discovered_restrictions = set()\n\n        for fare_config in config.fares:\n            fare = passengersim.core.Fare(\n                self.carriers_dict[fare_config.carrier],\n                fare_config.orig,\n                fare_config.dest,\n                fare_config.booking_class,\n                fare_config.price,\n            )\n            if not disable_ap:\n                fare.adv_purch = fare_config.advance_purchase\n            for rest_code in fare_config.restrictions:\n                rest_num = self._get_fare_restriction_num(\n                    rest_code, ignore_when_missing=True\n                )\n                if rest_num:\n                    fare.add_restriction(rest_num)\n                    discovered_restrictions.add(str(rest_code).casefold())\n                else:\n                    if config.simulation_controls.allow_unused_restrictions:\n                        warnings.warn(\n                            f\"Restriction {rest_code!r} found in fares \"\n                            f\"but not used in any choice model\",\n                            skip_file_prefixes=_warn_skips,\n                            stacklevel=1,\n                        )\n                    else:\n                        raise ValueError(\n                            f\"Restriction {rest_code!r} found in fares but not \"\n                            f\"used in any choice model\"\n                        )\n            self.sim.add_fare(fare)\n            if self.debug:\n                print(f\"Added fare: {fare}\")\n            # self.fares.append(fare)\n\n        # check that all restrictions used in choice models are present in fares\n        for r in self._fare_restriction_list:\n            if r not in discovered_restrictions:\n                if config.simulation_controls.allow_unused_restrictions:\n                    warnings.warn(\n                        f\"Restriction {r!r} used in choice models but \"\n                        f\"not found in fares\",\n                        skip_file_prefixes=_warn_skips,\n                        stacklevel=1,\n                    )\n                else:\n                    raise ValueError(\n                        f\"Restriction {r!r} used in choice models but not found \"\n                        f\"in fares\"\n                    )\n\n        carriers = {cxr.name: cxr for cxr in self.sim.carriers}\n        for path_config in config.paths:\n            p = passengersim.core.Path(path_config.orig, path_config.dest, 0.0)\n            p.path_quality_index = path_config.path_quality_index\n            leg_index1 = path_config.legs[0]\n            tmp_leg = self.legs[leg_index1]\n            assert (\n                tmp_leg.orig == path_config.orig\n            ), \"Path statement is corrupted, orig doesn't match\"\n            assert tmp_leg.flt_no == leg_index1\n            p.add_leg(tmp_leg)\n            if len(path_config.legs) &gt;= 2:\n                leg_index2 = path_config.legs[1]\n                if leg_index2 &gt; 0:\n                    tmp_leg = self.legs[leg_index2]\n                    p.add_leg(self.legs[leg_index2])\n            assert (\n                tmp_leg.dest == path_config.dest\n            ), \"Path statement is corrupted, dest doesn't match\"\n            path_carrier_name = tmp_leg.carrier_name\n            if path_carrier_name not in carriers:\n                raise ValueError(f\"Carrier {path_carrier_name} not found\")\n            p.add_carrier(carriers[path_carrier_name])\n            self.sim.add_path(p)\n\n        # Go through and make sure things are linked correctly\n        fares_dict = defaultdict(list)\n        lowest_fare_dict = defaultdict(lambda: 9e9)\n        highest_fare_dict = defaultdict(float)\n        for f in self.sim.fares:\n            od_key = (f.orig, f.dest)\n            fares_dict[od_key].append(f)\n            lowest_fare_dict[od_key] = min(lowest_fare_dict[od_key], f.price)\n            highest_fare_dict[od_key] = max(highest_fare_dict[od_key], f.price)\n        for dmd in self.sim.demands:\n            tmp_fares = fares_dict[(dmd.orig, dmd.dest)]\n            tmp_fares = sorted(tmp_fares, reverse=True, key=lambda p: p.price)\n            for fare in tmp_fares:\n                dmd.add_fare(fare)\n\n            # Now set upper and lower bounds, these are used in continuous pricing\n            # CP can never go lower than the lowest published fare\n            lowest_published = lowest_fare_dict[(dmd.orig, dmd.dest)]\n            highest_published = highest_fare_dict[(dmd.orig, dmd.dest)]\n            for cxr in self.sim.carriers:\n                cp_bounds = self.config.carriers[cxr.name].cp_bounds\n                prev_fare = None\n                for fare in tmp_fares:\n                    if fare.carrier_name != cxr.name:\n                        continue\n                    if prev_fare is not None:\n                        diff = prev_fare.price - fare.price\n                        prev_fare.price_lower_bound = max(\n                            fare.price - diff * cp_bounds, lowest_published\n                        )\n                        fare.price_upper_bound = min(\n                            fare.price + diff * cp_bounds, highest_published\n                        )\n                        # This provides a price floor, but will be overwritten\n                        # each time through the loop EXCEPT for the lowest fare\n                        fare.price_lower_bound = max(\n                            fare.price - diff * cp_bounds, lowest_published\n                        )\n                    else:\n                        fare.price_upper_bound = min(fare.price, highest_published)\n                    prev_fare = fare\n\n        logger.info(\"Initializing bucket decision fares\")\n        for leg in self.sim.legs:\n            try:\n                leg_market = self.sim.markets[f\"{leg.orig}~{leg.dest}\"]\n            except KeyError:\n                # no market for this leg, so no fares, that's ok\n                continue\n            assert len(leg_market.fares) &gt; 0, f\"No fares found for market {leg_market}\"\n            for fare in leg_market.fares:\n                if fare.carrier_name == leg.carrier_name:\n                    leg.set_bucket_blank_value(fare.booking_class, fare.price)\n\n        self.sim.base_time = config.simulation_controls.reference_epoch()\n\n    def _initialize_leg_cabin_bucket(self, config: Config):\n        logger.info(\"Initializing legs, cabins, and buckets\")\n        self.legs = {}\n        carriers = {}\n        for carrier in self.sim.carriers:\n            carriers[carrier.name] = carrier\n        next_leg_id = 1\n        for leg_config in config.legs:\n            # if no leg_id is provided, we'll use the fltno if it's not already in use\n            if (\n                leg_config.leg_id is None\n                and leg_config.fltno is not None\n                and not self.sim.leg_id_exists(leg_config.fltno)\n            ):\n                leg_config.leg_id = leg_config.fltno\n            # if still no leg_id, we'll use the next available\n            if leg_config.leg_id is None:\n                while self.sim.leg_id_exists(next_leg_id):\n                    next_leg_id += 1\n                leg_config.leg_id = next_leg_id\n            leg = passengersim.core.Leg(\n                leg_config.leg_id,\n                carriers[leg_config.carrier],\n                leg_config.fltno,\n                leg_config.orig,\n                leg_config.dest,\n            )\n            leg.dep_time = leg_config.dep_time\n            leg.arr_time = leg_config.arr_time\n            leg.dep_time_offset = leg_config.dep_time_offset\n            leg.arr_time_offset = leg_config.arr_time_offset\n            if leg_config.distance:\n                leg.distance = leg_config.distance\n            elif len(self.airports) &gt; 0:\n                leg.distance = get_mileage(self.airports, leg.orig, leg.dest)\n            self.sim.add_leg(leg)\n\n            # Now we do the cabins and buckets\n            if isinstance(leg_config.capacity, int):\n                cap = int(leg_config.capacity * self.capacity_multiplier)\n                leg.capacity = cap\n                cabin = passengersim.core.Cabin(\"\", cap)\n                leg.add_cabin(cabin)\n                self.set_classes(leg, cabin)\n            else:\n                tot_cap = 0\n                for cabin_code, tmp_cap in leg_config.capacity.items():\n                    cap = int(tmp_cap * self.capacity_multiplier)\n                    tot_cap += cap\n                    cabin = passengersim.core.Cabin(cabin_code, cap)\n                    leg.add_cabin(cabin)\n                leg.capacity = tot_cap\n                self.set_classes(leg, cabin)\n            if self.debug:\n                print(f\"Added leg: {leg}, dist = {leg.distance}\")\n            self.legs[leg.leg_id] = leg\n\n    def set_classes(self, leg: passengersim.core.Leg, _cabin, debug=False):\n        leg_classes = self.config.carriers[leg.carrier.name].classes\n        if len(leg_classes) == 0:\n            return\n        cap = float(leg.capacity)\n        if debug:\n            print(leg, \"Capacity = \", cap)\n        history_def = leg.carrier.get_history_def()\n        for bkg_class in leg_classes:\n            # Input as a percentage\n            auth = int(cap * self.init_rm.get(bkg_class, 100.0) / 100.0)\n            if isinstance(bkg_class, tuple):\n                # We are likely using multi-cabin, so unpack it\n                (bkg_class, cabin_code) = bkg_class\n            b = passengersim.core.Bucket(bkg_class, alloc=auth, history=history_def)\n            leg.add_bucket(b)\n            if debug:\n                print(\"    Bucket\", bkg_class, auth)\n\n    def setup_scenario(self) -&gt; None:\n        \"\"\"\n        Set up the scenario for the simulation.\n\n        This will delete any existing data in the database under the same simulation\n        name, build the connections if needed, and then call the vn_initial_mapping\n        method to set up the initial mapping for the carriers using virtual nesting.\n        \"\"\"\n        self.cnx.delete_experiment(self.sim.name)\n        logger.debug(\"building connections\")\n        num_paths = self.sim.build_connections()\n        self.sim.compute_hhi()\n        if num_paths and self.cnx.is_open:\n            database.tables.create_table_path_defs(self.cnx._connection, self.sim.paths)\n        logger.debug(f\"Connections done, num_paths = {num_paths}\")\n        self.sim.initialize_bucket_ap_rules()\n\n        # start with default number of timeframes\n        num_timeframes_default = len(self.config.dcps)\n        if len(self.config.dcps) and self.config.dcps[-1] == 0:\n            num_timeframes_default -= 1\n\n        # initialize pathclasses for each carrier, using settings from the carrier\n        # to size the history buffers\n        for carrier in self.sim.carriers:\n            self.sim.initialize_pathclasses(carrier.get_history_def(), carrier.name)\n\n        # Airlines using Q-forecasting need to have pathclasses set up for all paths\n        # so Q-demand can be forecasted by pathclass even in the absence of bookings\n        for carrier in self.sim.carriers:\n            if carrier.frat5:\n                logger.info(\n                    f\"Setting up path classes for carrier {carrier.name}, \"\n                    \"which is using a Frat5 curve\"\n                )\n                for pth in self.sim.paths:\n                    if pth.carrier_name != carrier.name:\n                        continue\n                    mkt = self.sim.markets[f\"{pth.orig}~{pth.dest}\"]\n                    for fare in mkt.fares:\n                        if fare.carrier_name == pth.carrier_name:\n                            pthcls = pth.add_booking_class(\n                                fare.booking_class, if_not_found=True\n                            )\n                            if pthcls is not None:\n                                pthcls.add_fare(fare)\n            self.vn_initial_mapping2(carrier.name)\n\n        # This will save approximately the number of choice sets requested\n        if self.choice_set_file is not None and self.choice_set_obs &gt; 0:\n            tot_dmd = 0\n            for d in self.config.demands:\n                tot_dmd += d.base_demand\n            total_choice_sets = (\n                tot_dmd\n                * self.sim.num_trials\n                * (self.sim.num_samples - self.sim.burn_samples)\n            )\n            prob = (\n                self.choice_set_obs / total_choice_sets if total_choice_sets &gt; 0 else 0\n            )\n            self.sim.choice_set_sampling_probability = prob\n\n    def vn_initial_mapping(self):\n        vn_carriers = []\n        for carrier in self.sim.carriers:\n            if carrier.control == \"vn\":\n                vn_carriers.append(carrier.name)\n        for path in self.sim.paths:\n            if path.get_leg_carrier(0) in vn_carriers:\n                for bc in self.classes:\n                    pc = PathClass(bc)\n                    index = int(bc[1])\n                    pc.set_index(0, index)\n                    path.add_path_class(pc)\n\n    def vn_initial_mapping2(self, carrier_code):\n        for path in self.sim.paths:\n            if path.get_leg_carrier(0) == carrier_code:\n                for i, pc in enumerate(path.pathclasses):\n                    pc.set_index(0, i)\n\n    def end_sample(self):\n        \"\"\"End of sample processing.\"\"\"\n\n        # Record the departure statistics to carrier-level counters in the simulation\n        self.sim.record_departure_statistics()\n\n        # Roll histories to next sample\n        self.sim.next_departure()\n\n        # Commit data to the database\n        if self.cnx:\n            try:\n                self.cnx.commit()\n            except AttributeError:\n                pass\n\n        # Are we capturing choice-set data?\n        if self.choice_set_file is not None:\n            if self.sim.sample &gt; self.sim.burn_samples:\n                cs = self.sim.get_choice_set()\n                for line in cs:\n                    tmp = [str(z) for z in line]\n                    tmp2 = \",\".join(tmp)\n                    print(tmp2, file=self.choice_set_file)\n            self.sim.clear_choice_set()\n\n        # Market share computation (MIDT-lite), might move to C++ in a future version\n        alpha = 0.15\n        for m in self.sim.markets.values():\n            sold = float(m.sold)\n            for a in self.sim.carriers:\n                carrier_sold = m.get_carrier_sold(a.name)\n                share = carrier_sold / sold if sold &gt; 0 else 0\n                if self.sim.sample &gt; 1:\n                    try:\n                        old_share = m.get_carrier_share(a.name)\n                    except KeyError:\n                        old_share = 0.0\n                    new_share = alpha * share + (1.0 - alpha) * old_share\n                    m.set_carrier_share(a.name, new_share)\n                else:\n                    m.set_carrier_share(a.name, share)\n\n    def begin_trial(self, trial: int):\n        \"\"\"Beginning of trial processing.\n\n        Parameters\n        ----------\n        trial : int\n            The trial number.\n        \"\"\"\n        self.sim.trial = trial\n        self.sim.reset_trial_counters()\n\n        for carrier in self.sim.carriers:\n            # Initialize the histories all the various things that need them.\n            # This is by-carrier, as the carriers may eventually have different\n            # data requirements (sizes) for their history arrays.\n            self.sim.initialize_histories(\n                carrier,\n                num_departures=26,  # TODO make this a parameter\n                num_timeframes=len(self.dcps) - 1,\n                truncation_rule=carrier.truncation_rule,\n                store_priceable=bool(carrier.frat5),\n                floating_closures=False,\n                wipe_existing=True,\n            )\n\n    def end_trial(self):\n        \"\"\"End of trial processing.\"\"\"\n        self.extract_segmentation_by_timeframe()\n        self.extract_and_reset_bid_price_traces()\n        if self.cnx.is_open:\n            self.db_writer.final_write_to_sqlite(self.cnx._connection)\n            # self.cnx.save_final(self.sim)\n\n    def extract_and_reset_bid_price_traces(self):\n        self.bid_price_traces[self.sim.trial] = {\n            carrier.name: carrier.raw_bid_price_trace() for carrier in self.sim.carriers\n        }\n        self.displacement_traces[self.sim.trial] = {\n            carrier.name: carrier.raw_displacement_cost_trace()\n            for carrier in self.sim.carriers\n        }\n        for carrier in self.sim.carriers:\n            carrier.reset_bid_price_trace()\n            carrier.reset_displacement_cost_trace()\n\n    def extract_segmentation_by_timeframe(\n        self,\n    ):\n        # this should be run, if desired, at the end of each trial\n        num_samples = self.sim.num_samples - self.sim.burn_samples\n        top_level = {}\n        for k in (\"bookings\", \"revenue\"):\n            data = {}\n            for carrier in self.sim.carriers:\n                carrier_data = {}\n                for segment, values in getattr(\n                    carrier, f\"raw_{k}_by_segment_fare_dcp\"\n                )().items():\n                    carrier_data[segment] = (\n                        pd.DataFrame.from_dict(values, \"columns\")\n                        .rename_axis(index=\"days_prior\", columns=\"booking_class\")\n                        .stack()\n                    )\n                if carrier_data:\n                    data[carrier.name] = (\n                        pd.concat(carrier_data, axis=1, names=[\"segment\"]).fillna(0)\n                        / num_samples\n                    )\n            if len(data) == 0:\n                return None\n            top_level[k] = pd.concat(data, axis=0, names=[\"carrier\"])\n        df = pd.concat(top_level, axis=1, names=[\"metric\"])\n        self.segmentation_data_by_timeframe[self.sim.trial] = df\n        return df\n\n    @contextlib.contextmanager\n    def run_single_sample(self) -&gt; int:\n        \"\"\"Context manager to run the next sample in the current trial.\n\n        On entry, the sample number is run through to departure, so all\n        sales have happened, but per-sample wrap up (e.g. rolling history\n        forward, resetting counters) is deferred until exit.  This is useful\n        for running a single sample in a testing framework.\n\n        Yields\n        ------\n        int\n            The sample number just completed.\n        \"\"\"\n        if self.sim.trial &lt; 0:\n            warnings.warn(\n                \"Trial must be started before running a sample, \"\n                \"implicitly starting Trial 0\",\n                skip_file_prefixes=_warn_skips,\n                stacklevel=1,\n            )\n            self.begin_trial(0)\n        self.sim.sample += 1\n        self.reseed(\n            [\n                self.sim.config.simulation_controls.random_seed,\n                self.sim.trial,\n                self.sim.sample,\n            ]\n        )\n        self.sim.reset_counters()\n        self.generate_demands()\n        while True:\n            event = self.sim.go()\n            self.run_carrier_models(event)\n            if event is None or str(event) == \"Done\" or (event[0] == \"Done\"):\n                assert (\n                    self.sim.num_events() == 0\n                ), f\"Event queue still has {self.sim.num_events()} events\"\n                break\n        yield self.sim.sample\n        self.end_sample()\n\n    def _run_single_trial(\n        self,\n        trial: int,\n        n_samples_done: int = 0,\n        n_samples_total: int = 0,\n        progress: ProgressBar | None = None,\n        update_freq: int | None = None,\n    ):\n        \"\"\"Run a single trial of the simulation.\"\"\"\n        memory_log(f\"begin _run_single_trial {trial}\")\n        if not n_samples_total:\n            n_samples_total = self.sim.num_trials * self.sim.num_samples\n\n        self.begin_trial(trial)\n        for sample in range(self.sim.num_samples):\n            t = time.time()\n            if self.sim.config.simulation_controls.double_capacity_until:\n                # Just trying this, PODS has something similar during burn phase\n                if sample == 0:\n                    for leg in self.sim.legs:\n                        leg.capacity = leg.capacity * 2.0\n                elif (\n                    sample == self.sim.config.simulation_controls.double_capacity_until\n                ):\n                    for leg in self.sim.legs:\n                        leg.capacity = leg.capacity / 2.0\n\n            self.sim.sample = sample\n            if self.sim.config.simulation_controls.random_seed is not None:\n                self.reseed(\n                    [\n                        self.sim.config.simulation_controls.random_seed,\n                        trial,\n                        sample,\n                    ]\n                )\n            if update_freq is not None and self.sim.sample % update_freq == 0:\n                total_rev, n = 0.0, 0\n                carrier_info = \"\"\n                for cxr in self.sim.carriers:\n                    total_rev += cxr.revenue\n                    n += 1\n                    carrier_info += (\n                        f\"{', ' if n &gt; 0 else ''}{cxr.name}=${cxr.revenue:8.0f}\"\n                    )\n                dmd_b, dmd_l = 0, 0\n                for dmd in self.sim.demands:\n                    if dmd.business:\n                        dmd_b += dmd.scenario_demand\n                    else:\n                        dmd_l += dmd.scenario_demand\n                d_info = f\", {int(dmd_b)}, {int(dmd_l)}\"\n                logger.info(\n                    f\"Trial={self.sim.trial}, \"\n                    f\"Sample={self.sim.sample}{carrier_info}{d_info}\"\n                )\n            self.sim.reset_counters()\n            if self.sim.sample == 0:\n                self.sim.reset_trial_counters()\n            self.generate_demands()\n            # self.generate_demands_gamma()\n\n            # Loop on passengers\n            while True:\n                event = self.sim.go()\n                memory_log(f\"pre-run_carrier_models {event}\")\n                self.run_carrier_models(event)\n                memory_log(f\"post-run_carrier_models {event}\")\n                if event is None or str(event) == \"Done\" or (event[0] == \"Done\"):\n                    assert (\n                        self.sim.num_events() == 0\n                    ), f\"Event queue still has {self.sim.num_events()} events\"\n                    break\n\n            n_samples_done += 1\n            self.sample_done_callback(n_samples_done, n_samples_total)\n            self.end_sample()\n            if progress is not None:\n                progress.tick(refresh=(sample == 0))\n            logger.info(\"completed sample %i in %.2f secs\", sample, time.time() - t)\n\n        self.sim.num_trials_completed += 1\n        self.end_trial()\n\n    def _run_sim(self, rich_progress: ProgressBar | None = None):\n        update_freq = self.update_frequency\n        logger.debug(\n            f\"run_sim, num_trials = {self.sim.num_trials}, \"\n            f\"num_samples = {self.sim.num_samples}\"\n        )\n        self.db_writer.update_db_write_flags()\n        n_samples_total = self.sim.num_trials * self.sim.num_samples\n        n_samples_done = 0\n        self.sample_done_callback(n_samples_done, n_samples_total)\n        if rich_progress is None:\n            if self.sim.config.simulation_controls.show_progress_bar:\n                progress = ProgressBar(total=n_samples_total)\n            else:\n                progress = DummyProgressBar()\n        else:\n            progress = rich_progress\n        with progress:\n            for trial in range(self.sim.num_trials):\n                self._run_single_trial(\n                    trial,\n                    n_samples_done,\n                    n_samples_total,\n                    progress,\n                    update_freq,\n                )\n\n    def _run_sim_single_trial(\n        self, trial: int, *, rich_progress: ProgressBar | None = None\n    ):\n        update_freq = self.update_frequency\n        self.db_writer.update_db_write_flags()\n        n_samples_total = self.sim.num_samples\n        n_samples_done = 0\n        self.sample_done_callback(n_samples_done, n_samples_total)\n        if rich_progress is None:\n            progress = DummyProgressBar()\n        else:\n            progress = rich_progress\n        with progress:\n            self._run_single_trial(\n                trial,\n                n_samples_done,\n                n_samples_total,\n                progress,\n                update_freq,\n            )\n\n    def run_carrier_models(self, info: Any = None, departed: bool = False, debug=False):\n        what_had_happened_was = []\n        try:\n            event_type = info[0]\n\n            if event_type.startswith(\"callback_\"):\n                # This is a callback function, not a string event type\n                # so, call it with the remaining arguments\n                callback_t = event_type[9:]\n                callback_f = info[1]\n                result = callback_f(self, *info[2:])\n                if isinstance(result, dict):\n                    self.callback_data.update_data(\n                        callback_t, self.sim.trial, self.sim.sample, *info[2:], **result\n                    )\n                return\n\n            recording_day = info[\n                1\n            ]  # could in theory also be non-integer for fractional days\n            dcp_index = info[2]\n            if dcp_index == -1:\n                dcp_index = len(self.dcp_list) - 1\n\n            if event_type.lower() in {\"dcp\", \"done\"}:\n                self.sim.last_dcp = recording_day\n                self.sim.last_dcp_index = dcp_index\n                # self.capture_dcp_data(dcp_index)\n                # self.capture_competitor_data()  # Simulates Infare / QL2\n\n            # Run the specified process(es) for the carriers\n            for carrier in self.sim.carriers:\n                if event_type.lower() == \"dcp\":\n                    # Regular Data Collection Points (pre-departure)\n                    what_had_happened_was.append(f\"run {carrier.name} DCP\")\n                    carrier.rm_system.run(\n                        self.sim,\n                        carrier.name,\n                        dcp_index,\n                        recording_day,\n                        event_type=\"dcp\",\n                    )\n                elif event_type.lower() == \"daily\":\n                    # Daily report, every day prior to departure EXCEPT specified DCPs\n                    what_had_happened_was.append(f\"run {carrier.name} daily\")\n                    carrier.rm_system.run(\n                        self.sim,\n                        carrier.name,\n                        dcp_index,\n                        recording_day,\n                        event_type=\"daily\",\n                    )\n                elif event_type.lower() == \"done\":\n                    # Post departure processing\n                    what_had_happened_was.append(f\"run {carrier.name} done\")\n                    carrier.rm_system.run(\n                        self.sim,\n                        carrier.name,\n                        dcp_index,\n                        recording_day,\n                        event_type=\"dcp\",\n                    )\n                    carrier.rm_system.run(\n                        self.sim,\n                        carrier.name,\n                        dcp_index,\n                        recording_day,\n                        event_type=\"departure\",\n                    )\n                    if self.sim.sample % 7 == 0:\n                        # Can be used less frequently,\n                        # such as ML steps on accumulated data\n                        carrier.rm_system.run(\n                            self.sim,\n                            carrier.name,\n                            dcp_index,\n                            recording_day,\n                            event_type=\"weekly\",\n                        )\n\n            # Internal simulation data capture that is normally done by RM systems\n            if event_type.lower() in {\"dcp\", \"done\"}:\n                self.sim.last_dcp = recording_day\n                self.sim.last_dcp_index = dcp_index\n                self.capture_dcp_data(dcp_index)\n                what_had_happened_was.append(\"capture_dcp_close_data\")\n                if self.sim.config.simulation_controls.capture_competitor_data:\n                    self.capture_competitor_data()  # Simulates Infare / QL2\n\n            # Database capture\n            if event_type.lower() == \"daily\":\n                if (\n                    self.cnx.is_open\n                    and self.sim.save_timeframe_details\n                    and recording_day &gt; 0\n                ):\n                    # if self.sim.sample == 101:\n                    #     print(\"write_to_sqlite DAILY\")\n                    what_had_happened_was.append(\"write_to_sqlite daily\")\n                    _internal_log = self.db_writer.write_to_sqlite(\n                        self.cnx._connection,\n                        recording_day,\n                        store_bid_prices=self.sim.config.db.store_leg_bid_prices,\n                        intermediate_day=True,\n                        store_displacements=self.sim.config.db.store_displacements,\n                    )\n            elif event_type.lower() in {\"dcp\", \"done\"}:\n                if (\n                    event_type.lower() == \"done\"\n                    and \"forecast_accuracy\" in self.config.outputs.reports\n                ):\n                    self.sim.capture_forecast_accuracy()\n                if self.cnx.is_open:\n                    self.cnx.save_details(self.db_writer, self.sim, recording_day)\n                if self.file_writer is not None:\n                    self.file_writer.save_details(self.sim, recording_day)\n\n            # simulation statistics record\n            if event_type.lower() in {\"dcp\", \"done\"}:\n                self.sim.record_dcp_statistics(recording_day)\n            self.sim.record_daily_statistics(recording_day)\n\n        except Exception as e:\n            print(e)\n            print(\"Error in run_carrier_models\")\n            print(f\"{info=}\")\n            print(\"what_had_happened_was=\", what_had_happened_was)\n            raise\n\n    def capture_competitor_data(self):\n        for mkt in self.sim.markets.values():\n            lowest = self.sim.shop(mkt.orig, mkt.dest)\n            for cxr, price in lowest:\n                mkt.set_competitor_price(cxr, price)\n\n    def capture_dcp_data(self, dcp_index, closures_only=False):\n        for leg in self.sim.legs:\n            leg.capture_dcp(dcp_index)\n        for path in self.sim.paths:\n            path.capture_dcp(dcp_index, closures_only=closures_only)\n        for carrier in self.sim.carriers:\n            if dcp_index &gt; 0:\n                carrier.current_tf_index += 1\n\n    def _accum_by_tf(self, dcp_index):\n        # This is now replaced by C++ native counters ...\n        if dcp_index &gt; 0:\n            prev_dcp = self.dcp_list[dcp_index - 1]\n            for f in self.sim.fares:\n                curr_business = self.fare_sales_by_dcp.get((\"business\", prev_dcp), 0)\n                curr_leisure = self.fare_sales_by_dcp.get((\"leisure\", prev_dcp), 0)\n                inc_leisure = curr_leisure + (f.sold - f.sold_business)\n                inc_business = curr_business + f.sold_business\n                self.fare_sales_by_dcp[(\"business\", prev_dcp)] = inc_business\n                self.fare_sales_by_dcp[(\"leisure\", prev_dcp)] = inc_leisure\n\n                key2 = (f.carrier_name, prev_dcp)\n                curr_carrier = self.fare_sales_by_carrier_dcp[key2]\n                self.fare_sales_by_carrier_dcp[key2] = curr_carrier + f.sold\n\n                key3 = (f.carrier_name, f.booking_class, prev_dcp)\n                self.fare_details_sold[key3] += f.sold\n                self.fare_details_sold_business[key3] += f.sold_business\n                self.fare_details_revenue[key3] += f.price * f.sold\n\n    def generate_dcp_rm_events(self, debug=False):\n        \"\"\"Pushes an event per reading day (DCP) onto the queue.\n        Also adds events for daily reoptimzation\"\"\"\n        dcp_hour = self.sim.config.simulation_controls.dcp_hour\n        if debug:\n            tmp = datetime.fromtimestamp(self.sim.base_time, tz=timezone.utc)\n            print(f\"Base Time is {tmp.strftime('%Y-%m-%d %H:%M:%S %Z')}\")\n        for dcp_index, dcp in enumerate(self.dcp_list):\n            if dcp == 0:\n                continue\n            event_time = int(self.sim.base_time - dcp * 86400 + 3600 * dcp_hour)\n            if debug:\n                tmp = datetime.fromtimestamp(event_time, tz=timezone.utc)\n                print(f\"Added DCP {dcp} at {tmp.strftime('%Y-%m-%d %H:%M:%S %Z')}\")\n            info = (\"DCP\", dcp, dcp_index)\n            rm_event = Event(info, event_time)\n            self.sim.add_event(rm_event)\n\n        # Now add the events for daily reoptimization\n        max_days_prior = max(self.dcp_list)\n        dcp_idx = 0\n        for days_prior in reversed(range(max_days_prior)):\n            if days_prior not in self.dcp_list:\n                info = (\"daily\", days_prior, dcp_idx)\n                event_time = int(\n                    self.sim.base_time - days_prior * 86400 + 3600 * dcp_hour\n                )\n                rm_event = Event(info, event_time)\n                self.sim.add_event(rm_event)\n            else:\n                dcp_idx += 1\n\n        # add events for begin and end sample callbacks\n        self.add_callback_events()\n\n    def generate_demands(self, system_rn=None, debug=False):\n        \"\"\"Generate demands, following the procedure used in PODS\n        The biggest difference is that we can put all the timeframe (DCP) demands\n        into the event queue before any processing.\n        For large models, I might rewrite this into the C++ core in the future\"\"\"\n        self.generate_dcp_rm_events()\n        total_events = 0\n        system_rn = (\n            self.random_generator.get_normal() if system_rn is None else system_rn\n        )\n\n        # We don't have an O&amp;D object, but we use this to get a market random number\n        # per market\n        mrn_ref = {}\n\n        # Need to have leisure / business split for PODS\n        trn_ref = {\n            \"business\": self.random_generator.get_normal(),\n            \"leisure\": self.random_generator.get_normal(),\n        }\n\n        def get_or_make_random(grouping, key):\n            if key not in grouping:\n                grouping[key] = self.random_generator.get_normal()\n            return grouping[key]\n\n        end_time = self.base_time\n\n        for dmd in self.sim.demands:\n            base = dmd.base_demand\n\n            # Get the random numbers we're going to use to perturb demand\n            trn = get_or_make_random(trn_ref, (dmd.orig, dmd.dest, dmd.segment))\n            mrn = get_or_make_random(mrn_ref, (dmd.orig, dmd.dest))\n            if self.sim.config.simulation_controls.simple_k_factor:\n                urn = (\n                    self.random_generator.get_normal()\n                    * self.sim.config.simulation_controls.simple_k_factor\n                )\n            else:\n                urn = 0\n\n            mu = base * (\n                1.0\n                + system_rn * self.sim.sys_k_factor\n                + mrn * self.sim.mkt_k_factor\n                + trn * self.sim.pax_type_k_factor\n                + urn\n            )\n            mu = max(mu, 0.0)\n            sigma = sqrt(\n                mu * self.sim.config.simulation_controls.tot_z_factor\n            )  # Correct?\n            n = mu + sigma * self.random_generator.get_normal()\n            dmd.scenario_demand = max(n, 0)\n\n            if debug:\n                logger.debug(\n                    f\"DMD,{self.sim.sample},{dmd.orig},{dmd.dest},\"\n                    f\"{dmd.segment},{dmd.base_demand},\"\n                    f\"{round(mu,2)},{round(sigma,2)},{round(n,2)}\"\n                )\n\n            # Now we split it up over timeframes and add it to the simulation\n            num_pax = int(dmd.scenario_demand + 0.5)  # rounding\n            if (\n                self.sim.config.simulation_controls.timeframe_demand_allocation\n                == \"pods\"\n            ):\n                num_events_by_tf = self.sim.allocate_demand_to_tf_pods(\n                    dmd, num_pax, self.sim.tf_k_factor, int(end_time)\n                )\n            else:\n                num_events_by_tf = self.sim.allocate_demand_to_tf(\n                    dmd, num_pax, self.sim.tf_k_factor, int(end_time)\n                )\n            num_events = sum(num_events_by_tf)\n            total_events += num_events\n            if num_events != round(num_pax):\n                raise ValueError(\n                    f\"Generate demand function, num_pax={num_pax}, \"\n                    f\"num_events={num_events}\"\n                )\n\n        return total_events\n\n    def generate_demands_gamma(self, system_rn=None, debug=False):\n        \"\"\"Using this as a quick test\"\"\"\n        self.generate_dcp_rm_events()\n        end_time = self.base_time\n        cv100 = 0.3\n        for dmd in self.sim.demands:\n            mu = dmd.base_demand\n            std_dev = cv100 * sqrt(mu) * 10.0\n            # std_dev = mu * 0.3\n            var = std_dev**2\n            shape_a = mu**2 / var\n            scale_b = var / mu\n            loc = 0.0\n            r = gamma.rvs(shape_a, loc, scale_b, size=1)\n            num_pax = int(r[0] + 0.5)\n            dmd.scenario_demand = num_pax\n            self.sim.allocate_demand_to_tf_pods(\n                dmd, num_pax, self.sim.tf_k_factor, int(end_time)\n            )\n        total_events = 0\n        return total_events\n\n    def compute_reports(\n        self,\n        sim: SimulationEngine,\n        to_log=True,\n        to_db: bool | database.Database = True,\n        additional=(\n            \"fare_class_mix\",\n            \"load_factors\",\n            # \"bookings_by_timeframe\",\n            \"total_demand\",\n        ),\n    ) -&gt; SummaryTables:\n        num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n        if num_samples &lt;= 0:\n            raise ValueError(\n                \"insufficient number of samples outside burn period for reporting\"\n                f\"\\n- num_trials = {sim.num_trials}\"\n                f\"\\n- num_samples = {sim.num_samples}\"\n                f\"\\n- burn_samples = {sim.burn_samples}\"\n            )\n\n        if to_db is True:\n            to_db = self.cnx\n        class_dist_df = self.compute_class_dist(sim, to_log, to_db)\n        dmd_df = self.compute_demand_report(sim, to_log, to_db)\n        fare_df = self.compute_fare_report(sim, to_log, to_db)\n        leg_df = self.compute_leg_report(sim, to_log, to_db)\n        path_df = self.compute_path_report(sim, to_log, to_db)\n        path_classes_df = self.compute_path_class_report(sim, to_log, to_db)\n        carrier_df = self.compute_carrier_report(sim, to_log, to_db)\n        segmentation_df = self.compute_segmentation_by_timeframe()\n        raw_load_factor_dist_df = self.compute_raw_load_factor_distribution(\n            sim, to_log, to_db\n        )\n        leg_avg_load_factor_dist_df = self.compute_leg_avg_load_factor_distribution(\n            sim, to_log, to_db\n        )\n        fare_class_dist_df = self.compute_raw_fare_class_mix(sim, to_log, to_db)\n        bid_price_history_df = self.compute_bid_price_history(sim, to_log, to_db)\n        displacement_df = self.compute_displacement_history(sim, to_log, to_db)\n        demand_to_come_df = self.compute_demand_to_come_summary(sim, to_log, to_db)\n        local_fraction_dist_df = self.compute_leg_local_fraction_distribution(\n            sim, to_log, to_db\n        )\n        local_fraction_by_place = self.compute_local_fraction_by_place(\n            sim, to_log, to_db\n        )\n\n        summary = SummaryTables(\n            name=sim.name,\n            class_dist=class_dist_df,\n            config=sim.config,\n            demands=dmd_df,\n            fares=fare_df,\n            legs=leg_df,\n            paths=path_df,\n            path_classes=path_classes_df,\n            carriers=carrier_df,\n            bid_price_history=bid_price_history_df,\n            raw_load_factor_distribution=raw_load_factor_dist_df,\n            leg_avg_load_factor_distribution=leg_avg_load_factor_dist_df,\n            raw_fare_class_mix=fare_class_dist_df,\n            leg_local_fraction_distribution=local_fraction_dist_df,\n            local_fraction_by_place=local_fraction_by_place,\n            n_total_samples=num_samples,\n            segmentation_by_timeframe=segmentation_df,\n            displacement_history=displacement_df,\n            demand_to_come_summary=demand_to_come_df,\n        )\n        summary.load_additional_tables(self.cnx, sim.name, sim.burn_samples, additional)\n        summary.cnx = self.cnx\n        return summary\n\n    def compute_demand_report(\n        self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n    ):\n        dmd_df = []\n        for m in sim.demands:\n            avg_price = m.revenue / m.sold if m.sold &gt; 0 else 0\n            dmd_df.append(\n                dict(\n                    orig=m.orig,\n                    dest=m.dest,\n                    segment=m.segment,\n                    sold=m.sold,\n                    revenue=m.revenue,\n                    avg_fare=m.revenue / m.sold if m.sold &gt; 0 else 0,\n                    gt_demand=m.gt_demand,\n                    gt_sold=m.gt_sold,\n                    gt_revenue=m.gt_revenue,\n                )\n            )\n            if to_log:\n                logger.info(\n                    f\"   Dmd: {m.orig}-{m.dest}:{m.segment}\"\n                    f\"  Sold = {m.sold},  \"\n                    f\"Rev = {m.revenue}, \"\n                    f\"AvgFare = {avg_price:.2f}\"\n                )\n        dmd_df = pd.DataFrame(dmd_df)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"demand_summary\", dmd_df)\n        return dmd_df\n\n    def compute_class_dist(\n        self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n    ):\n        # Get unique segments\n        segs = set([dmd.segment for dmd in sim.demands])\n        dist = defaultdict(int)\n        for f in sim.fares:\n            for seg in segs:\n                k = (f.booking_class, seg)\n                try:\n                    dist[k] += f.get_sales_by_segment(seg)\n                except Exception:\n                    # If the segment isn't found, just ignore it.\n                    # i.e. basic economy won't book Y0\n                    pass\n\n        class_dist_df = []\n        for (cls, seg), sold in dist.items():\n            class_dist_df.append(dict(booking_class=cls, segment=seg, sold=sold))\n        class_dist_df = pd.DataFrame(class_dist_df)\n        return class_dist_df\n\n    def compute_fare_report(\n        self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n    ):\n        fare_df = []\n        for f in sim.fares:\n            for dcp_index in range(16):\n                days_prior = self.dcp_list[dcp_index]\n                fare_df.append(\n                    dict(\n                        carrier=f.carrier.name,\n                        orig=f.orig,\n                        dest=f.dest,\n                        booking_class=f.booking_class,\n                        dcp_index=dcp_index,\n                        price=f.price,\n                        sold=f.get_sales_by_dcp2(days_prior),\n                        gt_sold=f.gt_sold,\n                        avg_adjusted_price=f.get_adjusted_by_dcp(dcp_index),\n                    )\n                )\n                if to_log:\n                    logger.info(\n                        f\"   Fare: {f.carrier} {f.orig}-{f.dest}:{f.booking_class}\"\n                        # f\"AvgAdjFare = {avg_adj_price:.2f},\"\n                        f\"  Sold = {f.sold},  \"\n                        f\"Price = {f.price}\"\n                    )\n        fare_df = pd.DataFrame(fare_df)\n        #        if to_db and to_db.is_open:\n        #            to_db.save_dataframe(\"fare_summary\", fare_df)\n        return fare_df\n\n    def compute_leg_report(\n        self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n    ):\n        num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n        leg_df = []\n        for leg in sim.legs:\n            # Checking consistency while I debug the cabin code\n            sum_b1, sum_b2 = 0, 0\n            for b in leg.buckets:\n                sum_b1 += b.sold\n            for c in leg.cabins:\n                for b in c.buckets:\n                    sum_b2 += b.sold\n            if sum_b1 != sum_b2:\n                print(\"Oh, crap!\")\n            avg_sold = leg.gt_sold / num_samples\n            avg_rev = leg.gt_revenue / num_samples\n            lf = 100.0 * leg.gt_sold / (leg.capacity * num_samples)\n            if to_log:\n                logger.info(\n                    f\"    Leg: {leg.carrier}:{leg.flt_no} {leg.orig}-{leg.dest}: \"\n                    f\" AvgSold = {avg_sold:6.2f},  AvgRev = ${avg_rev:,.2f}, \"\n                    f\"LF = {lf:,.2f}%\"\n                )\n            leg_df.append(\n                dict(\n                    leg_id=leg.leg_id,\n                    carrier=leg.carrier_name,\n                    flt_no=leg.flt_no,\n                    orig=leg.orig,\n                    dest=leg.dest,\n                    avg_sold=avg_sold,\n                    avg_rev=avg_rev,\n                    lf=lf,\n                )\n            )\n        leg_df = pd.DataFrame(leg_df)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"leg_summary\", leg_df)\n        return leg_df\n\n    def compute_path_report(\n        self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n    ):\n        num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n        avg_lf, n = 0.0, 0\n        for leg in sim.legs:\n            lf = 100.0 * leg.gt_sold / (leg.capacity * num_samples)\n            avg_lf += lf\n            n += 1\n\n        tot_rev = 0.0\n        for m in sim.demands:\n            tot_rev += m.revenue\n\n        avg_lf = avg_lf / n if n &gt; 0 else 0\n        if to_log:\n            logger.info(f\"    LF:  {avg_lf:6.2f}%, Total revenue = ${tot_rev:,.2f}\")\n\n        path_df = []\n        for path in sim.paths:\n            avg_sold = path.gt_sold / num_samples\n            avg_sold_priceable = path.gt_sold_priceable / num_samples\n            avg_rev = path.gt_revenue / num_samples\n            if to_log:\n                logger.info(\n                    f\"{path}, avg_sold={avg_sold:6.2f}, avg_rev=${avg_rev:10,.2f}\"\n                )\n            data = dict(\n                orig=path.orig,\n                dest=path.dest,\n                carrier1=path.get_leg_carrier(0),\n                leg_id1=path.get_leg_id(0),\n                carrier2=None,\n                leg_id2=None,\n                carrier3=None,\n                leg_id3=None,\n                avg_sold=avg_sold,\n                avg_sold_priceable=avg_sold_priceable,\n                avg_rev=avg_rev,\n            )\n            if path.num_legs() == 1:\n                path_df.append(data)\n            elif path.num_legs() == 2:\n                data[\"carrier2\"] = path.get_leg_carrier(1)\n                data[\"leg_id2\"] = path.get_leg_id(1)\n                path_df.append(data)\n            elif path.num_legs() == 3:\n                data[\"carrier2\"] = path.get_leg_carrier(1)\n                data[\"leg_id2\"] = path.get_leg_id(1)\n                data[\"carrier3\"] = path.get_leg_carrier(2)\n                data[\"leg_id3\"] = path.get_leg_id(2)\n                path_df.append(data)\n            else:\n                raise NotImplementedError(\"path with more than 3 legs\")\n        path_df = pd.DataFrame(path_df)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"path_summary\", path_df)\n        return path_df\n\n    def compute_path_class_report(\n        self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n    ):\n        num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n\n        path_class_df = []\n        for path in sim.paths:\n            for pc in path.pathclasses:\n                avg_sold = pc.gt_sold / num_samples\n                avg_sold_priceable = pc.gt_sold_priceable / num_samples\n                avg_rev = pc.gt_revenue / num_samples\n                if to_log:\n                    logger.info(\n                        f\"{pc}, avg_sold={avg_sold:6.2f}, avg_rev=${avg_rev:10,.2f}\"\n                    )\n                data = dict(\n                    orig=path.orig,\n                    dest=path.dest,\n                    carrier1=path.get_leg_carrier(0),\n                    leg_id1=path.get_leg_id(0),\n                    carrier2=None,\n                    leg_id2=None,\n                    carrier3=None,\n                    leg_id3=None,\n                    booking_class=pc.booking_class,\n                    avg_sold=avg_sold,\n                    avg_sold_priceable=avg_sold_priceable,\n                    avg_rev=avg_rev,\n                )\n                if path.num_legs() == 1:\n                    path_class_df.append(data)\n                elif path.num_legs() == 2:\n                    data[\"carrier2\"] = path.get_leg_carrier(1)\n                    data[\"leg_id2\"] = path.get_leg_id(1)\n                    path_class_df.append(data)\n                elif path.num_legs() == 3:\n                    data[\"carrier2\"] = path.get_leg_carrier(1)\n                    data[\"leg_id2\"] = path.get_leg_id(1)\n                    data[\"carrier3\"] = path.get_leg_carrier(2)\n                    data[\"leg_id3\"] = path.get_leg_id(2)\n                    path_class_df.append(data)\n                else:\n                    raise NotImplementedError(\"path with more than 3 legs\")\n        path_class_df = pd.DataFrame(path_class_df)\n        if not path_class_df.empty:\n            path_class_df.sort_values(\n                by=[\"orig\", \"dest\", \"carrier1\", \"leg_id1\", \"booking_class\"]\n            )\n            #        if to_db and to_db.is_open:\n            #            to_db.save_dataframe(\"path_class_summary\", path_class_df)\n        return path_class_df\n\n    def compute_carrier_report(\n        self,\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Compute a carrier summary table.\n\n        The resulting table has one row per simulated carrier, and the following\n        columns:\n\n        - name\n        - avg_sold\n        - load_factor\n        - avg_rev\n        - asm (available seat miles)\n        - rpm (revenue passenger miles)\n        \"\"\"\n        num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n        carrier_df = []\n\n        carrier_asm = defaultdict(float)\n        carrier_rpm = defaultdict(float)\n        carrier_leg_lf = defaultdict(float)\n        carrier_leg_count = defaultdict(float)\n        for leg in sim.legs:\n            carrier_name = (\n                leg.carrier_name if hasattr(leg, \"carrier_name\") else leg.carrier\n            )  # TODO: remove hasattr\n            carrier_asm[carrier_name] += leg.distance * leg.capacity * num_samples\n            carrier_rpm[carrier_name] += leg.distance * leg.gt_sold\n            carrier_leg_lf[carrier_name] += leg.gt_sold / (leg.capacity * num_samples)\n            carrier_leg_count[carrier_name] += 1\n\n        for cxr in sim.carriers:\n            avg_sold = cxr.gt_sold / num_samples\n            avg_rev = cxr.gt_revenue / num_samples\n            asm = carrier_asm[cxr.name] / num_samples\n            rpm = carrier_rpm[cxr.name] / num_samples\n            # sys_lf = 100.0 * cxr.gt_revenue_passenger_miles / asm if asm &gt; 0 else 0.0\n            denom = carrier_asm[cxr.name]\n            sys_lf = (100.0 * carrier_rpm[cxr.name] / denom) if denom &gt; 0 else 0\n            if to_log:\n                logger.info(\n                    f\"Carrier: {cxr.name}, AvgSold: {round(avg_sold, 2)}, \"\n                    f\"LF {sys_lf:.2f}%,  AvgRev ${avg_rev:10,.2f}\"\n                )\n\n            # Add up total ancillaries\n            tot_anc_rev = 0.0\n            for anc in cxr.ancillaries:\n                print(str(anc))\n                tot_anc_rev += anc.price * anc.sold\n\n            carrier_df.append(\n                {\n                    \"carrier\": cxr.name,\n                    \"sold\": avg_sold,\n                    \"sys_lf\": sys_lf,\n                    \"avg_leg_lf\": 100\n                    * carrier_leg_lf[cxr.name]\n                    / max(carrier_leg_count[cxr.name], 1),\n                    \"avg_rev\": avg_rev,\n                    \"avg_price\": avg_rev / avg_sold if avg_sold &gt; 0 else 0,\n                    \"asm\": asm,\n                    \"rpm\": rpm,\n                    \"yield\": np.nan if rpm == 0 else avg_rev / rpm,\n                    \"ancillary_rev\": tot_anc_rev,\n                }\n            )\n        carrier_df = pd.DataFrame(carrier_df)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"carrier_summary\", carrier_df)\n        return carrier_df\n\n    def compute_segmentation_by_timeframe(self) -&gt; pd.DataFrame | None:\n        if self.segmentation_data_by_timeframe:\n            df = (\n                pd.concat(self.segmentation_data_by_timeframe, axis=0, names=[\"trial\"])\n                .reorder_levels([\"trial\", \"carrier\", \"booking_class\", \"days_prior\"])\n                .sort_index()\n            )\n            # df[\"Total\"] = df.sum(axis=1)\n            return df\n\n    @staticmethod\n    def compute_raw_load_factor_distribution(\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Compute a load factor distribution report.\n\n        This report is a dataframe, with integer index values from 0 to 100,\n        and column for each carrier in the simulation. The values are the\n        frequency of each leg load factor observed during the simulation\n        (excluding any burn period).  The values for leg load factors are\n        rounded down, so that a leg load factor of 99.9% is counted as 99,\n        and only actually sold-out flights are in the 100% bin.\n        \"\"\"\n        result = {}\n        for carrier in sim.carriers:\n            lf = pd.Series(\n                carrier.raw_load_factor_distribution(),\n                index=pd.RangeIndex(101, name=\"leg_load_factor\"),\n                name=\"frequency\",\n            )\n            result[carrier.name] = lf\n        if result:\n            df = pd.concat(result, axis=1, names=[\"carrier\"])\n        else:\n            df = pd.DataFrame(\n                index=pd.RangeIndex(101, name=\"leg_load_factor\"), columns=[]\n            )\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"raw_load_factor_distribution\", df)\n        return df\n\n    @staticmethod\n    def compute_leg_avg_load_factor_distribution(\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Compute a leg average load factor distribution report.\n\n        This report is a dataframe, with integer index values from 0 to 100,\n        and column for each carrier in the simulation. The values are the\n        frequency of each leg average load factor observed over the simulation\n        (excluding any burn period).  The values for leg average load factors\n        are rounded down, so that a leg average load factor of 99.9% is counted\n        as 99, and only always sold-out flights are in the 100% bin.\n\n        This is different from the raw load factor distribution, which is the\n        distribution of load factors across sample days.  The number of\n        observations in the leg average load factor (this distribution) is\n        equal to the number of legs, while the raw load factor distribution\n        has one observation per leg per sample day.  The variance of this\n        distribution is much lower than the raw load factor distribution.\n        \"\"\"\n        idx = pd.RangeIndex(101, name=\"leg_load_factor\")\n        result = {\n            carrier.name: pd.Series(np.zeros(101, dtype=np.int32), index=idx)\n            for carrier in sim.carriers\n        }\n        for leg in sim.legs:\n            try:\n                lf = int(np.floor(leg.avg_load_factor()))\n            except TypeError:\n                # TODO: remove this\n                lf = int(np.floor(leg.avg_load_factor))\n            if lf &gt; 100:\n                lf = 100\n            if lf &lt; 0:\n                lf = 0\n            # TODO remove hasattr\n            result[\n                leg.carrier_name if hasattr(leg, \"carrier_name\") else leg.carrier\n            ].iloc[lf] += 1\n        if result:\n            df = pd.concat(result, axis=1, names=[\"carrier\"])\n        else:\n            df = pd.DataFrame(\n                index=pd.RangeIndex(101, name=\"leg_load_factor\"), columns=[]\n            )\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"leg_avg_load_factor_distribution\", df)\n        return df\n\n    def compute_raw_fare_class_mix(\n        self,\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Compute a fare class distribution report.\n\n        This report is a dataframe, with index values giving the fare class,\n        and column for each carrier in the simulation. The values are the\n        number of passengers for each fare class observed during the simulation\n        (excluding any burn period). This is a count of passengers not legs, so\n        a passenger on a connecting itinerary only counts once.\n        \"\"\"\n        result = {}\n        for carrier in sim.carriers:\n            fc = carrier.raw_fare_class_distribution()\n            fc_sold = pd.Series(\n                {k: v[\"sold\"] for k, v in fc.items()},\n                name=\"frequency\",\n            )\n            fc_rev = pd.Series(\n                {k: v[\"revenue\"] for k, v in fc.items()},\n                name=\"frequency\",\n            )\n            result[carrier.name] = pd.concat(\n                [fc_sold, fc_rev], axis=1, keys=[\"sold\", \"revenue\"]\n            ).rename_axis(index=\"booking_class\")\n        if result:\n            df = pd.concat(result, axis=0, names=[\"carrier\"])\n        else:\n            df = pd.DataFrame(\n                columns=[\"sold\", \"revenue\"],\n                index=pd.MultiIndex(\n                    [[], []], [[], []], names=[\"carrier\", \"booking_class\"]\n                ),\n            )\n        df = df.fillna(0)\n        df[\"sold\"] = df[\"sold\"].astype(int)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"fare_class_distribution\", df)\n        return df\n\n    @staticmethod\n    def compute_bid_price_history(\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Compute the average bid price history for each carrier.\"\"\"\n        result = {}\n        for carrier in sim.carriers:\n            bp = carrier.raw_bid_price_trace()\n            result[carrier.name] = (\n                pd.DataFrame.from_dict(bp, orient=\"index\")\n                .sort_index(ascending=False)\n                .rename_axis(index=\"days_prior\")\n            )\n        if result:\n            df = pd.concat(result, axis=0, names=[\"carrier\"])\n        else:\n            df = pd.DataFrame(\n                columns=[\n                    \"bid_price_mean\",\n                    \"bid_price_stdev\",\n                    \"some_cap_bid_price_mean\",\n                    \"some_cap_bid_price_stdev\",\n                    \"fraction_some_cap\",\n                    \"fraction_zero_cap\",\n                ],\n                index=pd.MultiIndex(\n                    [[], []], [[], []], names=[\"carrier\", \"days_prior\"]\n                ),\n            )\n        df = df.fillna(0)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"bid_price_history\", df)\n        return df\n\n    @staticmethod\n    def compute_displacement_history(\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Compute the average displacement cost history for each carrier.\"\"\"\n        result = {}\n        for carrier in sim.carriers:\n            bp = carrier.raw_displacement_cost_trace()\n            result[carrier.name] = (\n                pd.DataFrame.from_dict(bp, orient=\"index\")\n                .sort_index(ascending=False)\n                .rename_axis(index=\"days_prior\")\n            )\n        if result:\n            df = pd.concat(result, axis=0, names=[\"carrier\"])\n        else:\n            df = pd.DataFrame(\n                columns=[\n                    \"displacement_mean\",\n                    \"displacement_stdev\",\n                ],\n                index=pd.MultiIndex(\n                    [[], []], [[], []], names=[\"carrier\", \"days_prior\"]\n                ),\n            )\n        df = df.fillna(0)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"displacement_history\", df)\n        return df\n\n    @staticmethod\n    def compute_demand_to_come_summary(\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        raw = sim.summary_demand_to_come()\n        df = (\n            from_nested_dict(raw, [\"segment\", \"days_prior\", \"metric\"])\n            .sort_index(ascending=[True, False])\n            .rename(\n                columns={\"mean\": \"mean_future_demand\", \"stdev\": \"stdev_future_demand\"}\n            )\n        )\n        return df\n\n    def compute_leg_local_fraction_distribution(\n        self,\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Compute a report on the fraction of leg passengers who are local.\n\n        This report is a dataframe, with integer index values from 0 to 100,\n        and column for each carrier in the simulation. The values are the\n        frequency of the local leg-passenger fraction on each leg observed\n        over the simulation (excluding any burn period).  The values are\n        rounded down, so that a leg local fraction of 99.9% is counted\n        as 99, and only always-local flights are in the 100% bin.\n        \"\"\"\n        result = {}\n        for carrier in sim.carriers:\n            lf = pd.Series(\n                sim.distribution_local_leg_passengers(carrier),\n                index=pd.RangeIndex(101, name=\"local_fraction\"),\n                name=\"frequency\",\n            )\n            result[carrier.name] = lf\n        if result:\n            df = pd.concat(result, axis=1, names=[\"carrier\"])\n        else:\n            df = pd.DataFrame(\n                index=pd.RangeIndex(101, name=\"local_fraction\"), columns=[]\n            )\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"leg_local_fraction_distribution\", df)\n        return df\n\n    def compute_local_fraction_by_place(\n        self,\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Compute a report on the fraction of leg passengers who are local.\n\n        Parameters\n        ----------\n        sim\n        to_log\n        to_db\n\n        Returns\n        -------\n        pd.DataFrame\n        \"\"\"\n        result = {}\n        for carrier in sim.carriers:\n            df = pd.Series(\n                sim.fraction_local_by_carrier_and_place(carrier.name),\n                name=carrier.name,\n            )\n            result[carrier.name] = df\n        if result:\n            df = pd.concat(result, axis=1, names=[\"carrier\"])\n        else:\n            df = pd.DataFrame(index=[], columns=[])\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"local_fraction_by_place\", df)\n        return df\n\n    def reseed(self, seed: int | list[int] | None = 42):\n        logger.debug(\"reseeding random_generator: %s\", seed)\n        self.sim.random_generator.seed(seed)\n\n    def _user_certificate(self, certificate_filename=None):\n        if certificate_filename:\n            from cryptography.x509 import load_pem_x509_certificate\n\n            certificate_filename = pathlib.Path(certificate_filename)\n            with certificate_filename.open(\"rb\") as f:\n                user_cert = load_pem_x509_certificate(f.read())\n        else:\n            user_cert = self.sim.config.license_certificate\n        return user_cert\n\n    def validate_license(self, certificate_filename=None, future: int = 0):\n        user_cert = self._user_certificate(certificate_filename)\n        return self.sim.validate_license(user_cert, future=future)\n\n    def license_info(self, certificate_filename=None):\n        user_cert = self._user_certificate(certificate_filename)\n        return self.sim.license_info(user_cert)\n\n    @property\n    def config(self) -&gt; Config:\n        \"\"\"The configuration used for this Simulation.\"\"\"\n        return self.sim.config\n\n    def run(\n        self,\n        log_reports: bool = False,\n        *,\n        single_trial: int | None = None,\n        summarizer: type[SimulationTablesT]\n        | SimulationTablesT\n        | None = SimulationTables,\n    ) -&gt; SummaryTables | SimulationTablesT:\n        \"\"\"\n        Run the simulation and compute reports.\n\n        Parameters\n        ----------\n        log_reports : bool\n        single_trial : int, optional\n            Run only a single trial, with the given trial number (to get\n            the correct fixed random seed, for example).\n        summarizer : type[SimulationTables] | SimulationTables | None\n            Use this summarizer to compute the reports.  If None, the\n            reports are computed in the SummaryTables object; this option\n            is deprecated and will eventually be removed.\n\n        Returns\n        -------\n        SimulationTables or SummaryTables\n        \"\"\"\n        if summarizer is None:\n            warnings.warn(\n                \"Using SummaryTables to compute reports is deprecated, \"\n                \"prefer SimulationTables in new code.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n\n        start_time = time.time()\n        self.setup_scenario()\n        if single_trial is not None:\n            self._run_sim_single_trial(single_trial)\n        else:\n            self._run_sim()\n        if self.choice_set_file is not None:\n            self.choice_set_file.close()\n        logger.info(\"Computing reports\")\n        if summarizer is None:\n            summary = self.compute_reports(\n                self.sim,\n                to_log=log_reports or self.sim.config.outputs.log_reports,\n                additional=self.sim.config.outputs.reports,\n            )\n            logger.info(\"Saving reports\")\n            if self.sim.config.outputs.excel:\n                summary.to_xlsx(self.sim.config.outputs.excel)\n        else:\n            if isinstance(summarizer, GenericSimulationTables):\n                summary = summarizer._extract(self)\n            elif issubclass(summarizer, GenericSimulationTables):\n                summary = summarizer.extract(self)\n            else:\n                raise TypeError(\n                    \"summarizer must be an instance or subclass of \"\n                    \"GenericSimulationTables\"\n                )\n\n        # write output files if designated\n        if isinstance(summary, GenericSimulationTables):\n            if self.config.outputs.html:\n                out_filename = summary.to_html(self.config.outputs.html.filename)\n                summary._metadata[\"outputs.html_filename\"] = out_filename\n            if self.config.outputs.pickle:\n                pkl_filename = summary.to_pickle(self.config.outputs.pickle)\n                summary._metadata[\"outputs.pickle_filename\"] = pkl_filename\n            if self.config.outputs.excel:\n                summary.to_xlsx(self.config.outputs.excel)\n\n        logger.info(\n            f\"Th' th' that's all folks !!!    \"\n            f\"(Elapsed time = {round(time.time() - start_time, 2)})\"\n        )\n        return summary\n\n    def run_trial(self, trial: int, log_reports: bool = False) -&gt; SummaryTables:\n        self.setup_scenario()\n        self.sim.trial = trial\n\n        update_freq = self.update_frequency\n        logger.debug(\n            f\"run_sim, num_trials = {self.sim.num_trials}, \"\n            f\"num_samples = {self.sim.num_samples}\"\n        )\n        self.db_writer.update_db_write_flags()\n        n_samples_total = self.sim.num_samples\n        n_samples_done = 0\n        self.sample_done_callback(n_samples_done, n_samples_total)\n        if self.sim.config.simulation_controls.show_progress_bar:\n            progress = ProgressBar(total=n_samples_total)\n        else:\n            progress = DummyProgressBar()\n        with progress:\n            self._run_single_trial(\n                trial,\n                n_samples_done,\n                n_samples_total,\n                progress,\n                update_freq,\n            )\n        summary = self.compute_reports(\n            self.sim,\n            to_log=log_reports or self.sim.config.outputs.log_reports,\n            additional=self.sim.config.outputs.reports,\n        )\n        return summary\n\n    def backup_db(self, dst: pathlib.Path | str | sqlite3.Connection):\n        \"\"\"Back up this database to another copy.\n\n        Parameters\n        ----------\n        dst : Path-like or sqlite3.Connection\n        \"\"\"\n        return self.cnx.backup(dst)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.airports", "title": "airports  <code>instance-attribute</code>", "text": "<pre><code>airports = {}\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.base_time", "title": "base_time  <code>property</code>", "text": "<pre><code>base_time: int\n</code></pre> <p>The base time for the simulation, in seconds since the epoch.</p>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.bid_price_traces", "title": "bid_price_traces  <code>instance-attribute</code>", "text": "<pre><code>bid_price_traces: dict[int, Any] = {}\n</code></pre> <p>Bid price traces for each carrier.</p> <p>The key is the trial number, and the value is a dictionary with carrier names as keys and bid price traces as values.</p>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.callback_data", "title": "callback_data  <code>instance-attribute</code>", "text": "<pre><code>callback_data = CallbackData()\n</code></pre> <p>Data stored from callbacks.</p> <p>This allows a user to store arbitrary data during a simulation using callbacks, and access it later.</p>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.capacity_multiplier", "title": "capacity_multiplier  <code>instance-attribute</code>", "text": "<pre><code>capacity_multiplier = 1.0\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.choice_models", "title": "choice_models  <code>instance-attribute</code>", "text": "<pre><code>choice_models = {}\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.choice_set_file", "title": "choice_set_file  <code>instance-attribute</code>", "text": "<pre><code>choice_set_file = None\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.choice_set_obs", "title": "choice_set_obs  <code>instance-attribute</code>", "text": "<pre><code>choice_set_obs = 0\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.classes", "title": "classes  <code>instance-attribute</code>", "text": "<pre><code>classes = []\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.cnx", "title": "cnx  <code>instance-attribute</code>", "text": "<pre><code>cnx = Database()\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.config", "title": "config  <code>property</code>", "text": "<pre><code>config: Config\n</code></pre> <p>The configuration used for this Simulation.</p>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.db_writer", "title": "db_writer  <code>instance-attribute</code>", "text": "<pre><code>db_writer = None\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.dcp_list", "title": "dcp_list  <code>instance-attribute</code>", "text": "<pre><code>dcp_list = [\n    63,\n    56,\n    49,\n    42,\n    35,\n    31,\n    28,\n    24,\n    21,\n    17,\n    14,\n    10,\n    7,\n    5,\n    3,\n    1,\n    0,\n]\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.debug", "title": "debug  <code>instance-attribute</code>", "text": "<pre><code>debug = False\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.demand_multiplier", "title": "demand_multiplier  <code>instance-attribute</code>", "text": "<pre><code>demand_multiplier = 1.0\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.displacement_traces", "title": "displacement_traces  <code>instance-attribute</code>", "text": "<pre><code>displacement_traces: dict[int, Any] = {}\n</code></pre> <p>Displacement cost traces for each carrier.</p> <p>The key is the trial number, and the value is a dictionary with carrier names as keys and displacement cost traces as values.</p>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_details_revenue", "title": "fare_details_revenue  <code>instance-attribute</code>", "text": "<pre><code>fare_details_revenue = defaultdict(float)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_details_sold", "title": "fare_details_sold  <code>instance-attribute</code>", "text": "<pre><code>fare_details_sold = defaultdict(int)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_details_sold_business", "title": "fare_details_sold_business  <code>instance-attribute</code>", "text": "<pre><code>fare_details_sold_business = defaultdict(int)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_sales_by_carrier_dcp", "title": "fare_sales_by_carrier_dcp  <code>instance-attribute</code>", "text": "<pre><code>fare_sales_by_carrier_dcp = defaultdict(int)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_sales_by_dcp", "title": "fare_sales_by_dcp  <code>instance-attribute</code>", "text": "<pre><code>fare_sales_by_dcp = defaultdict(int)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.file_writer", "title": "file_writer  <code>instance-attribute</code>", "text": "<pre><code>file_writer = FileWriter(output_dir)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.frat5curves", "title": "frat5curves  <code>instance-attribute</code>", "text": "<pre><code>frat5curves = {}\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.load_factor_curves", "title": "load_factor_curves  <code>instance-attribute</code>", "text": "<pre><code>load_factor_curves = {}\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator = Generator(42)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.sample_done_callback", "title": "sample_done_callback  <code>instance-attribute</code>", "text": "<pre><code>sample_done_callback = lambda n, n_total: None\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.segmentation_data_by_timeframe", "title": "segmentation_data_by_timeframe  <code>instance-attribute</code>", "text": "<pre><code>segmentation_data_by_timeframe: dict[int, DataFrame] = {}\n</code></pre> <p>Bookings and revenue segmentation by timeframe.</p> <p>The key is the trial number, and the value is a DataFrame with a breakdown of bookings and revenue by timeframe, customer segment, carrier, and booking class.</p>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.snapshot_filters", "title": "snapshot_filters  <code>property</code> <code>writable</code>", "text": "<pre><code>snapshot_filters: list[SnapshotFilter] | None\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.todd_curves", "title": "todd_curves  <code>instance-attribute</code>", "text": "<pre><code>todd_curves = {}\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.update_frequency", "title": "update_frequency  <code>instance-attribute</code>", "text": "<pre><code>update_frequency = None\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.__init__", "title": "__init__", "text": "<pre><code>__init__(config: Config, output_dir: Path | None = None)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def __init__(\n    self,\n    config: Config,\n    output_dir: pathlib.Path | None = None,\n):\n    revalidate(config)\n    super().__init__(config, output_dir)\n    if config.simulation_controls.write_raw_files:\n        try:\n            from passengersim_core.utils import FileWriter\n        except ImportError:\n            self.file_writer = None\n        else:\n            self.file_writer = FileWriter.FileWriter(output_dir)\n    else:\n        self.file_writer = None\n    self.db_writer = None\n    self.dcp_list = [63, 56, 49, 42, 35, 31, 28, 24, 21, 17, 14, 10, 7, 5, 3, 1, 0]\n    self.classes = []\n    self.fare_sales_by_dcp = defaultdict(int)\n    self.fare_sales_by_carrier_dcp = defaultdict(int)\n    self.fare_details_sold = defaultdict(int)\n    self.fare_details_sold_business = defaultdict(int)\n    self.fare_details_revenue = defaultdict(float)\n    self.demand_multiplier = 1.0\n    self.capacity_multiplier = 1.0\n    self.airports = {}\n    self.choice_models = {}\n    self.frat5curves = {}\n    self.load_factor_curves = {}\n    self.todd_curves = {}\n    self.debug = False\n    self.update_frequency = None\n    self.random_generator = passengersim.core.Generator(42)\n    self.sample_done_callback = lambda n, n_total: None\n    self.choice_set_file = None\n    self.choice_set_obs = 0\n    self.segmentation_data_by_timeframe: dict[int, pd.DataFrame] = {}\n    \"\"\"Bookings and revenue segmentation by timeframe.\n\n    The key is the trial number, and the value is a DataFrame with a\n    breakdown of bookings and revenue by timeframe, customer segment,\n    carrier, and booking class.\n    \"\"\"\n\n    self.bid_price_traces: dict[int, Any] = {}\n    \"\"\"Bid price traces for each carrier.\n\n    The key is the trial number, and the value is a dictionary with\n    carrier names as keys and bid price traces as values.\"\"\"\n\n    self.displacement_traces: dict[int, Any] = {}\n    \"\"\"Displacement cost traces for each carrier.\n\n    The key is the trial number, and the value is a dictionary with\n    carrier names as keys and displacement cost traces as values.\"\"\"\n\n    self._fare_restriction_mapping = {}\n    \"\"\"Mapping of fare restriction names to restriction numbers.\"\"\"\n\n    self._fare_restriction_list = []\n    \"\"\"List of fare restriction names in the order they were added.\"\"\"\n\n    self._initialize(config)\n    if not config.db:\n        self.cnx = database.Database()\n    else:\n        self.cnx = database.Database(\n            engine=config.db.engine,\n            filename=config.db.filename,\n            pragmas=config.db.pragmas,\n            commit_count_delay=config.db.commit_count_delay,\n        )\n    if self.cnx.is_open:\n        database.tables.create_table_leg_defs(self.cnx._connection, self.sim.legs)\n        database.tables.create_table_fare_defs(self.cnx._connection, self.sim.fares)\n        database.tables.create_table_fare_restriction_defs(\n            self.cnx._connection, self._fare_restriction_list\n        )\n        database.tables.create_table_path_defs(self.cnx._connection, self.sim.paths)\n        if config.db != \":memory:\":\n            self.cnx.save_configs(config)\n\n    self.callback_data = CallbackData()\n    \"\"\"Data stored from callbacks.\n\n    This allows a user to store arbitrary data during a simulation using callbacks,\n    and access it later.\n    \"\"\"\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.backup_db", "title": "backup_db", "text": "<pre><code>backup_db(dst: Path | str | Connection)\n</code></pre> <p>Back up this database to another copy.</p> <p>Parameters:</p> <ul> <li> <code>dst</code>               (<code>Path - like or Connection</code>)           \u2013            </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def backup_db(self, dst: pathlib.Path | str | sqlite3.Connection):\n    \"\"\"Back up this database to another copy.\n\n    Parameters\n    ----------\n    dst : Path-like or sqlite3.Connection\n    \"\"\"\n    return self.cnx.backup(dst)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.begin_trial", "title": "begin_trial", "text": "<pre><code>begin_trial(trial: int)\n</code></pre> <p>Beginning of trial processing.</p> <p>Parameters:</p> <ul> <li> <code>trial</code>               (<code>int</code>)           \u2013            <p>The trial number.</p> </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def begin_trial(self, trial: int):\n    \"\"\"Beginning of trial processing.\n\n    Parameters\n    ----------\n    trial : int\n        The trial number.\n    \"\"\"\n    self.sim.trial = trial\n    self.sim.reset_trial_counters()\n\n    for carrier in self.sim.carriers:\n        # Initialize the histories all the various things that need them.\n        # This is by-carrier, as the carriers may eventually have different\n        # data requirements (sizes) for their history arrays.\n        self.sim.initialize_histories(\n            carrier,\n            num_departures=26,  # TODO make this a parameter\n            num_timeframes=len(self.dcps) - 1,\n            truncation_rule=carrier.truncation_rule,\n            store_priceable=bool(carrier.frat5),\n            floating_closures=False,\n            wipe_existing=True,\n        )\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.capture_competitor_data", "title": "capture_competitor_data", "text": "<pre><code>capture_competitor_data()\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def capture_competitor_data(self):\n    for mkt in self.sim.markets.values():\n        lowest = self.sim.shop(mkt.orig, mkt.dest)\n        for cxr, price in lowest:\n            mkt.set_competitor_price(cxr, price)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.capture_dcp_data", "title": "capture_dcp_data", "text": "<pre><code>capture_dcp_data(dcp_index, closures_only=False)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def capture_dcp_data(self, dcp_index, closures_only=False):\n    for leg in self.sim.legs:\n        leg.capture_dcp(dcp_index)\n    for path in self.sim.paths:\n        path.capture_dcp(dcp_index, closures_only=closures_only)\n    for carrier in self.sim.carriers:\n        if dcp_index &gt; 0:\n            carrier.current_tf_index += 1\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_bid_price_history", "title": "compute_bid_price_history  <code>staticmethod</code>", "text": "<pre><code>compute_bid_price_history(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute the average bid price history for each carrier.</p> Source code in <code>passengersim/driver.py</code> <pre><code>@staticmethod\ndef compute_bid_price_history(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Compute the average bid price history for each carrier.\"\"\"\n    result = {}\n    for carrier in sim.carriers:\n        bp = carrier.raw_bid_price_trace()\n        result[carrier.name] = (\n            pd.DataFrame.from_dict(bp, orient=\"index\")\n            .sort_index(ascending=False)\n            .rename_axis(index=\"days_prior\")\n        )\n    if result:\n        df = pd.concat(result, axis=0, names=[\"carrier\"])\n    else:\n        df = pd.DataFrame(\n            columns=[\n                \"bid_price_mean\",\n                \"bid_price_stdev\",\n                \"some_cap_bid_price_mean\",\n                \"some_cap_bid_price_stdev\",\n                \"fraction_some_cap\",\n                \"fraction_zero_cap\",\n            ],\n            index=pd.MultiIndex(\n                [[], []], [[], []], names=[\"carrier\", \"days_prior\"]\n            ),\n        )\n    df = df.fillna(0)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"bid_price_history\", df)\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_carrier_report", "title": "compute_carrier_report", "text": "<pre><code>compute_carrier_report(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute a carrier summary table.</p> <p>The resulting table has one row per simulated carrier, and the following columns:</p> <ul> <li>name</li> <li>avg_sold</li> <li>load_factor</li> <li>avg_rev</li> <li>asm (available seat miles)</li> <li>rpm (revenue passenger miles)</li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_carrier_report(\n    self,\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute a carrier summary table.\n\n    The resulting table has one row per simulated carrier, and the following\n    columns:\n\n    - name\n    - avg_sold\n    - load_factor\n    - avg_rev\n    - asm (available seat miles)\n    - rpm (revenue passenger miles)\n    \"\"\"\n    num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n    carrier_df = []\n\n    carrier_asm = defaultdict(float)\n    carrier_rpm = defaultdict(float)\n    carrier_leg_lf = defaultdict(float)\n    carrier_leg_count = defaultdict(float)\n    for leg in sim.legs:\n        carrier_name = (\n            leg.carrier_name if hasattr(leg, \"carrier_name\") else leg.carrier\n        )  # TODO: remove hasattr\n        carrier_asm[carrier_name] += leg.distance * leg.capacity * num_samples\n        carrier_rpm[carrier_name] += leg.distance * leg.gt_sold\n        carrier_leg_lf[carrier_name] += leg.gt_sold / (leg.capacity * num_samples)\n        carrier_leg_count[carrier_name] += 1\n\n    for cxr in sim.carriers:\n        avg_sold = cxr.gt_sold / num_samples\n        avg_rev = cxr.gt_revenue / num_samples\n        asm = carrier_asm[cxr.name] / num_samples\n        rpm = carrier_rpm[cxr.name] / num_samples\n        # sys_lf = 100.0 * cxr.gt_revenue_passenger_miles / asm if asm &gt; 0 else 0.0\n        denom = carrier_asm[cxr.name]\n        sys_lf = (100.0 * carrier_rpm[cxr.name] / denom) if denom &gt; 0 else 0\n        if to_log:\n            logger.info(\n                f\"Carrier: {cxr.name}, AvgSold: {round(avg_sold, 2)}, \"\n                f\"LF {sys_lf:.2f}%,  AvgRev ${avg_rev:10,.2f}\"\n            )\n\n        # Add up total ancillaries\n        tot_anc_rev = 0.0\n        for anc in cxr.ancillaries:\n            print(str(anc))\n            tot_anc_rev += anc.price * anc.sold\n\n        carrier_df.append(\n            {\n                \"carrier\": cxr.name,\n                \"sold\": avg_sold,\n                \"sys_lf\": sys_lf,\n                \"avg_leg_lf\": 100\n                * carrier_leg_lf[cxr.name]\n                / max(carrier_leg_count[cxr.name], 1),\n                \"avg_rev\": avg_rev,\n                \"avg_price\": avg_rev / avg_sold if avg_sold &gt; 0 else 0,\n                \"asm\": asm,\n                \"rpm\": rpm,\n                \"yield\": np.nan if rpm == 0 else avg_rev / rpm,\n                \"ancillary_rev\": tot_anc_rev,\n            }\n        )\n    carrier_df = pd.DataFrame(carrier_df)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"carrier_summary\", carrier_df)\n    return carrier_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_class_dist", "title": "compute_class_dist", "text": "<pre><code>compute_class_dist(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_class_dist(\n    self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n):\n    # Get unique segments\n    segs = set([dmd.segment for dmd in sim.demands])\n    dist = defaultdict(int)\n    for f in sim.fares:\n        for seg in segs:\n            k = (f.booking_class, seg)\n            try:\n                dist[k] += f.get_sales_by_segment(seg)\n            except Exception:\n                # If the segment isn't found, just ignore it.\n                # i.e. basic economy won't book Y0\n                pass\n\n    class_dist_df = []\n    for (cls, seg), sold in dist.items():\n        class_dist_df.append(dict(booking_class=cls, segment=seg, sold=sold))\n    class_dist_df = pd.DataFrame(class_dist_df)\n    return class_dist_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_demand_report", "title": "compute_demand_report", "text": "<pre><code>compute_demand_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_demand_report(\n    self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n):\n    dmd_df = []\n    for m in sim.demands:\n        avg_price = m.revenue / m.sold if m.sold &gt; 0 else 0\n        dmd_df.append(\n            dict(\n                orig=m.orig,\n                dest=m.dest,\n                segment=m.segment,\n                sold=m.sold,\n                revenue=m.revenue,\n                avg_fare=m.revenue / m.sold if m.sold &gt; 0 else 0,\n                gt_demand=m.gt_demand,\n                gt_sold=m.gt_sold,\n                gt_revenue=m.gt_revenue,\n            )\n        )\n        if to_log:\n            logger.info(\n                f\"   Dmd: {m.orig}-{m.dest}:{m.segment}\"\n                f\"  Sold = {m.sold},  \"\n                f\"Rev = {m.revenue}, \"\n                f\"AvgFare = {avg_price:.2f}\"\n            )\n    dmd_df = pd.DataFrame(dmd_df)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"demand_summary\", dmd_df)\n    return dmd_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_demand_to_come_summary", "title": "compute_demand_to_come_summary  <code>staticmethod</code>", "text": "<pre><code>compute_demand_to_come_summary(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>@staticmethod\ndef compute_demand_to_come_summary(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    raw = sim.summary_demand_to_come()\n    df = (\n        from_nested_dict(raw, [\"segment\", \"days_prior\", \"metric\"])\n        .sort_index(ascending=[True, False])\n        .rename(\n            columns={\"mean\": \"mean_future_demand\", \"stdev\": \"stdev_future_demand\"}\n        )\n    )\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_displacement_history", "title": "compute_displacement_history  <code>staticmethod</code>", "text": "<pre><code>compute_displacement_history(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute the average displacement cost history for each carrier.</p> Source code in <code>passengersim/driver.py</code> <pre><code>@staticmethod\ndef compute_displacement_history(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Compute the average displacement cost history for each carrier.\"\"\"\n    result = {}\n    for carrier in sim.carriers:\n        bp = carrier.raw_displacement_cost_trace()\n        result[carrier.name] = (\n            pd.DataFrame.from_dict(bp, orient=\"index\")\n            .sort_index(ascending=False)\n            .rename_axis(index=\"days_prior\")\n        )\n    if result:\n        df = pd.concat(result, axis=0, names=[\"carrier\"])\n    else:\n        df = pd.DataFrame(\n            columns=[\n                \"displacement_mean\",\n                \"displacement_stdev\",\n            ],\n            index=pd.MultiIndex(\n                [[], []], [[], []], names=[\"carrier\", \"days_prior\"]\n            ),\n        )\n    df = df.fillna(0)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"displacement_history\", df)\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_fare_report", "title": "compute_fare_report", "text": "<pre><code>compute_fare_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_fare_report(\n    self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n):\n    fare_df = []\n    for f in sim.fares:\n        for dcp_index in range(16):\n            days_prior = self.dcp_list[dcp_index]\n            fare_df.append(\n                dict(\n                    carrier=f.carrier.name,\n                    orig=f.orig,\n                    dest=f.dest,\n                    booking_class=f.booking_class,\n                    dcp_index=dcp_index,\n                    price=f.price,\n                    sold=f.get_sales_by_dcp2(days_prior),\n                    gt_sold=f.gt_sold,\n                    avg_adjusted_price=f.get_adjusted_by_dcp(dcp_index),\n                )\n            )\n            if to_log:\n                logger.info(\n                    f\"   Fare: {f.carrier} {f.orig}-{f.dest}:{f.booking_class}\"\n                    # f\"AvgAdjFare = {avg_adj_price:.2f},\"\n                    f\"  Sold = {f.sold},  \"\n                    f\"Price = {f.price}\"\n                )\n    fare_df = pd.DataFrame(fare_df)\n    #        if to_db and to_db.is_open:\n    #            to_db.save_dataframe(\"fare_summary\", fare_df)\n    return fare_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_leg_avg_load_factor_distribution", "title": "compute_leg_avg_load_factor_distribution  <code>staticmethod</code>", "text": "<pre><code>compute_leg_avg_load_factor_distribution(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute a leg average load factor distribution report.</p> <p>This report is a dataframe, with integer index values from 0 to 100, and column for each carrier in the simulation. The values are the frequency of each leg average load factor observed over the simulation (excluding any burn period).  The values for leg average load factors are rounded down, so that a leg average load factor of 99.9% is counted as 99, and only always sold-out flights are in the 100% bin.</p> <p>This is different from the raw load factor distribution, which is the distribution of load factors across sample days.  The number of observations in the leg average load factor (this distribution) is equal to the number of legs, while the raw load factor distribution has one observation per leg per sample day.  The variance of this distribution is much lower than the raw load factor distribution.</p> Source code in <code>passengersim/driver.py</code> <pre><code>@staticmethod\ndef compute_leg_avg_load_factor_distribution(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute a leg average load factor distribution report.\n\n    This report is a dataframe, with integer index values from 0 to 100,\n    and column for each carrier in the simulation. The values are the\n    frequency of each leg average load factor observed over the simulation\n    (excluding any burn period).  The values for leg average load factors\n    are rounded down, so that a leg average load factor of 99.9% is counted\n    as 99, and only always sold-out flights are in the 100% bin.\n\n    This is different from the raw load factor distribution, which is the\n    distribution of load factors across sample days.  The number of\n    observations in the leg average load factor (this distribution) is\n    equal to the number of legs, while the raw load factor distribution\n    has one observation per leg per sample day.  The variance of this\n    distribution is much lower than the raw load factor distribution.\n    \"\"\"\n    idx = pd.RangeIndex(101, name=\"leg_load_factor\")\n    result = {\n        carrier.name: pd.Series(np.zeros(101, dtype=np.int32), index=idx)\n        for carrier in sim.carriers\n    }\n    for leg in sim.legs:\n        try:\n            lf = int(np.floor(leg.avg_load_factor()))\n        except TypeError:\n            # TODO: remove this\n            lf = int(np.floor(leg.avg_load_factor))\n        if lf &gt; 100:\n            lf = 100\n        if lf &lt; 0:\n            lf = 0\n        # TODO remove hasattr\n        result[\n            leg.carrier_name if hasattr(leg, \"carrier_name\") else leg.carrier\n        ].iloc[lf] += 1\n    if result:\n        df = pd.concat(result, axis=1, names=[\"carrier\"])\n    else:\n        df = pd.DataFrame(\n            index=pd.RangeIndex(101, name=\"leg_load_factor\"), columns=[]\n        )\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"leg_avg_load_factor_distribution\", df)\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_leg_local_fraction_distribution", "title": "compute_leg_local_fraction_distribution", "text": "<pre><code>compute_leg_local_fraction_distribution(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute a report on the fraction of leg passengers who are local.</p> <p>This report is a dataframe, with integer index values from 0 to 100, and column for each carrier in the simulation. The values are the frequency of the local leg-passenger fraction on each leg observed over the simulation (excluding any burn period).  The values are rounded down, so that a leg local fraction of 99.9% is counted as 99, and only always-local flights are in the 100% bin.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_leg_local_fraction_distribution(\n    self,\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute a report on the fraction of leg passengers who are local.\n\n    This report is a dataframe, with integer index values from 0 to 100,\n    and column for each carrier in the simulation. The values are the\n    frequency of the local leg-passenger fraction on each leg observed\n    over the simulation (excluding any burn period).  The values are\n    rounded down, so that a leg local fraction of 99.9% is counted\n    as 99, and only always-local flights are in the 100% bin.\n    \"\"\"\n    result = {}\n    for carrier in sim.carriers:\n        lf = pd.Series(\n            sim.distribution_local_leg_passengers(carrier),\n            index=pd.RangeIndex(101, name=\"local_fraction\"),\n            name=\"frequency\",\n        )\n        result[carrier.name] = lf\n    if result:\n        df = pd.concat(result, axis=1, names=[\"carrier\"])\n    else:\n        df = pd.DataFrame(\n            index=pd.RangeIndex(101, name=\"local_fraction\"), columns=[]\n        )\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"leg_local_fraction_distribution\", df)\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_leg_report", "title": "compute_leg_report", "text": "<pre><code>compute_leg_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_leg_report(\n    self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n):\n    num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n    leg_df = []\n    for leg in sim.legs:\n        # Checking consistency while I debug the cabin code\n        sum_b1, sum_b2 = 0, 0\n        for b in leg.buckets:\n            sum_b1 += b.sold\n        for c in leg.cabins:\n            for b in c.buckets:\n                sum_b2 += b.sold\n        if sum_b1 != sum_b2:\n            print(\"Oh, crap!\")\n        avg_sold = leg.gt_sold / num_samples\n        avg_rev = leg.gt_revenue / num_samples\n        lf = 100.0 * leg.gt_sold / (leg.capacity * num_samples)\n        if to_log:\n            logger.info(\n                f\"    Leg: {leg.carrier}:{leg.flt_no} {leg.orig}-{leg.dest}: \"\n                f\" AvgSold = {avg_sold:6.2f},  AvgRev = ${avg_rev:,.2f}, \"\n                f\"LF = {lf:,.2f}%\"\n            )\n        leg_df.append(\n            dict(\n                leg_id=leg.leg_id,\n                carrier=leg.carrier_name,\n                flt_no=leg.flt_no,\n                orig=leg.orig,\n                dest=leg.dest,\n                avg_sold=avg_sold,\n                avg_rev=avg_rev,\n                lf=lf,\n            )\n        )\n    leg_df = pd.DataFrame(leg_df)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"leg_summary\", leg_df)\n    return leg_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_local_fraction_by_place", "title": "compute_local_fraction_by_place", "text": "<pre><code>compute_local_fraction_by_place(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute a report on the fraction of leg passengers who are local.</p> <p>Parameters:</p> <ul> <li> <code>sim</code>               (<code>SimulationEngine</code>)           \u2013            </li> <li> <code>to_log</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>to_db</code>               (<code>Database | None</code>, default:                   <code>None</code> )           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_local_fraction_by_place(\n    self,\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute a report on the fraction of leg passengers who are local.\n\n    Parameters\n    ----------\n    sim\n    to_log\n    to_db\n\n    Returns\n    -------\n    pd.DataFrame\n    \"\"\"\n    result = {}\n    for carrier in sim.carriers:\n        df = pd.Series(\n            sim.fraction_local_by_carrier_and_place(carrier.name),\n            name=carrier.name,\n        )\n        result[carrier.name] = df\n    if result:\n        df = pd.concat(result, axis=1, names=[\"carrier\"])\n    else:\n        df = pd.DataFrame(index=[], columns=[])\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"local_fraction_by_place\", df)\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_path_class_report", "title": "compute_path_class_report", "text": "<pre><code>compute_path_class_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_path_class_report(\n    self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n):\n    num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n\n    path_class_df = []\n    for path in sim.paths:\n        for pc in path.pathclasses:\n            avg_sold = pc.gt_sold / num_samples\n            avg_sold_priceable = pc.gt_sold_priceable / num_samples\n            avg_rev = pc.gt_revenue / num_samples\n            if to_log:\n                logger.info(\n                    f\"{pc}, avg_sold={avg_sold:6.2f}, avg_rev=${avg_rev:10,.2f}\"\n                )\n            data = dict(\n                orig=path.orig,\n                dest=path.dest,\n                carrier1=path.get_leg_carrier(0),\n                leg_id1=path.get_leg_id(0),\n                carrier2=None,\n                leg_id2=None,\n                carrier3=None,\n                leg_id3=None,\n                booking_class=pc.booking_class,\n                avg_sold=avg_sold,\n                avg_sold_priceable=avg_sold_priceable,\n                avg_rev=avg_rev,\n            )\n            if path.num_legs() == 1:\n                path_class_df.append(data)\n            elif path.num_legs() == 2:\n                data[\"carrier2\"] = path.get_leg_carrier(1)\n                data[\"leg_id2\"] = path.get_leg_id(1)\n                path_class_df.append(data)\n            elif path.num_legs() == 3:\n                data[\"carrier2\"] = path.get_leg_carrier(1)\n                data[\"leg_id2\"] = path.get_leg_id(1)\n                data[\"carrier3\"] = path.get_leg_carrier(2)\n                data[\"leg_id3\"] = path.get_leg_id(2)\n                path_class_df.append(data)\n            else:\n                raise NotImplementedError(\"path with more than 3 legs\")\n    path_class_df = pd.DataFrame(path_class_df)\n    if not path_class_df.empty:\n        path_class_df.sort_values(\n            by=[\"orig\", \"dest\", \"carrier1\", \"leg_id1\", \"booking_class\"]\n        )\n        #        if to_db and to_db.is_open:\n        #            to_db.save_dataframe(\"path_class_summary\", path_class_df)\n    return path_class_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_path_report", "title": "compute_path_report", "text": "<pre><code>compute_path_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_path_report(\n    self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n):\n    num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n    avg_lf, n = 0.0, 0\n    for leg in sim.legs:\n        lf = 100.0 * leg.gt_sold / (leg.capacity * num_samples)\n        avg_lf += lf\n        n += 1\n\n    tot_rev = 0.0\n    for m in sim.demands:\n        tot_rev += m.revenue\n\n    avg_lf = avg_lf / n if n &gt; 0 else 0\n    if to_log:\n        logger.info(f\"    LF:  {avg_lf:6.2f}%, Total revenue = ${tot_rev:,.2f}\")\n\n    path_df = []\n    for path in sim.paths:\n        avg_sold = path.gt_sold / num_samples\n        avg_sold_priceable = path.gt_sold_priceable / num_samples\n        avg_rev = path.gt_revenue / num_samples\n        if to_log:\n            logger.info(\n                f\"{path}, avg_sold={avg_sold:6.2f}, avg_rev=${avg_rev:10,.2f}\"\n            )\n        data = dict(\n            orig=path.orig,\n            dest=path.dest,\n            carrier1=path.get_leg_carrier(0),\n            leg_id1=path.get_leg_id(0),\n            carrier2=None,\n            leg_id2=None,\n            carrier3=None,\n            leg_id3=None,\n            avg_sold=avg_sold,\n            avg_sold_priceable=avg_sold_priceable,\n            avg_rev=avg_rev,\n        )\n        if path.num_legs() == 1:\n            path_df.append(data)\n        elif path.num_legs() == 2:\n            data[\"carrier2\"] = path.get_leg_carrier(1)\n            data[\"leg_id2\"] = path.get_leg_id(1)\n            path_df.append(data)\n        elif path.num_legs() == 3:\n            data[\"carrier2\"] = path.get_leg_carrier(1)\n            data[\"leg_id2\"] = path.get_leg_id(1)\n            data[\"carrier3\"] = path.get_leg_carrier(2)\n            data[\"leg_id3\"] = path.get_leg_id(2)\n            path_df.append(data)\n        else:\n            raise NotImplementedError(\"path with more than 3 legs\")\n    path_df = pd.DataFrame(path_df)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"path_summary\", path_df)\n    return path_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_raw_fare_class_mix", "title": "compute_raw_fare_class_mix", "text": "<pre><code>compute_raw_fare_class_mix(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute a fare class distribution report.</p> <p>This report is a dataframe, with index values giving the fare class, and column for each carrier in the simulation. The values are the number of passengers for each fare class observed during the simulation (excluding any burn period). This is a count of passengers not legs, so a passenger on a connecting itinerary only counts once.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_raw_fare_class_mix(\n    self,\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute a fare class distribution report.\n\n    This report is a dataframe, with index values giving the fare class,\n    and column for each carrier in the simulation. The values are the\n    number of passengers for each fare class observed during the simulation\n    (excluding any burn period). This is a count of passengers not legs, so\n    a passenger on a connecting itinerary only counts once.\n    \"\"\"\n    result = {}\n    for carrier in sim.carriers:\n        fc = carrier.raw_fare_class_distribution()\n        fc_sold = pd.Series(\n            {k: v[\"sold\"] for k, v in fc.items()},\n            name=\"frequency\",\n        )\n        fc_rev = pd.Series(\n            {k: v[\"revenue\"] for k, v in fc.items()},\n            name=\"frequency\",\n        )\n        result[carrier.name] = pd.concat(\n            [fc_sold, fc_rev], axis=1, keys=[\"sold\", \"revenue\"]\n        ).rename_axis(index=\"booking_class\")\n    if result:\n        df = pd.concat(result, axis=0, names=[\"carrier\"])\n    else:\n        df = pd.DataFrame(\n            columns=[\"sold\", \"revenue\"],\n            index=pd.MultiIndex(\n                [[], []], [[], []], names=[\"carrier\", \"booking_class\"]\n            ),\n        )\n    df = df.fillna(0)\n    df[\"sold\"] = df[\"sold\"].astype(int)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"fare_class_distribution\", df)\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_raw_load_factor_distribution", "title": "compute_raw_load_factor_distribution  <code>staticmethod</code>", "text": "<pre><code>compute_raw_load_factor_distribution(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute a load factor distribution report.</p> <p>This report is a dataframe, with integer index values from 0 to 100, and column for each carrier in the simulation. The values are the frequency of each leg load factor observed during the simulation (excluding any burn period).  The values for leg load factors are rounded down, so that a leg load factor of 99.9% is counted as 99, and only actually sold-out flights are in the 100% bin.</p> Source code in <code>passengersim/driver.py</code> <pre><code>@staticmethod\ndef compute_raw_load_factor_distribution(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute a load factor distribution report.\n\n    This report is a dataframe, with integer index values from 0 to 100,\n    and column for each carrier in the simulation. The values are the\n    frequency of each leg load factor observed during the simulation\n    (excluding any burn period).  The values for leg load factors are\n    rounded down, so that a leg load factor of 99.9% is counted as 99,\n    and only actually sold-out flights are in the 100% bin.\n    \"\"\"\n    result = {}\n    for carrier in sim.carriers:\n        lf = pd.Series(\n            carrier.raw_load_factor_distribution(),\n            index=pd.RangeIndex(101, name=\"leg_load_factor\"),\n            name=\"frequency\",\n        )\n        result[carrier.name] = lf\n    if result:\n        df = pd.concat(result, axis=1, names=[\"carrier\"])\n    else:\n        df = pd.DataFrame(\n            index=pd.RangeIndex(101, name=\"leg_load_factor\"), columns=[]\n        )\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"raw_load_factor_distribution\", df)\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_reports", "title": "compute_reports", "text": "<pre><code>compute_reports(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: bool | Database = True,\n    additional=(\n        \"fare_class_mix\",\n        \"load_factors\",\n        \"total_demand\",\n    ),\n) -&gt; SummaryTables\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_reports(\n    self,\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: bool | database.Database = True,\n    additional=(\n        \"fare_class_mix\",\n        \"load_factors\",\n        # \"bookings_by_timeframe\",\n        \"total_demand\",\n    ),\n) -&gt; SummaryTables:\n    num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n    if num_samples &lt;= 0:\n        raise ValueError(\n            \"insufficient number of samples outside burn period for reporting\"\n            f\"\\n- num_trials = {sim.num_trials}\"\n            f\"\\n- num_samples = {sim.num_samples}\"\n            f\"\\n- burn_samples = {sim.burn_samples}\"\n        )\n\n    if to_db is True:\n        to_db = self.cnx\n    class_dist_df = self.compute_class_dist(sim, to_log, to_db)\n    dmd_df = self.compute_demand_report(sim, to_log, to_db)\n    fare_df = self.compute_fare_report(sim, to_log, to_db)\n    leg_df = self.compute_leg_report(sim, to_log, to_db)\n    path_df = self.compute_path_report(sim, to_log, to_db)\n    path_classes_df = self.compute_path_class_report(sim, to_log, to_db)\n    carrier_df = self.compute_carrier_report(sim, to_log, to_db)\n    segmentation_df = self.compute_segmentation_by_timeframe()\n    raw_load_factor_dist_df = self.compute_raw_load_factor_distribution(\n        sim, to_log, to_db\n    )\n    leg_avg_load_factor_dist_df = self.compute_leg_avg_load_factor_distribution(\n        sim, to_log, to_db\n    )\n    fare_class_dist_df = self.compute_raw_fare_class_mix(sim, to_log, to_db)\n    bid_price_history_df = self.compute_bid_price_history(sim, to_log, to_db)\n    displacement_df = self.compute_displacement_history(sim, to_log, to_db)\n    demand_to_come_df = self.compute_demand_to_come_summary(sim, to_log, to_db)\n    local_fraction_dist_df = self.compute_leg_local_fraction_distribution(\n        sim, to_log, to_db\n    )\n    local_fraction_by_place = self.compute_local_fraction_by_place(\n        sim, to_log, to_db\n    )\n\n    summary = SummaryTables(\n        name=sim.name,\n        class_dist=class_dist_df,\n        config=sim.config,\n        demands=dmd_df,\n        fares=fare_df,\n        legs=leg_df,\n        paths=path_df,\n        path_classes=path_classes_df,\n        carriers=carrier_df,\n        bid_price_history=bid_price_history_df,\n        raw_load_factor_distribution=raw_load_factor_dist_df,\n        leg_avg_load_factor_distribution=leg_avg_load_factor_dist_df,\n        raw_fare_class_mix=fare_class_dist_df,\n        leg_local_fraction_distribution=local_fraction_dist_df,\n        local_fraction_by_place=local_fraction_by_place,\n        n_total_samples=num_samples,\n        segmentation_by_timeframe=segmentation_df,\n        displacement_history=displacement_df,\n        demand_to_come_summary=demand_to_come_df,\n    )\n    summary.load_additional_tables(self.cnx, sim.name, sim.burn_samples, additional)\n    summary.cnx = self.cnx\n    return summary\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_segmentation_by_timeframe", "title": "compute_segmentation_by_timeframe", "text": "<pre><code>compute_segmentation_by_timeframe() -&gt; DataFrame | None\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_segmentation_by_timeframe(self) -&gt; pd.DataFrame | None:\n    if self.segmentation_data_by_timeframe:\n        df = (\n            pd.concat(self.segmentation_data_by_timeframe, axis=0, names=[\"trial\"])\n            .reorder_levels([\"trial\", \"carrier\", \"booking_class\", \"days_prior\"])\n            .sort_index()\n        )\n        # df[\"Total\"] = df.sum(axis=1)\n        return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.end_sample", "title": "end_sample", "text": "<pre><code>end_sample()\n</code></pre> <p>End of sample processing.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def end_sample(self):\n    \"\"\"End of sample processing.\"\"\"\n\n    # Record the departure statistics to carrier-level counters in the simulation\n    self.sim.record_departure_statistics()\n\n    # Roll histories to next sample\n    self.sim.next_departure()\n\n    # Commit data to the database\n    if self.cnx:\n        try:\n            self.cnx.commit()\n        except AttributeError:\n            pass\n\n    # Are we capturing choice-set data?\n    if self.choice_set_file is not None:\n        if self.sim.sample &gt; self.sim.burn_samples:\n            cs = self.sim.get_choice_set()\n            for line in cs:\n                tmp = [str(z) for z in line]\n                tmp2 = \",\".join(tmp)\n                print(tmp2, file=self.choice_set_file)\n        self.sim.clear_choice_set()\n\n    # Market share computation (MIDT-lite), might move to C++ in a future version\n    alpha = 0.15\n    for m in self.sim.markets.values():\n        sold = float(m.sold)\n        for a in self.sim.carriers:\n            carrier_sold = m.get_carrier_sold(a.name)\n            share = carrier_sold / sold if sold &gt; 0 else 0\n            if self.sim.sample &gt; 1:\n                try:\n                    old_share = m.get_carrier_share(a.name)\n                except KeyError:\n                    old_share = 0.0\n                new_share = alpha * share + (1.0 - alpha) * old_share\n                m.set_carrier_share(a.name, new_share)\n            else:\n                m.set_carrier_share(a.name, share)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.end_trial", "title": "end_trial", "text": "<pre><code>end_trial()\n</code></pre> <p>End of trial processing.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def end_trial(self):\n    \"\"\"End of trial processing.\"\"\"\n    self.extract_segmentation_by_timeframe()\n    self.extract_and_reset_bid_price_traces()\n    if self.cnx.is_open:\n        self.db_writer.final_write_to_sqlite(self.cnx._connection)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.extract_and_reset_bid_price_traces", "title": "extract_and_reset_bid_price_traces", "text": "<pre><code>extract_and_reset_bid_price_traces()\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def extract_and_reset_bid_price_traces(self):\n    self.bid_price_traces[self.sim.trial] = {\n        carrier.name: carrier.raw_bid_price_trace() for carrier in self.sim.carriers\n    }\n    self.displacement_traces[self.sim.trial] = {\n        carrier.name: carrier.raw_displacement_cost_trace()\n        for carrier in self.sim.carriers\n    }\n    for carrier in self.sim.carriers:\n        carrier.reset_bid_price_trace()\n        carrier.reset_displacement_cost_trace()\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.extract_segmentation_by_timeframe", "title": "extract_segmentation_by_timeframe", "text": "<pre><code>extract_segmentation_by_timeframe()\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def extract_segmentation_by_timeframe(\n    self,\n):\n    # this should be run, if desired, at the end of each trial\n    num_samples = self.sim.num_samples - self.sim.burn_samples\n    top_level = {}\n    for k in (\"bookings\", \"revenue\"):\n        data = {}\n        for carrier in self.sim.carriers:\n            carrier_data = {}\n            for segment, values in getattr(\n                carrier, f\"raw_{k}_by_segment_fare_dcp\"\n            )().items():\n                carrier_data[segment] = (\n                    pd.DataFrame.from_dict(values, \"columns\")\n                    .rename_axis(index=\"days_prior\", columns=\"booking_class\")\n                    .stack()\n                )\n            if carrier_data:\n                data[carrier.name] = (\n                    pd.concat(carrier_data, axis=1, names=[\"segment\"]).fillna(0)\n                    / num_samples\n                )\n        if len(data) == 0:\n            return None\n        top_level[k] = pd.concat(data, axis=0, names=[\"carrier\"])\n    df = pd.concat(top_level, axis=1, names=[\"metric\"])\n    self.segmentation_data_by_timeframe[self.sim.trial] = df\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.generate_dcp_rm_events", "title": "generate_dcp_rm_events", "text": "<pre><code>generate_dcp_rm_events(debug=False)\n</code></pre> <p>Pushes an event per reading day (DCP) onto the queue. Also adds events for daily reoptimzation</p> Source code in <code>passengersim/driver.py</code> <pre><code>def generate_dcp_rm_events(self, debug=False):\n    \"\"\"Pushes an event per reading day (DCP) onto the queue.\n    Also adds events for daily reoptimzation\"\"\"\n    dcp_hour = self.sim.config.simulation_controls.dcp_hour\n    if debug:\n        tmp = datetime.fromtimestamp(self.sim.base_time, tz=timezone.utc)\n        print(f\"Base Time is {tmp.strftime('%Y-%m-%d %H:%M:%S %Z')}\")\n    for dcp_index, dcp in enumerate(self.dcp_list):\n        if dcp == 0:\n            continue\n        event_time = int(self.sim.base_time - dcp * 86400 + 3600 * dcp_hour)\n        if debug:\n            tmp = datetime.fromtimestamp(event_time, tz=timezone.utc)\n            print(f\"Added DCP {dcp} at {tmp.strftime('%Y-%m-%d %H:%M:%S %Z')}\")\n        info = (\"DCP\", dcp, dcp_index)\n        rm_event = Event(info, event_time)\n        self.sim.add_event(rm_event)\n\n    # Now add the events for daily reoptimization\n    max_days_prior = max(self.dcp_list)\n    dcp_idx = 0\n    for days_prior in reversed(range(max_days_prior)):\n        if days_prior not in self.dcp_list:\n            info = (\"daily\", days_prior, dcp_idx)\n            event_time = int(\n                self.sim.base_time - days_prior * 86400 + 3600 * dcp_hour\n            )\n            rm_event = Event(info, event_time)\n            self.sim.add_event(rm_event)\n        else:\n            dcp_idx += 1\n\n    # add events for begin and end sample callbacks\n    self.add_callback_events()\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.generate_demands", "title": "generate_demands", "text": "<pre><code>generate_demands(system_rn=None, debug=False)\n</code></pre> <p>Generate demands, following the procedure used in PODS The biggest difference is that we can put all the timeframe (DCP) demands into the event queue before any processing. For large models, I might rewrite this into the C++ core in the future</p> Source code in <code>passengersim/driver.py</code> <pre><code>def generate_demands(self, system_rn=None, debug=False):\n    \"\"\"Generate demands, following the procedure used in PODS\n    The biggest difference is that we can put all the timeframe (DCP) demands\n    into the event queue before any processing.\n    For large models, I might rewrite this into the C++ core in the future\"\"\"\n    self.generate_dcp_rm_events()\n    total_events = 0\n    system_rn = (\n        self.random_generator.get_normal() if system_rn is None else system_rn\n    )\n\n    # We don't have an O&amp;D object, but we use this to get a market random number\n    # per market\n    mrn_ref = {}\n\n    # Need to have leisure / business split for PODS\n    trn_ref = {\n        \"business\": self.random_generator.get_normal(),\n        \"leisure\": self.random_generator.get_normal(),\n    }\n\n    def get_or_make_random(grouping, key):\n        if key not in grouping:\n            grouping[key] = self.random_generator.get_normal()\n        return grouping[key]\n\n    end_time = self.base_time\n\n    for dmd in self.sim.demands:\n        base = dmd.base_demand\n\n        # Get the random numbers we're going to use to perturb demand\n        trn = get_or_make_random(trn_ref, (dmd.orig, dmd.dest, dmd.segment))\n        mrn = get_or_make_random(mrn_ref, (dmd.orig, dmd.dest))\n        if self.sim.config.simulation_controls.simple_k_factor:\n            urn = (\n                self.random_generator.get_normal()\n                * self.sim.config.simulation_controls.simple_k_factor\n            )\n        else:\n            urn = 0\n\n        mu = base * (\n            1.0\n            + system_rn * self.sim.sys_k_factor\n            + mrn * self.sim.mkt_k_factor\n            + trn * self.sim.pax_type_k_factor\n            + urn\n        )\n        mu = max(mu, 0.0)\n        sigma = sqrt(\n            mu * self.sim.config.simulation_controls.tot_z_factor\n        )  # Correct?\n        n = mu + sigma * self.random_generator.get_normal()\n        dmd.scenario_demand = max(n, 0)\n\n        if debug:\n            logger.debug(\n                f\"DMD,{self.sim.sample},{dmd.orig},{dmd.dest},\"\n                f\"{dmd.segment},{dmd.base_demand},\"\n                f\"{round(mu,2)},{round(sigma,2)},{round(n,2)}\"\n            )\n\n        # Now we split it up over timeframes and add it to the simulation\n        num_pax = int(dmd.scenario_demand + 0.5)  # rounding\n        if (\n            self.sim.config.simulation_controls.timeframe_demand_allocation\n            == \"pods\"\n        ):\n            num_events_by_tf = self.sim.allocate_demand_to_tf_pods(\n                dmd, num_pax, self.sim.tf_k_factor, int(end_time)\n            )\n        else:\n            num_events_by_tf = self.sim.allocate_demand_to_tf(\n                dmd, num_pax, self.sim.tf_k_factor, int(end_time)\n            )\n        num_events = sum(num_events_by_tf)\n        total_events += num_events\n        if num_events != round(num_pax):\n            raise ValueError(\n                f\"Generate demand function, num_pax={num_pax}, \"\n                f\"num_events={num_events}\"\n            )\n\n    return total_events\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.generate_demands_gamma", "title": "generate_demands_gamma", "text": "<pre><code>generate_demands_gamma(system_rn=None, debug=False)\n</code></pre> <p>Using this as a quick test</p> Source code in <code>passengersim/driver.py</code> <pre><code>def generate_demands_gamma(self, system_rn=None, debug=False):\n    \"\"\"Using this as a quick test\"\"\"\n    self.generate_dcp_rm_events()\n    end_time = self.base_time\n    cv100 = 0.3\n    for dmd in self.sim.demands:\n        mu = dmd.base_demand\n        std_dev = cv100 * sqrt(mu) * 10.0\n        # std_dev = mu * 0.3\n        var = std_dev**2\n        shape_a = mu**2 / var\n        scale_b = var / mu\n        loc = 0.0\n        r = gamma.rvs(shape_a, loc, scale_b, size=1)\n        num_pax = int(r[0] + 0.5)\n        dmd.scenario_demand = num_pax\n        self.sim.allocate_demand_to_tf_pods(\n            dmd, num_pax, self.sim.tf_k_factor, int(end_time)\n        )\n    total_events = 0\n    return total_events\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.get_restriction_name", "title": "get_restriction_name", "text": "<pre><code>get_restriction_name(restriction_num: int) -&gt; str\n</code></pre> <p>Convert restriction number to a restriction name.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def get_restriction_name(self, restriction_num: int) -&gt; str:\n    \"\"\"Convert restriction number to a restriction name.\"\"\"\n    if restriction_num &lt; 1:\n        raise IndexError(restriction_num)\n    return self._fare_restriction_list[restriction_num - 1]\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.license_info", "title": "license_info", "text": "<pre><code>license_info(certificate_filename=None)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def license_info(self, certificate_filename=None):\n    user_cert = self._user_certificate(certificate_filename)\n    return self.sim.license_info(user_cert)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.parse_restriction_flags", "title": "parse_restriction_flags", "text": "<pre><code>parse_restriction_flags(\n    restriction_flags: int,\n) -&gt; list[str]\n</code></pre> <p>Convert restriction flags to a tuple of restriction names.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def parse_restriction_flags(self, restriction_flags: int) -&gt; list[str]:\n    \"\"\"Convert restriction flags to a tuple of restriction names.\"\"\"\n    result = []\n    rest_num = 1\n    rest_names = self._fare_restriction_list\n    while restriction_flags:\n        if restriction_flags &amp; 1:\n            result.append(rest_names[rest_num - 1])\n        rest_num += 1\n        restriction_flags &gt;&gt;= 1\n    return result\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.reseed", "title": "reseed", "text": "<pre><code>reseed(seed: int | list[int] | None = 42)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def reseed(self, seed: int | list[int] | None = 42):\n    logger.debug(\"reseeding random_generator: %s\", seed)\n    self.sim.random_generator.seed(seed)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.run", "title": "run", "text": "<pre><code>run(\n    log_reports: bool = False,\n    *,\n    single_trial: int | None = None,\n    summarizer: type[SimulationTablesT]\n    | SimulationTablesT\n    | None = SimulationTables,\n) -&gt; SummaryTables | SimulationTablesT\n</code></pre> <p>Run the simulation and compute reports.</p> <p>Parameters:</p> <ul> <li> <code>log_reports</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>single_trial</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Run only a single trial, with the given trial number (to get the correct fixed random seed, for example).</p> </li> <li> <code>summarizer</code>               (<code>type[SimulationTables] | SimulationTables | None</code>, default:                   <code>SimulationTables</code> )           \u2013            <p>Use this summarizer to compute the reports.  If None, the reports are computed in the SummaryTables object; this option is deprecated and will eventually be removed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SimulationTables or SummaryTables</code>           \u2013            </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def run(\n    self,\n    log_reports: bool = False,\n    *,\n    single_trial: int | None = None,\n    summarizer: type[SimulationTablesT]\n    | SimulationTablesT\n    | None = SimulationTables,\n) -&gt; SummaryTables | SimulationTablesT:\n    \"\"\"\n    Run the simulation and compute reports.\n\n    Parameters\n    ----------\n    log_reports : bool\n    single_trial : int, optional\n        Run only a single trial, with the given trial number (to get\n        the correct fixed random seed, for example).\n    summarizer : type[SimulationTables] | SimulationTables | None\n        Use this summarizer to compute the reports.  If None, the\n        reports are computed in the SummaryTables object; this option\n        is deprecated and will eventually be removed.\n\n    Returns\n    -------\n    SimulationTables or SummaryTables\n    \"\"\"\n    if summarizer is None:\n        warnings.warn(\n            \"Using SummaryTables to compute reports is deprecated, \"\n            \"prefer SimulationTables in new code.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    start_time = time.time()\n    self.setup_scenario()\n    if single_trial is not None:\n        self._run_sim_single_trial(single_trial)\n    else:\n        self._run_sim()\n    if self.choice_set_file is not None:\n        self.choice_set_file.close()\n    logger.info(\"Computing reports\")\n    if summarizer is None:\n        summary = self.compute_reports(\n            self.sim,\n            to_log=log_reports or self.sim.config.outputs.log_reports,\n            additional=self.sim.config.outputs.reports,\n        )\n        logger.info(\"Saving reports\")\n        if self.sim.config.outputs.excel:\n            summary.to_xlsx(self.sim.config.outputs.excel)\n    else:\n        if isinstance(summarizer, GenericSimulationTables):\n            summary = summarizer._extract(self)\n        elif issubclass(summarizer, GenericSimulationTables):\n            summary = summarizer.extract(self)\n        else:\n            raise TypeError(\n                \"summarizer must be an instance or subclass of \"\n                \"GenericSimulationTables\"\n            )\n\n    # write output files if designated\n    if isinstance(summary, GenericSimulationTables):\n        if self.config.outputs.html:\n            out_filename = summary.to_html(self.config.outputs.html.filename)\n            summary._metadata[\"outputs.html_filename\"] = out_filename\n        if self.config.outputs.pickle:\n            pkl_filename = summary.to_pickle(self.config.outputs.pickle)\n            summary._metadata[\"outputs.pickle_filename\"] = pkl_filename\n        if self.config.outputs.excel:\n            summary.to_xlsx(self.config.outputs.excel)\n\n    logger.info(\n        f\"Th' th' that's all folks !!!    \"\n        f\"(Elapsed time = {round(time.time() - start_time, 2)})\"\n    )\n    return summary\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.run_carrier_models", "title": "run_carrier_models", "text": "<pre><code>run_carrier_models(\n    info: Any = None, departed: bool = False, debug=False\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def run_carrier_models(self, info: Any = None, departed: bool = False, debug=False):\n    what_had_happened_was = []\n    try:\n        event_type = info[0]\n\n        if event_type.startswith(\"callback_\"):\n            # This is a callback function, not a string event type\n            # so, call it with the remaining arguments\n            callback_t = event_type[9:]\n            callback_f = info[1]\n            result = callback_f(self, *info[2:])\n            if isinstance(result, dict):\n                self.callback_data.update_data(\n                    callback_t, self.sim.trial, self.sim.sample, *info[2:], **result\n                )\n            return\n\n        recording_day = info[\n            1\n        ]  # could in theory also be non-integer for fractional days\n        dcp_index = info[2]\n        if dcp_index == -1:\n            dcp_index = len(self.dcp_list) - 1\n\n        if event_type.lower() in {\"dcp\", \"done\"}:\n            self.sim.last_dcp = recording_day\n            self.sim.last_dcp_index = dcp_index\n            # self.capture_dcp_data(dcp_index)\n            # self.capture_competitor_data()  # Simulates Infare / QL2\n\n        # Run the specified process(es) for the carriers\n        for carrier in self.sim.carriers:\n            if event_type.lower() == \"dcp\":\n                # Regular Data Collection Points (pre-departure)\n                what_had_happened_was.append(f\"run {carrier.name} DCP\")\n                carrier.rm_system.run(\n                    self.sim,\n                    carrier.name,\n                    dcp_index,\n                    recording_day,\n                    event_type=\"dcp\",\n                )\n            elif event_type.lower() == \"daily\":\n                # Daily report, every day prior to departure EXCEPT specified DCPs\n                what_had_happened_was.append(f\"run {carrier.name} daily\")\n                carrier.rm_system.run(\n                    self.sim,\n                    carrier.name,\n                    dcp_index,\n                    recording_day,\n                    event_type=\"daily\",\n                )\n            elif event_type.lower() == \"done\":\n                # Post departure processing\n                what_had_happened_was.append(f\"run {carrier.name} done\")\n                carrier.rm_system.run(\n                    self.sim,\n                    carrier.name,\n                    dcp_index,\n                    recording_day,\n                    event_type=\"dcp\",\n                )\n                carrier.rm_system.run(\n                    self.sim,\n                    carrier.name,\n                    dcp_index,\n                    recording_day,\n                    event_type=\"departure\",\n                )\n                if self.sim.sample % 7 == 0:\n                    # Can be used less frequently,\n                    # such as ML steps on accumulated data\n                    carrier.rm_system.run(\n                        self.sim,\n                        carrier.name,\n                        dcp_index,\n                        recording_day,\n                        event_type=\"weekly\",\n                    )\n\n        # Internal simulation data capture that is normally done by RM systems\n        if event_type.lower() in {\"dcp\", \"done\"}:\n            self.sim.last_dcp = recording_day\n            self.sim.last_dcp_index = dcp_index\n            self.capture_dcp_data(dcp_index)\n            what_had_happened_was.append(\"capture_dcp_close_data\")\n            if self.sim.config.simulation_controls.capture_competitor_data:\n                self.capture_competitor_data()  # Simulates Infare / QL2\n\n        # Database capture\n        if event_type.lower() == \"daily\":\n            if (\n                self.cnx.is_open\n                and self.sim.save_timeframe_details\n                and recording_day &gt; 0\n            ):\n                # if self.sim.sample == 101:\n                #     print(\"write_to_sqlite DAILY\")\n                what_had_happened_was.append(\"write_to_sqlite daily\")\n                _internal_log = self.db_writer.write_to_sqlite(\n                    self.cnx._connection,\n                    recording_day,\n                    store_bid_prices=self.sim.config.db.store_leg_bid_prices,\n                    intermediate_day=True,\n                    store_displacements=self.sim.config.db.store_displacements,\n                )\n        elif event_type.lower() in {\"dcp\", \"done\"}:\n            if (\n                event_type.lower() == \"done\"\n                and \"forecast_accuracy\" in self.config.outputs.reports\n            ):\n                self.sim.capture_forecast_accuracy()\n            if self.cnx.is_open:\n                self.cnx.save_details(self.db_writer, self.sim, recording_day)\n            if self.file_writer is not None:\n                self.file_writer.save_details(self.sim, recording_day)\n\n        # simulation statistics record\n        if event_type.lower() in {\"dcp\", \"done\"}:\n            self.sim.record_dcp_statistics(recording_day)\n        self.sim.record_daily_statistics(recording_day)\n\n    except Exception as e:\n        print(e)\n        print(\"Error in run_carrier_models\")\n        print(f\"{info=}\")\n        print(\"what_had_happened_was=\", what_had_happened_was)\n        raise\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.run_single_sample", "title": "run_single_sample", "text": "<pre><code>run_single_sample() -&gt; int\n</code></pre> <p>Context manager to run the next sample in the current trial.</p> <p>On entry, the sample number is run through to departure, so all sales have happened, but per-sample wrap up (e.g. rolling history forward, resetting counters) is deferred until exit.  This is useful for running a single sample in a testing framework.</p> <p>Yields:</p> <ul> <li> <code>int</code>           \u2013            <p>The sample number just completed.</p> </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>@contextlib.contextmanager\ndef run_single_sample(self) -&gt; int:\n    \"\"\"Context manager to run the next sample in the current trial.\n\n    On entry, the sample number is run through to departure, so all\n    sales have happened, but per-sample wrap up (e.g. rolling history\n    forward, resetting counters) is deferred until exit.  This is useful\n    for running a single sample in a testing framework.\n\n    Yields\n    ------\n    int\n        The sample number just completed.\n    \"\"\"\n    if self.sim.trial &lt; 0:\n        warnings.warn(\n            \"Trial must be started before running a sample, \"\n            \"implicitly starting Trial 0\",\n            skip_file_prefixes=_warn_skips,\n            stacklevel=1,\n        )\n        self.begin_trial(0)\n    self.sim.sample += 1\n    self.reseed(\n        [\n            self.sim.config.simulation_controls.random_seed,\n            self.sim.trial,\n            self.sim.sample,\n        ]\n    )\n    self.sim.reset_counters()\n    self.generate_demands()\n    while True:\n        event = self.sim.go()\n        self.run_carrier_models(event)\n        if event is None or str(event) == \"Done\" or (event[0] == \"Done\"):\n            assert (\n                self.sim.num_events() == 0\n            ), f\"Event queue still has {self.sim.num_events()} events\"\n            break\n    yield self.sim.sample\n    self.end_sample()\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.run_trial", "title": "run_trial", "text": "<pre><code>run_trial(\n    trial: int, log_reports: bool = False\n) -&gt; SummaryTables\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def run_trial(self, trial: int, log_reports: bool = False) -&gt; SummaryTables:\n    self.setup_scenario()\n    self.sim.trial = trial\n\n    update_freq = self.update_frequency\n    logger.debug(\n        f\"run_sim, num_trials = {self.sim.num_trials}, \"\n        f\"num_samples = {self.sim.num_samples}\"\n    )\n    self.db_writer.update_db_write_flags()\n    n_samples_total = self.sim.num_samples\n    n_samples_done = 0\n    self.sample_done_callback(n_samples_done, n_samples_total)\n    if self.sim.config.simulation_controls.show_progress_bar:\n        progress = ProgressBar(total=n_samples_total)\n    else:\n        progress = DummyProgressBar()\n    with progress:\n        self._run_single_trial(\n            trial,\n            n_samples_done,\n            n_samples_total,\n            progress,\n            update_freq,\n        )\n    summary = self.compute_reports(\n        self.sim,\n        to_log=log_reports or self.sim.config.outputs.log_reports,\n        additional=self.sim.config.outputs.reports,\n    )\n    return summary\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.set_classes", "title": "set_classes", "text": "<pre><code>set_classes(leg: Leg, _cabin, debug=False)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def set_classes(self, leg: passengersim.core.Leg, _cabin, debug=False):\n    leg_classes = self.config.carriers[leg.carrier.name].classes\n    if len(leg_classes) == 0:\n        return\n    cap = float(leg.capacity)\n    if debug:\n        print(leg, \"Capacity = \", cap)\n    history_def = leg.carrier.get_history_def()\n    for bkg_class in leg_classes:\n        # Input as a percentage\n        auth = int(cap * self.init_rm.get(bkg_class, 100.0) / 100.0)\n        if isinstance(bkg_class, tuple):\n            # We are likely using multi-cabin, so unpack it\n            (bkg_class, cabin_code) = bkg_class\n        b = passengersim.core.Bucket(bkg_class, alloc=auth, history=history_def)\n        leg.add_bucket(b)\n        if debug:\n            print(\"    Bucket\", bkg_class, auth)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.setup_scenario", "title": "setup_scenario", "text": "<pre><code>setup_scenario() -&gt; None\n</code></pre> <p>Set up the scenario for the simulation.</p> <p>This will delete any existing data in the database under the same simulation name, build the connections if needed, and then call the vn_initial_mapping method to set up the initial mapping for the carriers using virtual nesting.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def setup_scenario(self) -&gt; None:\n    \"\"\"\n    Set up the scenario for the simulation.\n\n    This will delete any existing data in the database under the same simulation\n    name, build the connections if needed, and then call the vn_initial_mapping\n    method to set up the initial mapping for the carriers using virtual nesting.\n    \"\"\"\n    self.cnx.delete_experiment(self.sim.name)\n    logger.debug(\"building connections\")\n    num_paths = self.sim.build_connections()\n    self.sim.compute_hhi()\n    if num_paths and self.cnx.is_open:\n        database.tables.create_table_path_defs(self.cnx._connection, self.sim.paths)\n    logger.debug(f\"Connections done, num_paths = {num_paths}\")\n    self.sim.initialize_bucket_ap_rules()\n\n    # start with default number of timeframes\n    num_timeframes_default = len(self.config.dcps)\n    if len(self.config.dcps) and self.config.dcps[-1] == 0:\n        num_timeframes_default -= 1\n\n    # initialize pathclasses for each carrier, using settings from the carrier\n    # to size the history buffers\n    for carrier in self.sim.carriers:\n        self.sim.initialize_pathclasses(carrier.get_history_def(), carrier.name)\n\n    # Airlines using Q-forecasting need to have pathclasses set up for all paths\n    # so Q-demand can be forecasted by pathclass even in the absence of bookings\n    for carrier in self.sim.carriers:\n        if carrier.frat5:\n            logger.info(\n                f\"Setting up path classes for carrier {carrier.name}, \"\n                \"which is using a Frat5 curve\"\n            )\n            for pth in self.sim.paths:\n                if pth.carrier_name != carrier.name:\n                    continue\n                mkt = self.sim.markets[f\"{pth.orig}~{pth.dest}\"]\n                for fare in mkt.fares:\n                    if fare.carrier_name == pth.carrier_name:\n                        pthcls = pth.add_booking_class(\n                            fare.booking_class, if_not_found=True\n                        )\n                        if pthcls is not None:\n                            pthcls.add_fare(fare)\n        self.vn_initial_mapping2(carrier.name)\n\n    # This will save approximately the number of choice sets requested\n    if self.choice_set_file is not None and self.choice_set_obs &gt; 0:\n        tot_dmd = 0\n        for d in self.config.demands:\n            tot_dmd += d.base_demand\n        total_choice_sets = (\n            tot_dmd\n            * self.sim.num_trials\n            * (self.sim.num_samples - self.sim.burn_samples)\n        )\n        prob = (\n            self.choice_set_obs / total_choice_sets if total_choice_sets &gt; 0 else 0\n        )\n        self.sim.choice_set_sampling_probability = prob\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.validate_license", "title": "validate_license", "text": "<pre><code>validate_license(\n    certificate_filename=None, future: int = 0\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def validate_license(self, certificate_filename=None, future: int = 0):\n    user_cert = self._user_certificate(certificate_filename)\n    return self.sim.validate_license(user_cert, future=future)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.vn_initial_mapping", "title": "vn_initial_mapping", "text": "<pre><code>vn_initial_mapping()\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def vn_initial_mapping(self):\n    vn_carriers = []\n    for carrier in self.sim.carriers:\n        if carrier.control == \"vn\":\n            vn_carriers.append(carrier.name)\n    for path in self.sim.paths:\n        if path.get_leg_carrier(0) in vn_carriers:\n            for bc in self.classes:\n                pc = PathClass(bc)\n                index = int(bc[1])\n                pc.set_index(0, index)\n                path.add_path_class(pc)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.vn_initial_mapping2", "title": "vn_initial_mapping2", "text": "<pre><code>vn_initial_mapping2(carrier_code)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def vn_initial_mapping2(self, carrier_code):\n    for path in self.sim.paths:\n        if path.get_leg_carrier(0) == carrier_code:\n            for i, pc in enumerate(path.pathclasses):\n                pc.set_index(0, i)\n</code></pre>"}, {"location": "API/summary.html", "title": "Summary Results", "text": ""}, {"location": "API/summary.html#passengersim.summary.logger", "title": "logger  <code>module-attribute</code>", "text": "<pre><code>logger = getLogger('passengersim.summary')\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables", "title": "SummaryTables", "text": "Source code in <code>passengersim/summary.py</code> <pre><code>class SummaryTables:\n    @classmethod\n    def from_sqlite(\n        cls,\n        filename: str | pathlib.Path,\n        make_indexes: bool | dict = False,\n        additional: Collection[str | tuple] | str | None = None,\n    ):\n        summarytables_is_deprecated()\n        if not os.path.isfile(filename):\n            raise FileNotFoundError(filename)\n        db = database.Database(\n            engine=\"sqlite\",\n            filename=filename,\n        )\n\n        demands = cls.load_basic_table(db, \"demand_summary\")\n        legs = cls.load_basic_table(db, \"leg_summary\")\n        paths = cls.load_basic_table(db, \"path_summary\")\n        carriers = cls.load_basic_table(db, \"carrier_summary\")\n\n        summary = cls(\n            demands=demands,\n            legs=legs,\n            paths=paths,\n            carriers=carriers,\n        )\n\n        if make_indexes:\n            if isinstance(make_indexes, dict):\n                db.add_indexes(**make_indexes)\n            else:\n                db.add_indexes()\n\n        logger.info(\"loading configs\")\n        config = db.load_configs(on_validation_error=\"ignore\")\n        try:\n            scenario = config.scenario\n            burn_samples = config.simulation_controls.burn_samples\n        except AttributeError:\n            scenario = config.get(\"scenario\", \"unknown\")\n            burn_samples = config.get(\"simulation_controls\", {}).get(\n                \"burn_samples\", 100\n            )\n\n        summary.load_additional_tables(\n            db,\n            scenario=scenario,\n            burn_samples=burn_samples,\n            additional=additional,\n        )\n        summary.cnx = db\n        return summary\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        if \"cnx\" in state:\n            del state[\"cnx\"]\n        if \"config\" in state:\n            # state[\"_config_yaml\"] = state[\"config\"].to_yaml()\n            del state[\"config\"]\n        if \"meta_trials\" in state and not state.get(\"_preserve_meta_trials\", True):\n            del state[\"meta_trials\"]\n        if \"_preserve_meta_trials\" in state:\n            del state[\"_preserve_meta_trials\"]\n        return state\n\n    def __setstate__(self, state):\n        # if \"_config_yaml\" in state:\n        #     state[\"config\"] = Config.from_raw_yaml(state.pop(\"_config_yaml\"))\n        self.__dict__.update(state)\n\n    def to_pickle(\n        self,\n        filename: str | pathlib.Path,\n        add_timestamp_ext: bool = True,\n        preserve_meta_trials: bool = False,\n    ):\n        \"\"\"Save the object to a pickle file.\n\n        Parameters\n        ----------\n        filename : str or Path-like\n            The filename to save the object to.\n        add_timestamp_ext : bool, default True\n            Add a timestamp extension to the filename.\n        \"\"\"\n        import pickle\n\n        if add_timestamp_ext:\n            filename = filename_with_timestamp(filename, suffix=\".pkl\")\n\n        with open(filename, \"wb\") as f:\n            self._preserve_meta_trials = preserve_meta_trials\n            pickle.dump(self, f)\n            del self._preserve_meta_trials\n\n    @classmethod\n    def from_pickle(cls, filename: str | pathlib.Path, read_latest: bool = True):\n        \"\"\"Load the object from a pickle file.\n\n        Parameters\n        ----------\n        filename : str or Path-like\n            The filename to load the object from.\n        read_latest : bool, default True\n            If True, read the latest file matching the pattern.\n        \"\"\"\n        summarytables_is_deprecated()\n\n        import glob\n        import pickle\n\n        if read_latest:\n            filename_glob = pathlib.Path(filename).with_suffix(\".*.pkl\")\n            files = sorted(glob.glob(str(filename_glob)))\n            if not files:\n                if not os.path.exists(filename):\n                    raise FileNotFoundError(filename)\n            else:\n                filename = files[-1]\n\n        with open(filename, \"rb\") as f:\n            result = pickle.load(f)\n            if result.__class__.__name__ != cls.__name__:\n                raise TypeError(f\"Expected {cls}, got {type(result)}\")\n            return result\n\n    @classmethod\n    def aggregate(cls, summaries: Collection[SummaryTables]):\n        \"\"\"Aggregate multiple summary tables.\"\"\"\n        summarytables_is_deprecated()\n\n        if not summaries:\n            return None\n\n        # dataframes where trial is in the index, just concatenate\n        def concat(name):\n            frames = []\n            for s in summaries:\n                frame = getattr(s, name)\n                if frame is not None:\n                    frames.append(frame)\n            if frames:\n                return pd.concat(frames)\n            return None\n\n        carrier_history = concat(\"carrier_history\")\n        bookings_by_timeframe = concat(\"bookings_by_timeframe\")\n        segmentation_by_timeframe = concat(\"segmentation_by_timeframe\")\n        demand_to_come = concat(\"demand_to_come\")\n\n        # demands has some columns that are averages and some that are sums\n        demands_avg = sum(\n            s.demands.set_index([\"orig\", \"dest\", \"segment\"])[\n                [\"sold\", \"revenue\", \"avg_fare\"]\n            ]\n            for s in summaries\n        ) / len(summaries)\n        demands_sum = sum(\n            s.demands.set_index([\"orig\", \"dest\", \"segment\"])[\n                [\"gt_demand\", \"gt_sold\", \"gt_revenue\"]\n            ]\n            for s in summaries\n        )\n        demands = pd.concat([demands_avg, demands_sum], axis=1).reset_index()\n\n        # TODO: aggregate fares\n        # fares has some columns that are (weighted) averages and some that are sums\n        # fares_gt_adj_price = sum(\n        #     s.fares.set_index(\n        #     [\"carrier\", \"orig\", \"dest\", \"booking_class\", \"dcp_index\"]\n        #     ).eval(\"gt_sold * avg_adjusted_price\")\n        #     for s in summaries\n        # )\n        # fares_avg = sum(\n        #     s.fares.set_index(\n        #     [\"carrier\", \"orig\", \"dest\", \"booking_class\", \"dcp_index\"]\n        #     )[\n        #         [\"price\", \"gt_sold\"]\n        #     ]\n        #     for s in summaries\n        # ) / len(summaries)\n        # fares_sum = sum(\n        #     s.fares.set_index(\n        #     [\"carrier\", \"orig\", \"dest\", \"booking_class\", \"dcp_index\"]\n        #     )[\n        #         [\"gt_sold\"]\n        #     ]\n        #     for s in summaries\n        # )\n\n        # TODO: aggregate path_classes\n\n        # these are averages, but need to have the index values excluded\n        # TODO: the index values should be set properly on the original dataframes\n        carriers = sum(s.carriers.set_index(\"carrier\") for s in summaries) / len(\n            summaries\n        )\n        legs = sum(\n            s.legs.set_index([\"carrier\", \"leg_id\", \"flt_no\", \"orig\", \"dest\"])\n            for s in summaries\n        ) / len(summaries)\n        legs = legs.reset_index()\n        paths = sum(\n            s.paths.set_index([\"orig\", \"dest\", \"carrier1\", \"leg_id1\", \"carrier2\"])\n            for s in summaries\n        ) / len(summaries)\n\n        def average(name):\n            frames = []\n            for s in summaries:\n                frame = getattr(s, name)\n                if frame is not None:\n                    frames.append(frame)\n            if frames:\n                return sum(frames) / len(frames)\n            return None\n\n        fare_class_mix = average(\"fare_class_mix\")\n        leg_forecasts = average(\"leg_forecasts\")\n        path_forecasts = average(\"path_forecasts\")\n        bid_price_history = average(\"bid_price_history\")\n        displacement_history = average(\"displacement_history\")\n        demand_to_come_summary = average(\"demand_to_come_summary\")\n\n        # dataframes with count data that need to be summed\n        def sum_count(name):\n            frames = []\n            for s in summaries:\n                frame = getattr(s, name)\n                if frame is not None:\n                    frames.append(frame)\n            if frames:\n                return sum(frames)\n            return None\n\n        raw_load_factor_distribution = sum_count(\"raw_load_factor_distribution\")\n        leg_avg_load_factor_distribution = sum_count(\"leg_avg_load_factor_distribution\")\n        raw_fare_class_mix = sum_count(\"raw_fare_class_mix\")\n        leg_local_fraction_distribution = sum_count(\"leg_local_fraction_distribution\")\n\n        result = cls(\n            demands=demands,\n            legs=legs,\n            paths=paths,\n            carriers=carriers,\n            fare_class_mix=fare_class_mix,\n            leg_forecasts=leg_forecasts,\n            path_forecasts=path_forecasts,\n            carrier_history=carrier_history,\n            bookings_by_timeframe=bookings_by_timeframe,\n            segmentation_by_timeframe=segmentation_by_timeframe,\n            bid_price_history=bid_price_history,\n            displacement_history=displacement_history,\n            demand_to_come=demand_to_come,\n            demand_to_come_summary=demand_to_come_summary,\n            leg_avg_load_factor_distribution=leg_avg_load_factor_distribution,\n            leg_local_fraction_distribution=leg_local_fraction_distribution,\n            raw_load_factor_distribution=raw_load_factor_distribution,\n            raw_fare_class_mix=raw_fare_class_mix,\n            n_total_samples=sum(s.n_total_samples for s in summaries),\n        )\n        result.meta_trials = summaries\n        return result\n\n    @classmethod\n    def from_sqlite_glob(\n        cls,\n        pattern: str,\n        make_indexes: bool | dict = False,\n        additional: Collection[str | tuple] | str | None = None,\n        *,\n        load_config: bool = True,\n        max_num_files: int = 9999,\n    ):\n        \"\"\"\n        Load and aggregate multiple summary tables from a glob pattern.\n\n        Parameters\n        ----------\n        pattern : str\n            A glob pattern to match the files to load.\n        make_indexes\n        additional\n        load_config\n\n        Returns\n        -------\n        SummaryTables\n        \"\"\"\n        summarytables_is_deprecated()\n\n        import glob\n\n        cfg = None\n        raw = []\n        n = 0\n        for filename in glob.glob(pattern):\n            n += 1\n            if n &gt; max_num_files:\n                continue\n            raw.append(\n                cls.from_sqlite(\n                    filename,\n                    make_indexes=make_indexes,\n                    additional=additional,\n                )\n            )\n            if cfg is None and load_config:\n                cfg = raw[-1].cnx.load_configs(on_validation_error=\"ignore\")\n        if n &gt; max_num_files:\n            warnings.warn(\n                f\"Only loaded {max_num_files} of {n} files matching pattern\",\n                stacklevel=2,\n            )\n        try:\n            result = cls.aggregate(raw)\n        except Exception as e:\n            logger.error(\"Error aggregating summary tables: %s\", e)\n            logger.exception(e)\n            return raw\n        if cfg is not None:\n            result.config = cfg\n        return result\n\n    @classmethod\n    def load_basic_table(self, db: database.Database, tablename: str):\n        \"\"\"Load a basic table\"\"\"\n        logger.info(\"loading %s\", tablename)\n        return db.dataframe(f\"SELECT * FROM {tablename}\")\n\n    def load_additional_tables(\n        self,\n        db: database.Database,\n        scenario: str,\n        burn_samples: int,\n        additional: Collection[str | tuple] | str | None = (\n            \"fare_class_mix\",\n            \"bookings_by_timeframe\",\n            \"total_demand\",\n            \"load_factor_distribution\",\n        ),\n    ) -&gt; None:\n        \"\"\"\n        Load additional summary tables based on common queries.\n\n        Parameters\n        ----------\n        db : Database\n        scenario : str\n        burn_samples : int\n            The number of samples in the burn period.  The data from these samples\n            is ignored in most common queries.\n        additional : Collection[str | tuple] | str\n            One or more additional tables to load.  If \"*\", then this will load\n            all common queries supported by the configuration used during the\n            simulation.\n        \"\"\"\n        if isinstance(additional, str):\n            if additional == \"*\":\n                additional = set()\n                cfg = db.load_configs(scenario)\n                if \"fare\" in cfg.db.write_items:\n                    additional.add(\"fare_class_mix\")\n                if \"fare_final\" in cfg.db.write_items:\n                    additional.add(\"fare_class_mix\")\n                if \"bookings\" in cfg.db.write_items:\n                    additional.add(\"bookings_by_timeframe\")\n                if \"demand\" in cfg.db.write_items:\n                    additional.add(\"total_demand\")\n                    additional.add(\"demand_to_come\")\n                if \"demand_final\" in cfg.db.write_items:\n                    additional.add(\"total_demand\")\n                if \"bucket\" in cfg.db.write_items:\n                    additional.add(\"leg_forecasts\")\n                    additional.add(\"carrier_history\")\n                if \"pathclass\" in cfg.db.write_items:\n                    additional.add(\"path_forecasts\")\n                    additional.add(\"local_and_flow_yields\")\n                if \"pathclass_final\" in cfg.db.write_items:\n                    additional.add(\"local_and_flow_yields\")\n                if \"leg\" in cfg.db.write_items and cfg.db.store_leg_bid_prices:\n                    additional.add(\"bid_price_history\")\n                if \"leg\" in cfg.db.write_items and cfg.db.store_displacements:\n                    additional.add(\"displacement_history\")\n                if \"leg\" in cfg.db.write_items or \"leg_final\" in cfg.db.write_items:\n                    additional.add(\"load_factor_distribution\")\n            else:\n                additional = [additional]\n        elif additional is None:\n            additional = []\n\n        if \"fare_class_mix\" in additional and db.is_open:\n            logger.info(\"loading fare_class_mix\")\n            self.fare_class_mix = database.common_queries.fare_class_mix(\n                db, scenario, burn_samples=burn_samples\n            )\n            if self.od_fare_class_mix:\n                for orig, dest in list(self.od_fare_class_mix):\n                    self.od_fare_class_mix[(orig, dest)] = (\n                        database.common_queries.od_fare_class_mix(\n                            db, orig, dest, scenario, burn_samples=burn_samples\n                        )\n                    )\n        # load additional fare class mix tables\n        for i in additional:\n            if isinstance(i, tuple) and i[0] == \"od_fare_class_mix\" and db.is_open:\n                orig, dest = i[1], i[2]\n                if self.od_fare_class_mix is None:\n                    self.od_fare_class_mix = {}\n                logger.info(f\"loading od_fare_class_mix({orig},{dest})\")\n                self.od_fare_class_mix[(orig, dest)] = (\n                    database.common_queries.od_fare_class_mix(\n                        db, orig, dest, scenario, burn_samples=burn_samples\n                    )\n                )\n\n        for i in additional:\n            cutoffs = None\n            if i == \"load_factor_distribution\" and db.is_open:\n                cutoffs = (0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95)  # default cutoffs\n            elif (\n                isinstance(i, tuple)\n                and i[0] == \"load_factor_distribution\"\n                and db.is_open\n            ):\n                cutoffs = ast.literal_eval(i[1])\n            if cutoffs is not None:\n                logger.info(\"loading load_factor_distribution\")\n                self.load_factor_distribution = (\n                    database.common_queries.load_factor_distribution(\n                        db,\n                        scenario=scenario,\n                        burn_samples=burn_samples,\n                        cutoffs=cutoffs,\n                    )\n                )\n\n        if \"bookings_by_timeframe\" in additional and db.is_open:\n            logger.info(\"loading bookings_by_timeframe\")\n            self.bookings_by_timeframe = database.common_queries.bookings_by_timeframe(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"total_demand\" in additional and db.is_open:\n            logger.info(\"loading total_demand\")\n            self.total_demand = database.common_queries.total_demand(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"leg_forecasts\" in additional and db.is_open:\n            logger.info(\"loading leg_forecasts\")\n            self.leg_forecasts = database.common_queries.leg_forecasts(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"path_forecasts\" in additional and db.is_open:\n            logger.info(\"loading path_forecasts\")\n            self.path_forecasts = database.common_queries.path_forecasts(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"demand_to_come\" in additional and db.is_open:\n            logger.info(\"loading demand_to_come\")\n            self.demand_to_come = database.common_queries.demand_to_come(\n                db, scenario=scenario\n            )\n\n        if \"demand_to_come_summary\" in additional and db.is_open:\n            logger.info(\"loading demand_to_come_summary\")\n            self.demand_to_come_summary = (\n                database.common_queries.demand_to_come_summary(db, scenario=scenario)\n            )\n\n        if \"carrier_history\" in additional and db.is_open:\n            logger.info(\"loading carrier_history\")\n            self.carrier_history = database.common_queries.carrier_history(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"bid_price_history\" in additional and db.is_open:\n            logger.info(\"loading bid_price_history\")\n            self.bid_price_history = database.common_queries.bid_price_history(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"displacement_history\" in additional and db.is_open:\n            logger.info(\"loading displacement_history\")\n            self.displacement_history = database.common_queries.displacement_history(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"local_and_flow_yields\" in additional and db.is_open:\n            logger.info(\"loading local_and_flow_yields\")\n            self.local_and_flow_yields = database.common_queries.local_and_flow_yields(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"leg_local_and_flow_by_class\" in additional and db.is_open:\n            logger.info(\"loading leg_local_and_flow_by_class\")\n            self.leg_carried = database.common_queries.leg_local_and_flow_by_class(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"edgar\" in additional and db.is_open:\n            logger.info(\"loading edgar\")\n            self.edgar = database.common_queries.edgar(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n    def __init__(\n        self,\n        *,\n        name: str | None = \"name?\",\n        config: Config | None = None,\n        cnx: database.Database | None = None,\n        sim: Simulation | None = None,\n        class_dist: pd.DataFrame | None = None,\n        demands: pd.DataFrame | None = None,\n        fares: pd.DataFrame | None = None,\n        legs: pd.DataFrame | None = None,\n        paths: pd.DataFrame | None = None,\n        path_classes: pd.DataFrame | None = None,\n        carriers: pd.DataFrame | None = None,\n        fare_class_mix: pd.DataFrame | None = None,\n        load_factors: pd.DataFrame | None = None,\n        bookings_by_timeframe: pd.DataFrame | None = None,\n        segmentation_by_timeframe: pd.DataFrame | None = None,\n        total_demand: float | None = None,\n        od_fare_class_mix: dict[tuple[str, str], pd.DataFrame] | None = None,\n        leg_forecasts: pd.DataFrame | None = None,\n        path_forecasts: pd.DataFrame | None = None,\n        carrier_history: pd.DataFrame | None = None,\n        demand_to_come: pd.DataFrame | None = None,\n        demand_to_come_summary: pd.DataFrame | None = None,\n        bid_price_history: pd.DataFrame | None = None,\n        displacement_history: pd.DataFrame | None = None,\n        local_and_flow_yields: pd.DataFrame | None = None,\n        leg_carried: pd.DataFrame | None = None,\n        load_factor_distribution: pd.DataFrame | None = None,\n        leg_avg_load_factor_distribution: pd.DataFrame | None = None,\n        raw_load_factor_distribution: pd.DataFrame | None = None,\n        raw_fare_class_mix: pd.DataFrame | None = None,\n        leg_local_fraction_distribution: pd.DataFrame | None = None,\n        local_fraction_by_place: pd.DataFrame | None = None,\n        n_total_samples: int = 0,\n    ):\n        summarytables_is_deprecated()\n\n        self.config = config\n        \"\"\"Configuration used in the simulation that generated the summary tables.\"\"\"\n\n        self.cnx = cnx\n        \"\"\"The database connection used to load the summary tables.\"\"\"\n\n        self.sim = sim\n        \"\"\"The simulation object that generated the summary tables.\"\"\"\n\n        self.class_dist = class_dist\n        self.demands = demands\n        self.fares = fares\n        self.legs = legs\n        self.paths = paths\n        self.path_classes = path_classes\n        self.carriers = carriers\n        self.fare_class_mix = fare_class_mix\n        self.od_fare_class_mix = od_fare_class_mix\n        self.load_factors = load_factors\n        self.bookings_by_timeframe = bookings_by_timeframe\n        self.segmentation_by_timeframe = segmentation_by_timeframe\n        self.total_demand = total_demand\n        self.leg_forecasts = leg_forecasts\n        self.path_forecasts = path_forecasts\n        self.carrier_history = carrier_history\n        self.demand_to_come = demand_to_come\n        self.demand_to_come_summary = demand_to_come_summary\n        self.bid_price_history = bid_price_history\n        self.displacement_history = displacement_history\n        self.local_and_flow_yields = local_and_flow_yields\n        self.leg_carried = leg_carried\n        self.load_factor_distribution = load_factor_distribution\n\n        self.leg_avg_load_factor_distribution = leg_avg_load_factor_distribution\n        \"\"\"Leg average load factor distribution (integers 0-100).\"\"\"\n\n        self.raw_load_factor_distribution = raw_load_factor_distribution\n        \"\"\"Total number of departures by carrier by load factor (integers 0-100).\"\"\"\n\n        self.raw_fare_class_mix = raw_fare_class_mix\n        \"\"\"Total number of passengers by carrier by fare class.\"\"\"\n\n        self.leg_local_fraction_distribution = leg_local_fraction_distribution\n        \"\"\"Fraction of local passengers on each leg.\"\"\"\n\n        self.local_fraction_by_place = local_fraction_by_place\n        \"\"\"Fraction of local passengers by place.\"\"\"\n\n        self.n_total_samples = n_total_samples\n        \"\"\"Total number of sample departures simulated to create these summaries.\n\n        This excludes any burn samples.\n        \"\"\"\n\n    def to_records(self) -&gt; dict[str, list[dict]]:\n        \"\"\"Convert all summary tables to a dictionary of records.\"\"\"\n        return {k: v.to_dict(orient=\"records\") for (k, v) in self.__dict__.items()}\n\n    def to_xlsx(self, filename: str | pathlib.Path) -&gt; None:\n        \"\"\"Write summary tables to excel.\n\n        Parameters\n        ----------\n        filename : Path-like\n            The excel file to write.\n        \"\"\"\n        if isinstance(filename, str):\n            filename = pathlib.Path(filename)\n        filename.parent.mkdir(exist_ok=True, parents=True)\n        with pd.ExcelWriter(filename) as writer:\n            for k, v in self.__dict__.items():\n                if isinstance(v, pd.DataFrame):\n                    v.to_excel(writer, sheet_name=k)\n\n    def to_dataframe(self, table) -&gt; pd.DataFrame:\n        \"\"\"Convert the summary tables to a individual dataframes.\"\"\"\n        sheet_count = 0\n        for k, v in self.__dict__.items():\n            if isinstance(v, pd.DataFrame):\n                sheet_count += 1\n                if sheet_count == table:\n                    return v.assign(table=k)\n\n        raise IndexError(\"There are fewer than\", table, \" DataFrames in the object\")\n\n    def aggregate_demand_history(self, by_segment: bool = True) -&gt; pd.Series:\n        \"\"\"\n        Total demand by sample, aggregated over all markets.\n\n        Parameters\n        ----------\n        by_segment : bool, default True\n            Aggregate by segment.  If false, segments are also aggregated.\n\n        Returns\n        -------\n        pandas.Series\n            Total demand, indexed by trial, sample, and segment\n            (business/leisure).\n        \"\"\"\n        groupbys = [\"trial\", \"sample\"]\n        if by_segment:\n            groupbys.append(\"segment\")\n        return self.demand_to_come.iloc[:, 0].groupby(groupbys, observed=False).sum()\n\n    def demand_in_tf(self) -&gt; pd.DataFrame | None:\n        \"\"\"History of demand arriving in each timeframe.\n\n        This dataframe is derived from the `demand_to_come` dataframe\n        by taking the sequential differences.\n        \"\"\"\n        if self.demand_to_come is None:\n            return None\n        return self.demand_to_come.diff(-1, axis=1).iloc[:, :-1]\n\n    def fig_carrier_mileage(self, raw_df: bool = False, report=None):\n        \"\"\"\n        Figure showing ASM, RPM by carrier.\n\n        ASM is available seat miles.  RPM is revenue passenger miles.\n\n        Parameters\n        ----------\n        raw_df : bool, default False\n            Return the raw data for this figure as a pandas DataFrame, instead\n            of generating the figure itself.\n        report : xmle.Reporter, optional\n            Also append this figure to the given report.\n        \"\"\"\n        df = (\n            self.carriers.reset_index()[[\"carrier\", \"asm\", \"rpm\"]]\n            .set_index(\"carrier\")\n            .rename_axis(columns=\"measure\")\n            .unstack()\n            .to_frame(\"value\")\n            .reset_index()\n        )\n        if raw_df:\n            return df\n        import altair as alt\n\n        chart = alt.Chart(df, title=\"Carrier Loads\")\n        bars = chart.mark_bar().encode(\n            x=alt.X(\"carrier:N\", title=\"Carrier\"),\n            y=alt.Y(\"value\", stack=None, title=\"miles\"),\n            color=\"measure\",\n            tooltip=[\"carrier\", \"measure\", alt.Tooltip(\"value\", format=\".4s\")],\n        )\n        text = chart.mark_text(\n            dx=0,\n            dy=5,\n            color=\"white\",\n            baseline=\"top\",\n        ).encode(\n            x=alt.X(\"carrier:N\"),\n            y=alt.Y(\"value\").stack(None),\n            text=alt.Text(\"value:Q\", format=\".4s\"),\n        )\n        fig = (\n            (bars + text)\n            .properties(\n                width=400,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n        if report:\n            report.add_figure(fig)\n        return fig\n\n    def _fig_fare_class_mix(\n        self, df: pd.DataFrame, label_threshold: float = 0.06, title=None\n    ):\n        import altair as alt\n\n        label_threshold_value = (\n            df.groupby(\"carrier\", observed=False).avg_sold.sum().max() * label_threshold\n        )\n        chart = alt.Chart(\n            df, **({\"title\": title} if title else {})\n        ).transform_calculate(\n            halfsold=\"datum.avg_sold / 2.0\",\n        )\n        bars = chart.mark_bar().encode(\n            x=alt.X(\"carrier:N\", title=\"Carrier\"),\n            y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n            color=\"booking_class\",\n            tooltip=[\n                \"carrier\",\n                \"booking_class\",\n                alt.Tooltip(\"avg_sold\", format=\".2f\"),\n            ],\n        )\n        text = chart.mark_text(dx=0, dy=3, color=\"white\", baseline=\"top\").encode(\n            x=alt.X(\"carrier:N\", title=\"Carrier\"),\n            y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n            text=alt.Text(\"avg_sold:Q\", format=\".2f\"),\n            opacity=alt.condition(\n                f\"datum.avg_sold &lt; {label_threshold_value:.3f}\",\n                alt.value(0),\n                alt.value(1),\n            ),\n            order=alt.Order(\"booking_class:N\", sort=\"descending\"),\n        )\n        return (\n            (bars + text)\n            .properties(\n                width=400,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n\n    @report_figure\n    def fig_fare_class_mix(self, raw_df=False, label_threshold=0.06):\n        if self.fare_class_mix is not None:\n            df = self.fare_class_mix.reset_index()[\n                [\"carrier\", \"booking_class\", \"avg_sold\"]\n            ]\n        elif self.raw_fare_class_mix is not None and self.n_total_samples &gt; 0:\n            df = self.raw_fare_class_mix / self.n_total_samples\n            df = df.rename(columns={\"sold\": \"avg_sold\"})\n            df = df.reset_index()[[\"carrier\", \"booking_class\", \"avg_sold\"]]\n        else:\n            return None\n\n        if raw_df:\n            return df\n        return self._fig_fare_class_mix(\n            df,\n            label_threshold=label_threshold,\n            title=\"Fare Class Mix\",\n        )\n\n    @report_figure\n    def fig_od_fare_class_mix(\n        self, orig: str, dest: str, raw_df=False, label_threshold=0.06\n    ):\n        df = self.od_fare_class_mix[orig, dest].reset_index()[\n            [\"carrier\", \"booking_class\", \"avg_sold\"]\n        ]\n        if raw_df:\n            return df\n        return self._fig_fare_class_mix(\n            df, label_threshold=label_threshold, title=f\"Fare Class Mix ({orig}-{dest})\"\n        )\n\n    @report_figure\n    def fig_load_factor_distribution(\n        self,\n        by_carrier: bool | str = True,\n        breakpoints: Collection[int] = (\n            50,\n            55,\n            60,\n            65,\n            70,\n            75,\n            80,\n            85,\n            90,\n            95,\n            100,\n        ),\n        source: Literal[\"leg_avg\", \"raw\", \"db\"] = \"leg_avg\",\n        raw_df=False,\n    ):\n        \"\"\"\n        Figure showing the distribution of leg load factors.\n\n        Parameters\n        ----------\n        by_carrier : bool or str, default True\n            If True, show the distribution by carrier.  If a string, show the\n            distribution for that carrier. If False, show the distribution\n            aggregated over all carriers.\n        breakpoints : Collection[int, ...], default (50, 55, 60, 65, ..., 90, 95, 100)\n            The breakpoints for the load factor ranges, which represent the lowest\n            load factor value in each bin. The first and last breakpoints are always\n            bounded to 0 and 101, respectively; these bounds can be included explicitly\n            or omitted to be included implicitly. Setting the top value to 101 ensures\n            that the highest load factor value (100) is included in the last bin.\n        source : {\"raw\", \"db\"}, default \"raw\"\n            The source of the data.  \"raw\" uses the raw load factor distribution\n            output from the simulation, which is faster and preferred if available.\n            \"db\" uses the older load factor distribution table, which is extracted\n            as a query from the database.  This requires leg level departure (final)\n            details to have been recorded in the database, but potentially allows\n            arbitrary custom filters or transformations to be applied.\n        raw_df : bool, default False\n            Return the raw data for this figure as a pandas DataFrame, instead\n            of generating the figure itself.\n\n        Returns\n        -------\n        altair.Chart or pd.DataFrame\n        \"\"\"\n        title = \"Load Factor Frequency\"  # default title\n        if source == \"raw\" or source == \"leg_avg\":\n            # Load using faster raw load factor data generated by the simulation\n            # This is faster than loading from the database and now preferred\n            if source == \"raw\":\n                if self.raw_load_factor_distribution is None:\n                    raise AttributeError(\n                        \"raw_load_factor_distribution not found, \"\n                        \"it is required for using raw source data.\"\n                    )\n                df_for_chart = (\n                    self.raw_load_factor_distribution.rename_axis(columns=\"carrier\")\n                    .stack(future_stack=True)\n                    .rename(\"Count\")\n                    .reset_index()\n                )\n                title = \"Raw Load Factor Frequency\"\n            elif source == \"leg_avg\":\n                if self.leg_avg_load_factor_distribution is None:\n                    raise AttributeError(\n                        \"leg_avg_load_factor_distribution not found, \"\n                        \"it is required for using leg_avg source data.\"\n                    )\n                df_for_chart = (\n                    self.leg_avg_load_factor_distribution.rename_axis(columns=\"carrier\")\n                    .stack(future_stack=True)\n                    .rename(\"Count\")\n                    .reset_index()\n                )\n                title = \"Leg Average Load Factor Frequency\"\n            if not isinstance(breakpoints, tuple):\n                breakpoints = tuple(breakpoints)\n            if breakpoints[0] &lt;= 0:\n                breakpoints = (-1,) + breakpoints[1:]\n            else:\n                breakpoints = (-1,) + breakpoints\n            if breakpoints[-1] &gt;= 101:\n                breakpoints = breakpoints[:-1] + (101,)\n            else:\n                breakpoints = breakpoints + (101,)\n\n            # Create labels for categories\n            def make_label(i, j):\n                if i == j - 1:\n                    return f\"{i}\"\n                else:\n                    return f\"{i}-{j-1}\"\n\n            labels = [make_label(0, breakpoints[1])]\n            for i in range(1, len(breakpoints) - 2):\n                labels += [make_label(breakpoints[i], breakpoints[i + 1])]\n            if breakpoints[-2] &lt; 100:\n                labels += [make_label(breakpoints[-2], 101)]\n            else:\n                labels += [\"100\"]\n            breaker = pd.cut(\n                df_for_chart.leg_load_factor,\n                bins=breakpoints,\n                right=False,\n                labels=labels,\n            ).rename(\"Load Factor Range\")\n            df_for_chart = (\n                df_for_chart.groupby([\"carrier\", breaker], observed=False)\n                .Count.sum()\n                .reset_index()\n            )\n\n        elif source == \"db\":\n            # Older load factor distribution table, taken from database\n            if not hasattr(self, \"load_factor_distribution\"):\n                raise AttributeError(\n                    \"load_factor_distribution data not found. Please load it first.\"\n                )\n\n            df_for_chart = self.load_factor_distribution\n            df_for_chart.columns.names = [\"Load Factor Range\"]\n            df_for_chart = df_for_chart.set_index(\"carrier\")\n            df_for_chart = (\n                df_for_chart.stack(future_stack=True).rename(\"Count\").reset_index()\n            )\n\n        else:\n            raise ValueError(f\"Unknown source {source}, should be 'raw' or 'db'\")\n\n        if not by_carrier:\n            df_for_chart = (\n                df_for_chart.groupby([\"Load Factor Range\"], observed=False)\n                .Count.sum()\n                .reset_index()\n            )\n        elif isinstance(by_carrier, str):\n            df_for_chart = df_for_chart[df_for_chart[\"carrier\"] == by_carrier]\n            df_for_chart = df_for_chart.drop(columns=[\"carrier\"])\n\n        if raw_df:\n            return df_for_chart\n\n        import altair as alt\n\n        if by_carrier is True:\n            chart = (\n                alt.Chart(df_for_chart)\n                .mark_bar()\n                .encode(\n                    x=alt.X(\"Load Factor Range\", title=\"Load Factor Range\"),\n                    y=alt.Y(\"Count:Q\", title=\"Count\"),\n                    facet=alt.Facet(\"carrier:N\", columns=2, title=\"Carrier\"),\n                    tooltip=[\n                        alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                        alt.Tooltip(\"Count\", title=\"Count\"),\n                    ],\n                )\n                .properties(width=300, height=250, title=f\"{title} by Carrier\")\n            )\n        else:\n            chart = (\n                alt.Chart(df_for_chart)\n                .mark_bar()\n                .encode(\n                    x=alt.X(\"Load Factor Range\", title=\"Load Factor Range\"),\n                    y=alt.Y(\"Count:Q\", title=\"Count\"),\n                )\n                .properties(\n                    width=600,\n                    height=400,\n                    title=title if not by_carrier else f\"{title} ({by_carrier})\",\n                )\n            )\n\n        return chart\n\n    def fig_leg_local_fraction_distribution(\n        self,\n        by_carrier: bool | str = True,\n        breakpoints: Collection[int] = (\n            50,\n            55,\n            60,\n            65,\n            70,\n            75,\n            80,\n            85,\n            90,\n            95,\n            100,\n        ),\n        raw_df=False,\n    ):\n        \"\"\"\n        Figure showing the distribution of fraction of leg passengers who are local.\n\n        Parameters\n        ----------\n        by_carrier : bool or str, default True\n            If True, show the distribution by carrier.  If a string, show the\n            distribution for that carrier. If False, show the distribution\n            aggregated over all carriers.\n        breakpoints : Collection[int, ...], default (50, 55, 60, 65, ..., 90, 95, 100)\n            The breakpoints for the local fraction ranges, which represent the lowest\n            local fraction value in each bin. The first and last breakpoints are always\n            bounded to 0 and 101, respectively; these bounds can be included explicitly\n            or omitted to be included implicitly. Setting the top value to 101 ensures\n            that the highest local fraction value (100) is included in the last bin.\n        raw_df : bool, default False\n            Return the raw data for this figure as a pandas DataFrame, instead\n            of generating the figure itself.\n\n        Returns\n        -------\n        altair.Chart or pd.DataFrame\n        \"\"\"\n        title = \"Local Fraction Frequency\"  # default title\n        if self.leg_local_fraction_distribution is None:\n            raise AttributeError(\n                \"leg_local_fraction_distribution not found, \"\n                \"it is required for using raw source data.\"\n            )\n        df_for_chart = (\n            self.leg_local_fraction_distribution.rename_axis(columns=\"carrier\")\n            .stack(future_stack=True)\n            .rename(\"Count\")\n            .reset_index()\n        )\n        if not isinstance(breakpoints, tuple):\n            breakpoints = tuple(breakpoints)\n        if breakpoints[0] &lt;= 0:\n            breakpoints = (-1,) + breakpoints[1:]\n        else:\n            breakpoints = (-1,) + breakpoints\n        if breakpoints[-1] &gt;= 101:\n            breakpoints = breakpoints[:-1] + (101,)\n        else:\n            breakpoints = breakpoints + (101,)\n\n        # Create labels for categories\n        def make_label(i, j):\n            if i == j - 1:\n                return f\"{i}\"\n            else:\n                return f\"{i}-{j-1}\"\n\n        labels = [make_label(0, breakpoints[1])]\n        for i in range(1, len(breakpoints) - 2):\n            labels += [make_label(breakpoints[i], breakpoints[i + 1])]\n        if breakpoints[-2] &lt; 100:\n            labels += [make_label(breakpoints[-2], 101)]\n        else:\n            labels += [\"100\"]\n\n        breaker = pd.cut(\n            df_for_chart.local_fraction,\n            bins=breakpoints,\n            right=False,\n            labels=labels,\n        ).rename(\"Leg Local Fraction Range\")\n        df_for_chart = (\n            df_for_chart.groupby([\"carrier\", breaker], observed=False)\n            .Count.sum()\n            .reset_index()\n        )\n\n        if not by_carrier:\n            df_for_chart = (\n                df_for_chart.groupby([\"Leg Local Fraction Range\"], observed=False)\n                .Count.sum()\n                .reset_index()\n            )\n        elif isinstance(by_carrier, str):\n            df_for_chart = df_for_chart[df_for_chart[\"carrier\"] == by_carrier]\n            df_for_chart = df_for_chart.drop(columns=[\"carrier\"])\n\n        if raw_df:\n            return df_for_chart\n\n        import altair as alt\n\n        if by_carrier is True:\n            chart = (\n                alt.Chart(df_for_chart)\n                .mark_bar()\n                .encode(\n                    x=alt.X(\n                        \"Leg Local Fraction Range\", title=\"Leg Local Fraction Range\"\n                    ),\n                    y=alt.Y(\"Count:Q\", title=\"Count\"),\n                    facet=alt.Facet(\"carrier:N\", columns=2, title=\"Carrier\"),\n                    tooltip=[\n                        alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                        alt.Tooltip(\"Count\", title=\"Count\"),\n                    ],\n                )\n                .properties(width=300, height=250, title=f\"{title} by Carrier\")\n            )\n        else:\n            chart = (\n                alt.Chart(df_for_chart)\n                .mark_bar()\n                .encode(\n                    x=alt.X(\n                        \"Leg Local Fraction Range\", title=\"Leg Local Fraction Range\"\n                    ),\n                    y=alt.Y(\"Count:Q\", title=\"Count\"),\n                )\n                .properties(\n                    width=600,\n                    height=400,\n                    title=title if not by_carrier else f\"{title} ({by_carrier})\",\n                )\n            )\n        return chart\n\n    @report_figure\n    def fig_bookings_by_timeframe(\n        self,\n        by_carrier: bool | str = True,\n        by_class: bool | str = False,\n        raw_df: bool = False,\n        errorbands: bool = False,\n        exclude_nogo: bool = True,\n    ):\n        if errorbands:\n            if by_carrier is True:\n                raise NotImplementedError(\"error bands for all carriers is messy\")\n            return self._fig_bookings_by_timeframe_errorband(\n                by_carrier=by_carrier, raw_df=raw_df\n            )\n\n        def differs(x):\n            return x.shift(-1, fill_value=0) - x\n\n        def _summarize(x: pd.DataFrame, c: str):\n            if \"trial\" not in x.columns:\n                x = x.assign(trial=0)\n            if by_class:\n                y = (\n                    x.groupby(\n                        [\"trial\", \"carrier\", \"booking_class\", \"days_prior\"],\n                        observed=False,\n                    )[f\"avg_{c}\"]\n                    .sum()\n                    .unstack([\"trial\", \"carrier\", \"booking_class\"])\n                    .sort_index(ascending=False)\n                    .apply(differs)\n                    .stack([\"carrier\", \"booking_class\"], future_stack=True)\n                    .aggregate([\"mean\", \"sem\"], axis=1)\n                    .assign(\n                        ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                        ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                    )\n                )\n            else:\n                y = (\n                    x.groupby([\"trial\", \"carrier\", \"days_prior\"], observed=False)[\n                        f\"avg_{c}\"\n                    ]\n                    .sum()\n                    .unstack([\"trial\", \"carrier\"])\n                    .sort_index(ascending=False)\n                    .apply(differs)\n                    .stack(\"carrier\", future_stack=True)\n                    .aggregate([\"mean\", \"sem\"], axis=1)\n                    .assign(\n                        ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                        ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                    )\n                )\n            return pd.concat({c: y}, names=[\"paxtype\"])\n\n        if self.bookings_by_timeframe is None:\n            raise ValueError(\"bookings_by_timeframe not found\")\n        bookings_by_timeframe = self.bookings_by_timeframe.reset_index()\n        df0 = _summarize(bookings_by_timeframe, \"business\")\n        df1 = _summarize(bookings_by_timeframe, \"leisure\")\n        df = (\n            pd.concat([df0, df1], axis=0)\n            .rename(columns={\"mean\": \"sold\"})\n            .reset_index()\n            .query(\"(days_prior&gt;0) &amp; (sold&gt;0)\")\n        )\n        title = \"Bookings by Timeframe\"\n        if by_class is True:\n            title = \"Bookings by Timeframe and Booking Class\"\n        title_annot = []\n        if not by_carrier:\n            g = [\"days_prior\", \"paxtype\"]\n            if by_class:\n                g += [\"booking_class\"]\n            df = (\n                df.groupby(g, observed=False)[[\"sold\", \"ci0\", \"ci1\"]]\n                .sum()\n                .reset_index()\n            )\n        if isinstance(by_carrier, str):\n            df = df[df[\"carrier\"] == by_carrier]\n            df = df.drop(columns=[\"carrier\"])\n            title_annot.append(by_carrier)\n            by_carrier = False\n        if isinstance(by_class, str):\n            df = df[df[\"booking_class\"] == by_class]\n            df = df.drop(columns=[\"booking_class\"])\n            title_annot.append(f\"Class {by_class}\")\n            by_class = False\n        if title_annot:\n            title = f\"{title} ({', '.join(title_annot)})\"\n        if exclude_nogo and \"carrier\" in df.columns:\n            df = df[df[\"carrier\"] != \"NONE\"]\n        if raw_df:\n            return df\n\n        import altair as alt\n\n        if by_carrier:\n            color = \"carrier:N\"\n            color_title = \"Carrier\"\n        elif by_class:\n            color = \"booking_class:N\"\n            color_title = \"Booking Class\"\n        else:\n            color = \"paxtype:N\"\n            color_title = \"Passenger Type\"\n\n        if by_class:\n            chart = (\n                alt.Chart(df)\n                .mark_bar()\n                .encode(\n                    color=alt.Color(color).title(color_title),\n                    x=alt.X(\"days_prior:O\")\n                    .scale(reverse=True)\n                    .title(\"Days Prior to Departure\"),\n                    y=alt.Y(\"sold\"),\n                    tooltip=(\n                        [alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else []\n                    )\n                    + [\n                        alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                        alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                        alt.Tooltip(\"sold\", format=\".2f\"),\n                    ],\n                )\n                .properties(\n                    width=500,\n                    height=200,\n                )\n                .facet(\n                    row=alt.Row(\"paxtype:N\", title=\"Passenger Type\"),\n                    title=title,\n                )\n            )\n        else:\n            chart = (\n                alt.Chart(df, title=title)\n                .mark_line()\n                .encode(\n                    color=alt.Color(color).title(color_title),\n                    x=alt.X(\"days_prior:O\")\n                    .scale(reverse=True)\n                    .title(\"Days Prior to Departure\"),\n                    y=alt.Y(\"sold\") if by_class else \"sold\",\n                    strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n                    tooltip=(\n                        [alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else []\n                    )\n                    + [\n                        alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                        alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                        alt.Tooltip(\"sold\", format=\".2f\"),\n                    ],\n                )\n                .properties(\n                    width=500,\n                    height=300,\n                )\n                .configure_axis(\n                    labelFontSize=12,\n                    titleFontSize=12,\n                )\n                .configure_legend(\n                    titleFontSize=12,\n                    labelFontSize=15,\n                )\n            )\n        return chart\n\n    def _fig_bookings_by_timeframe_errorband(\n        self, by_carrier: bool | str = True, raw_df=False\n    ):\n        def differs(x):\n            return x.shift(-1, fill_value=0) - x\n\n        b = self.bookings_by_timeframe.reset_index()\n\n        def _summarize(x, c):\n            y = (\n                x.groupby([\"trial\", \"carrier\", \"days_prior\"], observed=False)[\n                    f\"avg_{c}\"\n                ]\n                .sum()\n                .unstack([\"trial\", \"carrier\"])\n                .sort_index(ascending=False)\n                .apply(differs)\n                .stack(\"carrier\", future_stack=True)\n                .aggregate([\"mean\", \"sem\"], axis=1)\n                .assign(\n                    ci0=lambda x: x[\"mean\"] - 1.96 * x[\"sem\"],\n                    ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                )\n            )\n            return pd.concat({c: y}, names=[\"paxtype\"])\n\n        df0 = _summarize(b, \"business\")\n        df1 = _summarize(b, \"leisure\")\n        df = (\n            pd.concat([df0, df1], axis=0)\n            .rename(columns={\"mean\": \"sold\"})\n            .reset_index()\n            .query(\"days_prior&gt;0\")\n        )\n        if not by_carrier:\n            df = (\n                df.groupby([\"days_prior\", \"paxtype\"], observed=False)[\n                    [\"sold\", \"ci0\", \"ci1\"]\n                ]\n                .sum()\n                .reset_index()\n            )\n        if isinstance(by_carrier, str):\n            df = df[df[\"carrier\"] == by_carrier]\n            df = df.drop(columns=[\"carrier\"])\n            by_carrier = False\n        if raw_df:\n            return df\n        import altair as alt\n\n        chart = alt.Chart(df)\n        lines = chart.mark_line().encode(\n            color=alt.Color(\"carrier:N\" if by_carrier else \"paxtype\").title(\n                \"Carrier\" if by_carrier else \"Passenger Type\"\n            ),\n            x=alt.X(\"days_prior:O\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            y=\"sold\",\n            strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n            tooltip=([alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else [])\n            + [\n                alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                alt.Tooltip(\"sold\", format=\".2f\"),\n            ],\n        )\n        bands = chart.mark_errorband().encode(\n            color=alt.Color(\n                \"carrier:N\" if by_carrier else \"paxtype\",\n                title=\"Carrier\" if by_carrier else \"Passenger Type\",\n            ),\n            x=alt.X(\"days_prior:O\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            y=\"ci0\",\n            y2=\"ci1\",\n            strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n        )\n\n        return (\n            (lines + bands)\n            .properties(\n                width=500,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n\n    @report_figure\n    def fig_segmentation_by_timeframe(\n        self,\n        metric: Literal[\"bookings\", \"revenue\"],\n        by_carrier: bool | str = True,\n        by_class: bool | str = False,\n        raw_df: bool = False,\n        exclude_nogo: bool = True,\n    ):\n        if self.segmentation_by_timeframe is None:\n            raise ValueError(\"segmentation_by_timeframe not found\")\n        df = self.segmentation_by_timeframe\n        idxs = list(df.index.names)\n        if \"trial\" in idxs:\n            idxs.remove(\"trial\")\n            df = df.groupby(idxs).mean()\n        df = df[metric].stack().rename(metric).reset_index()\n\n        title = f\"{metric.title()} by Timeframe\"\n        if by_class is True:\n            title = f\"{metric.title()} by Timeframe and Booking Class\"\n        title_annot = []\n        if not by_carrier:\n            g = [\"days_prior\", \"segment\"]\n            if by_class:\n                g += [\"booking_class\"]\n            df = df.groupby(g, observed=False)[[metric]].sum().reset_index()\n        if by_carrier and not by_class:\n            df = (\n                df.groupby([\"carrier\", \"days_prior\", \"segment\"], observed=False)[\n                    [metric]\n                ]\n                .sum()\n                .reset_index()\n            )\n        if isinstance(by_carrier, str):\n            df = df[df[\"carrier\"] == by_carrier]\n            df = df.drop(columns=[\"carrier\"])\n            title_annot.append(by_carrier)\n            by_carrier = False\n        if isinstance(by_class, str):\n            df = df[df[\"booking_class\"] == by_class]\n            df = df.drop(columns=[\"booking_class\"])\n            title_annot.append(f\"Class {by_class}\")\n            by_class = False\n        if title_annot:\n            title = f\"{title} ({', '.join(title_annot)})\"\n        if exclude_nogo and \"carrier\" in df.columns:\n            df = df[df[\"carrier\"] != \"NONE\"]\n        if raw_df:\n            return df\n\n        import altair as alt\n\n        if by_carrier:\n            color = \"carrier:N\"\n            color_title = \"Carrier\"\n        elif by_class:\n            color = \"booking_class:N\"\n            color_title = \"Booking Class\"\n        else:\n            color = \"segment:N\"\n            color_title = \"Passenger Type\"\n\n        if metric == \"revenue\":\n            metric_fmt = \"$,.0f\"\n        else:\n            metric_fmt = \",.2f\"\n\n        chart = (\n            alt.Chart(df)\n            .mark_bar()\n            .encode(\n                color=alt.Color(color).title(color_title),\n                x=alt.X(\"days_prior:O\")\n                .scale(reverse=True)\n                .title(\"Days Prior to Departure\"),\n                y=alt.Y(metric),\n                tooltip=(\n                    [alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else []\n                )\n                + (\n                    [alt.Tooltip(\"booking_class\").title(\"Booking Class\")]\n                    if by_class\n                    else []\n                )\n                + [\n                    alt.Tooltip(\"segment\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"days_prior\", title=\"Days Prior\"),\n                    alt.Tooltip(metric, format=metric_fmt, title=metric.title()),\n                ],\n            )\n            .properties(\n                width=500,\n                height=200,\n            )\n        )\n        if by_carrier or by_class:\n            chart = chart.facet(\n                row=alt.Row(\"segment:N\", title=\"Passenger Type\"),\n                title=title,\n            )\n        return chart\n\n    def _fig_carrier_load_factors(\n        self,\n        raw_df: bool,\n        load_measure: str,\n        measure_name: str,\n        measure_format: str = \".2f\",\n        orient: Literal[\"h\", \"v\"] = \"h\",\n        title: str | None = None,\n    ):\n        df = self.carriers.reset_index()[[\"carrier\", load_measure]]\n        if raw_df:\n            return df\n        import altair as alt\n\n        chart = alt.Chart(df)\n        if orient == \"v\":\n            bars = chart.mark_bar().encode(\n                x=alt.X(\"carrier:N\", title=\"Carrier\"),\n                y=alt.Y(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                tooltip=[\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\n                        f\"{load_measure}:Q\", title=measure_name, format=measure_format\n                    ),\n                ],\n            )\n            text = chart.mark_text(dx=0, dy=3, color=\"white\", baseline=\"top\").encode(\n                x=alt.X(\"carrier:N\", title=\"Carrier\"),\n                y=alt.Y(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                text=alt.Text(f\"{load_measure}:Q\", format=measure_format),\n            )\n        else:\n            bars = chart.mark_bar().encode(\n                y=alt.Y(\"carrier:N\", title=\"Carrier\"),\n                x=alt.X(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                tooltip=[\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\n                        f\"{load_measure}:Q\", title=measure_name, format=measure_format\n                    ),\n                ],\n            )\n            text = chart.mark_text(\n                dx=-5, dy=0, color=\"white\", baseline=\"middle\", align=\"right\"\n            ).encode(\n                y=alt.Y(\"carrier:N\", title=\"Carrier\"),\n                x=alt.X(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                text=alt.Text(f\"{load_measure}:Q\", format=measure_format),\n            )\n        fig = (\n            (bars + text)\n            .properties(\n                width=500,\n                height=10 + 20 * len(df),\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n        if title:\n            fig.title = title\n        return fig\n\n    @report_figure\n    def fig_carrier_load_factors(\n        self, raw_df=False, load_measure: Literal[\"sys_lf\", \"avg_leg_lf\"] = \"sys_lf\"\n    ):\n        measure_name = (\n            \"System Load Factor\" if load_measure == \"sys_lf\" else \"Leg Load Factor\"\n        )\n        return self._fig_carrier_load_factors(\n            raw_df,\n            load_measure,\n            measure_name,\n            title=f\"Carrier {measure_name}s\",\n        )\n\n    @report_figure\n    def fig_carrier_revenues(self, raw_df=False):\n        return self._fig_carrier_load_factors(\n            raw_df, \"avg_rev\", \"Average Revenue\", \"$.4s\", title=\"Carrier Revenues\"\n        )\n\n    @report_figure\n    def fig_carrier_yields(self, raw_df=False):\n        return self._fig_carrier_load_factors(\n            raw_df, \"yield\", \"Average Yield\", \"$.4f\", title=\"Carrier Yields\"\n        )\n\n    @report_figure\n    def fig_carrier_total_bookings(self, raw_df=False):\n        return self._fig_carrier_load_factors(\n            raw_df, \"sold\", \"Total Bookings\", \".4s\", title=\"Carrier Total Bookings\"\n        )\n\n    def _fig_forecasts(\n        self,\n        df,\n        facet_on=None,\n        y=\"forecast_mean\",\n        color=\"booking_class:N\",\n        y_title=\"Avg Demand Forecast\",\n    ):\n        import altair as alt\n\n        encoding = dict(\n            x=alt.X(\"days_prior:O\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            y=alt.Y(f\"{y}:Q\", title=y_title),\n        )\n        if color:\n            encoding[\"color\"] = color\n        if not facet_on:\n            return alt.Chart(df).mark_line().encode(**encoding)\n        else:\n            return (\n                alt.Chart(df)\n                .mark_line()\n                .encode(**encoding)\n                .facet(\n                    facet=f\"{facet_on}:N\",\n                    columns=3,\n                )\n            )\n\n    @report_figure\n    def fig_leg_forecasts(\n        self,\n        by_leg_id: bool | int = True,\n        by_class: bool | str = True,\n        of: Literal[\"mu\", \"sigma\"] | list[Literal[\"mu\", \"sigma\"]] = \"mu\",\n        raw_df=False,\n    ):\n        if isinstance(of, list):\n            if raw_df:\n                raise NotImplementedError\n            fig = self.fig_leg_forecasts(\n                by_leg_id=by_leg_id,\n                by_class=by_class,\n                of=of[0],\n            )\n            for of_ in of[1:]:\n                fig |= self.fig_leg_forecasts(\n                    by_leg_id=by_leg_id,\n                    by_class=by_class,\n                    of=of_,\n                )\n            return fig\n        y = \"forecast_mean\" if of == \"mu\" else \"forecast_stdev\"\n        columns = [\n            \"carrier\",\n            \"leg_id\",\n            \"booking_class\",\n            \"days_prior\",\n            y,\n        ]\n        if self.leg_forecasts is None:\n            raise ValueError(\"the leg_forecasts summary table is not available\")\n        df = self.leg_forecasts.reset_index()[columns]\n        color = \"booking_class:N\"\n        if isinstance(by_leg_id, int) and by_leg_id is not True:\n            df = df[df.leg_id == by_leg_id]\n        if isinstance(by_class, str):\n            df = df[df.booking_class == by_class]\n            color = None\n        if raw_df:\n            return df\n        return self._fig_forecasts(\n            df,\n            facet_on=None,\n            y=y,\n            color=color,\n            y_title=\"Mean Demand Forecast\" if of == \"mu\" else \"Std Dev Demand Forecast\",\n        )\n\n    @report_figure\n    def fig_path_forecasts(\n        self,\n        by_path_id: bool | int = True,\n        by_class: bool | str = True,\n        of: Literal[\"mu\", \"sigma\", \"closed\", \"adj_price\"] = \"mu\",\n        raw_df=False,\n    ):\n        if self.path_forecasts is None:\n            raise ValueError(\"the path_forecasts summary table is not available\")\n        of_columns = {\n            \"mu\": \"forecast_mean\",\n            \"sigma\": \"forecast_stdev\",\n            \"closed\": \"forecast_closed_in_tf\",\n            \"adj_price\": \"adjusted_price\",\n        }\n        y = of_columns.get(of)\n        columns = [\n            \"path_id\",\n            \"booking_class\",\n            \"days_prior\",\n            y,\n        ]\n        df = self.path_forecasts.reset_index()[columns]\n        color = \"booking_class:N\"\n        if isinstance(by_path_id, int) and by_path_id is not True:\n            df = df[df.path_id == by_path_id]\n        if isinstance(by_class, str):\n            df = df[df.booking_class == by_class]\n            color = None\n        if raw_df:\n            return df\n        facet_on = None\n        if by_path_id is True:\n            facet_on = \"path_id\"\n        return self._fig_forecasts(df, facet_on=facet_on, y=y, color=color)\n\n    @report_figure\n    def fig_bid_price_history(\n        self,\n        by_carrier: bool | str = True,\n        show_stdev: float | bool | None = None,\n        cap: Literal[\"some\", \"zero\", None] = None,\n        raw_df=False,\n    ):\n        if cap is None:\n            bp_mean = \"bid_price_mean\"\n        elif cap == \"some\":\n            bp_mean = \"some_cap_bid_price_mean\"\n        elif cap == \"zero\":\n            bp_mean = \"zero_cap_bid_price_mean\"\n        else:\n            raise ValueError(f\"cap={cap!r} not in ['some', 'zero', None]\")\n        df = self.bid_price_history.reset_index()\n        color = None\n        if isinstance(by_carrier, str):\n            df = df[df.carrier == by_carrier]\n        elif by_carrier:\n            color = \"carrier:N\"\n            if show_stdev is None:\n                show_stdev = False\n        if show_stdev:\n            if show_stdev is True:\n                show_stdev = 2\n            df[\"bid_price_upper\"] = df[bp_mean] + show_stdev * df[\"bid_price_stdev\"]\n            df[\"bid_price_lower\"] = (\n                df[bp_mean] - show_stdev * df[\"bid_price_stdev\"]\n            ).clip(0, None)\n        if raw_df:\n            return df\n\n        import altair as alt\n\n        line_encoding = dict(\n            x=alt.X(\"days_prior:Q\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            y=alt.Y(bp_mean, title=\"Bid Price\"),\n        )\n        if color:\n            line_encoding[\"color\"] = color\n        chart = alt.Chart(df)\n        fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n        if show_stdev:\n            area_encoding = dict(\n                x=alt.X(\"days_prior:Q\")\n                .scale(reverse=True)\n                .title(\"Days Prior to Departure\"),\n                y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"),\n                y2=alt.Y2(\"bid_price_upper:Q\", title=\"Bid Price\"),\n            )\n            bound = chart.mark_area(\n                opacity=0.1,\n                interpolate=\"step-before\",\n            ).encode(**area_encoding)\n            bound_line = chart.mark_line(\n                opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\"\n            ).encode(\n                x=alt.X(\"days_prior:Q\")\n                .scale(reverse=True)\n                .title(\"Days Prior to Departure\")\n            )\n            top_line = bound_line.encode(\n                y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\")\n            )\n            bottom_line = bound_line.encode(\n                y=alt.Y(\"bid_price_upper:Q\", title=\"Bid Price\")\n            )\n            fig = fig + bound + top_line + bottom_line\n        return fig\n\n    @report_figure\n    def fig_displacement_history(\n        self,\n        by_carrier: bool | str = True,\n        show_stdev: float | bool | None = None,\n        raw_df=False,\n    ):\n        df = self.displacement_history.reset_index()\n        color = None\n        if isinstance(by_carrier, str):\n            df = df[df.carrier == by_carrier]\n        elif by_carrier:\n            color = \"carrier:N\"\n            if show_stdev is None:\n                show_stdev = False\n        if show_stdev:\n            if show_stdev is True:\n                show_stdev = 2\n            df[\"displacement_upper\"] = (\n                df[\"displacement_mean\"] + show_stdev * df[\"displacement_stdev\"]\n            )\n            df[\"displacement_lower\"] = (\n                df[\"displacement_mean\"] - show_stdev * df[\"displacement_stdev\"]\n            ).clip(0, None)\n        if raw_df:\n            return df\n\n        import altair as alt\n\n        line_encoding = dict(\n            x=alt.X(\"days_prior:Q\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            y=alt.Y(\"displacement_mean\", title=\"Displacement Cost\"),\n        )\n        if color:\n            line_encoding[\"color\"] = color\n        chart = alt.Chart(df)\n        fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n        if show_stdev:\n            area_encoding = dict(\n                x=alt.X(\"days_prior:Q\")\n                .scale(reverse=True)\n                .title(\"Days Prior to Departure\"),\n                y=alt.Y(\"displacement_lower:Q\", title=\"Displacement Cost\"),\n                y2=alt.Y2(\"displacement_upper:Q\", title=\"Displacement Cost\"),\n            )\n            bound = chart.mark_area(\n                opacity=0.1,\n                interpolate=\"step-before\",\n            ).encode(**area_encoding)\n            bound_line = chart.mark_line(\n                opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\"\n            ).encode(\n                x=alt.X(\"days_prior:Q\")\n                .scale(reverse=True)\n                .title(\"Days Prior to Departure\")\n            )\n            top_line = bound_line.encode(\n                y=alt.Y(\"displacement_lower:Q\", title=\"Displacement Cost\")\n            )\n            bottom_line = bound_line.encode(\n                y=alt.Y(\"displacement_upper:Q\", title=\"Displacement Cost\")\n            )\n            fig = fig + bound + top_line + bottom_line\n        return fig\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.bid_price_history", "title": "bid_price_history  <code>instance-attribute</code>", "text": "<pre><code>bid_price_history = bid_price_history\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.bookings_by_timeframe", "title": "bookings_by_timeframe  <code>instance-attribute</code>", "text": "<pre><code>bookings_by_timeframe = bookings_by_timeframe\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.carrier_history", "title": "carrier_history  <code>instance-attribute</code>", "text": "<pre><code>carrier_history = carrier_history\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.carriers", "title": "carriers  <code>instance-attribute</code>", "text": "<pre><code>carriers = carriers\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.class_dist", "title": "class_dist  <code>instance-attribute</code>", "text": "<pre><code>class_dist = class_dist\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.cnx", "title": "cnx  <code>instance-attribute</code>", "text": "<pre><code>cnx = cnx\n</code></pre> <p>The database connection used to load the summary tables.</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.config", "title": "config  <code>instance-attribute</code>", "text": "<pre><code>config = config\n</code></pre> <p>Configuration used in the simulation that generated the summary tables.</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.demand_to_come", "title": "demand_to_come  <code>instance-attribute</code>", "text": "<pre><code>demand_to_come = demand_to_come\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.demand_to_come_summary", "title": "demand_to_come_summary  <code>instance-attribute</code>", "text": "<pre><code>demand_to_come_summary = demand_to_come_summary\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.demands", "title": "demands  <code>instance-attribute</code>", "text": "<pre><code>demands = demands\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.displacement_history", "title": "displacement_history  <code>instance-attribute</code>", "text": "<pre><code>displacement_history = displacement_history\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fare_class_mix", "title": "fare_class_mix  <code>instance-attribute</code>", "text": "<pre><code>fare_class_mix = fare_class_mix\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fares", "title": "fares  <code>instance-attribute</code>", "text": "<pre><code>fares = fares\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.leg_avg_load_factor_distribution", "title": "leg_avg_load_factor_distribution  <code>instance-attribute</code>", "text": "<pre><code>leg_avg_load_factor_distribution = (\n    leg_avg_load_factor_distribution\n)\n</code></pre> <p>Leg average load factor distribution (integers 0-100).</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.leg_carried", "title": "leg_carried  <code>instance-attribute</code>", "text": "<pre><code>leg_carried = leg_carried\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.leg_forecasts", "title": "leg_forecasts  <code>instance-attribute</code>", "text": "<pre><code>leg_forecasts = leg_forecasts\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.leg_local_fraction_distribution", "title": "leg_local_fraction_distribution  <code>instance-attribute</code>", "text": "<pre><code>leg_local_fraction_distribution = (\n    leg_local_fraction_distribution\n)\n</code></pre> <p>Fraction of local passengers on each leg.</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.legs", "title": "legs  <code>instance-attribute</code>", "text": "<pre><code>legs = legs\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.load_factor_distribution", "title": "load_factor_distribution  <code>instance-attribute</code>", "text": "<pre><code>load_factor_distribution = load_factor_distribution\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.load_factors", "title": "load_factors  <code>instance-attribute</code>", "text": "<pre><code>load_factors = load_factors\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.local_and_flow_yields", "title": "local_and_flow_yields  <code>instance-attribute</code>", "text": "<pre><code>local_and_flow_yields = local_and_flow_yields\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.local_fraction_by_place", "title": "local_fraction_by_place  <code>instance-attribute</code>", "text": "<pre><code>local_fraction_by_place = local_fraction_by_place\n</code></pre> <p>Fraction of local passengers by place.</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.n_total_samples", "title": "n_total_samples  <code>instance-attribute</code>", "text": "<pre><code>n_total_samples = n_total_samples\n</code></pre> <p>Total number of sample departures simulated to create these summaries.</p> <p>This excludes any burn samples.</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.od_fare_class_mix", "title": "od_fare_class_mix  <code>instance-attribute</code>", "text": "<pre><code>od_fare_class_mix = od_fare_class_mix\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.path_classes", "title": "path_classes  <code>instance-attribute</code>", "text": "<pre><code>path_classes = path_classes\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.path_forecasts", "title": "path_forecasts  <code>instance-attribute</code>", "text": "<pre><code>path_forecasts = path_forecasts\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.paths", "title": "paths  <code>instance-attribute</code>", "text": "<pre><code>paths = paths\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.raw_fare_class_mix", "title": "raw_fare_class_mix  <code>instance-attribute</code>", "text": "<pre><code>raw_fare_class_mix = raw_fare_class_mix\n</code></pre> <p>Total number of passengers by carrier by fare class.</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.raw_load_factor_distribution", "title": "raw_load_factor_distribution  <code>instance-attribute</code>", "text": "<pre><code>raw_load_factor_distribution = raw_load_factor_distribution\n</code></pre> <p>Total number of departures by carrier by load factor (integers 0-100).</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.segmentation_by_timeframe", "title": "segmentation_by_timeframe  <code>instance-attribute</code>", "text": "<pre><code>segmentation_by_timeframe = segmentation_by_timeframe\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.sim", "title": "sim  <code>instance-attribute</code>", "text": "<pre><code>sim = sim\n</code></pre> <p>The simulation object that generated the summary tables.</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.total_demand", "title": "total_demand  <code>instance-attribute</code>", "text": "<pre><code>total_demand = total_demand\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.__getstate__", "title": "__getstate__", "text": "<pre><code>__getstate__()\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>def __getstate__(self):\n    state = self.__dict__.copy()\n    if \"cnx\" in state:\n        del state[\"cnx\"]\n    if \"config\" in state:\n        # state[\"_config_yaml\"] = state[\"config\"].to_yaml()\n        del state[\"config\"]\n    if \"meta_trials\" in state and not state.get(\"_preserve_meta_trials\", True):\n        del state[\"meta_trials\"]\n    if \"_preserve_meta_trials\" in state:\n        del state[\"_preserve_meta_trials\"]\n    return state\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    *,\n    name: str | None = \"name?\",\n    config: Config | None = None,\n    cnx: Database | None = None,\n    sim: Simulation | None = None,\n    class_dist: DataFrame | None = None,\n    demands: DataFrame | None = None,\n    fares: DataFrame | None = None,\n    legs: DataFrame | None = None,\n    paths: DataFrame | None = None,\n    path_classes: DataFrame | None = None,\n    carriers: DataFrame | None = None,\n    fare_class_mix: DataFrame | None = None,\n    load_factors: DataFrame | None = None,\n    bookings_by_timeframe: DataFrame | None = None,\n    segmentation_by_timeframe: DataFrame | None = None,\n    total_demand: float | None = None,\n    od_fare_class_mix: dict[tuple[str, str], DataFrame]\n    | None = None,\n    leg_forecasts: DataFrame | None = None,\n    path_forecasts: DataFrame | None = None,\n    carrier_history: DataFrame | None = None,\n    demand_to_come: DataFrame | None = None,\n    demand_to_come_summary: DataFrame | None = None,\n    bid_price_history: DataFrame | None = None,\n    displacement_history: DataFrame | None = None,\n    local_and_flow_yields: DataFrame | None = None,\n    leg_carried: DataFrame | None = None,\n    load_factor_distribution: DataFrame | None = None,\n    leg_avg_load_factor_distribution: DataFrame\n    | None = None,\n    raw_load_factor_distribution: DataFrame | None = None,\n    raw_fare_class_mix: DataFrame | None = None,\n    leg_local_fraction_distribution: DataFrame\n    | None = None,\n    local_fraction_by_place: DataFrame | None = None,\n    n_total_samples: int = 0,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>def __init__(\n    self,\n    *,\n    name: str | None = \"name?\",\n    config: Config | None = None,\n    cnx: database.Database | None = None,\n    sim: Simulation | None = None,\n    class_dist: pd.DataFrame | None = None,\n    demands: pd.DataFrame | None = None,\n    fares: pd.DataFrame | None = None,\n    legs: pd.DataFrame | None = None,\n    paths: pd.DataFrame | None = None,\n    path_classes: pd.DataFrame | None = None,\n    carriers: pd.DataFrame | None = None,\n    fare_class_mix: pd.DataFrame | None = None,\n    load_factors: pd.DataFrame | None = None,\n    bookings_by_timeframe: pd.DataFrame | None = None,\n    segmentation_by_timeframe: pd.DataFrame | None = None,\n    total_demand: float | None = None,\n    od_fare_class_mix: dict[tuple[str, str], pd.DataFrame] | None = None,\n    leg_forecasts: pd.DataFrame | None = None,\n    path_forecasts: pd.DataFrame | None = None,\n    carrier_history: pd.DataFrame | None = None,\n    demand_to_come: pd.DataFrame | None = None,\n    demand_to_come_summary: pd.DataFrame | None = None,\n    bid_price_history: pd.DataFrame | None = None,\n    displacement_history: pd.DataFrame | None = None,\n    local_and_flow_yields: pd.DataFrame | None = None,\n    leg_carried: pd.DataFrame | None = None,\n    load_factor_distribution: pd.DataFrame | None = None,\n    leg_avg_load_factor_distribution: pd.DataFrame | None = None,\n    raw_load_factor_distribution: pd.DataFrame | None = None,\n    raw_fare_class_mix: pd.DataFrame | None = None,\n    leg_local_fraction_distribution: pd.DataFrame | None = None,\n    local_fraction_by_place: pd.DataFrame | None = None,\n    n_total_samples: int = 0,\n):\n    summarytables_is_deprecated()\n\n    self.config = config\n    \"\"\"Configuration used in the simulation that generated the summary tables.\"\"\"\n\n    self.cnx = cnx\n    \"\"\"The database connection used to load the summary tables.\"\"\"\n\n    self.sim = sim\n    \"\"\"The simulation object that generated the summary tables.\"\"\"\n\n    self.class_dist = class_dist\n    self.demands = demands\n    self.fares = fares\n    self.legs = legs\n    self.paths = paths\n    self.path_classes = path_classes\n    self.carriers = carriers\n    self.fare_class_mix = fare_class_mix\n    self.od_fare_class_mix = od_fare_class_mix\n    self.load_factors = load_factors\n    self.bookings_by_timeframe = bookings_by_timeframe\n    self.segmentation_by_timeframe = segmentation_by_timeframe\n    self.total_demand = total_demand\n    self.leg_forecasts = leg_forecasts\n    self.path_forecasts = path_forecasts\n    self.carrier_history = carrier_history\n    self.demand_to_come = demand_to_come\n    self.demand_to_come_summary = demand_to_come_summary\n    self.bid_price_history = bid_price_history\n    self.displacement_history = displacement_history\n    self.local_and_flow_yields = local_and_flow_yields\n    self.leg_carried = leg_carried\n    self.load_factor_distribution = load_factor_distribution\n\n    self.leg_avg_load_factor_distribution = leg_avg_load_factor_distribution\n    \"\"\"Leg average load factor distribution (integers 0-100).\"\"\"\n\n    self.raw_load_factor_distribution = raw_load_factor_distribution\n    \"\"\"Total number of departures by carrier by load factor (integers 0-100).\"\"\"\n\n    self.raw_fare_class_mix = raw_fare_class_mix\n    \"\"\"Total number of passengers by carrier by fare class.\"\"\"\n\n    self.leg_local_fraction_distribution = leg_local_fraction_distribution\n    \"\"\"Fraction of local passengers on each leg.\"\"\"\n\n    self.local_fraction_by_place = local_fraction_by_place\n    \"\"\"Fraction of local passengers by place.\"\"\"\n\n    self.n_total_samples = n_total_samples\n    \"\"\"Total number of sample departures simulated to create these summaries.\n\n    This excludes any burn samples.\n    \"\"\"\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.__setstate__", "title": "__setstate__", "text": "<pre><code>__setstate__(state)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>def __setstate__(self, state):\n    # if \"_config_yaml\" in state:\n    #     state[\"config\"] = Config.from_raw_yaml(state.pop(\"_config_yaml\"))\n    self.__dict__.update(state)\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.aggregate", "title": "aggregate  <code>classmethod</code>", "text": "<pre><code>aggregate(summaries: Collection[SummaryTables])\n</code></pre> <p>Aggregate multiple summary tables.</p> Source code in <code>passengersim/summary.py</code> <pre><code>@classmethod\ndef aggregate(cls, summaries: Collection[SummaryTables]):\n    \"\"\"Aggregate multiple summary tables.\"\"\"\n    summarytables_is_deprecated()\n\n    if not summaries:\n        return None\n\n    # dataframes where trial is in the index, just concatenate\n    def concat(name):\n        frames = []\n        for s in summaries:\n            frame = getattr(s, name)\n            if frame is not None:\n                frames.append(frame)\n        if frames:\n            return pd.concat(frames)\n        return None\n\n    carrier_history = concat(\"carrier_history\")\n    bookings_by_timeframe = concat(\"bookings_by_timeframe\")\n    segmentation_by_timeframe = concat(\"segmentation_by_timeframe\")\n    demand_to_come = concat(\"demand_to_come\")\n\n    # demands has some columns that are averages and some that are sums\n    demands_avg = sum(\n        s.demands.set_index([\"orig\", \"dest\", \"segment\"])[\n            [\"sold\", \"revenue\", \"avg_fare\"]\n        ]\n        for s in summaries\n    ) / len(summaries)\n    demands_sum = sum(\n        s.demands.set_index([\"orig\", \"dest\", \"segment\"])[\n            [\"gt_demand\", \"gt_sold\", \"gt_revenue\"]\n        ]\n        for s in summaries\n    )\n    demands = pd.concat([demands_avg, demands_sum], axis=1).reset_index()\n\n    # TODO: aggregate fares\n    # fares has some columns that are (weighted) averages and some that are sums\n    # fares_gt_adj_price = sum(\n    #     s.fares.set_index(\n    #     [\"carrier\", \"orig\", \"dest\", \"booking_class\", \"dcp_index\"]\n    #     ).eval(\"gt_sold * avg_adjusted_price\")\n    #     for s in summaries\n    # )\n    # fares_avg = sum(\n    #     s.fares.set_index(\n    #     [\"carrier\", \"orig\", \"dest\", \"booking_class\", \"dcp_index\"]\n    #     )[\n    #         [\"price\", \"gt_sold\"]\n    #     ]\n    #     for s in summaries\n    # ) / len(summaries)\n    # fares_sum = sum(\n    #     s.fares.set_index(\n    #     [\"carrier\", \"orig\", \"dest\", \"booking_class\", \"dcp_index\"]\n    #     )[\n    #         [\"gt_sold\"]\n    #     ]\n    #     for s in summaries\n    # )\n\n    # TODO: aggregate path_classes\n\n    # these are averages, but need to have the index values excluded\n    # TODO: the index values should be set properly on the original dataframes\n    carriers = sum(s.carriers.set_index(\"carrier\") for s in summaries) / len(\n        summaries\n    )\n    legs = sum(\n        s.legs.set_index([\"carrier\", \"leg_id\", \"flt_no\", \"orig\", \"dest\"])\n        for s in summaries\n    ) / len(summaries)\n    legs = legs.reset_index()\n    paths = sum(\n        s.paths.set_index([\"orig\", \"dest\", \"carrier1\", \"leg_id1\", \"carrier2\"])\n        for s in summaries\n    ) / len(summaries)\n\n    def average(name):\n        frames = []\n        for s in summaries:\n            frame = getattr(s, name)\n            if frame is not None:\n                frames.append(frame)\n        if frames:\n            return sum(frames) / len(frames)\n        return None\n\n    fare_class_mix = average(\"fare_class_mix\")\n    leg_forecasts = average(\"leg_forecasts\")\n    path_forecasts = average(\"path_forecasts\")\n    bid_price_history = average(\"bid_price_history\")\n    displacement_history = average(\"displacement_history\")\n    demand_to_come_summary = average(\"demand_to_come_summary\")\n\n    # dataframes with count data that need to be summed\n    def sum_count(name):\n        frames = []\n        for s in summaries:\n            frame = getattr(s, name)\n            if frame is not None:\n                frames.append(frame)\n        if frames:\n            return sum(frames)\n        return None\n\n    raw_load_factor_distribution = sum_count(\"raw_load_factor_distribution\")\n    leg_avg_load_factor_distribution = sum_count(\"leg_avg_load_factor_distribution\")\n    raw_fare_class_mix = sum_count(\"raw_fare_class_mix\")\n    leg_local_fraction_distribution = sum_count(\"leg_local_fraction_distribution\")\n\n    result = cls(\n        demands=demands,\n        legs=legs,\n        paths=paths,\n        carriers=carriers,\n        fare_class_mix=fare_class_mix,\n        leg_forecasts=leg_forecasts,\n        path_forecasts=path_forecasts,\n        carrier_history=carrier_history,\n        bookings_by_timeframe=bookings_by_timeframe,\n        segmentation_by_timeframe=segmentation_by_timeframe,\n        bid_price_history=bid_price_history,\n        displacement_history=displacement_history,\n        demand_to_come=demand_to_come,\n        demand_to_come_summary=demand_to_come_summary,\n        leg_avg_load_factor_distribution=leg_avg_load_factor_distribution,\n        leg_local_fraction_distribution=leg_local_fraction_distribution,\n        raw_load_factor_distribution=raw_load_factor_distribution,\n        raw_fare_class_mix=raw_fare_class_mix,\n        n_total_samples=sum(s.n_total_samples for s in summaries),\n    )\n    result.meta_trials = summaries\n    return result\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.aggregate_demand_history", "title": "aggregate_demand_history", "text": "<pre><code>aggregate_demand_history(by_segment: bool = True) -&gt; Series\n</code></pre> <p>Total demand by sample, aggregated over all markets.</p> <p>Parameters:</p> <ul> <li> <code>by_segment</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Aggregate by segment.  If false, segments are also aggregated.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>Total demand, indexed by trial, sample, and segment (business/leisure).</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def aggregate_demand_history(self, by_segment: bool = True) -&gt; pd.Series:\n    \"\"\"\n    Total demand by sample, aggregated over all markets.\n\n    Parameters\n    ----------\n    by_segment : bool, default True\n        Aggregate by segment.  If false, segments are also aggregated.\n\n    Returns\n    -------\n    pandas.Series\n        Total demand, indexed by trial, sample, and segment\n        (business/leisure).\n    \"\"\"\n    groupbys = [\"trial\", \"sample\"]\n    if by_segment:\n        groupbys.append(\"segment\")\n    return self.demand_to_come.iloc[:, 0].groupby(groupbys, observed=False).sum()\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.demand_in_tf", "title": "demand_in_tf", "text": "<pre><code>demand_in_tf() -&gt; DataFrame | None\n</code></pre> <p>History of demand arriving in each timeframe.</p> <p>This dataframe is derived from the <code>demand_to_come</code> dataframe by taking the sequential differences.</p> Source code in <code>passengersim/summary.py</code> <pre><code>def demand_in_tf(self) -&gt; pd.DataFrame | None:\n    \"\"\"History of demand arriving in each timeframe.\n\n    This dataframe is derived from the `demand_to_come` dataframe\n    by taking the sequential differences.\n    \"\"\"\n    if self.demand_to_come is None:\n        return None\n    return self.demand_to_come.diff(-1, axis=1).iloc[:, :-1]\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_bid_price_history", "title": "fig_bid_price_history", "text": "<pre><code>fig_bid_price_history(\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_bid_price_history(\n    self,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df=False,\n):\n    if cap is None:\n        bp_mean = \"bid_price_mean\"\n    elif cap == \"some\":\n        bp_mean = \"some_cap_bid_price_mean\"\n    elif cap == \"zero\":\n        bp_mean = \"zero_cap_bid_price_mean\"\n    else:\n        raise ValueError(f\"cap={cap!r} not in ['some', 'zero', None]\")\n    df = self.bid_price_history.reset_index()\n    color = None\n    if isinstance(by_carrier, str):\n        df = df[df.carrier == by_carrier]\n    elif by_carrier:\n        color = \"carrier:N\"\n        if show_stdev is None:\n            show_stdev = False\n    if show_stdev:\n        if show_stdev is True:\n            show_stdev = 2\n        df[\"bid_price_upper\"] = df[bp_mean] + show_stdev * df[\"bid_price_stdev\"]\n        df[\"bid_price_lower\"] = (\n            df[bp_mean] - show_stdev * df[\"bid_price_stdev\"]\n        ).clip(0, None)\n    if raw_df:\n        return df\n\n    import altair as alt\n\n    line_encoding = dict(\n        x=alt.X(\"days_prior:Q\")\n        .scale(reverse=True)\n        .title(\"Days Prior to Departure\"),\n        y=alt.Y(bp_mean, title=\"Bid Price\"),\n    )\n    if color:\n        line_encoding[\"color\"] = color\n    chart = alt.Chart(df)\n    fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n    if show_stdev:\n        area_encoding = dict(\n            x=alt.X(\"days_prior:Q\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"),\n            y2=alt.Y2(\"bid_price_upper:Q\", title=\"Bid Price\"),\n        )\n        bound = chart.mark_area(\n            opacity=0.1,\n            interpolate=\"step-before\",\n        ).encode(**area_encoding)\n        bound_line = chart.mark_line(\n            opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\"\n        ).encode(\n            x=alt.X(\"days_prior:Q\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\")\n        )\n        top_line = bound_line.encode(\n            y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\")\n        )\n        bottom_line = bound_line.encode(\n            y=alt.Y(\"bid_price_upper:Q\", title=\"Bid Price\")\n        )\n        fig = fig + bound + top_line + bottom_line\n    return fig\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_bookings_by_timeframe", "title": "fig_bookings_by_timeframe", "text": "<pre><code>fig_bookings_by_timeframe(\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df: bool = False,\n    errorbands: bool = False,\n    exclude_nogo: bool = True,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_bookings_by_timeframe(\n    self,\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df: bool = False,\n    errorbands: bool = False,\n    exclude_nogo: bool = True,\n):\n    if errorbands:\n        if by_carrier is True:\n            raise NotImplementedError(\"error bands for all carriers is messy\")\n        return self._fig_bookings_by_timeframe_errorband(\n            by_carrier=by_carrier, raw_df=raw_df\n        )\n\n    def differs(x):\n        return x.shift(-1, fill_value=0) - x\n\n    def _summarize(x: pd.DataFrame, c: str):\n        if \"trial\" not in x.columns:\n            x = x.assign(trial=0)\n        if by_class:\n            y = (\n                x.groupby(\n                    [\"trial\", \"carrier\", \"booking_class\", \"days_prior\"],\n                    observed=False,\n                )[f\"avg_{c}\"]\n                .sum()\n                .unstack([\"trial\", \"carrier\", \"booking_class\"])\n                .sort_index(ascending=False)\n                .apply(differs)\n                .stack([\"carrier\", \"booking_class\"], future_stack=True)\n                .aggregate([\"mean\", \"sem\"], axis=1)\n                .assign(\n                    ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                    ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                )\n            )\n        else:\n            y = (\n                x.groupby([\"trial\", \"carrier\", \"days_prior\"], observed=False)[\n                    f\"avg_{c}\"\n                ]\n                .sum()\n                .unstack([\"trial\", \"carrier\"])\n                .sort_index(ascending=False)\n                .apply(differs)\n                .stack(\"carrier\", future_stack=True)\n                .aggregate([\"mean\", \"sem\"], axis=1)\n                .assign(\n                    ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                    ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                )\n            )\n        return pd.concat({c: y}, names=[\"paxtype\"])\n\n    if self.bookings_by_timeframe is None:\n        raise ValueError(\"bookings_by_timeframe not found\")\n    bookings_by_timeframe = self.bookings_by_timeframe.reset_index()\n    df0 = _summarize(bookings_by_timeframe, \"business\")\n    df1 = _summarize(bookings_by_timeframe, \"leisure\")\n    df = (\n        pd.concat([df0, df1], axis=0)\n        .rename(columns={\"mean\": \"sold\"})\n        .reset_index()\n        .query(\"(days_prior&gt;0) &amp; (sold&gt;0)\")\n    )\n    title = \"Bookings by Timeframe\"\n    if by_class is True:\n        title = \"Bookings by Timeframe and Booking Class\"\n    title_annot = []\n    if not by_carrier:\n        g = [\"days_prior\", \"paxtype\"]\n        if by_class:\n            g += [\"booking_class\"]\n        df = (\n            df.groupby(g, observed=False)[[\"sold\", \"ci0\", \"ci1\"]]\n            .sum()\n            .reset_index()\n        )\n    if isinstance(by_carrier, str):\n        df = df[df[\"carrier\"] == by_carrier]\n        df = df.drop(columns=[\"carrier\"])\n        title_annot.append(by_carrier)\n        by_carrier = False\n    if isinstance(by_class, str):\n        df = df[df[\"booking_class\"] == by_class]\n        df = df.drop(columns=[\"booking_class\"])\n        title_annot.append(f\"Class {by_class}\")\n        by_class = False\n    if title_annot:\n        title = f\"{title} ({', '.join(title_annot)})\"\n    if exclude_nogo and \"carrier\" in df.columns:\n        df = df[df[\"carrier\"] != \"NONE\"]\n    if raw_df:\n        return df\n\n    import altair as alt\n\n    if by_carrier:\n        color = \"carrier:N\"\n        color_title = \"Carrier\"\n    elif by_class:\n        color = \"booking_class:N\"\n        color_title = \"Booking Class\"\n    else:\n        color = \"paxtype:N\"\n        color_title = \"Passenger Type\"\n\n    if by_class:\n        chart = (\n            alt.Chart(df)\n            .mark_bar()\n            .encode(\n                color=alt.Color(color).title(color_title),\n                x=alt.X(\"days_prior:O\")\n                .scale(reverse=True)\n                .title(\"Days Prior to Departure\"),\n                y=alt.Y(\"sold\"),\n                tooltip=(\n                    [alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else []\n                )\n                + [\n                    alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                    alt.Tooltip(\"sold\", format=\".2f\"),\n                ],\n            )\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"paxtype:N\", title=\"Passenger Type\"),\n                title=title,\n            )\n        )\n    else:\n        chart = (\n            alt.Chart(df, title=title)\n            .mark_line()\n            .encode(\n                color=alt.Color(color).title(color_title),\n                x=alt.X(\"days_prior:O\")\n                .scale(reverse=True)\n                .title(\"Days Prior to Departure\"),\n                y=alt.Y(\"sold\") if by_class else \"sold\",\n                strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n                tooltip=(\n                    [alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else []\n                )\n                + [\n                    alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                    alt.Tooltip(\"sold\", format=\".2f\"),\n                ],\n            )\n            .properties(\n                width=500,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n    return chart\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_load_factors", "title": "fig_carrier_load_factors", "text": "<pre><code>fig_carrier_load_factors(\n    raw_df=False,\n    load_measure: Literal[\n        \"sys_lf\", \"avg_leg_lf\"\n    ] = \"sys_lf\",\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_carrier_load_factors(\n    self, raw_df=False, load_measure: Literal[\"sys_lf\", \"avg_leg_lf\"] = \"sys_lf\"\n):\n    measure_name = (\n        \"System Load Factor\" if load_measure == \"sys_lf\" else \"Leg Load Factor\"\n    )\n    return self._fig_carrier_load_factors(\n        raw_df,\n        load_measure,\n        measure_name,\n        title=f\"Carrier {measure_name}s\",\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_mileage", "title": "fig_carrier_mileage", "text": "<pre><code>fig_carrier_mileage(raw_df: bool = False, report=None)\n</code></pre> <p>Figure showing ASM, RPM by carrier.</p> <p>ASM is available seat miles.  RPM is revenue passenger miles.</p> <p>Parameters:</p> <ul> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return the raw data for this figure as a pandas DataFrame, instead of generating the figure itself.</p> </li> <li> <code>report</code>               (<code>Reporter</code>, default:                   <code>None</code> )           \u2013            <p>Also append this figure to the given report.</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def fig_carrier_mileage(self, raw_df: bool = False, report=None):\n    \"\"\"\n    Figure showing ASM, RPM by carrier.\n\n    ASM is available seat miles.  RPM is revenue passenger miles.\n\n    Parameters\n    ----------\n    raw_df : bool, default False\n        Return the raw data for this figure as a pandas DataFrame, instead\n        of generating the figure itself.\n    report : xmle.Reporter, optional\n        Also append this figure to the given report.\n    \"\"\"\n    df = (\n        self.carriers.reset_index()[[\"carrier\", \"asm\", \"rpm\"]]\n        .set_index(\"carrier\")\n        .rename_axis(columns=\"measure\")\n        .unstack()\n        .to_frame(\"value\")\n        .reset_index()\n    )\n    if raw_df:\n        return df\n    import altair as alt\n\n    chart = alt.Chart(df, title=\"Carrier Loads\")\n    bars = chart.mark_bar().encode(\n        x=alt.X(\"carrier:N\", title=\"Carrier\"),\n        y=alt.Y(\"value\", stack=None, title=\"miles\"),\n        color=\"measure\",\n        tooltip=[\"carrier\", \"measure\", alt.Tooltip(\"value\", format=\".4s\")],\n    )\n    text = chart.mark_text(\n        dx=0,\n        dy=5,\n        color=\"white\",\n        baseline=\"top\",\n    ).encode(\n        x=alt.X(\"carrier:N\"),\n        y=alt.Y(\"value\").stack(None),\n        text=alt.Text(\"value:Q\", format=\".4s\"),\n    )\n    fig = (\n        (bars + text)\n        .properties(\n            width=400,\n            height=300,\n        )\n        .configure_axis(\n            labelFontSize=12,\n            titleFontSize=12,\n        )\n        .configure_legend(\n            titleFontSize=12,\n            labelFontSize=15,\n        )\n    )\n    if report:\n        report.add_figure(fig)\n    return fig\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_revenues", "title": "fig_carrier_revenues", "text": "<pre><code>fig_carrier_revenues(raw_df=False)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_carrier_revenues(self, raw_df=False):\n    return self._fig_carrier_load_factors(\n        raw_df, \"avg_rev\", \"Average Revenue\", \"$.4s\", title=\"Carrier Revenues\"\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_total_bookings", "title": "fig_carrier_total_bookings", "text": "<pre><code>fig_carrier_total_bookings(raw_df=False)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_carrier_total_bookings(self, raw_df=False):\n    return self._fig_carrier_load_factors(\n        raw_df, \"sold\", \"Total Bookings\", \".4s\", title=\"Carrier Total Bookings\"\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_yields", "title": "fig_carrier_yields", "text": "<pre><code>fig_carrier_yields(raw_df=False)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_carrier_yields(self, raw_df=False):\n    return self._fig_carrier_load_factors(\n        raw_df, \"yield\", \"Average Yield\", \"$.4f\", title=\"Carrier Yields\"\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_displacement_history", "title": "fig_displacement_history", "text": "<pre><code>fig_displacement_history(\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_displacement_history(\n    self,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    raw_df=False,\n):\n    df = self.displacement_history.reset_index()\n    color = None\n    if isinstance(by_carrier, str):\n        df = df[df.carrier == by_carrier]\n    elif by_carrier:\n        color = \"carrier:N\"\n        if show_stdev is None:\n            show_stdev = False\n    if show_stdev:\n        if show_stdev is True:\n            show_stdev = 2\n        df[\"displacement_upper\"] = (\n            df[\"displacement_mean\"] + show_stdev * df[\"displacement_stdev\"]\n        )\n        df[\"displacement_lower\"] = (\n            df[\"displacement_mean\"] - show_stdev * df[\"displacement_stdev\"]\n        ).clip(0, None)\n    if raw_df:\n        return df\n\n    import altair as alt\n\n    line_encoding = dict(\n        x=alt.X(\"days_prior:Q\")\n        .scale(reverse=True)\n        .title(\"Days Prior to Departure\"),\n        y=alt.Y(\"displacement_mean\", title=\"Displacement Cost\"),\n    )\n    if color:\n        line_encoding[\"color\"] = color\n    chart = alt.Chart(df)\n    fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n    if show_stdev:\n        area_encoding = dict(\n            x=alt.X(\"days_prior:Q\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            y=alt.Y(\"displacement_lower:Q\", title=\"Displacement Cost\"),\n            y2=alt.Y2(\"displacement_upper:Q\", title=\"Displacement Cost\"),\n        )\n        bound = chart.mark_area(\n            opacity=0.1,\n            interpolate=\"step-before\",\n        ).encode(**area_encoding)\n        bound_line = chart.mark_line(\n            opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\"\n        ).encode(\n            x=alt.X(\"days_prior:Q\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\")\n        )\n        top_line = bound_line.encode(\n            y=alt.Y(\"displacement_lower:Q\", title=\"Displacement Cost\")\n        )\n        bottom_line = bound_line.encode(\n            y=alt.Y(\"displacement_upper:Q\", title=\"Displacement Cost\")\n        )\n        fig = fig + bound + top_line + bottom_line\n    return fig\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_fare_class_mix", "title": "fig_fare_class_mix", "text": "<pre><code>fig_fare_class_mix(raw_df=False, label_threshold=0.06)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_fare_class_mix(self, raw_df=False, label_threshold=0.06):\n    if self.fare_class_mix is not None:\n        df = self.fare_class_mix.reset_index()[\n            [\"carrier\", \"booking_class\", \"avg_sold\"]\n        ]\n    elif self.raw_fare_class_mix is not None and self.n_total_samples &gt; 0:\n        df = self.raw_fare_class_mix / self.n_total_samples\n        df = df.rename(columns={\"sold\": \"avg_sold\"})\n        df = df.reset_index()[[\"carrier\", \"booking_class\", \"avg_sold\"]]\n    else:\n        return None\n\n    if raw_df:\n        return df\n    return self._fig_fare_class_mix(\n        df,\n        label_threshold=label_threshold,\n        title=\"Fare Class Mix\",\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_leg_forecasts", "title": "fig_leg_forecasts", "text": "<pre><code>fig_leg_forecasts(\n    by_leg_id: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"]\n    | list[Literal[\"mu\", \"sigma\"]] = \"mu\",\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_leg_forecasts(\n    self,\n    by_leg_id: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"] | list[Literal[\"mu\", \"sigma\"]] = \"mu\",\n    raw_df=False,\n):\n    if isinstance(of, list):\n        if raw_df:\n            raise NotImplementedError\n        fig = self.fig_leg_forecasts(\n            by_leg_id=by_leg_id,\n            by_class=by_class,\n            of=of[0],\n        )\n        for of_ in of[1:]:\n            fig |= self.fig_leg_forecasts(\n                by_leg_id=by_leg_id,\n                by_class=by_class,\n                of=of_,\n            )\n        return fig\n    y = \"forecast_mean\" if of == \"mu\" else \"forecast_stdev\"\n    columns = [\n        \"carrier\",\n        \"leg_id\",\n        \"booking_class\",\n        \"days_prior\",\n        y,\n    ]\n    if self.leg_forecasts is None:\n        raise ValueError(\"the leg_forecasts summary table is not available\")\n    df = self.leg_forecasts.reset_index()[columns]\n    color = \"booking_class:N\"\n    if isinstance(by_leg_id, int) and by_leg_id is not True:\n        df = df[df.leg_id == by_leg_id]\n    if isinstance(by_class, str):\n        df = df[df.booking_class == by_class]\n        color = None\n    if raw_df:\n        return df\n    return self._fig_forecasts(\n        df,\n        facet_on=None,\n        y=y,\n        color=color,\n        y_title=\"Mean Demand Forecast\" if of == \"mu\" else \"Std Dev Demand Forecast\",\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_leg_local_fraction_distribution", "title": "fig_leg_local_fraction_distribution", "text": "<pre><code>fig_leg_local_fraction_distribution(\n    by_carrier: bool | str = True,\n    breakpoints: Collection[int] = (\n        50,\n        55,\n        60,\n        65,\n        70,\n        75,\n        80,\n        85,\n        90,\n        95,\n        100,\n    ),\n    raw_df=False,\n)\n</code></pre> <p>Figure showing the distribution of fraction of leg passengers who are local.</p> <p>Parameters:</p> <ul> <li> <code>by_carrier</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>If True, show the distribution by carrier.  If a string, show the distribution for that carrier. If False, show the distribution aggregated over all carriers.</p> </li> <li> <code>breakpoints</code>               (<code>Collection[int, ...]</code>, default:                   <code>(50, 55, 60, 65, ..., 90, 95, 100)</code> )           \u2013            <p>The breakpoints for the local fraction ranges, which represent the lowest local fraction value in each bin. The first and last breakpoints are always bounded to 0 and 101, respectively; these bounds can be included explicitly or omitted to be included implicitly. Setting the top value to 101 ensures that the highest local fraction value (100) is included in the last bin.</p> </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return the raw data for this figure as a pandas DataFrame, instead of generating the figure itself.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def fig_leg_local_fraction_distribution(\n    self,\n    by_carrier: bool | str = True,\n    breakpoints: Collection[int] = (\n        50,\n        55,\n        60,\n        65,\n        70,\n        75,\n        80,\n        85,\n        90,\n        95,\n        100,\n    ),\n    raw_df=False,\n):\n    \"\"\"\n    Figure showing the distribution of fraction of leg passengers who are local.\n\n    Parameters\n    ----------\n    by_carrier : bool or str, default True\n        If True, show the distribution by carrier.  If a string, show the\n        distribution for that carrier. If False, show the distribution\n        aggregated over all carriers.\n    breakpoints : Collection[int, ...], default (50, 55, 60, 65, ..., 90, 95, 100)\n        The breakpoints for the local fraction ranges, which represent the lowest\n        local fraction value in each bin. The first and last breakpoints are always\n        bounded to 0 and 101, respectively; these bounds can be included explicitly\n        or omitted to be included implicitly. Setting the top value to 101 ensures\n        that the highest local fraction value (100) is included in the last bin.\n    raw_df : bool, default False\n        Return the raw data for this figure as a pandas DataFrame, instead\n        of generating the figure itself.\n\n    Returns\n    -------\n    altair.Chart or pd.DataFrame\n    \"\"\"\n    title = \"Local Fraction Frequency\"  # default title\n    if self.leg_local_fraction_distribution is None:\n        raise AttributeError(\n            \"leg_local_fraction_distribution not found, \"\n            \"it is required for using raw source data.\"\n        )\n    df_for_chart = (\n        self.leg_local_fraction_distribution.rename_axis(columns=\"carrier\")\n        .stack(future_stack=True)\n        .rename(\"Count\")\n        .reset_index()\n    )\n    if not isinstance(breakpoints, tuple):\n        breakpoints = tuple(breakpoints)\n    if breakpoints[0] &lt;= 0:\n        breakpoints = (-1,) + breakpoints[1:]\n    else:\n        breakpoints = (-1,) + breakpoints\n    if breakpoints[-1] &gt;= 101:\n        breakpoints = breakpoints[:-1] + (101,)\n    else:\n        breakpoints = breakpoints + (101,)\n\n    # Create labels for categories\n    def make_label(i, j):\n        if i == j - 1:\n            return f\"{i}\"\n        else:\n            return f\"{i}-{j-1}\"\n\n    labels = [make_label(0, breakpoints[1])]\n    for i in range(1, len(breakpoints) - 2):\n        labels += [make_label(breakpoints[i], breakpoints[i + 1])]\n    if breakpoints[-2] &lt; 100:\n        labels += [make_label(breakpoints[-2], 101)]\n    else:\n        labels += [\"100\"]\n\n    breaker = pd.cut(\n        df_for_chart.local_fraction,\n        bins=breakpoints,\n        right=False,\n        labels=labels,\n    ).rename(\"Leg Local Fraction Range\")\n    df_for_chart = (\n        df_for_chart.groupby([\"carrier\", breaker], observed=False)\n        .Count.sum()\n        .reset_index()\n    )\n\n    if not by_carrier:\n        df_for_chart = (\n            df_for_chart.groupby([\"Leg Local Fraction Range\"], observed=False)\n            .Count.sum()\n            .reset_index()\n        )\n    elif isinstance(by_carrier, str):\n        df_for_chart = df_for_chart[df_for_chart[\"carrier\"] == by_carrier]\n        df_for_chart = df_for_chart.drop(columns=[\"carrier\"])\n\n    if raw_df:\n        return df_for_chart\n\n    import altair as alt\n\n    if by_carrier is True:\n        chart = (\n            alt.Chart(df_for_chart)\n            .mark_bar()\n            .encode(\n                x=alt.X(\n                    \"Leg Local Fraction Range\", title=\"Leg Local Fraction Range\"\n                ),\n                y=alt.Y(\"Count:Q\", title=\"Count\"),\n                facet=alt.Facet(\"carrier:N\", columns=2, title=\"Carrier\"),\n                tooltip=[\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\"Count\", title=\"Count\"),\n                ],\n            )\n            .properties(width=300, height=250, title=f\"{title} by Carrier\")\n        )\n    else:\n        chart = (\n            alt.Chart(df_for_chart)\n            .mark_bar()\n            .encode(\n                x=alt.X(\n                    \"Leg Local Fraction Range\", title=\"Leg Local Fraction Range\"\n                ),\n                y=alt.Y(\"Count:Q\", title=\"Count\"),\n            )\n            .properties(\n                width=600,\n                height=400,\n                title=title if not by_carrier else f\"{title} ({by_carrier})\",\n            )\n        )\n    return chart\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_load_factor_distribution", "title": "fig_load_factor_distribution", "text": "<pre><code>fig_load_factor_distribution(\n    by_carrier: bool | str = True,\n    breakpoints: Collection[int] = (\n        50,\n        55,\n        60,\n        65,\n        70,\n        75,\n        80,\n        85,\n        90,\n        95,\n        100,\n    ),\n    source: Literal[\"leg_avg\", \"raw\", \"db\"] = \"leg_avg\",\n    raw_df=False,\n)\n</code></pre> <p>Figure showing the distribution of leg load factors.</p> <p>Parameters:</p> <ul> <li> <code>by_carrier</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>If True, show the distribution by carrier.  If a string, show the distribution for that carrier. If False, show the distribution aggregated over all carriers.</p> </li> <li> <code>breakpoints</code>               (<code>Collection[int, ...]</code>, default:                   <code>(50, 55, 60, 65, ..., 90, 95, 100)</code> )           \u2013            <p>The breakpoints for the load factor ranges, which represent the lowest load factor value in each bin. The first and last breakpoints are always bounded to 0 and 101, respectively; these bounds can be included explicitly or omitted to be included implicitly. Setting the top value to 101 ensures that the highest load factor value (100) is included in the last bin.</p> </li> <li> <code>source</code>               (<code>('raw', 'db')</code>, default:                   <code>\"raw\"</code> )           \u2013            <p>The source of the data.  \"raw\" uses the raw load factor distribution output from the simulation, which is faster and preferred if available. \"db\" uses the older load factor distribution table, which is extracted as a query from the database.  This requires leg level departure (final) details to have been recorded in the database, but potentially allows arbitrary custom filters or transformations to be applied.</p> </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return the raw data for this figure as a pandas DataFrame, instead of generating the figure itself.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_load_factor_distribution(\n    self,\n    by_carrier: bool | str = True,\n    breakpoints: Collection[int] = (\n        50,\n        55,\n        60,\n        65,\n        70,\n        75,\n        80,\n        85,\n        90,\n        95,\n        100,\n    ),\n    source: Literal[\"leg_avg\", \"raw\", \"db\"] = \"leg_avg\",\n    raw_df=False,\n):\n    \"\"\"\n    Figure showing the distribution of leg load factors.\n\n    Parameters\n    ----------\n    by_carrier : bool or str, default True\n        If True, show the distribution by carrier.  If a string, show the\n        distribution for that carrier. If False, show the distribution\n        aggregated over all carriers.\n    breakpoints : Collection[int, ...], default (50, 55, 60, 65, ..., 90, 95, 100)\n        The breakpoints for the load factor ranges, which represent the lowest\n        load factor value in each bin. The first and last breakpoints are always\n        bounded to 0 and 101, respectively; these bounds can be included explicitly\n        or omitted to be included implicitly. Setting the top value to 101 ensures\n        that the highest load factor value (100) is included in the last bin.\n    source : {\"raw\", \"db\"}, default \"raw\"\n        The source of the data.  \"raw\" uses the raw load factor distribution\n        output from the simulation, which is faster and preferred if available.\n        \"db\" uses the older load factor distribution table, which is extracted\n        as a query from the database.  This requires leg level departure (final)\n        details to have been recorded in the database, but potentially allows\n        arbitrary custom filters or transformations to be applied.\n    raw_df : bool, default False\n        Return the raw data for this figure as a pandas DataFrame, instead\n        of generating the figure itself.\n\n    Returns\n    -------\n    altair.Chart or pd.DataFrame\n    \"\"\"\n    title = \"Load Factor Frequency\"  # default title\n    if source == \"raw\" or source == \"leg_avg\":\n        # Load using faster raw load factor data generated by the simulation\n        # This is faster than loading from the database and now preferred\n        if source == \"raw\":\n            if self.raw_load_factor_distribution is None:\n                raise AttributeError(\n                    \"raw_load_factor_distribution not found, \"\n                    \"it is required for using raw source data.\"\n                )\n            df_for_chart = (\n                self.raw_load_factor_distribution.rename_axis(columns=\"carrier\")\n                .stack(future_stack=True)\n                .rename(\"Count\")\n                .reset_index()\n            )\n            title = \"Raw Load Factor Frequency\"\n        elif source == \"leg_avg\":\n            if self.leg_avg_load_factor_distribution is None:\n                raise AttributeError(\n                    \"leg_avg_load_factor_distribution not found, \"\n                    \"it is required for using leg_avg source data.\"\n                )\n            df_for_chart = (\n                self.leg_avg_load_factor_distribution.rename_axis(columns=\"carrier\")\n                .stack(future_stack=True)\n                .rename(\"Count\")\n                .reset_index()\n            )\n            title = \"Leg Average Load Factor Frequency\"\n        if not isinstance(breakpoints, tuple):\n            breakpoints = tuple(breakpoints)\n        if breakpoints[0] &lt;= 0:\n            breakpoints = (-1,) + breakpoints[1:]\n        else:\n            breakpoints = (-1,) + breakpoints\n        if breakpoints[-1] &gt;= 101:\n            breakpoints = breakpoints[:-1] + (101,)\n        else:\n            breakpoints = breakpoints + (101,)\n\n        # Create labels for categories\n        def make_label(i, j):\n            if i == j - 1:\n                return f\"{i}\"\n            else:\n                return f\"{i}-{j-1}\"\n\n        labels = [make_label(0, breakpoints[1])]\n        for i in range(1, len(breakpoints) - 2):\n            labels += [make_label(breakpoints[i], breakpoints[i + 1])]\n        if breakpoints[-2] &lt; 100:\n            labels += [make_label(breakpoints[-2], 101)]\n        else:\n            labels += [\"100\"]\n        breaker = pd.cut(\n            df_for_chart.leg_load_factor,\n            bins=breakpoints,\n            right=False,\n            labels=labels,\n        ).rename(\"Load Factor Range\")\n        df_for_chart = (\n            df_for_chart.groupby([\"carrier\", breaker], observed=False)\n            .Count.sum()\n            .reset_index()\n        )\n\n    elif source == \"db\":\n        # Older load factor distribution table, taken from database\n        if not hasattr(self, \"load_factor_distribution\"):\n            raise AttributeError(\n                \"load_factor_distribution data not found. Please load it first.\"\n            )\n\n        df_for_chart = self.load_factor_distribution\n        df_for_chart.columns.names = [\"Load Factor Range\"]\n        df_for_chart = df_for_chart.set_index(\"carrier\")\n        df_for_chart = (\n            df_for_chart.stack(future_stack=True).rename(\"Count\").reset_index()\n        )\n\n    else:\n        raise ValueError(f\"Unknown source {source}, should be 'raw' or 'db'\")\n\n    if not by_carrier:\n        df_for_chart = (\n            df_for_chart.groupby([\"Load Factor Range\"], observed=False)\n            .Count.sum()\n            .reset_index()\n        )\n    elif isinstance(by_carrier, str):\n        df_for_chart = df_for_chart[df_for_chart[\"carrier\"] == by_carrier]\n        df_for_chart = df_for_chart.drop(columns=[\"carrier\"])\n\n    if raw_df:\n        return df_for_chart\n\n    import altair as alt\n\n    if by_carrier is True:\n        chart = (\n            alt.Chart(df_for_chart)\n            .mark_bar()\n            .encode(\n                x=alt.X(\"Load Factor Range\", title=\"Load Factor Range\"),\n                y=alt.Y(\"Count:Q\", title=\"Count\"),\n                facet=alt.Facet(\"carrier:N\", columns=2, title=\"Carrier\"),\n                tooltip=[\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\"Count\", title=\"Count\"),\n                ],\n            )\n            .properties(width=300, height=250, title=f\"{title} by Carrier\")\n        )\n    else:\n        chart = (\n            alt.Chart(df_for_chart)\n            .mark_bar()\n            .encode(\n                x=alt.X(\"Load Factor Range\", title=\"Load Factor Range\"),\n                y=alt.Y(\"Count:Q\", title=\"Count\"),\n            )\n            .properties(\n                width=600,\n                height=400,\n                title=title if not by_carrier else f\"{title} ({by_carrier})\",\n            )\n        )\n\n    return chart\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_od_fare_class_mix", "title": "fig_od_fare_class_mix", "text": "<pre><code>fig_od_fare_class_mix(\n    orig: str, dest: str, raw_df=False, label_threshold=0.06\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_od_fare_class_mix(\n    self, orig: str, dest: str, raw_df=False, label_threshold=0.06\n):\n    df = self.od_fare_class_mix[orig, dest].reset_index()[\n        [\"carrier\", \"booking_class\", \"avg_sold\"]\n    ]\n    if raw_df:\n        return df\n    return self._fig_fare_class_mix(\n        df, label_threshold=label_threshold, title=f\"Fare Class Mix ({orig}-{dest})\"\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_path_forecasts", "title": "fig_path_forecasts", "text": "<pre><code>fig_path_forecasts(\n    by_path_id: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\n        \"mu\", \"sigma\", \"closed\", \"adj_price\"\n    ] = \"mu\",\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_path_forecasts(\n    self,\n    by_path_id: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\", \"closed\", \"adj_price\"] = \"mu\",\n    raw_df=False,\n):\n    if self.path_forecasts is None:\n        raise ValueError(\"the path_forecasts summary table is not available\")\n    of_columns = {\n        \"mu\": \"forecast_mean\",\n        \"sigma\": \"forecast_stdev\",\n        \"closed\": \"forecast_closed_in_tf\",\n        \"adj_price\": \"adjusted_price\",\n    }\n    y = of_columns.get(of)\n    columns = [\n        \"path_id\",\n        \"booking_class\",\n        \"days_prior\",\n        y,\n    ]\n    df = self.path_forecasts.reset_index()[columns]\n    color = \"booking_class:N\"\n    if isinstance(by_path_id, int) and by_path_id is not True:\n        df = df[df.path_id == by_path_id]\n    if isinstance(by_class, str):\n        df = df[df.booking_class == by_class]\n        color = None\n    if raw_df:\n        return df\n    facet_on = None\n    if by_path_id is True:\n        facet_on = \"path_id\"\n    return self._fig_forecasts(df, facet_on=facet_on, y=y, color=color)\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_segmentation_by_timeframe", "title": "fig_segmentation_by_timeframe", "text": "<pre><code>fig_segmentation_by_timeframe(\n    metric: Literal[\"bookings\", \"revenue\"],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df: bool = False,\n    exclude_nogo: bool = True,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_segmentation_by_timeframe(\n    self,\n    metric: Literal[\"bookings\", \"revenue\"],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df: bool = False,\n    exclude_nogo: bool = True,\n):\n    if self.segmentation_by_timeframe is None:\n        raise ValueError(\"segmentation_by_timeframe not found\")\n    df = self.segmentation_by_timeframe\n    idxs = list(df.index.names)\n    if \"trial\" in idxs:\n        idxs.remove(\"trial\")\n        df = df.groupby(idxs).mean()\n    df = df[metric].stack().rename(metric).reset_index()\n\n    title = f\"{metric.title()} by Timeframe\"\n    if by_class is True:\n        title = f\"{metric.title()} by Timeframe and Booking Class\"\n    title_annot = []\n    if not by_carrier:\n        g = [\"days_prior\", \"segment\"]\n        if by_class:\n            g += [\"booking_class\"]\n        df = df.groupby(g, observed=False)[[metric]].sum().reset_index()\n    if by_carrier and not by_class:\n        df = (\n            df.groupby([\"carrier\", \"days_prior\", \"segment\"], observed=False)[\n                [metric]\n            ]\n            .sum()\n            .reset_index()\n        )\n    if isinstance(by_carrier, str):\n        df = df[df[\"carrier\"] == by_carrier]\n        df = df.drop(columns=[\"carrier\"])\n        title_annot.append(by_carrier)\n        by_carrier = False\n    if isinstance(by_class, str):\n        df = df[df[\"booking_class\"] == by_class]\n        df = df.drop(columns=[\"booking_class\"])\n        title_annot.append(f\"Class {by_class}\")\n        by_class = False\n    if title_annot:\n        title = f\"{title} ({', '.join(title_annot)})\"\n    if exclude_nogo and \"carrier\" in df.columns:\n        df = df[df[\"carrier\"] != \"NONE\"]\n    if raw_df:\n        return df\n\n    import altair as alt\n\n    if by_carrier:\n        color = \"carrier:N\"\n        color_title = \"Carrier\"\n    elif by_class:\n        color = \"booking_class:N\"\n        color_title = \"Booking Class\"\n    else:\n        color = \"segment:N\"\n        color_title = \"Passenger Type\"\n\n    if metric == \"revenue\":\n        metric_fmt = \"$,.0f\"\n    else:\n        metric_fmt = \",.2f\"\n\n    chart = (\n        alt.Chart(df)\n        .mark_bar()\n        .encode(\n            color=alt.Color(color).title(color_title),\n            x=alt.X(\"days_prior:O\")\n            .scale(reverse=True)\n            .title(\"Days Prior to Departure\"),\n            y=alt.Y(metric),\n            tooltip=(\n                [alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else []\n            )\n            + (\n                [alt.Tooltip(\"booking_class\").title(\"Booking Class\")]\n                if by_class\n                else []\n            )\n            + [\n                alt.Tooltip(\"segment\", title=\"Passenger Type\"),\n                alt.Tooltip(\"days_prior\", title=\"Days Prior\"),\n                alt.Tooltip(metric, format=metric_fmt, title=metric.title()),\n            ],\n        )\n        .properties(\n            width=500,\n            height=200,\n        )\n    )\n    if by_carrier or by_class:\n        chart = chart.facet(\n            row=alt.Row(\"segment:N\", title=\"Passenger Type\"),\n            title=title,\n        )\n    return chart\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.from_pickle", "title": "from_pickle  <code>classmethod</code>", "text": "<pre><code>from_pickle(filename: str | Path, read_latest: bool = True)\n</code></pre> <p>Load the object from a pickle file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str or Path - like</code>)           \u2013            <p>The filename to load the object from.</p> </li> <li> <code>read_latest</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, read the latest file matching the pattern.</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>@classmethod\ndef from_pickle(cls, filename: str | pathlib.Path, read_latest: bool = True):\n    \"\"\"Load the object from a pickle file.\n\n    Parameters\n    ----------\n    filename : str or Path-like\n        The filename to load the object from.\n    read_latest : bool, default True\n        If True, read the latest file matching the pattern.\n    \"\"\"\n    summarytables_is_deprecated()\n\n    import glob\n    import pickle\n\n    if read_latest:\n        filename_glob = pathlib.Path(filename).with_suffix(\".*.pkl\")\n        files = sorted(glob.glob(str(filename_glob)))\n        if not files:\n            if not os.path.exists(filename):\n                raise FileNotFoundError(filename)\n        else:\n            filename = files[-1]\n\n    with open(filename, \"rb\") as f:\n        result = pickle.load(f)\n        if result.__class__.__name__ != cls.__name__:\n            raise TypeError(f\"Expected {cls}, got {type(result)}\")\n        return result\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.from_sqlite", "title": "from_sqlite  <code>classmethod</code>", "text": "<pre><code>from_sqlite(\n    filename: str | Path,\n    make_indexes: bool | dict = False,\n    additional: Collection[str | tuple] | str | None = None,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@classmethod\ndef from_sqlite(\n    cls,\n    filename: str | pathlib.Path,\n    make_indexes: bool | dict = False,\n    additional: Collection[str | tuple] | str | None = None,\n):\n    summarytables_is_deprecated()\n    if not os.path.isfile(filename):\n        raise FileNotFoundError(filename)\n    db = database.Database(\n        engine=\"sqlite\",\n        filename=filename,\n    )\n\n    demands = cls.load_basic_table(db, \"demand_summary\")\n    legs = cls.load_basic_table(db, \"leg_summary\")\n    paths = cls.load_basic_table(db, \"path_summary\")\n    carriers = cls.load_basic_table(db, \"carrier_summary\")\n\n    summary = cls(\n        demands=demands,\n        legs=legs,\n        paths=paths,\n        carriers=carriers,\n    )\n\n    if make_indexes:\n        if isinstance(make_indexes, dict):\n            db.add_indexes(**make_indexes)\n        else:\n            db.add_indexes()\n\n    logger.info(\"loading configs\")\n    config = db.load_configs(on_validation_error=\"ignore\")\n    try:\n        scenario = config.scenario\n        burn_samples = config.simulation_controls.burn_samples\n    except AttributeError:\n        scenario = config.get(\"scenario\", \"unknown\")\n        burn_samples = config.get(\"simulation_controls\", {}).get(\n            \"burn_samples\", 100\n        )\n\n    summary.load_additional_tables(\n        db,\n        scenario=scenario,\n        burn_samples=burn_samples,\n        additional=additional,\n    )\n    summary.cnx = db\n    return summary\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.from_sqlite_glob", "title": "from_sqlite_glob  <code>classmethod</code>", "text": "<pre><code>from_sqlite_glob(\n    pattern: str,\n    make_indexes: bool | dict = False,\n    additional: Collection[str | tuple] | str | None = None,\n    *,\n    load_config: bool = True,\n    max_num_files: int = 9999,\n)\n</code></pre> <p>Load and aggregate multiple summary tables from a glob pattern.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>A glob pattern to match the files to load.</p> </li> <li> <code>make_indexes</code>               (<code>bool | dict</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>additional</code>               (<code>Collection[str | tuple] | str | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>load_config</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>SummaryTables</code>           \u2013            </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>@classmethod\ndef from_sqlite_glob(\n    cls,\n    pattern: str,\n    make_indexes: bool | dict = False,\n    additional: Collection[str | tuple] | str | None = None,\n    *,\n    load_config: bool = True,\n    max_num_files: int = 9999,\n):\n    \"\"\"\n    Load and aggregate multiple summary tables from a glob pattern.\n\n    Parameters\n    ----------\n    pattern : str\n        A glob pattern to match the files to load.\n    make_indexes\n    additional\n    load_config\n\n    Returns\n    -------\n    SummaryTables\n    \"\"\"\n    summarytables_is_deprecated()\n\n    import glob\n\n    cfg = None\n    raw = []\n    n = 0\n    for filename in glob.glob(pattern):\n        n += 1\n        if n &gt; max_num_files:\n            continue\n        raw.append(\n            cls.from_sqlite(\n                filename,\n                make_indexes=make_indexes,\n                additional=additional,\n            )\n        )\n        if cfg is None and load_config:\n            cfg = raw[-1].cnx.load_configs(on_validation_error=\"ignore\")\n    if n &gt; max_num_files:\n        warnings.warn(\n            f\"Only loaded {max_num_files} of {n} files matching pattern\",\n            stacklevel=2,\n        )\n    try:\n        result = cls.aggregate(raw)\n    except Exception as e:\n        logger.error(\"Error aggregating summary tables: %s\", e)\n        logger.exception(e)\n        return raw\n    if cfg is not None:\n        result.config = cfg\n    return result\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.load_additional_tables", "title": "load_additional_tables", "text": "<pre><code>load_additional_tables(\n    db: Database,\n    scenario: str,\n    burn_samples: int,\n    additional: Collection[str | tuple] | str | None = (\n        \"fare_class_mix\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n        \"load_factor_distribution\",\n    ),\n) -&gt; None\n</code></pre> <p>Load additional summary tables based on common queries.</p> <p>Parameters:</p> <ul> <li> <code>db</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>)           \u2013            <p>The number of samples in the burn period.  The data from these samples is ignored in most common queries.</p> </li> <li> <code>additional</code>               (<code>Collection[str | tuple] | str</code>, default:                   <code>('fare_class_mix', 'bookings_by_timeframe', 'total_demand', 'load_factor_distribution')</code> )           \u2013            <p>One or more additional tables to load.  If \"*\", then this will load all common queries supported by the configuration used during the simulation.</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def load_additional_tables(\n    self,\n    db: database.Database,\n    scenario: str,\n    burn_samples: int,\n    additional: Collection[str | tuple] | str | None = (\n        \"fare_class_mix\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n        \"load_factor_distribution\",\n    ),\n) -&gt; None:\n    \"\"\"\n    Load additional summary tables based on common queries.\n\n    Parameters\n    ----------\n    db : Database\n    scenario : str\n    burn_samples : int\n        The number of samples in the burn period.  The data from these samples\n        is ignored in most common queries.\n    additional : Collection[str | tuple] | str\n        One or more additional tables to load.  If \"*\", then this will load\n        all common queries supported by the configuration used during the\n        simulation.\n    \"\"\"\n    if isinstance(additional, str):\n        if additional == \"*\":\n            additional = set()\n            cfg = db.load_configs(scenario)\n            if \"fare\" in cfg.db.write_items:\n                additional.add(\"fare_class_mix\")\n            if \"fare_final\" in cfg.db.write_items:\n                additional.add(\"fare_class_mix\")\n            if \"bookings\" in cfg.db.write_items:\n                additional.add(\"bookings_by_timeframe\")\n            if \"demand\" in cfg.db.write_items:\n                additional.add(\"total_demand\")\n                additional.add(\"demand_to_come\")\n            if \"demand_final\" in cfg.db.write_items:\n                additional.add(\"total_demand\")\n            if \"bucket\" in cfg.db.write_items:\n                additional.add(\"leg_forecasts\")\n                additional.add(\"carrier_history\")\n            if \"pathclass\" in cfg.db.write_items:\n                additional.add(\"path_forecasts\")\n                additional.add(\"local_and_flow_yields\")\n            if \"pathclass_final\" in cfg.db.write_items:\n                additional.add(\"local_and_flow_yields\")\n            if \"leg\" in cfg.db.write_items and cfg.db.store_leg_bid_prices:\n                additional.add(\"bid_price_history\")\n            if \"leg\" in cfg.db.write_items and cfg.db.store_displacements:\n                additional.add(\"displacement_history\")\n            if \"leg\" in cfg.db.write_items or \"leg_final\" in cfg.db.write_items:\n                additional.add(\"load_factor_distribution\")\n        else:\n            additional = [additional]\n    elif additional is None:\n        additional = []\n\n    if \"fare_class_mix\" in additional and db.is_open:\n        logger.info(\"loading fare_class_mix\")\n        self.fare_class_mix = database.common_queries.fare_class_mix(\n            db, scenario, burn_samples=burn_samples\n        )\n        if self.od_fare_class_mix:\n            for orig, dest in list(self.od_fare_class_mix):\n                self.od_fare_class_mix[(orig, dest)] = (\n                    database.common_queries.od_fare_class_mix(\n                        db, orig, dest, scenario, burn_samples=burn_samples\n                    )\n                )\n    # load additional fare class mix tables\n    for i in additional:\n        if isinstance(i, tuple) and i[0] == \"od_fare_class_mix\" and db.is_open:\n            orig, dest = i[1], i[2]\n            if self.od_fare_class_mix is None:\n                self.od_fare_class_mix = {}\n            logger.info(f\"loading od_fare_class_mix({orig},{dest})\")\n            self.od_fare_class_mix[(orig, dest)] = (\n                database.common_queries.od_fare_class_mix(\n                    db, orig, dest, scenario, burn_samples=burn_samples\n                )\n            )\n\n    for i in additional:\n        cutoffs = None\n        if i == \"load_factor_distribution\" and db.is_open:\n            cutoffs = (0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95)  # default cutoffs\n        elif (\n            isinstance(i, tuple)\n            and i[0] == \"load_factor_distribution\"\n            and db.is_open\n        ):\n            cutoffs = ast.literal_eval(i[1])\n        if cutoffs is not None:\n            logger.info(\"loading load_factor_distribution\")\n            self.load_factor_distribution = (\n                database.common_queries.load_factor_distribution(\n                    db,\n                    scenario=scenario,\n                    burn_samples=burn_samples,\n                    cutoffs=cutoffs,\n                )\n            )\n\n    if \"bookings_by_timeframe\" in additional and db.is_open:\n        logger.info(\"loading bookings_by_timeframe\")\n        self.bookings_by_timeframe = database.common_queries.bookings_by_timeframe(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"total_demand\" in additional and db.is_open:\n        logger.info(\"loading total_demand\")\n        self.total_demand = database.common_queries.total_demand(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"leg_forecasts\" in additional and db.is_open:\n        logger.info(\"loading leg_forecasts\")\n        self.leg_forecasts = database.common_queries.leg_forecasts(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"path_forecasts\" in additional and db.is_open:\n        logger.info(\"loading path_forecasts\")\n        self.path_forecasts = database.common_queries.path_forecasts(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"demand_to_come\" in additional and db.is_open:\n        logger.info(\"loading demand_to_come\")\n        self.demand_to_come = database.common_queries.demand_to_come(\n            db, scenario=scenario\n        )\n\n    if \"demand_to_come_summary\" in additional and db.is_open:\n        logger.info(\"loading demand_to_come_summary\")\n        self.demand_to_come_summary = (\n            database.common_queries.demand_to_come_summary(db, scenario=scenario)\n        )\n\n    if \"carrier_history\" in additional and db.is_open:\n        logger.info(\"loading carrier_history\")\n        self.carrier_history = database.common_queries.carrier_history(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"bid_price_history\" in additional and db.is_open:\n        logger.info(\"loading bid_price_history\")\n        self.bid_price_history = database.common_queries.bid_price_history(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"displacement_history\" in additional and db.is_open:\n        logger.info(\"loading displacement_history\")\n        self.displacement_history = database.common_queries.displacement_history(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"local_and_flow_yields\" in additional and db.is_open:\n        logger.info(\"loading local_and_flow_yields\")\n        self.local_and_flow_yields = database.common_queries.local_and_flow_yields(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"leg_local_and_flow_by_class\" in additional and db.is_open:\n        logger.info(\"loading leg_local_and_flow_by_class\")\n        self.leg_carried = database.common_queries.leg_local_and_flow_by_class(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"edgar\" in additional and db.is_open:\n        logger.info(\"loading edgar\")\n        self.edgar = database.common_queries.edgar(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.load_basic_table", "title": "load_basic_table  <code>classmethod</code>", "text": "<pre><code>load_basic_table(db: Database, tablename: str)\n</code></pre> <p>Load a basic table</p> Source code in <code>passengersim/summary.py</code> <pre><code>@classmethod\ndef load_basic_table(self, db: database.Database, tablename: str):\n    \"\"\"Load a basic table\"\"\"\n    logger.info(\"loading %s\", tablename)\n    return db.dataframe(f\"SELECT * FROM {tablename}\")\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.to_dataframe", "title": "to_dataframe", "text": "<pre><code>to_dataframe(table) -&gt; DataFrame\n</code></pre> <p>Convert the summary tables to a individual dataframes.</p> Source code in <code>passengersim/summary.py</code> <pre><code>def to_dataframe(self, table) -&gt; pd.DataFrame:\n    \"\"\"Convert the summary tables to a individual dataframes.\"\"\"\n    sheet_count = 0\n    for k, v in self.__dict__.items():\n        if isinstance(v, pd.DataFrame):\n            sheet_count += 1\n            if sheet_count == table:\n                return v.assign(table=k)\n\n    raise IndexError(\"There are fewer than\", table, \" DataFrames in the object\")\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.to_pickle", "title": "to_pickle", "text": "<pre><code>to_pickle(\n    filename: str | Path,\n    add_timestamp_ext: bool = True,\n    preserve_meta_trials: bool = False,\n)\n</code></pre> <p>Save the object to a pickle file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str or Path - like</code>)           \u2013            <p>The filename to save the object to.</p> </li> <li> <code>add_timestamp_ext</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Add a timestamp extension to the filename.</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def to_pickle(\n    self,\n    filename: str | pathlib.Path,\n    add_timestamp_ext: bool = True,\n    preserve_meta_trials: bool = False,\n):\n    \"\"\"Save the object to a pickle file.\n\n    Parameters\n    ----------\n    filename : str or Path-like\n        The filename to save the object to.\n    add_timestamp_ext : bool, default True\n        Add a timestamp extension to the filename.\n    \"\"\"\n    import pickle\n\n    if add_timestamp_ext:\n        filename = filename_with_timestamp(filename, suffix=\".pkl\")\n\n    with open(filename, \"wb\") as f:\n        self._preserve_meta_trials = preserve_meta_trials\n        pickle.dump(self, f)\n        del self._preserve_meta_trials\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.to_records", "title": "to_records", "text": "<pre><code>to_records() -&gt; dict[str, list[dict]]\n</code></pre> <p>Convert all summary tables to a dictionary of records.</p> Source code in <code>passengersim/summary.py</code> <pre><code>def to_records(self) -&gt; dict[str, list[dict]]:\n    \"\"\"Convert all summary tables to a dictionary of records.\"\"\"\n    return {k: v.to_dict(orient=\"records\") for (k, v) in self.__dict__.items()}\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.to_xlsx", "title": "to_xlsx", "text": "<pre><code>to_xlsx(filename: str | Path) -&gt; None\n</code></pre> <p>Write summary tables to excel.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>Path - like</code>)           \u2013            <p>The excel file to write.</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def to_xlsx(self, filename: str | pathlib.Path) -&gt; None:\n    \"\"\"Write summary tables to excel.\n\n    Parameters\n    ----------\n    filename : Path-like\n        The excel file to write.\n    \"\"\"\n    if isinstance(filename, str):\n        filename = pathlib.Path(filename)\n    filename.parent.mkdir(exist_ok=True, parents=True)\n    with pd.ExcelWriter(filename) as writer:\n        for k, v in self.__dict__.items():\n            if isinstance(v, pd.DataFrame):\n                v.to_excel(writer, sheet_name=k)\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.summarytables_is_deprecated", "title": "summarytables_is_deprecated", "text": "<pre><code>summarytables_is_deprecated()\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>def summarytables_is_deprecated():\n    warnings.warn(\n        \"SummaryTables is deprecated and will be removed in a future version.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n</code></pre>"}, {"location": "API/Core/index.html", "title": "PassengerSim.Core API", "text": "<p>While the main <code>passengersim</code> package available as a freely downloadable open source package, the functionality in the <code>passengersim.core</code> sub-package is only available to authorized users.  The documentation of the API for this sub-package is provided here.</p>"}, {"location": "API/Core/00-SimulationEngine.html", "title": "Simulation Engine", "text": ""}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine-attributes", "title": "Attributes", "text": ""}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.base_time", "title": "base_time  <code>instance-attribute</code>", "text": "<pre><code>base_time: int\n</code></pre> <p>The base time of the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.bucketnames", "title": "bucketnames  <code>instance-attribute</code>", "text": "<pre><code>bucketnames: Sequence[str]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.buckets", "title": "buckets  <code>instance-attribute</code>", "text": "<pre><code>buckets: Sequence[Bucket]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.burn_samples", "title": "burn_samples  <code>instance-attribute</code>", "text": "<pre><code>burn_samples: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.carriers", "title": "carriers  <code>instance-attribute</code>", "text": "<pre><code>carriers: Sequence[Carrier]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.choice_set_sampling_probability", "title": "choice_set_sampling_probability  <code>instance-attribute</code>", "text": "<pre><code>choice_set_sampling_probability: float\n</code></pre> <p>Used to randomly sample the choice set, especially useful for large networks</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.config", "title": "config  <code>instance-attribute</code>", "text": "<pre><code>config: Config | None\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.demands", "title": "demands  <code>instance-attribute</code>", "text": "<pre><code>demands: Sequence[Demand]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.disable_ap", "title": "disable_ap  <code>instance-attribute</code>", "text": "<pre><code>disable_ap: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.dwm_lite", "title": "dwm_lite  <code>instance-attribute</code>", "text": "<pre><code>dwm_lite: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.fares", "title": "fares  <code>instance-attribute</code>", "text": "<pre><code>fares: Sequence[Fare]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.iteration", "title": "iteration  <code>instance-attribute</code>", "text": "<pre><code>iteration: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.last_dcp", "title": "last_dcp  <code>instance-attribute</code>", "text": "<pre><code>last_dcp: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.last_dcp_index", "title": "last_dcp_index  <code>instance-attribute</code>", "text": "<pre><code>last_dcp_index: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.last_event_time", "title": "last_event_time  <code>instance-attribute</code>", "text": "<pre><code>last_event_time: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.legs", "title": "legs  <code>instance-attribute</code>", "text": "<pre><code>legs: LegIterator\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.manual_paths", "title": "manual_paths  <code>instance-attribute</code>", "text": "<pre><code>manual_paths: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.markets", "title": "markets  <code>instance-attribute</code>", "text": "<pre><code>markets: Mapping[str, Market]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.max_connect_time", "title": "max_connect_time  <code>instance-attribute</code>", "text": "<pre><code>max_connect_time: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.mkt_k_factor", "title": "mkt_k_factor  <code>instance-attribute</code>", "text": "<pre><code>mkt_k_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_dcps", "title": "num_dcps  <code>instance-attribute</code>", "text": "<pre><code>num_dcps: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_samples", "title": "num_samples  <code>instance-attribute</code>", "text": "<pre><code>num_samples: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_trials", "title": "num_trials  <code>instance-attribute</code>", "text": "<pre><code>num_trials: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_trials_completed", "title": "num_trials_completed  <code>instance-attribute</code>", "text": "<pre><code>num_trials_completed: int\n</code></pre> <p>Number of trials actually completed with this simulation.</p> <p>When multiprocessing, this typically will be just 1, as each process will complete only one trial.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.pathclasses", "title": "pathclasses  <code>instance-attribute</code>", "text": "<pre><code>pathclasses: Sequence[PathClass]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.paths", "title": "paths  <code>instance-attribute</code>", "text": "<pre><code>paths: PathIterator\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.pax_type_k_factor", "title": "pax_type_k_factor  <code>instance-attribute</code>", "text": "<pre><code>pax_type_k_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.prorate_revenue", "title": "prorate_revenue  <code>instance-attribute</code>", "text": "<pre><code>prorate_revenue: bool\n</code></pre> <p>When set to True, O&amp;D revenue is prorated by mileage to the leg level</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator: Generator\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.rm_start_sample", "title": "rm_start_sample  <code>instance-attribute</code>", "text": "<pre><code>rm_start_sample: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.sample", "title": "sample  <code>instance-attribute</code>", "text": "<pre><code>sample: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.save_timeframe_details", "title": "save_timeframe_details  <code>instance-attribute</code>", "text": "<pre><code>save_timeframe_details: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.snapshot_filters", "title": "snapshot_filters  <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[SnapshotFilter] | None\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.sys_k_factor", "title": "sys_k_factor  <code>instance-attribute</code>", "text": "<pre><code>sys_k_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.tf_k_factor", "title": "tf_k_factor  <code>instance-attribute</code>", "text": "<pre><code>tf_k_factor: float\n</code></pre> <p>Timeframe k-factor, controls variance in the passenger arrival curves</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.tf_z_factor", "title": "tf_z_factor  <code>instance-attribute</code>", "text": "<pre><code>tf_z_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.trial", "title": "trial  <code>instance-attribute</code>", "text": "<pre><code>trial: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine-functions", "title": "Functions", "text": ""}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.__init__", "title": "__init__", "text": "<pre><code>__init__(name: str = 'Incognito', random_generator=None)\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine._book_offer", "title": "_book_offer", "text": "<pre><code>_book_offer(\n    dmd: Demand, offer: Offer, num_pax: int = 1\n) -&gt; None\n</code></pre> <p>Exercise the bookOffer method in CoreSim, this is ONLY for unit testing !!!</p> <p>Trying to do anything else with this method may result in pain, mental anguish and gnashing of teeth</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine._get_event", "title": "_get_event", "text": "<pre><code>_get_event() -&gt; float\n</code></pre> <p>Pop the next event from the queue and return the timestamp.</p> <p>Only used for unit testing.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_airport", "title": "add_airport", "text": "<pre><code>add_airport(airport: Airport) -&gt; None\n</code></pre> <p>Add an Airport to the simulation</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_carrier", "title": "add_carrier", "text": "<pre><code>add_carrier(carrier: Carrier) -&gt; None\n</code></pre> <p>Add a Carrier to the simulation</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_dcp", "title": "add_dcp", "text": "<pre><code>add_dcp(dcp_index: int, days_prior: int) -&gt; None\n</code></pre> <p>Add dcp_index and days_prior.  Must be added in ascending order of dcp_index</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_demand", "title": "add_demand", "text": "<pre><code>add_demand(dmd: Demand) -&gt; None\n</code></pre> <p>Add a Market Segment demand to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_event", "title": "add_event", "text": "<pre><code>add_event(e: Event) -&gt; None\n</code></pre> <p>Add a user Event to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_fare", "title": "add_fare", "text": "<pre><code>add_fare(fare: Fare) -&gt; None\n</code></pre> <p>Add a Fare to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_frat5", "title": "add_frat5", "text": "<pre><code>add_frat5(frat5: Frat5) -&gt; None\n</code></pre> <p>Add a Frat5 curve to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_leg", "title": "add_leg", "text": "<pre><code>add_leg(leg: Leg) -&gt; None\n</code></pre> <p>Add a Leg to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_path", "title": "add_path", "text": "<pre><code>add_path(path: Path) -&gt; None\n</code></pre> <p>Add a Path to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.allocate_demand_to_tf", "title": "allocate_demand_to_tf", "text": "<pre><code>allocate_demand_to_tf(\n    dmd: Demand,\n    num_pax: int,\n    tf_k_factor: float,\n    endTS: int,\n    debug: bool = False,\n) -&gt; tuple[int]\n</code></pre> <p>Generate events for a single demand</p> <p>Parameters:</p> <ul> <li> <code>dmd</code>               (<code>Demand</code>)           \u2013            </li> <li> <code>num_pax</code>               (<code>int</code>)           \u2013            </li> <li> <code>tf_k_factor</code>               (<code>float</code>)           \u2013            </li> <li> <code>endTS</code>               (<code>int</code>)           \u2013            </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of events allocated.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.allocate_demand_to_tf_pods", "title": "allocate_demand_to_tf_pods", "text": "<pre><code>allocate_demand_to_tf_pods(\n    dmd: Demand,\n    num_pax: int,\n    tf_k_factor: float,\n    endTS: int,\n) -&gt; tuple[int]\n</code></pre> <p>Generate events for a single demand (used to simulate PODS processing)</p> <p>Parameters:</p> <ul> <li> <code>dmd</code>               (<code>Demand</code>)           \u2013            </li> <li> <code>num_pax</code>               (<code>int</code>)           \u2013            </li> <li> <code>tf_k_factor</code>               (<code>float</code>)           \u2013            </li> <li> <code>endTS</code>               (<code>int</code>)           \u2013            </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int]</code>           \u2013            <p>Number of events allocated by DCP.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.build_connections", "title": "build_connections", "text": "<pre><code>build_connections(\n    dmd: Demand, debug: bool | None = False\n) -&gt; None\n</code></pre> <p>Build connections for the demands.</p> <p>This will create <code>Path</code> objects for each demand, if the network is given only by the <code>Leg</code> objects.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.build_expiration", "title": "build_expiration", "text": "<pre><code>build_expiration() -&gt; datetime\n</code></pre> <p>Get the expiration time for this build.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.capture_forecast_accuracy", "title": "capture_forecast_accuracy", "text": "<pre><code>capture_forecast_accuracy() -&gt; None\n</code></pre> <p>Capture EDGAR-like forecast accuracy data</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.choice_set_columns", "title": "choice_set_columns", "text": "<pre><code>choice_set_columns() -&gt; list\n</code></pre> <p>Return a list of column names for the choice set</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.clear_choice_set", "title": "clear_choice_set", "text": "<pre><code>clear_choice_set() -&gt; None\n</code></pre> <p>Delete the choice set data that is stored in memory</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.compute_hhi", "title": "compute_hhi", "text": "<pre><code>compute_hhi(debug: bool | None = False)\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.distribution_local_leg_passengers", "title": "distribution_local_leg_passengers", "text": "<pre><code>distribution_local_leg_passengers(carrier: str) -&gt; ndarray\n</code></pre> <p>Return the distribution of percent local passengers by leg for this carrier.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.final_write_to_sqlite", "title": "final_write_to_sqlite", "text": "<pre><code>final_write_to_sqlite(cnx: Connection)\n</code></pre> <p>Write final summary details to sqlite</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.fraction_local_by_carrier_and_place", "title": "fraction_local_by_carrier_and_place", "text": "<pre><code>fraction_local_by_carrier_and_place(\n    carrier: str,\n) -&gt; dict[str, float]\n</code></pre> <p>Return the fraction of local passengers by place for this carrier.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.get_airport_carrier_share", "title": "get_airport_carrier_share", "text": "<pre><code>get_airport_carrier_share(\n    selfself, airport: str, carrier: str\n) -&gt; float\n</code></pre> <p>Get the seat share for this carrier at the specified airport</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.get_choice_set", "title": "get_choice_set", "text": "<pre><code>get_choice_set(carrier: str | None) -&gt; list\n</code></pre> <p>Get the choice set for the all, or subset for the specified carrier</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.get_days_prior", "title": "get_days_prior", "text": "<pre><code>get_days_prior(dcp_index: int) -&gt; int\n</code></pre> <p>Get days_prior for this dcp_index</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.get_preferred_carrier", "title": "get_preferred_carrier", "text": "<pre><code>get_preferred_carrier(\n    dmd: Demand, z_val: float, debug: bool\n)\n</code></pre> <p>Calls the code to set preferred carrier. This is for unit tests</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.go", "title": "go", "text": "<pre><code>go() -&gt; Any\n</code></pre> <p>Run the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.license_info", "title": "license_info", "text": "<pre><code>license_info(user_cert=None) -&gt; str\n</code></pre> <p>Access license info as a human-readable string.</p> <p>Parameters:</p> <ul> <li> <code>user_cert</code>               (<code>Certificate</code>, default:                   <code>None</code> )           \u2013            <p>The license.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_events", "title": "num_events", "text": "<pre><code>num_events() -&gt; int\n</code></pre> <p>Return the number of events currently on the event queue.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.path_2_leg", "title": "path_2_leg", "text": "<pre><code>path_2_leg(carrier: str, dcp_index: int) -&gt; None\n</code></pre> <p>Aggregate PathClass forecasts to Leg/Bucket</p> <p>The dcp_index is used to adjust forecast revenues when fare adjustment is used.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.record_daily_statistics", "title": "record_daily_statistics", "text": "<pre><code>record_daily_statistics(days_prior: int) -&gt; int\n</code></pre> <p>Record daily statistics.</p> <p>Parameters:</p> <ul> <li> <code>days_prior</code>               (<code>int</code>)           \u2013            <p>The current number of days prior to departure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>1 if statistics were recorded (i.e. the sample is after the burn period), or 0 otherwise.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.record_dcp_statistics", "title": "record_dcp_statistics", "text": "<pre><code>record_dcp_statistics(days_prior: int) -&gt; int\n</code></pre> <p>Record DCP statistics.</p> <p>Parameters:</p> <ul> <li> <code>days_prior</code>               (<code>int</code>)           \u2013            <p>The current number of days prior to departure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>1 if statistics were recorded (i.e. the sample is after the burn period), or 0 otherwise.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.record_departure_statistics", "title": "record_departure_statistics", "text": "<pre><code>record_departure_statistics() -&gt; int\n</code></pre> <p>Record departure statistics.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>1 if statistics were recorded (i.e. the sample is after the burn period), or 0 otherwise.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.reset_counters", "title": "reset_counters", "text": "<pre><code>reset_counters() -&gt; None\n</code></pre> <p>Reset counters for sold &amp; revenue, for demands and legs.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.set_parm", "title": "set_parm", "text": "<pre><code>set_parm(name: str, value: float) -&gt; None\n</code></pre> <p>Set a simulation parameter by name and value</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.shop", "title": "shop", "text": "<pre><code>shop(orig: str, dest: str) -&gt; list[tuple]\n</code></pre> <p>Shop all carriers for this O-D pair, return a list of (carrier, price)</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.update_db_write_flags", "title": "update_db_write_flags", "text": "<pre><code>update_db_write_flags()\n</code></pre> <p>Update database writing flags based on config.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.validate_license", "title": "validate_license", "text": "<pre><code>validate_license(user_cert=None, future: int = 0) -&gt; None\n</code></pre> <p>Validate a user's license certificate.</p> <p>Parameters:</p> <ul> <li> <code>user_cert</code>               (<code>Certificate</code>, default:                   <code>None</code> )           \u2013            <p>The license.</p> </li> <li> <code>future</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Validate as if it is this many days in the future.  This is primarily used for debugging and testing. This is treated as an unsigned integer internally, so negative values will not go back in time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the license certificate is not valid.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.write_to_sqlite", "title": "write_to_sqlite", "text": "<pre><code>write_to_sqlite(\n    cnx: Connection,\n    dcp: int,\n    store_bid_prices: bool = True,\n    intermediate_day: bool = False,\n    store_displacements: bool = True,\n)\n</code></pre> <p>Write details to sqlite</p>"}, {"location": "API/Core/BookingCurves.html", "title": "Booking Curves", "text": ""}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator: Generator\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.__init__", "title": "__init__", "text": "<pre><code>__init__(name: str)\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.add_dcp", "title": "add_dcp", "text": "<pre><code>add_dcp(dcp: int, pct: float)\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.get_curve", "title": "get_curve", "text": "<pre><code>get_curve() -&gt; dict[int, float]\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.verify_curve", "title": "verify_curve", "text": "<pre><code>verify_curve() -&gt; bool\n</code></pre>"}, {"location": "API/Core/Bucket.html", "title": "Bucket", "text": ""}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.alloc", "title": "alloc  <code>instance-attribute</code>", "text": "<pre><code>alloc: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.fcst_revenue", "title": "fcst_revenue  <code>instance-attribute</code>", "text": "<pre><code>fcst_revenue: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.force_closed", "title": "force_closed  <code>instance-attribute</code>", "text": "<pre><code>force_closed: bool\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.forecast", "title": "forecast  <code>instance-attribute</code>", "text": "<pre><code>forecast: Forecast\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.protection", "title": "protection  <code>instance-attribute</code>", "text": "<pre><code>protection: int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.untruncated_demand", "title": "untruncated_demand  <code>instance-attribute</code>", "text": "<pre><code>untruncated_demand: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    name: str,\n    alloc: float = 0,\n    price: float = 0,\n    sold: float = 0,\n    revenue: float = 0,\n    fcst_mean: float = 0,\n    fcst_std_dev: float = 0,\n    *,\n    history: History | dict | None = None,\n)\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.capture_history", "title": "capture_history", "text": "<pre><code>capture_history(dcp_index: int)\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.get_history_closed", "title": "get_history_closed", "text": "<pre><code>get_history_closed(period: int, dcp_index: int) -&gt; float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.get_history_demand", "title": "get_history_demand", "text": "<pre><code>get_history_demand(period: int, dcp_index: int) -&gt; float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.get_history_num_dcp", "title": "get_history_num_dcp", "text": "<pre><code>get_history_num_dcp() -&gt; int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.get_history_num_dep", "title": "get_history_num_dep", "text": "<pre><code>get_history_num_dep() -&gt; int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.get_history_sold", "title": "get_history_sold", "text": "<pre><code>get_history_sold(period: int, dcp_index: int) -&gt; float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.push_history", "title": "push_history", "text": "<pre><code>push_history()\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.set_history_demand", "title": "set_history_demand", "text": "<pre><code>set_history_demand(dcp_index: int, demand: float)\n</code></pre>"}, {"location": "API/Core/Carrier.html", "title": "Carrier", "text": ""}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.ancillaries", "title": "ancillaries  <code>instance-attribute</code>", "text": "<pre><code>ancillaries: Iterator[Ancillary]\n</code></pre> <p>An instance of RmSystem, called at each DCP to do detruncation / forecasting / optimization</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.brand_preference", "title": "brand_preference  <code>instance-attribute</code>", "text": "<pre><code>brand_preference: float\n</code></pre>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.control", "title": "control  <code>instance-attribute</code>", "text": "<pre><code>control: Literal[\n    \"leg\",\n    \"cabin\",\n    \"theft\",\n    \"bp\",\n    \"bp_loose\",\n    \"vn\",\n    \"lft\",\n    \"none\",\n]\n</code></pre> <p>Control method for this carrier.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.cp_algorithm", "title": "cp_algorithm  <code>instance-attribute</code>", "text": "<pre><code>cp_algorithm: Literal['None', 'BP', 'CBC']\n</code></pre>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.cp_bounds", "title": "cp_bounds  <code>instance-attribute</code>", "text": "<pre><code>cp_bounds: float\n</code></pre>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.cp_quantize", "title": "cp_quantize  <code>instance-attribute</code>", "text": "<pre><code>cp_quantize: int\n</code></pre>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.cp_scale", "title": "cp_scale  <code>instance-attribute</code>", "text": "<pre><code>cp_scale: float\n</code></pre>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.frat5", "title": "frat5  <code>instance-attribute</code>", "text": "<pre><code>frat5: Frat5 | None\n</code></pre>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.gt_available_seat_miles", "title": "gt_available_seat_miles  <code>instance-attribute</code>", "text": "<pre><code>gt_available_seat_miles: float\n</code></pre> <p>Grand total ASM, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.gt_cp_revenue", "title": "gt_cp_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_cp_revenue: float\n</code></pre> <p>Grand total of CP revenue</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.gt_demand", "title": "gt_demand  <code>instance-attribute</code>", "text": "<pre><code>gt_demand: int\n</code></pre> <p>Grand total generated demand, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre> <p>Grand total revenue, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.gt_revenue_passenger_miles", "title": "gt_revenue_passenger_miles  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue_passenger_miles: float\n</code></pre> <p>Grand total RPM, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre> <p>Grand total sold, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.load_factor_curve", "title": "load_factor_curve  <code>instance-attribute</code>", "text": "<pre><code>load_factor_curve: Any | None\n</code></pre>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.rm_system", "title": "rm_system  <code>instance-attribute</code>", "text": "<pre><code>rm_system: Any\n</code></pre>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    name: str,\n    control: Literal[\n        \"leg\",\n        \"cabin\",\n        \"theft\",\n        \"bp\",\n        \"bp_loose\",\n        \"vn\",\n        \"none\",\n    ] = \"leg\",\n)\n</code></pre>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.add_ancillary", "title": "add_ancillary", "text": "<pre><code>add_ancillary(anc: Ancillary)\n</code></pre> <p>Add ancillary item, code &amp; price)</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.add_carrier_history", "title": "add_carrier_history", "text": "<pre><code>add_carrier_history(\n    trial: int,\n    sample: int,\n    sold: int,\n    sold_priceable: int,\n    revenue: float,\n) -&gt; None\n</code></pre> <p>Add an item to carrier history.</p> <p>ONLY USED FOR UNIT TESTING</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.get_ancillary_price", "title": "get_ancillary_price", "text": "<pre><code>get_ancillary_price(name: str) -&gt; float\n</code></pre>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.get_ancillary_sold", "title": "get_ancillary_sold", "text": "<pre><code>get_ancillary_sold(name: str) -&gt; int\n</code></pre>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.get_carrier_history", "title": "get_carrier_history", "text": "<pre><code>get_carrier_history() -&gt; list\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html", "title": "Choice Model", "text": ""}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.buffer_threshold", "title": "buffer_threshold  <code>instance-attribute</code>", "text": "<pre><code>buffer_threshold: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.buffer_time_alpha", "title": "buffer_time_alpha  <code>instance-attribute</code>", "text": "<pre><code>buffer_time_alpha: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.buffer_time_beta", "title": "buffer_time_beta  <code>instance-attribute</code>", "text": "<pre><code>buffer_time_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.dwm_tod", "title": "dwm_tod  <code>instance-attribute</code>", "text": "<pre><code>dwm_tod: list[float]\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.elapsed_time_alpha", "title": "elapsed_time_alpha  <code>instance-attribute</code>", "text": "<pre><code>elapsed_time_alpha: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.elapsed_time_beta", "title": "elapsed_time_beta  <code>instance-attribute</code>", "text": "<pre><code>elapsed_time_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.k_factor", "title": "k_factor  <code>instance-attribute</code>", "text": "<pre><code>k_factor: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.path_quality_alpha", "title": "path_quality_alpha  <code>instance-attribute</code>", "text": "<pre><code>path_quality_alpha: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.path_quality_beta", "title": "path_quality_beta  <code>instance-attribute</code>", "text": "<pre><code>path_quality_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.preferred_carrier_alpha", "title": "preferred_carrier_alpha  <code>instance-attribute</code>", "text": "<pre><code>preferred_carrier_alpha: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.preferred_carrier_beta", "title": "preferred_carrier_beta  <code>instance-attribute</code>", "text": "<pre><code>preferred_carrier_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator: Generator\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.replanning_alpha", "title": "replanning_alpha  <code>instance-attribute</code>", "text": "<pre><code>replanning_alpha: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.replanning_beta", "title": "replanning_beta  <code>instance-attribute</code>", "text": "<pre><code>replanning_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.segment", "title": "segment  <code>instance-attribute</code>", "text": "<pre><code>segment: str\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    name: str,\n    type: Literal[\"logit\", \"pods\"],\n    random_generator: Generator | None = None,\n)\n</code></pre> <p>Create a choice model object.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the choice model.</p> </li> <li> <code>type</code>               (<code>Literal['logit', 'pods']</code>)           \u2013            <p>Type of the choice model.</p> </li> <li> <code>random_generator</code>               (<code>Generator</code>, default:                   <code>None</code> )           \u2013            <p>Random number generator.  If not provided, a default generator is used.</p> </li> </ul>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.add_parm", "title": "add_parm", "text": "<pre><code>add_parm(\n    name: str, value: float, value2: float = 0\n) -&gt; None\n</code></pre> <p>Add a parameter value to the choice model</p>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.get_dwm_penalty", "title": "get_dwm_penalty", "text": "<pre><code>get_dwm_penalty(\n    distance: int,\n    startTime: int,\n    endTime: int,\n    path: Path,\n    debug: bool,\n) -&gt; float\n</code></pre> <p>Get DWM penalty - used for Unit Tests</p>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.get_midpoint", "title": "get_midpoint", "text": "<pre><code>get_midpoint(z_val: float) -&gt; float\n</code></pre> <p>Get decision window midpoint - used for Unit Tests</p>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.get_time_disutility", "title": "get_time_disutility", "text": "<pre><code>get_time_disutility(\n    dmd: Demand, path: Path, debug: bool\n) -&gt; float\n</code></pre> <p>Get time (short connection and/or long elapsed) penalty - used for Unit Tests</p>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.get_window", "title": "get_window", "text": "<pre><code>get_window(\n    dmd: Demand, midpoint: int, distance: int, z_val: float\n) -&gt; tuple[int, int]\n</code></pre> <p>Get decision window start &amp; end - used for Unit Tests</p>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.serialize", "title": "serialize", "text": "<pre><code>serialize() -&gt; dict\n</code></pre> <p>Get all parameter values from the choice model.</p>"}, {"location": "API/Core/Demand.html", "title": "Demand", "text": ""}, {"location": "API/Core/Demand.html#passengersim_core.Demand.base_demand", "title": "base_demand  <code>instance-attribute</code>", "text": "<pre><code>base_demand: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.business", "title": "business  <code>instance-attribute</code>", "text": "<pre><code>business: bool\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.curve_number", "title": "curve_number  <code>instance-attribute</code>", "text": "<pre><code>curve_number: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.distance", "title": "distance  <code>instance-attribute</code>", "text": "<pre><code>distance: float\n</code></pre> <p>Market distance.</p> <p>This is a pass-through attribute of the market object.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.fares", "title": "fares  <code>instance-attribute</code>", "text": "<pre><code>fares: Iterator[Fare]\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.generated_demand", "title": "generated_demand  <code>instance-attribute</code>", "text": "<pre><code>generated_demand: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_demand", "title": "gt_demand  <code>instance-attribute</code>", "text": "<pre><code>gt_demand: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_eliminated_chose_nothing", "title": "gt_eliminated_chose_nothing  <code>instance-attribute</code>", "text": "<pre><code>gt_eliminated_chose_nothing: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_eliminated_no_offers", "title": "gt_eliminated_no_offers  <code>instance-attribute</code>", "text": "<pre><code>gt_eliminated_no_offers: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_eliminated_wtp", "title": "gt_eliminated_wtp  <code>instance-attribute</code>", "text": "<pre><code>gt_eliminated_wtp: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.identifier", "title": "identifier  <code>instance-attribute</code>", "text": "<pre><code>identifier: str\n</code></pre> <p>The unique identifier of this demand, in the form of \"orig~dest@segment\".</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.market", "title": "market  <code>instance-attribute</code>", "text": "<pre><code>market: Market\n</code></pre> <p>The market this demand is part of.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.prob_duration", "title": "prob_duration  <code>instance-attribute</code>", "text": "<pre><code>prob_duration: list[float]\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.prob_favored_carrier", "title": "prob_favored_carrier  <code>instance-attribute</code>", "text": "<pre><code>prob_favored_carrier: dict[str, float]\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.prob_saturday_night", "title": "prob_saturday_night  <code>instance-attribute</code>", "text": "<pre><code>prob_saturday_night: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.reference_fare", "title": "reference_fare  <code>instance-attribute</code>", "text": "<pre><code>reference_fare: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.scenario_demand", "title": "scenario_demand  <code>instance-attribute</code>", "text": "<pre><code>scenario_demand: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.segment", "title": "segment  <code>instance-attribute</code>", "text": "<pre><code>segment: str\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.unsold", "title": "unsold  <code>instance-attribute</code>", "text": "<pre><code>unsold: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    orig: str | None = None,\n    dest: str | None = None,\n    segment: str = \"\",\n    base_demand: float = 0,\n    scenario_demand: float = 0,\n    market: Market | None = None,\n)\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_choice_model", "title": "add_choice_model", "text": "<pre><code>add_choice_model(choicemodel: ChoiceModel)\n</code></pre> <p>Add a choice model to this market segment</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_curve", "title": "add_curve", "text": "<pre><code>add_curve(curve: BookingCurve)\n</code></pre> <p>Add a booking curve to this market segment</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_dwm", "title": "add_dwm", "text": "<pre><code>add_dwm(dwm: DecisionWindow)\n</code></pre> <p>Add a DecisionWindow model to this market segment</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_fare", "title": "add_fare", "text": "<pre><code>add_fare(fare: Fare)\n</code></pre> <p>Add a fare to this market segment</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_group_sizes", "title": "add_group_sizes", "text": "<pre><code>add_group_sizes(group_sizes: list[float])\n</code></pre> <p>Group sizes is an array of proportions, i.e [0.5, 0.4, 0.1] has 40% of bookings with 2 passengers</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_path", "title": "add_path", "text": "<pre><code>add_path(path: Path)\n</code></pre> <p>Add an itinerary path to this market segment</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_carrier_revenue", "title": "get_carrier_revenue", "text": "<pre><code>get_carrier_revenue(carrier_code: str)\n</code></pre> <p>Get revenue for the specified carrier code</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_carrier_sold", "title": "get_carrier_sold", "text": "<pre><code>get_carrier_sold(carrier_code: str)\n</code></pre> <p>Get sold for the specified carrier code</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_demand_dcp", "title": "get_demand_dcp", "text": "<pre><code>get_demand_dcp(dcp: int)\n</code></pre> <p>Get demand for the specified DCP</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_min_elapsed_time", "title": "get_min_elapsed_time", "text": "<pre><code>get_min_elapsed_time() -&gt; int\n</code></pre> <p>Find the shortest elapsed time across all paths</p>"}, {"location": "API/Core/Fare.html", "title": "Fare", "text": ""}, {"location": "API/Core/Fare.html#passengersim_core.Fare.adjusted_price", "title": "adjusted_price  <code>instance-attribute</code>", "text": "<pre><code>adjusted_price: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.adv_purch", "title": "adv_purch  <code>instance-attribute</code>", "text": "<pre><code>adv_purch: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.booking_class", "title": "booking_class  <code>instance-attribute</code>", "text": "<pre><code>booking_class: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.cabin", "title": "cabin  <code>instance-attribute</code>", "text": "<pre><code>cabin: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: Carrier | None\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.category", "title": "category  <code>instance-attribute</code>", "text": "<pre><code>category: Any\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.fare_id", "title": "fare_id  <code>instance-attribute</code>", "text": "<pre><code>fare_id: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.price_lower_bound", "title": "price_lower_bound  <code>instance-attribute</code>", "text": "<pre><code>price_lower_bound: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.price_upper_bound", "title": "price_upper_bound  <code>instance-attribute</code>", "text": "<pre><code>price_upper_bound: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.sold_business", "title": "sold_business  <code>instance-attribute</code>", "text": "<pre><code>sold_business: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    carrier: Carrier | None,\n    orig: str,\n    dest: str,\n    booking_class: str,\n    price: float,\n)\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.add_restriction", "title": "add_restriction", "text": "<pre><code>add_restriction(restriction: int) -&gt; None\n</code></pre> <p>Add a restriction code to this Fare.</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.adjust_price", "title": "adjust_price", "text": "<pre><code>adjust_price(dcp_index: int, adjusted_price: float)\n</code></pre> <p>Set the adjusted price.  The dcp_index is only used for tracking and reporting</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_adjusted_by_dcp", "title": "get_adjusted_by_dcp", "text": "<pre><code>get_adjusted_by_dcp(dcp_index: int) -&gt; float\n</code></pre> <p>Return the average adjusted fare for this DCP index.  Will return 0.0 if the DCP index was not found</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_restriction", "title": "get_restriction", "text": "<pre><code>get_restriction(n: int) -&gt; str\n</code></pre> <p>Get the n-th restriction code on this Fare</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_sales_by_dcp", "title": "get_sales_by_dcp", "text": "<pre><code>get_sales_by_dcp(dcp: int) -&gt; int\n</code></pre> <p>Get the sales by specified DCP</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_sales_by_dcp2", "title": "get_sales_by_dcp2", "text": "<pre><code>get_sales_by_dcp2(dcp: int) -&gt; int\n</code></pre> <p>Get the sales by specified DCP</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_sales_by_segment", "title": "get_sales_by_segment", "text": "<pre><code>get_sales_by_segment(seg: str) -&gt; int\n</code></pre> <p>Get the sales by demand segment DCP</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.num_restrictions", "title": "num_restrictions", "text": "<pre><code>num_restrictions() -&gt; int\n</code></pre> <p>How many restrictions do we have on this fare?</p>"}, {"location": "API/Core/Generator.html", "title": "Generator", "text": ""}, {"location": "API/Core/Generator.html#passengersim_core.Generator.bitgenerator", "title": "bitgenerator  <code>instance-attribute</code>", "text": "<pre><code>bitgenerator: BitGenerator\n</code></pre>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.bitgenerator_class", "title": "bitgenerator_class  <code>instance-attribute</code>", "text": "<pre><code>bitgenerator_class: type[BitGenerator]\n</code></pre>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    seed: int | None = None,\n    bitgenerator_class: type[BitGenerator] | None = None,\n)\n</code></pre> <p>Initialize a random number generator.</p> <p>Parameters:</p> <ul> <li> <code>seed</code>               (<code>int or None</code>, default:                   <code>None</code> )           \u2013            <p>For reproducibility, provide a seed.  If no seed is provided, a random seed is provided by the operating system and generally the results will be different every time you reseed.</p> </li> <li> <code>bitgenerator_class</code>               (<code>type[BitGenerator]</code>, default:                   <code>None</code> )           \u2013            <p>This is the class used to create new BitGenerator objects when the seed is reset.</p> </li> </ul>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.get_normal", "title": "get_normal", "text": "<pre><code>get_normal() -&gt; float\n</code></pre> <p>Return a random draw from a standard normal distribution.</p>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.get_uniform", "title": "get_uniform", "text": "<pre><code>get_uniform() -&gt; float\n</code></pre> <p>Return a random draw standard uniform distribution.</p>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.seed", "title": "seed", "text": "<pre><code>seed(seed: int | list[int] | None) -&gt; None\n</code></pre> <p>Reseed the random bit generator.</p>"}, {"location": "API/Core/Leg.html", "title": "Leg", "text": ""}, {"location": "API/Core/Leg.html#passengersim_core.Leg.action_state", "title": "action_state  <code>instance-attribute</code>", "text": "<pre><code>action_state: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.action_timestamp", "title": "action_timestamp  <code>instance-attribute</code>", "text": "<pre><code>action_timestamp: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.arr_time", "title": "arr_time  <code>instance-attribute</code>", "text": "<pre><code>arr_time: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.arr_time_offset", "title": "arr_time_offset  <code>instance-attribute</code>", "text": "<pre><code>arr_time_offset: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.bid_price", "title": "bid_price  <code>instance-attribute</code>", "text": "<pre><code>bid_price: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.bid_price_gradient", "title": "bid_price_gradient  <code>instance-attribute</code>", "text": "<pre><code>bid_price_gradient: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.buckets", "title": "buckets  <code>instance-attribute</code>", "text": "<pre><code>buckets: Iterator[Bucket]\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.cabins", "title": "cabins  <code>instance-attribute</code>", "text": "<pre><code>cabins: Iterator[Cabin]\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.capacity", "title": "capacity  <code>instance-attribute</code>", "text": "<pre><code>capacity: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: Carrier | None\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.dep_time", "title": "dep_time  <code>instance-attribute</code>", "text": "<pre><code>dep_time: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.dep_time_offset", "title": "dep_time_offset  <code>instance-attribute</code>", "text": "<pre><code>dep_time_offset: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.displacement", "title": "displacement  <code>instance-attribute</code>", "text": "<pre><code>displacement: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.distance", "title": "distance  <code>instance-attribute</code>", "text": "<pre><code>distance: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.duration", "title": "duration  <code>instance-attribute</code>", "text": "<pre><code>duration: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.equipment", "title": "equipment  <code>instance-attribute</code>", "text": "<pre><code>equipment: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.flt_no", "title": "flt_no  <code>instance-attribute</code>", "text": "<pre><code>flt_no: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.gt_capacity", "title": "gt_capacity  <code>instance-attribute</code>", "text": "<pre><code>gt_capacity: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.info", "title": "info  <code>instance-attribute</code>", "text": "<pre><code>info: Any\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.leg_id", "title": "leg_id  <code>instance-attribute</code>", "text": "<pre><code>leg_id: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.pathclass_identifiers", "title": "pathclass_identifiers  <code>instance-attribute</code>", "text": "<pre><code>pathclass_identifiers: Iterator[str]\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.q_demand", "title": "q_demand  <code>instance-attribute</code>", "text": "<pre><code>q_demand: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    leg_id: int,\n    carrier: Carrier | None,\n    flt_no: int,\n    orig: str,\n    dest: str,\n    capacity: int = 0,\n    sold: int = 0,\n    duration: int = 0,\n    equipment: str = None,\n    info: Any = None,\n)\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.add_bucket", "title": "add_bucket", "text": "<pre><code>add_bucket(*args: Bucket)\n</code></pre> <p>Add an inventory control bucket to the Leg.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.add_cabin", "title": "add_cabin", "text": "<pre><code>add_cabin(*args: Cabin)\n</code></pre> <p>Add a Cabin to the Leg.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.bucket_number", "title": "bucket_number", "text": "<pre><code>bucket_number(i: int | str) -&gt; Bucket\n</code></pre> <p>Get the bucket from the leg.</p> <p>Parameters:</p> <ul> <li> <code>i</code>               (<code>int or str</code>)           \u2013            <p>If an integer, returns the bucket at this index position from the list of buckets attached to this Leg.  If given as a str, returns the bucket with the indicated booking class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Bucket</code>           \u2013            </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.capture_dcp", "title": "capture_dcp", "text": "<pre><code>capture_dcp(i: int) -&gt; None\n</code></pre> <p>Grab a snapshot of important variables.</p> <p>Parameters:</p> <ul> <li> <code>i</code>               (<code>int</code>)           \u2013            <p>The index of the DCP to capture.</p> </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.compute_forecasts", "title": "compute_forecasts", "text": "<pre><code>compute_forecasts(\n    dcp_index: int,\n    algorithm: str = None,\n    snapshot_instruction: SnapshotInstruction | None = None,\n    recompute: bool = True,\n    alpha: float = 0.15,\n    event_time: int = None,\n    return_vectors: bool = False,\n) -&gt; None | dict[str, ForecastVectors]\n</code></pre> <p>Compute forecasts for the leg and its buckets.</p> <p>Parameters:</p> <ul> <li> <code>dcp_index</code>               (<code>int</code>)           \u2013            <p>The index of the DCP to compute the forecasts for. This is used to limit the computation to only the relevant data; if the DCP index is greater than zero then the forecast is only computed for the DCP(s) at and after this index.</p> </li> <li> <code>algorithm</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the forecast algorithm to use.  This must be provided if recompute is True, otherwise it is ignored.</p> </li> <li> <code>snapshot_instruction</code>               (<code>SnapshotInstruction</code>, default:                   <code>None</code> )           \u2013            <p>If given, this is a snapshot instruction to use for the forecast.</p> </li> <li> <code>recompute</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, recompute the forecast, otherwise use the existing forecast and simply update cached values on the Leg and its buckets to reflect the <code>dcp_index</code>.</p> </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.15</code> )           \u2013            <p>The alpha value to use for exponential smoothing.</p> </li> <li> <code>event_time</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The time of the event that triggered the forecast computation.</p> </li> <li> <code>return_vectors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a dictionary of forecast vectors for each bucket. Primarily used for debugging and testing.</p> </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.emsrb", "title": "emsrb", "text": "<pre><code>emsrb(debug: bool | None)\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.forecast", "title": "forecast", "text": "<pre><code>forecast(\n    dcp_index: int,\n    algorithm: str,\n    snapshot_instruction: SnapshotInstruction | None = None,\n)\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bid_price_array", "title": "get_bid_price_array", "text": "<pre><code>get_bid_price_array() -&gt; ndarray\n</code></pre> <p>Get a copy of the bid price array for the leg.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_auth", "title": "get_bucket_auth", "text": "<pre><code>get_bucket_auth(i: int | str) -&gt; int\n</code></pre> <p>Get the authorization for a bucket attached to this leg.</p> <p>Parameters:</p> <ul> <li> <code>i</code>               (<code>int or str</code>)           \u2013            <p>If an integer, returns the auth of the bucket at this index position from the list of buckets attached to this Leg.  If given as a str, returns the auth of the bucket with the indicated booking class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_fcst_mean", "title": "get_bucket_fcst_mean", "text": "<pre><code>get_bucket_fcst_mean(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the forecast demand for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_fcst_revenue", "title": "get_bucket_fcst_revenue", "text": "<pre><code>get_bucket_fcst_revenue(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the forecast revenue for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_fcst_std_dev", "title": "get_bucket_fcst_std_dev", "text": "<pre><code>get_bucket_fcst_std_dev(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the forecast demand std. dev. for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_revenue", "title": "get_bucket_revenue", "text": "<pre><code>get_bucket_revenue(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the revenue for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_sold", "title": "get_bucket_sold", "text": "<pre><code>get_bucket_sold(i: int | str) -&gt; int\n</code></pre> <p>Get the number of seats sold for a bucket attached to this leg.</p> <p>Parameters:</p> <ul> <li> <code>i</code>               (<code>int or str</code>)           \u2013            <p>If an integer, returns the number of seats sold for the bucket at this index position from the list of buckets attached to this Leg.  If given as a str, returns the number of seats sold for the bucket with the indicated booking class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_cabin", "title": "get_cabin", "text": "<pre><code>get_cabin(i: int) -&gt; Cabin\n</code></pre> <p>Get Cabin by index</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_num_buckets", "title": "get_num_buckets", "text": "<pre><code>get_num_buckets() -&gt; int\n</code></pre> <p>Get the number of buckets attached to this leg.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_num_cabins", "title": "get_num_cabins", "text": "<pre><code>get_num_cabins() -&gt; int\n</code></pre> <p>Get the number of cabins attached to this leg.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.littlewood", "title": "littlewood", "text": "<pre><code>littlewood(\n    mu: float,\n    sigma: float,\n    rev_hi: float,\n    rev_lo: float,\n    cv100: float,\n) -&gt; float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.print_bucket_detail", "title": "print_bucket_detail", "text": "<pre><code>print_bucket_detail() -&gt; None\n</code></pre> <p>Print a bunch of debugging info</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.print_bucket_history", "title": "print_bucket_history", "text": "<pre><code>print_bucket_history()\n</code></pre> <p>Print a bunch of debugging info</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_auth", "title": "set_bucket_auth", "text": "<pre><code>set_bucket_auth(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the authorization for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_fcst_mean", "title": "set_bucket_fcst_mean", "text": "<pre><code>set_bucket_fcst_mean(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the forecast demand for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_fcst_revenue", "title": "set_bucket_fcst_revenue", "text": "<pre><code>set_bucket_fcst_revenue(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the revenue forecast for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_fcst_std_dev", "title": "set_bucket_fcst_std_dev", "text": "<pre><code>set_bucket_fcst_std_dev(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the forecast demand std. dev. for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_revenue", "title": "set_bucket_revenue", "text": "<pre><code>set_bucket_revenue(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the revenue for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_sold", "title": "set_bucket_sold", "text": "<pre><code>set_bucket_sold(bkt_ref: int | str, sold: int)\n</code></pre> <p>Set the seats sold for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.untruncate_demand", "title": "untruncate_demand", "text": "<pre><code>untruncate_demand(\n    dcp_index: int,\n    algorithm: str,\n    snapshot_instruction: SnapshotInstruction | None = None,\n    maxiter: int = 20,\n    tolerance: float = 0.01,\n    pods_initialization: bool = False,\n    minimum_mu: float = 0.01,\n    minimum_sigma: float = 0.1,\n)\n</code></pre> <p>Run the demand untruncation models for this leg and its buckets.</p> <p>Parameters:</p> <ul> <li> <code>dcp_index</code>               (<code>int</code>)           \u2013            <p>The index of the DCP to run the untruncation models for.</p> </li> <li> <code>algorithm</code>               (<code>str</code>)           \u2013            <p>The name of the untruncation algorithm to use.</p> </li> <li> <code>snapshot_instruction</code>               (<code>SnapshotInstruction</code>, default:                   <code>None</code> )           \u2013            <p>If given, this is a snapshot instruction to use for the untruncation</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None or str</code>           \u2013            </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.write_to_sqlite", "title": "write_to_sqlite", "text": "<pre><code>write_to_sqlite(\n    sqlite_pointer: Connection,\n    sim: SimulationEngine,\n    dcp: int,\n)\n</code></pre> <p>Write to leg_bucket_detail.</p>"}, {"location": "API/Core/Path.html", "title": "Path", "text": ""}, {"location": "API/Core/Path.html#passengersim_core.Path.adjusted_at", "title": "adjusted_at  <code>instance-attribute</code>", "text": "<pre><code>adjusted_at: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: Carrier\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.carrier_name", "title": "carrier_name  <code>instance-attribute</code>", "text": "<pre><code>carrier_name: str\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.duration", "title": "duration  <code>instance-attribute</code>", "text": "<pre><code>duration: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.first_flight", "title": "first_flight  <code>instance-attribute</code>", "text": "<pre><code>first_flight: bool\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.gt_sold_priceable", "title": "gt_sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>gt_sold_priceable: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.last_fcst_ts", "title": "last_fcst_ts  <code>instance-attribute</code>", "text": "<pre><code>last_fcst_ts: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.last_flight", "title": "last_flight  <code>instance-attribute</code>", "text": "<pre><code>last_flight: bool\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.market", "title": "market  <code>instance-attribute</code>", "text": "<pre><code>market: Market\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.minimum_conect_time", "title": "minimum_conect_time  <code>instance-attribute</code>", "text": "<pre><code>minimum_conect_time: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.path_quality_index", "title": "path_quality_index  <code>instance-attribute</code>", "text": "<pre><code>path_quality_index: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.pathclasses", "title": "pathclasses  <code>instance-attribute</code>", "text": "<pre><code>pathclasses: Iterator[PathClass]\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.q_forecast", "title": "q_forecast  <code>instance-attribute</code>", "text": "<pre><code>q_forecast: Forecast\n</code></pre> <p>The Q-Forecast object for this Path.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.sold_priceable", "title": "sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>sold_priceable: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    orig: str,\n    dest: str,\n    price: float,\n    carrier: Carrier | None = None,\n)\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.accumulate_forecasts", "title": "accumulate_forecasts", "text": "<pre><code>accumulate_forecasts(dcpIndex: int)\n</code></pre> <p>Adds the path fcst to each leg / bucket</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.accumulate_forecasts_vn", "title": "accumulate_forecasts_vn", "text": "<pre><code>accumulate_forecasts_vn()\n</code></pre> <p>Adds the path fcst to each leg / bucket, using the Virtual Nesting mapping</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_booking_class", "title": "add_booking_class", "text": "<pre><code>add_booking_class(booking_class: str)\n</code></pre> <p>Add a booking class to this Path</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_carrier", "title": "add_carrier", "text": "<pre><code>add_carrier(carrier: Carrier) -&gt; None\n</code></pre> <p>Add a Carrier to this Path.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_leg", "title": "add_leg", "text": "<pre><code>add_leg(leg: Leg) -&gt; None\n</code></pre> <p>Add a leg to this Path.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_path_class", "title": "add_path_class", "text": "<pre><code>add_path_class(path_class: PathClass)\n</code></pre> <p>Add a path class to this Path</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.adjust_forecasts", "title": "adjust_forecasts", "text": "<pre><code>adjust_forecasts(\n    algorithm: str,\n    current_tf_index: int,\n    current_tf_begin_time: int,\n    current_time: int,\n    current_tf_end_time: int,\n    departure_time: int = 0,\n    snapshot_instruction: SnapshotInstruction | None = None,\n) -&gt; None\n</code></pre> <p>Adjust the forecast for this path and any path-class items it has, using in daily reoptimization</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.allocate_q_demand", "title": "allocate_q_demand", "text": "<pre><code>allocate_q_demand(\n    frat5: Frat5, dcp_index: int, debug: bool\n) -&gt; float\n</code></pre> <p>First step in Q-forecasting</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.capture_dcp", "title": "capture_dcp", "text": "<pre><code>capture_dcp(\n    dcp_index: int, frat5=None, snapshot_instruction=None\n)\n</code></pre> <p>Save relevant information for this DCP</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.check_avail", "title": "check_avail", "text": "<pre><code>check_avail(fare: Fare, num_pax: int, debug: bool | None)\n</code></pre> <p>Is this fare available on the Path?  Used for unit testing</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.compute_fare_adjustments", "title": "compute_fare_adjustments", "text": "<pre><code>compute_fare_adjustments(\n    dcp_index: int,\n    algorithm: Literal[\"mr\", \"ki\"],\n    frat5: Frat5,\n    scale_factor: float = 1.0,\n    snapshot_instruction: SnapshotInstruction | None = None,\n    *,\n    sort_pathclasses: bool = True,\n) -&gt; None\n</code></pre> <p>Compute the fare adjustment for this path and its path-class items.</p> <p>Parameters:</p> <ul> <li> <code>dcp_index</code>               (<code>int</code>)           \u2013            <p>Compute fare adjustments from this DCP to departure.</p> </li> <li> <code>algorithm</code>               (<code>('mr', 'ki')</code>, default:                   <code>'mr'</code> )           \u2013            <p>The algorithm to use for fare adjustment.</p> </li> <li> <code>frat5</code>               (<code>Frat5</code>)           \u2013            <p>Frat5 object to use for Q-forecasting.</p> </li> <li> <code>scale_factor</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Scale factor to apply to fare adjustments.  This overrides the scale factor set in the Frat5 object, which is deprecated.</p> </li> <li> <code>snapshot_instruction</code>               (<code>SnapshotInstruction</code>, default:                   <code>None</code> )           \u2013            <p>If not None, a snapshot of the forecast will be written based on these instructions.</p> </li> <li> <code>sort_pathclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, sort the pathclasses by fare before adjustment.  If the pathclasses are already sorted, this can be set to False to save time.</p> </li> </ul>"}, {"location": "API/Core/Path.html#passengersim_core.Path.compute_forecasts", "title": "compute_forecasts", "text": "<pre><code>compute_forecasts(\n    dcp_index: int,\n    algorithm: str = None,\n    snapshot_instruction: SnapshotInstruction | None = None,\n    recompute: bool = True,\n    *,\n    alpha: float = 0.15,\n    event_time: int | None = None,\n) -&gt; None\n</code></pre> <p>Run the standard forecast models for this Path and its PathClass items.</p> <p>Parameters:</p> <ul> <li> <code>dcp_index</code>               (<code>int</code>)           \u2013            <p>The index of the DCP to compute the forecasts for. This is used to limit the computation to only the relevant data; if the DCP index is greater than zero then the forecast is only computed for the DCP(s) at and after this index.</p> </li> <li> <code>algorithm</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the forecast algorithm to use.  This must be provided if recompute is True, otherwise it is ignored.</p> </li> <li> <code>snapshot_instruction</code>               (<code>SnapshotInstruction</code>, default:                   <code>None</code> )           \u2013            <p>If given, this is a snapshot instruction to use for the forecast.</p> </li> <li> <code>recompute</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, recompute the forecast, otherwise use the existing forecast and simply update cached values on the Leg and its buckets to reflect the <code>dcp_index</code>.</p> </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.15</code> )           \u2013            <p>The alpha value to use for exponential smoothing, this is ignored if <code>algorithm</code> is not 'exp_smoothing'.</p> </li> <li> <code>event_time</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The time of the event that triggered the forecast computation. This is used to when adjusting forecasts within a DCP.</p> </li> </ul>"}, {"location": "API/Core/Path.html#passengersim_core.Path.compute_hybrid_forecasts", "title": "compute_hybrid_forecasts", "text": "<pre><code>compute_hybrid_forecasts(\n    dcp_index: int,\n    algorithm: str,\n    frat5: Frat5,\n    snapshot_instruction: SnapshotInstruction | None = None,\n    recompute: bool = True,\n    pods_init: bool = False,\n    *,\n    alpha: float = 0.15,\n) -&gt; float\n</code></pre> <p>Run the hybrid forecast models for this path and its path-class items.</p> <p>Parameters:</p> <ul> <li> <code>dcp_index</code>               (<code>int</code>)           \u2013            <p>Only compute forecasts only from this DCP to departure.</p> </li> <li> <code>algorithm</code>               (<code>('exp_smoothing', 'additive_pickup')</code>, default:                   <code>'exp_smoothing'</code> )           \u2013            <p>Forecasting algorithm to use.</p> </li> <li> <code>frat5</code>               (<code>Frat5</code>)           \u2013            <p>Frat5 object to use for Q-forecasting.</p> </li> <li> <code>snapshot_instruction</code>               (<code>SnapshotInstruction</code>, default:                   <code>None</code> )           \u2013            <p>If not None, a snapshot of the forecast will be written based on these instructions.</p> </li> <li> <code>max_cap</code>               (<code>float</code>, default:                   <code>10.0</code> )           \u2013            <p>Maximum capacity inflation for Q-forecasting.</p> </li> <li> <code>pods_init</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.15</code> )           \u2013            <p>Smoothing factor for exponential smoothing. This is a keyword-only argument.</p> </li> </ul>"}, {"location": "API/Core/Path.html#passengersim_core.Path.compute_q_equivalent", "title": "compute_q_equivalent", "text": "<pre><code>compute_q_equivalent(\n    frat5: Frat5,\n    dcp_index: int,\n    max_cap: float = 10.0,\n    snapshot_instruction: SnapshotInstruction | None = None,\n) -&gt; float\n</code></pre> <p>First step in Q-forecasting</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_decision_fare", "title": "get_class_decision_fare", "text": "<pre><code>get_class_decision_fare(pc_index: int | str) -&gt; float\n</code></pre> <p>Get the decision fare amount for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_fcst_mean", "title": "get_class_fcst_mean", "text": "<pre><code>get_class_fcst_mean(pc_index: int | str) -&gt; float\n</code></pre> <p>Get the demand forecast for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_sold", "title": "get_class_sold", "text": "<pre><code>get_class_sold(pc_index: int | str) -&gt; int\n</code></pre> <p>Get the number sold for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_std_dev", "title": "get_class_std_dev", "text": "<pre><code>get_class_std_dev(pc_index: int | str) -&gt; float\n</code></pre> <p>Get the demand forecast std. dev. for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_bid_price", "title": "get_leg_bid_price", "text": "<pre><code>get_leg_bid_price(n: int) -&gt; float\n</code></pre> <p>Get the bid price on the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_carrier", "title": "get_leg_carrier", "text": "<pre><code>get_leg_carrier(n: int) -&gt; str\n</code></pre> <p>Get the carrier code for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_dep_time", "title": "get_leg_dep_time", "text": "<pre><code>get_leg_dep_time(n: int) -&gt; int\n</code></pre> <p>Get the departure timestamp code for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_dest", "title": "get_leg_dest", "text": "<pre><code>get_leg_dest(n: int) -&gt; str\n</code></pre> <p>Get the destination airport for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_equipment", "title": "get_leg_equipment", "text": "<pre><code>get_leg_equipment(n: int) -&gt; str\n</code></pre> <p>Get the equipment code for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_fltno", "title": "get_leg_fltno", "text": "<pre><code>get_leg_fltno(n: int) -&gt; int\n</code></pre> <p>Get the flight number for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_orig", "title": "get_leg_orig", "text": "<pre><code>get_leg_orig(n: int) -&gt; str\n</code></pre> <p>Get the origin airport for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_total_bid_price", "title": "get_total_bid_price", "text": "<pre><code>get_total_bid_price() -&gt; float\n</code></pre> <p>Get the total of bid prices on all legs</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_total_distance", "title": "get_total_distance", "text": "<pre><code>get_total_distance() -&gt; float\n</code></pre> <p>Get the total of distances on all legs</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.num_classes", "title": "num_classes", "text": "<pre><code>num_classes() -&gt; int\n</code></pre> <p>Return the number of booking classes that are tracked for this Path</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.num_deps", "title": "num_deps", "text": "<pre><code>num_deps() -&gt; int\n</code></pre> <p>How many historical departures are on this path?</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.num_legs", "title": "num_legs", "text": "<pre><code>num_legs() -&gt; int\n</code></pre> <p>How many legs are on this path?</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.print_class_history", "title": "print_class_history", "text": "<pre><code>print_class_history(path_class_index: int) -&gt; str\n</code></pre> <p>Print some historical data to stdout, mostly for debugging</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.reset_counters", "title": "reset_counters", "text": "<pre><code>reset_counters() -&gt; None\n</code></pre> <p>Reset the sold, revenue, and forecast counters for this path and any path-class items it has</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_decision_fare", "title": "set_class_decision_fare", "text": "<pre><code>set_class_decision_fare(pc_index: int | str, fcst: float)\n</code></pre> <p>Set the decision fare amount for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_fcst_mean", "title": "set_class_fcst_mean", "text": "<pre><code>set_class_fcst_mean(pc_index: int | str, fcst: float)\n</code></pre> <p>Set the demand forecast for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_sold", "title": "set_class_sold", "text": "<pre><code>set_class_sold(pc_index: int | str, sold: int)\n</code></pre> <p>Set the number sold for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_std_dev", "title": "set_class_std_dev", "text": "<pre><code>set_class_std_dev(pc_index: int | str, fcst: float)\n</code></pre> <p>Set the demand forecast std. dev.for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.untruncate_demand", "title": "untruncate_demand", "text": "<pre><code>untruncate_demand(\n    dcp_index: int,\n    algorithm: str,\n    debug: SnapshotInstruction | None = None,\n    maxiter: int = 20,\n    tolerance: float = 0.01,\n    pods_initialization: bool = False,\n    minimum_mu: float = 0.01,\n    minimum_sigma: float = 0.1,\n)\n</code></pre> <p>Run the demand untruncation models for this path and any path-class items it has</p>"}, {"location": "API/Core/PathClass.html", "title": "Path Class", "text": ""}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.adjusted_fare_price", "title": "adjusted_fare_price  <code>instance-attribute</code>", "text": "<pre><code>adjusted_fare_price: tuple[float]\n</code></pre> <p>Adjusted fare by DCP.</p> <p>This will be an empty tuple if fare adjustment is not being computed.</p>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.booking_class", "title": "booking_class  <code>instance-attribute</code>", "text": "<pre><code>booking_class: str\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.decision_fare", "title": "decision_fare  <code>instance-attribute</code>", "text": "<pre><code>decision_fare: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.fare", "title": "fare  <code>instance-attribute</code>", "text": "<pre><code>fare: Fare | None\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.forecast", "title": "forecast  <code>instance-attribute</code>", "text": "<pre><code>forecast: Forecast\n</code></pre> <p>Forecast of total demand.</p> <p>If hybrid forecasting is in use, this forecast includes both priceable and yieldable demand.</p>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.gt_sold_priceable", "title": "gt_sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>gt_sold_priceable: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.identifier", "title": "identifier  <code>instance-attribute</code>", "text": "<pre><code>identifier: str\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.path_id", "title": "path_id  <code>instance-attribute</code>", "text": "<pre><code>path_id: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.q_forecast", "title": "q_forecast  <code>instance-attribute</code>", "text": "<pre><code>q_forecast: Forecast\n</code></pre> <p>Forecast of the class allocation of Q-equivalent priceable demand.</p> <p>The forecasting for Q-equivalent priceable demand is handled at the Path level, and this attribute is used to store the allocated portion of that forecast for this pathclass.</p>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.sold_priceable", "title": "sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>sold_priceable: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.y_forecast", "title": "y_forecast  <code>instance-attribute</code>", "text": "<pre><code>y_forecast: Forecast\n</code></pre> <p>Forecast of yieldable demand.</p> <p>If hybrid forecasting is not in use, this will be the same as <code>forecast</code>.</p>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.__init__", "title": "__init__", "text": "<pre><code>__init__(booking_class: Any, fare: Fare | None = None)\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.add_fare", "title": "add_fare", "text": "<pre><code>add_fare(fare: Fare)\n</code></pre> <p>Add a Fare to the PathClass</p> <p>This method is deprecated, use the <code>fare</code> attribute instead.</p>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.get_indexes", "title": "get_indexes", "text": "<pre><code>get_indexes(leg_number: int) -&gt; None\n</code></pre> <p>Get a VN index for this PathClass.</p>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.set_indexes", "title": "set_indexes", "text": "<pre><code>set_indexes(leg_number: int, index: int) -&gt; None\n</code></pre> <p>Set a VN index for this PathClass.</p>"}, {"location": "API/config/00-configs.html", "title": "Config", "text": ""}, {"location": "API/config/00-configs.html#passengersim.config.base.Config", "title": "Config", "text": "<p>               Bases: <code>YamlConfig</code></p> Source code in <code>passengersim/config/base.py</code> <pre><code>class Config(YamlConfig, extra=\"forbid\"):\n    scenario: str = Field(default_factory=random_label)\n    \"\"\"Name for this scenario.\n\n    The scenario name is helpful when writing different simulations to the same\n    database so you can uniquely identify and query results for a particular\n    scenario.\"\"\"\n\n    simulation_controls: SimulationSettings = SimulationSettings()\n    \"\"\"\n    Controls that apply broadly to the overall simulation.\n\n    See [SimulationSettings][passengersim.config.SimulationSettings] for detailed\n    documentation.\n    \"\"\"\n\n    db: DatabaseConfig = DatabaseConfig()\n    \"\"\"\n    See [passengersim.config.DatabaseConfig][] for detailed documentation.\n    \"\"\"\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _db_is_none(cls, data: Any) -&gt; Any:\n        \"\"\"Setting the database to none creates a null database.\"\"\"\n        if isinstance(data, dict):\n            db = data.get(\"db\", None)\n            if db is None:\n                db = DatabaseConfig(filename=None, write_items=set())\n            data[\"db\"] = db\n        return data\n\n    @field_serializer(\"db\", mode=\"wrap\")\n    @classmethod\n    def _db_to_none(\n        cls, v: DatabaseConfig | None, nxt: SerializerFunctionWrapHandler\n    ) -&gt; dict | None:\n        \"\"\"Serialize the database to None if it is a null database.\"\"\"\n        if v is None:\n            return None\n        if v.filename is None and not v.write_items:\n            return None\n        return nxt(v)\n\n    outputs: OutputConfig = OutputConfig()\n    \"\"\"\n    See [passengersim.config.OutputConfig][] for detailed documentation.\n    \"\"\"\n\n    rm_systems: DictOfNamed[RmSystem] = {}\n    \"\"\"\n    The revenue management systems used by the carriers in this simulation.\n\n    See [RM Systems][rm-systems] for details.\n    \"\"\"\n\n    blf_curves: DictOfNamed[BlfCurve] = {}\n    \"\"\" Booked Load Factor curves\"\"\"\n\n    frat5_curves: DictOfNamed[Frat5Curve] = {}\n    \"\"\" FRAT5 curves are used to model sellup rates in Q-forecasting\"\"\"\n\n    load_factor_curves: DictOfNamed[LoadFactorCurve] = {}\n    \"\"\" FRAT5 curves are used to model sellup rates in Q-forecasting\"\"\"\n\n    todd_curves: DictOfNamed[ToddCurve] = {}\n    \"\"\" Time of Day curves\"\"\"\n\n    choice_models: DictOfNamed[ChoiceModel] = {}\n    \"\"\"Several choice models are programmed behind the scenes.\n\n    The choice_models option allows the user to set the parameters used in the\n    utility model for a particular choice model. There are two choice models\n    currently programmed.\n    1. PODS-like\n    2. MNL, using the Lurkin et. al. paper (needs more testing and pdating)\n\n    Need to explaining more here\"\"\"\n\n    carriers: DictOfNamed[Carrier] = {}\n    \"\"\"A list of carriers.\n\n    One convention is to use Airline1, Airline2, ... to list the carriers in the\n    network.  Another convention is to use IATA industry-standard two-letter airline\n    codes.  See the\n    [IATA code search](https://www.iata.org/en/publications/directories/code-search/)\n    for more information.\"\"\"\n\n    places: DictOfNamed[Place] = {}\n    \"\"\"A list of places (airports, vertiports, other stations).\"\"\"\n\n    circuity_rules: ListOfNamed[CircuityRule] = []\n    \"\"\"Specifies exceptions and the default rule\"\"\"\n\n    classes: list[str] = []\n    \"\"\"A list of fare classes.\n\n    One convention is to use Y0, Y1, ... to label fare classes from the highest\n    fare (Y0) to the lowest fare (Yn).  You can also use Y, B, M, H,... etc.\n    An example of classes is below.\n\n    Example\n    -------\n    ```{yaml}\n    classes:\n      - Y0\n      - Y1\n      - Y2\n      - Y3\n      - Y4\n      - Y5\n    ```\n    \"\"\"\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _classes_are_for_carriers(cls, data: Any) -&gt; Any:\n        \"\"\"Any carrier that doesn't have its own classes gets the global ones.\"\"\"\n        if isinstance(data, dict):\n            carriers = data.get(\"carriers\", {})\n            if isinstance(carriers, list):\n                for carrier in carriers:\n                    if isinstance(carrier, dict) and \"classes\" not in carrier:\n                        carrier[\"classes\"] = data.get(\"classes\", [])\n            else:\n                for carrier in carriers.values():\n                    if isinstance(carrier, dict) and \"classes\" not in carrier:\n                        carrier[\"classes\"] = data.get(\"classes\", [])\n            data[\"carriers\"] = carriers\n        return data\n\n    dcps: list[int] = []\n    \"\"\"A list of DCPs (data collection points).\n\n    The DCPs are given as integers, which represent the number of days\n    before departure.   An example of data collection points is given below.\n    Note that typically as you get closer to day of departure (DCP=0) the number\n    of days between two consecutive DCP periods decreases.  The DCP intervals are\n    shorter because as you get closer to departure, customer arrival rates tend\n    to increase, and it is advantageous to forecast changes in demand for shorter\n    intervals.\n\n    Example\n    -------\n    ```{yaml}\n    dcps: [63, 56, 49, 42, 35, 31, 28, 24, 21, 17, 14, 10, 7, 5, 3, 1]\n    ```\n    \"\"\"\n\n    booking_curves: DictOfNamed[BookingCurve] = {}\n    \"\"\"Booking curves\n\n    The booking curve points typically line up with the DCPs.\n\n    Example\n    -------\n    ```{yaml}\n    booking_curves:\n      - name: c1\n        curve:\n          63: 0.06\n          56: 0.11\n          49: 0.15\n          42: 0.2\n          35: 0.23\n          31: 0.25\n          28: 0.28\n          24: 0.31\n          21: 0.35\n          17: 0.4\n          14: 0.5\n          10: 0.62\n          7: 0.7\n          5: 0.78\n          3: 0.95\n          1: 1.0\n    \"\"\"\n\n    legs: list[Leg] = []\n    demands: list[Demand] = []\n    fares: list[Fare] = []\n    paths: list[Path] = []\n    markets: list[Market] = []\n\n    @property\n    def markets_dict(self):\n        result = {}\n        for m in self.markets:\n            if isinstance(m, dict):\n                m = Market(**m)\n            ident = f\"{m.orig}~{m.dest}\"\n            if ident in result:\n                raise ValueError(f\"Duplicate market {ident}\")\n            result[ident] = m\n        return result\n\n    @model_validator(mode=\"after\")\n    def _fare_ap_restrictions_must_match_dcps(cls, m: Config):\n        \"\"\"AP restrictions on fare can only be invoked at the DCPs.\"\"\"\n        for f in m.fares:\n            if f.advance_purchase != 0 and f.advance_purchase not in m.dcps:\n                raise ValueError(\n                    f\"Advance purchase restriction not aligned with DCP for Fare {f}\"\n                )\n        return m\n\n    @field_validator(\"markets\")\n    @classmethod\n    def _no_duplicate_markets(cls, v: list[Market]) -&gt; list[Market]:\n        \"\"\"Check for duplicate markets.\"\"\"\n        seen = set()\n        for mkt in v:\n            ident = f\"{mkt.orig}~{mkt.dest}\"\n            if ident in seen:\n                raise ValueError(f\"Duplicate market {ident}\")\n            seen.add(ident)\n        return v\n\n    snapshot_filters: list[SnapshotFilter] = []\n\n    @field_validator(\"snapshot_filters\", mode=\"before\")\n    @classmethod\n    def _handle_no_snapshot_filters(cls, v):\n        if v is None:\n            v = []\n        return v\n\n    raw_license_certificate: bytes | None | bool = None\n\n    @field_validator(\"raw_license_certificate\", mode=\"before\")\n    def _handle_license_certificate(cls, v):\n        if isinstance(v, str) and v.startswith(\"-----BEGIN CERTIFICATE-----\"):\n            v = v.encode(\"utf8\")\n        return v\n\n    @property\n    def license_certificate(self):\n        from cryptography.x509 import load_pem_x509_certificate\n\n        if isinstance(self.raw_license_certificate, bytes):\n            return load_pem_x509_certificate(self.raw_license_certificate)\n        elif self.raw_license_certificate is False:\n            return False\n        elif self.raw_license_certificate is None:\n            return None\n        raise ValueError(\"invalid license certificate\")\n\n    @model_validator(mode=\"after\")\n    def _burn_samples(cls, m: Config):\n        \"\"\"burn_samples must be strictly less than samples\"\"\"\n        if m.simulation_controls.burn_samples &gt;= m.simulation_controls.num_samples:\n            raise ValueError(\n                \"burn_samples must be strictly less than samples. \"\n                \"It will default to 100 if you haven't set a value\"\n            )\n        if (\n            m.simulation_controls.burn_samples == 0\n            and m.simulation_controls.num_samples &gt; 10\n        ):\n            raise ValueError(\n                \"to ensure meaningful results, burn_samples may not \"\n                \"be zero when num_samples &gt; 10.\"\n            )\n        return m\n\n    @model_validator(mode=\"after\")\n    def _manual_paths(cls, m: Config):\n        \"\"\"If manual_paths is true, there must be Path items\n        if it's set to false, then there shouldn't be any path items\"\"\"\n        if m.simulation_controls.manual_paths and len(m.paths) == 0:\n            raise ValueError(\n                \"manual_paths is set to true, but no paths found in the input config\"\n            )\n        if not m.simulation_controls.manual_paths and len(m.paths) &gt; 0:\n            raise ValueError(\n                \"manual_paths is set to false, \"\n                \"but paths were specified in the input config\"\n            )\n        return m\n\n    def _load_std_rm_system(self, std_name: str):\n        \"\"\"Load a standard RM system from the standard RM systems file.\n\n        Parameters\n        ----------\n        std_name : str\n            The name of the standard RM system to load.\n        \"\"\"\n        from .standards import standard_rm_systems_raw\n\n        raw_rm_systems = standard_rm_systems_raw()\n        if std_name in raw_rm_systems:\n            rm_sys = Config.model_validate(\n                {\"rm_systems\": {std_name: raw_rm_systems[std_name]}}\n            )\n            self.rm_systems[std_name] = rm_sys.rm_systems[std_name]\n        else:\n            raise KeyError(f\"Unknown standard RM system {std_name}\")\n\n    @classmethod\n    def _carriers_have_rm_systems(cls, m: Config):\n        \"\"\"Check that all carriers have RM systems that have been defined.\"\"\"\n        for carrier in m.carriers.values():\n            if carrier.rm_system not in m.rm_systems:\n                try:\n                    m._load_std_rm_system(carrier.rm_system)\n                except KeyError:\n                    raise ValueError(\n                        f\"Carrier {carrier.name} has unknown \"\n                        f\"RM system {carrier.rm_system}\"\n                    ) from None\n        return m\n\n    def _load_std_frat5(self, std_name: str):\n        \"\"\"Load a standard Frat5 curve from the standard Frat5 file.\n\n        Parameters\n        ----------\n        std_name : str\n            The name of the standard Frat5 curve to load.\n        \"\"\"\n        from passengersim import demo_network\n\n        std_cfg = Config.from_yaml(demo_network(\"standard-frat5.yaml\"))\n        if std_name in std_cfg.frat5_curves:\n            self.frat5_curves[std_name] = std_cfg.frat5_curves[std_name]\n        else:\n            raise KeyError(f\"Unknown standard Frat5 curve {std_name}\")\n\n    @model_validator(mode=\"after\")\n    def _carriers_have_frat5(cls, m: Config):\n        \"\"\"Check that all carriers have defined or null Frat5 curves.\"\"\"\n        cls._carriers_have_rm_systems(m)\n        for carrier in m.carriers.values():\n            # first, if the carrier has no Frat5 curve, see if the RM system has one\n            if not carrier.frat5:\n                rm_system = m.rm_systems[carrier.rm_system]\n                if rm_system.frat5:\n                    carrier.frat5 = rm_system.frat5\n            if carrier.frat5 and carrier.frat5 not in m.frat5_curves:\n                try:\n                    m._load_std_frat5(carrier.frat5)\n                except KeyError:\n                    raise ValueError(\n                        f\"Carrier {carrier.name} has unknown \"\n                        f\"Frat5 curve {carrier.frat5}\"\n                    ) from None\n        return m\n\n    @model_validator(mode=\"after\")\n    def _legs_have_carriers(cls, m: Config):\n        \"\"\"Check that all legs have a carrier that has been defined.\"\"\"\n        for leg in m.legs:\n            if leg.carrier not in m.carriers:\n                raise ValueError(\n                    f\"Carrier for leg {leg.carrier} {leg.fltno} is not defined\"\n                )\n        return m\n\n    @model_validator(mode=\"after\")\n    def _choice_model_todd_curves_exist(cls, m: Config):\n        \"\"\"Check that any TODD curves referenced in Demand objects have been defined.\"\"\"\n        for name, cm in m.choice_models.items():\n            if cm.todd_curve is not None and cm.todd_curve not in m.todd_curves:\n                raise ValueError(\n                    f\"ChoiceModel {name} has unknown TOD Curve {cm.todd_curve}\"\n                )\n        return m\n\n    @model_validator(mode=\"after\")\n    def _choice_model_airline_preferences(cls, m: Config):\n        \"\"\"Check that only one way of inputting airline preference was specified.\"\"\"\n        for _name, cm in m.choice_models.items():\n            a1 = 1 if cm.airline_pref_pods is not None else 0\n            a2 = 1 if cm.airline_pref_hhi is not None else 0\n            a3 = 1 if cm.airline_pref_seat_share is not None else 0\n            if a1 + a2 + a3 &gt; 1:\n                raise ValueError(\n                    f\"ChoiceModel '{cm.name}' has more than one \"\n                    f\"airline preference model specified\"\n                )\n        return m\n\n    @model_validator(mode=\"after\")\n    def _todd_curve_s_vs_replanning(cls, m: Config):\n        \"\"\"Check that only one way of inputting airline preference was specified.\"\"\"\n        for _name, tc in m.todd_curves.items():\n            if tc.replanning is not None and (tc.early_dep is not None or tc.late_arr is not None):\n                raise ValueError(\n                    f\"ToddCurve '{tc.name}' has replanning and early_dep / late_arr specifid,\"\n                    f\" pick one or the other but not both !!!\"\n                )\n        return m\n\n    @model_validator(mode=\"after\")\n    def _choice_set_sampling(cls, m: Config):\n        \"\"\"Ensure there is a limit on the number of observations in a choice set.\n        Don't allow a choice set to be created without a specified limit of observations\n        as unlimited sampling will run out of storage very quickly\"\"\"\n        if (\n            len(m.simulation_controls.capture_choice_set_file) &gt; 0\n            and m.simulation_controls.capture_choice_set_obs is None\n        ):\n            m.simulation_controls.capture_choice_set_obs = 10000\n            warnings.warn(\n                \"capture_choice_set_obs not specified, has been set to 10000\",\n                stacklevel=2,\n            )\n        return m\n\n    @model_validator(mode=\"after\")\n    def _demand_todd_curves_exist(cls, m: Config):\n        \"\"\"Check that any TODD curves referenced in Demand objects have been defined.\"\"\"\n        for dmd in m.demands:\n            if dmd.todd_curve is not None and dmd.todd_curve not in m.todd_curves:\n                raise ValueError(\n                    f\"Demand {dmd.orig}-{dmd.dest}:{dmd.segment} has \"\n                    f\"unknown TOD Curve {dmd.todd_curve}\"\n                )\n        return m\n\n    @model_validator(mode=\"after\")\n    def _booking_curves_match_dcps(cls, m: Config):\n        \"\"\"Check that all booking curves are complete and valid.\"\"\"\n        sorted_dcps = reversed(sorted(m.dcps))\n        for curve in m.booking_curves.values():\n            i = 0\n            for dcp in sorted_dcps:\n                assert (\n                    dcp in curve.curve\n                ), f\"booking curve {curve.name} is missing dcp {dcp}\"\n                assert (\n                    curve.curve[dcp] &gt;= i\n                ), f\"booking curve {curve.name} moves backwards at dcp {dcp}\"\n                i = curve.curve[dcp]\n        return m\n\n    @model_validator(mode=\"after\")\n    def _requested_summaries_have_data(cls, m: Config):\n        \"\"\"Check that requested summary outputs will have the data needed.\"\"\"\n        if \"local_and_flow_yields\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"pathclass_final\", \"pathclass\"}:\n                raise ValueError(\n                    \"the `local_and_flow_yields` report requires recording \"\n                    \"at least `pathclass_final` details in the database\"\n                )\n        if \"bid_price_history\" in m.outputs.reports:\n            if \"leg\" not in m.db.write_items:\n                raise ValueError(\n                    \"the `bid_price_history` report requires recording \"\n                    \"`leg` details in the database\"\n                )\n            if not m.db.store_leg_bid_prices:\n                raise ValueError(\n                    \"the `bid_price_history` report requires recording \"\n                    \"`store_leg_bid_prices` to be True\"\n                )\n        if \"demand_to_come\" in m.outputs.reports:\n            if \"demand\" not in m.db.write_items:\n                raise ValueError(\n                    \"the `demand_to_come` report requires recording \"\n                    \"`demand` details in the database\"\n                )\n        if \"demand_to_come_summary\" in m.outputs.reports:\n            if \"demand\" not in m.db.write_items:\n                raise ValueError(\n                    \"the `demand_to_come_summary` report requires recording \"\n                    \"`demand` details in the database\"\n                )\n        if \"path_forecasts\" in m.outputs.reports:\n            if \"pathclass\" not in m.db.write_items:\n                raise ValueError(\n                    \"the `path_forecasts` report requires recording \"\n                    \"`pathclass` details in the database\"\n                )\n        if \"leg_forecasts\" in m.outputs.reports:\n            if \"bucket\" not in m.db.write_items:\n                raise ValueError(\n                    \"the `leg_forecasts` report requires recording \"\n                    \"`bucket` details in the database\"\n                )\n        if \"bookings_by_timeframe\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"bookings\", \"fare\"}:\n                raise ValueError(\n                    \"the `bookings_by_timeframe` report requires recording \"\n                    \"`fare` or `bookings` details in the database\"\n                )\n        if \"total_demand\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"demand\", \"demand_final\"}:\n                raise ValueError(\n                    \"the `total_demand` report requires recording \"\n                    \"at least `demand_final` details in the database\"\n                )\n        if \"fare_class_mix\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"fare\", \"fare_final\"}:\n                raise ValueError(\n                    \"the `fare_class_mix` report requires recording \"\n                    \"at least `fare_final` details in the database\"\n                )\n        if \"load_factor_distribution\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"leg\", \"leg_final\"}:\n                raise ValueError(\n                    \"the `load_factor_distribution` report requires recording \"\n                    \"at least `leg_final` details in the database\"\n                )\n        if \"edgar\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"edgar\"}:\n                raise ValueError(\n                    \"the 'edgar' forecast accuray report requires recording \"\n                    \"'edgar' details in the database\"\n                )\n        return m\n\n    @model_validator(mode=\"after\")\n    def _bp_controls_are_expected_but_not_set(cls, m: Config):\n        \"\"\"Warn if bid price controls are expected but not set.\"\"\"\n        for rm_system in m.rm_systems.values():\n            if \"dcp\" in rm_system.processes:\n                for step in rm_system.processes[\"dcp\"]:\n                    if isinstance(step, RmStepBase):\n                        try:\n                            req = step.require_availability_control\n                        except AttributeError:\n                            req = None\n                        if (\n                            req is not None\n                            and rm_system.availability_control not in req\n                        ):\n                            raise ValueError(\n                                f\"RM System {rm_system.name} requires \"\n                                f\"availability control {req} for step {step.name}\"\n                            )\n        return m\n\n    __rm_steps_loaded: ClassVar[set[type[RmStepBase]]] = RmStepBase._get_subclasses()\n\n    @classmethod\n    def model_validate(\n        cls,\n        *args,\n        **kwargs,\n    ) -&gt; typing.Any:\n        \"\"\"Validate the passengersim Config inputs.\n\n        This method reloads the Config class to ensure all imported\n        RmSteps are properly registered before validation.\n\n        Parameters\n        ----------\n        obj\n            The object to validate.\n        strict : bool\n            Whether to raise an exception on invalid fields.\n        from_attributes\n            Whether to extract data from object attributes.\n        context\n            Additional context to pass to the validator.\n\n        Raises\n        ------\n        ValidationError\n            If the object could not be validated.\n\n        Returns\n        -------\n        Config\n            The validated model instance.\n        \"\"\"\n        # detect if there are any new RmSteps and reload the Config class\n        # to ensure they are properly registered\n        reloaded_class = cls\n        for k in RmStepBase._get_subclasses():\n            if k not in cls.__rm_steps_loaded:\n                # reload these to refresh for any newly defined RmSteps\n                module_parent = \".\".join(__name__.split(\".\")[:-1])\n                importlib.reload(sys.modules.get(f\"{module_parent}.rm_systems\"))\n                importlib.reload(sys.modules.get(__name__))\n                module = importlib.reload(sys.modules.get(module_parent))\n                reloaded_class = getattr(module, cls.__name__)\n        # `__tracebackhide__` tells pytest and some other tools to omit this\n        # function from tracebacks\n        __tracebackhide__ = True\n        return reloaded_class.__pydantic_validator__.validate_python(*args, **kwargs)\n\n    def model_revalidate(\n        self,\n    ) -&gt; typing.Self:\n        \"\"\"Revalidate the passengersim Config instance.\"\"\"\n        return self.as_reloaded.model_validate(self.model_dump(serialize_as_any=True))\n\n    @classmethod\n    @property\n    def as_reloaded(cls) -&gt; type[Config]:\n        \"\"\"Get the Config class, as most recently reloaded.\"\"\"\n        module_parent = \".\".join(__name__.split(\".\")[:-1])\n        module = sys.modules.get(module_parent)\n        reloaded_class = getattr(module, cls.__name__)\n        return reloaded_class\n\n    @classmethod\n    def instance_check(cls, obj) -&gt; bool:\n        \"\"\"Check if an object is an instance of the Config class.\"\"\"\n        # module_parent = \".\".join(__name__.split(\".\")[:-1])\n        # module = sys.modules.get(module_parent)\n        # reloaded_class = getattr(module, cls.__name__)\n        return isinstance(obj, cls.as_reloaded)\n\n    def find_differences(\n        self,\n        other: Config,\n        *,\n        include: IncEx = None,\n        exclude: IncEx = None,\n    ) -&gt; dict:\n        \"\"\"Find the differences between two Config objects.\"\"\"\n        if exclude is None:\n            exclude = {\n                \"raw_license_certificate\": True,\n                \"outputs\": {\"pickle\", \"excel\", \"html\", \"log_reports\"},\n            }\n        return find_differences(\n            self.model_dump(include=include, exclude=exclude),\n            other.model_dump(include=include, exclude=exclude),\n        )\n\n    def add_output_prefix(\n        self, prefix: pathlib.Path, spool_format: str = \"%Y%m%d-%H%M\"\n    ):\n        \"\"\"\n        Add a prefix directory to all simulation output files.\n        \"\"\"\n        if not isinstance(prefix, pathlib.Path):\n            prefix = pathlib.Path(prefix)\n        if spool_format:\n            proposal = prefix.joinpath(time.strftime(spool_format))\n            n = 0\n            while proposal.exists():\n                n += 1\n                proposal = prefix.joinpath(time.strftime(spool_format) + f\".{n}\")\n            prefix = proposal\n        prefix.mkdir(parents=True)\n\n        if self.db.filename:\n            self.db.filename = prefix.joinpath(self.db.filename)\n        if self.outputs.excel:\n            self.outputs.excel = prefix.joinpath(self.outputs.excel)\n        for sf in self.snapshot_filters:\n            if sf.directory:\n                sf.directory = prefix.joinpath(sf.directory)\n        return prefix\n\n    @model_validator(mode=\"after\")\n    def _attach_distance_to_things_without_it(self):\n        \"\"\"Attach distance in nautical miles to legs that are missing distance.\"\"\"\n        for leg in self.legs:\n            if leg.distance is None:\n                place_o = self.places.get(leg.orig, None)\n                place_d = self.places.get(leg.dest, None)\n                if place_o is not None and place_d is not None:\n                    leg.distance = great_circle(place_o, place_d)\n                if place_o is None:\n                    warnings.warn(f\"No defined place for {leg.orig}\", stacklevel=2)\n                if place_d is None:\n                    warnings.warn(f\"No defined place for {leg.dest}\", stacklevel=2)\n        for dmd in self.demands:\n            if not dmd.distance:\n                place_o = self.places.get(dmd.orig, None)\n                place_d = self.places.get(dmd.dest, None)\n                if place_o is not None and place_d is not None:\n                    dmd.distance = great_circle(place_o, place_d)\n                if place_o is None:\n                    warnings.warn(f\"No defined place for {dmd.orig}\", stacklevel=2)\n                if place_d is None:\n                    warnings.warn(f\"No defined place for {dmd.dest}\", stacklevel=2)\n        return self\n\n    @model_validator(mode=\"after\")\n    def _adjust_times_for_time_zones(self):\n        \"\"\"Adjust arrival/departure times to local time from UTC.\"\"\"\n        for leg in self.legs:\n            # the nominal time is local time but so far got stored as UTC,\n            # so we need to add the time zone offset to be actually local time\n\n            def adjust_time_zone(t, place):\n                if place is not None:\n                    tz = place.time_zone_info\n                    if tz is not None:\n                        # Alan's approach\n                        # It was converted as a local time, so unpack it and\n                        #   create a new datetime in the given TZ\n                        dt = datetime.fromtimestamp(t)  # , tz=timezone.utc)\n                        dt2 = datetime(\n                            dt.year,\n                            dt.month,\n                            dt.day,\n                            dt.hour,\n                            dt.minute,\n                            0,\n                            0,\n                            tzinfo=tz,\n                        )\n                        new_ts = int(dt2.timestamp())\n                        return new_ts, t - new_ts\n                return t, 0\n\n            if not leg.time_adjusted:\n                # if leg.orig == \"DFW\" and leg.dest == \"CLE\":\n                #     pass\n                place_o = self.places.get(leg.orig, None)\n                leg.dep_time, leg.dep_time_offset = adjust_time_zone(\n                    leg.dep_time, place_o\n                )\n                leg.orig_timezone = str(place_o.time_zone_info) if place_o else None\n                place_d = self.places.get(leg.dest, None)\n                leg.arr_time, leg.arr_time_offset = adjust_time_zone(\n                    leg.arr_time, place_d\n                )\n                leg.dest_timezone = str(place_d.time_zone_info) if place_d else None\n                if place_o is None:\n                    warnings.warn(f\"No defined place for {leg.orig}\", stacklevel=2)\n                if place_d is None:\n                    warnings.warn(f\"No defined place for {leg.dest}\", stacklevel=2)\n                leg.time_adjusted = True\n        return self\n\n    @model_validator(mode=\"after\")\n    def _places_exist_for_circuity(cls, cfg: Config):\n        \"\"\"Circuity rules can only refer to airports in the places data.\n        The core code will not crash if the places are missing, but the rules\n        may not work as expected and that'll be a PITA to debug !!!\"\"\"\n        for rule in cfg.circuity_rules:\n            if (\n                rule.carrier != \"\"\n                and rule.carrier is not None\n                and rule.carrier not in cfg.carriers\n            ):\n                raise ValueError(\n                    f\"Circuity rule '{rule.name}' refers to a \"\n                    f\"carrier that isn't specified in carriers\"\n                )\n            if (\n                rule.orig_airport != \"\"\n                and rule.orig_airport is not None\n                and rule.orig_airport not in cfg.places\n            ):\n                raise ValueError(\n                    f\"Circuity rule '{rule.name}' refers to an \"\n                    f\"orig airport that isn't specified in places\"\n                )\n            if (\n                rule.connect_airport != \"\"\n                and rule.connect_airport is not None\n                and rule.connect_airport not in cfg.places\n            ):\n                raise ValueError(\n                    f\"Circuity rule '{rule.name}' refers to a \"\n                    f\"connecting airport that isn't specified in places\"\n                )\n            if (\n                rule.dest_airport != \"\"\n                and rule.dest_airport is not None\n                and rule.dest_airport not in cfg.places\n            ):\n                raise ValueError(\n                    f\"Circuity rule '{rule.name}' refers to a \"\n                    f\"dest airport that isn't specified in places\"\n                )\n\n            # Now we check state codes\n        return cfg\n\n    def __repr__(self):\n        indent = 2\n        x = []\n        i = \" \" * indent\n        for k, v in self:\n            if k in {\"legs\", \"paths\", \"fares\", \"demands\"}:\n                val = f\"&lt;list of {len(v)} {k}&gt;\"\n            elif k in {\"booking_curves\"}:\n                val = f\"&lt;dict of {len(v)} {k}&gt;\"\n            elif isinstance(v, dict):\n                val = repr_dict_with_indent(v, indent)\n            else:\n                try:\n                    val = v.__repr_with_indent__(indent)\n                except AttributeError:\n                    val = repr(v)\n            if \"\\n\" in val:\n                val_lines = val.split(\"\\n\")\n                val = \"\\n  \" + \"\\n  \".join(val_lines)\n            x.append(f\"{i}{k}: {val}\")\n        return \"passengersim.Config:\\n\" + \"\\n\".join(x)\n\n    def __getstate__(self):\n        state = super().__getstate__()\n        # do not save a user's license certificate into the state\n        if \"raw_license_certificate\" in state:\n            state[\"raw_license_certificate\"] = None\n        if \"__dict__\" in state:\n            if \"raw_license_certificate\" in state[\"__dict__\"]:\n                state[\"__dict__\"][\"raw_license_certificate\"] = None\n        return state\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.__rm_steps_loaded", "title": "__rm_steps_loaded  <code>class-attribute</code>", "text": "<pre><code>__rm_steps_loaded: set[type[RmStepBase]] = _get_subclasses()\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.as_reloaded", "title": "as_reloaded  <code>classmethod</code> <code>property</code>", "text": "<pre><code>as_reloaded: type[Config]\n</code></pre> <p>Get the Config class, as most recently reloaded.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.blf_curves", "title": "blf_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>blf_curves: DictOfNamed[BlfCurve] = {}\n</code></pre> <p>Booked Load Factor curves</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.booking_curves", "title": "booking_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>booking_curves: DictOfNamed[BookingCurve] = {}\n</code></pre> <p>Booking curves</p> <p>The booking curve points typically line up with the DCPs.</p> Example <p>```{yaml} booking_curves:   - name: c1     curve:       63: 0.06       56: 0.11       49: 0.15       42: 0.2       35: 0.23       31: 0.25       28: 0.28       24: 0.31       21: 0.35       17: 0.4       14: 0.5       10: 0.62       7: 0.7       5: 0.78       3: 0.95       1: 1.0</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.carriers", "title": "carriers  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carriers: DictOfNamed[Carrier] = {}\n</code></pre> <p>A list of carriers.</p> <p>One convention is to use Airline1, Airline2, ... to list the carriers in the network.  Another convention is to use IATA industry-standard two-letter airline codes.  See the IATA code search for more information.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.choice_models", "title": "choice_models  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>choice_models: DictOfNamed[ChoiceModel] = {}\n</code></pre> <p>Several choice models are programmed behind the scenes.</p> <p>The choice_models option allows the user to set the parameters used in the utility model for a particular choice model. There are two choice models currently programmed. 1. PODS-like 2. MNL, using the Lurkin et. al. paper (needs more testing and pdating)</p> <p>Need to explaining more here</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.circuity_rules", "title": "circuity_rules  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>circuity_rules: ListOfNamed[CircuityRule] = []\n</code></pre> <p>Specifies exceptions and the default rule</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.classes", "title": "classes  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>classes: list[str] = []\n</code></pre> <p>A list of fare classes.</p> <p>One convention is to use Y0, Y1, ... to label fare classes from the highest fare (Y0) to the lowest fare (Yn).  You can also use Y, B, M, H,... etc. An example of classes is below.</p> Example <pre><code>classes:\n  - Y0\n  - Y1\n  - Y2\n  - Y3\n  - Y4\n  - Y5\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.db", "title": "db  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>db: DatabaseConfig = DatabaseConfig()\n</code></pre> <p>See passengersim.config.DatabaseConfig for detailed documentation.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.dcps", "title": "dcps  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcps: list[int] = []\n</code></pre> <p>A list of DCPs (data collection points).</p> <p>The DCPs are given as integers, which represent the number of days before departure.   An example of data collection points is given below. Note that typically as you get closer to day of departure (DCP=0) the number of days between two consecutive DCP periods decreases.  The DCP intervals are shorter because as you get closer to departure, customer arrival rates tend to increase, and it is advantageous to forecast changes in demand for shorter intervals.</p> Example <pre><code>dcps: [63, 56, 49, 42, 35, 31, 28, 24, 21, 17, 14, 10, 7, 5, 3, 1]\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.demands", "title": "demands  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>demands: list[Demand] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.fares", "title": "fares  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>fares: list[Fare] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.frat5_curves", "title": "frat5_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frat5_curves: DictOfNamed[Frat5Curve] = {}\n</code></pre> <p>FRAT5 curves are used to model sellup rates in Q-forecasting</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.legs", "title": "legs  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>legs: list[Leg] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.license_certificate", "title": "license_certificate  <code>property</code>", "text": "<pre><code>license_certificate\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.load_factor_curves", "title": "load_factor_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>load_factor_curves: DictOfNamed[LoadFactorCurve] = {}\n</code></pre> <p>FRAT5 curves are used to model sellup rates in Q-forecasting</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.markets", "title": "markets  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>markets: list[Market] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.markets_dict", "title": "markets_dict  <code>property</code>", "text": "<pre><code>markets_dict\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.outputs", "title": "outputs  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>outputs: OutputConfig = OutputConfig()\n</code></pre> <p>See passengersim.config.OutputConfig for detailed documentation.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.paths", "title": "paths  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>paths: list[Path] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.places", "title": "places  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>places: DictOfNamed[Place] = {}\n</code></pre> <p>A list of places (airports, vertiports, other stations).</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.raw_license_certificate", "title": "raw_license_certificate  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>raw_license_certificate: bytes | None | bool = None\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.rm_systems", "title": "rm_systems  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>rm_systems: DictOfNamed[RmSystem] = {}\n</code></pre> <p>The revenue management systems used by the carriers in this simulation.</p> <p>See RM Systems for details.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.scenario", "title": "scenario  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>scenario: str = Field(default_factory=random_label)\n</code></pre> <p>Name for this scenario.</p> <p>The scenario name is helpful when writing different simulations to the same database so you can uniquely identify and query results for a particular scenario.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.simulation_controls", "title": "simulation_controls  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>simulation_controls: SimulationSettings = (\n    SimulationSettings()\n)\n</code></pre> <p>Controls that apply broadly to the overall simulation.</p> <p>See SimulationSettings for detailed documentation.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[SnapshotFilter] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.todd_curves", "title": "todd_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>todd_curves: DictOfNamed[ToddCurve] = {}\n</code></pre> <p>Time of Day curves</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.__getstate__", "title": "__getstate__", "text": "<pre><code>__getstate__()\n</code></pre> Source code in <code>passengersim/config/base.py</code> <pre><code>def __getstate__(self):\n    state = super().__getstate__()\n    # do not save a user's license certificate into the state\n    if \"raw_license_certificate\" in state:\n        state[\"raw_license_certificate\"] = None\n    if \"__dict__\" in state:\n        if \"raw_license_certificate\" in state[\"__dict__\"]:\n            state[\"__dict__\"][\"raw_license_certificate\"] = None\n    return state\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.__repr__", "title": "__repr__", "text": "<pre><code>__repr__()\n</code></pre> Source code in <code>passengersim/config/base.py</code> <pre><code>def __repr__(self):\n    indent = 2\n    x = []\n    i = \" \" * indent\n    for k, v in self:\n        if k in {\"legs\", \"paths\", \"fares\", \"demands\"}:\n            val = f\"&lt;list of {len(v)} {k}&gt;\"\n        elif k in {\"booking_curves\"}:\n            val = f\"&lt;dict of {len(v)} {k}&gt;\"\n        elif isinstance(v, dict):\n            val = repr_dict_with_indent(v, indent)\n        else:\n            try:\n                val = v.__repr_with_indent__(indent)\n            except AttributeError:\n                val = repr(v)\n        if \"\\n\" in val:\n            val_lines = val.split(\"\\n\")\n            val = \"\\n  \" + \"\\n  \".join(val_lines)\n        x.append(f\"{i}{k}: {val}\")\n    return \"passengersim.Config:\\n\" + \"\\n\".join(x)\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.add_output_prefix", "title": "add_output_prefix", "text": "<pre><code>add_output_prefix(\n    prefix: Path, spool_format: str = \"%Y%m%d-%H%M\"\n)\n</code></pre> <p>Add a prefix directory to all simulation output files.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>def add_output_prefix(\n    self, prefix: pathlib.Path, spool_format: str = \"%Y%m%d-%H%M\"\n):\n    \"\"\"\n    Add a prefix directory to all simulation output files.\n    \"\"\"\n    if not isinstance(prefix, pathlib.Path):\n        prefix = pathlib.Path(prefix)\n    if spool_format:\n        proposal = prefix.joinpath(time.strftime(spool_format))\n        n = 0\n        while proposal.exists():\n            n += 1\n            proposal = prefix.joinpath(time.strftime(spool_format) + f\".{n}\")\n        prefix = proposal\n    prefix.mkdir(parents=True)\n\n    if self.db.filename:\n        self.db.filename = prefix.joinpath(self.db.filename)\n    if self.outputs.excel:\n        self.outputs.excel = prefix.joinpath(self.outputs.excel)\n    for sf in self.snapshot_filters:\n        if sf.directory:\n            sf.directory = prefix.joinpath(sf.directory)\n    return prefix\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.find_differences", "title": "find_differences", "text": "<pre><code>find_differences(\n    other: Config,\n    *,\n    include: IncEx = None,\n    exclude: IncEx = None,\n) -&gt; dict\n</code></pre> <p>Find the differences between two Config objects.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>def find_differences(\n    self,\n    other: Config,\n    *,\n    include: IncEx = None,\n    exclude: IncEx = None,\n) -&gt; dict:\n    \"\"\"Find the differences between two Config objects.\"\"\"\n    if exclude is None:\n        exclude = {\n            \"raw_license_certificate\": True,\n            \"outputs\": {\"pickle\", \"excel\", \"html\", \"log_reports\"},\n        }\n    return find_differences(\n        self.model_dump(include=include, exclude=exclude),\n        other.model_dump(include=include, exclude=exclude),\n    )\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.instance_check", "title": "instance_check  <code>classmethod</code>", "text": "<pre><code>instance_check(obj) -&gt; bool\n</code></pre> <p>Check if an object is an instance of the Config class.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>@classmethod\ndef instance_check(cls, obj) -&gt; bool:\n    \"\"\"Check if an object is an instance of the Config class.\"\"\"\n    # module_parent = \".\".join(__name__.split(\".\")[:-1])\n    # module = sys.modules.get(module_parent)\n    # reloaded_class = getattr(module, cls.__name__)\n    return isinstance(obj, cls.as_reloaded)\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.model_revalidate", "title": "model_revalidate", "text": "<pre><code>model_revalidate() -&gt; Self\n</code></pre> <p>Revalidate the passengersim Config instance.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>def model_revalidate(\n    self,\n) -&gt; typing.Self:\n    \"\"\"Revalidate the passengersim Config instance.\"\"\"\n    return self.as_reloaded.model_validate(self.model_dump(serialize_as_any=True))\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.model_validate", "title": "model_validate  <code>classmethod</code>", "text": "<pre><code>model_validate(*args, **kwargs) -&gt; Any\n</code></pre> <p>Validate the passengersim Config inputs.</p> <p>This method reloads the Config class to ensure all imported RmSteps are properly registered before validation.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>           \u2013            <p>The object to validate.</p> </li> <li> <code>strict</code>               (<code>bool</code>)           \u2013            <p>Whether to raise an exception on invalid fields.</p> </li> <li> <code>from_attributes</code>           \u2013            <p>Whether to extract data from object attributes.</p> </li> <li> <code>context</code>           \u2013            <p>Additional context to pass to the validator.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValidationError</code>             \u2013            <p>If the object could not be validated.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config</code>           \u2013            <p>The validated model instance.</p> </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    *args,\n    **kwargs,\n) -&gt; typing.Any:\n    \"\"\"Validate the passengersim Config inputs.\n\n    This method reloads the Config class to ensure all imported\n    RmSteps are properly registered before validation.\n\n    Parameters\n    ----------\n    obj\n        The object to validate.\n    strict : bool\n        Whether to raise an exception on invalid fields.\n    from_attributes\n        Whether to extract data from object attributes.\n    context\n        Additional context to pass to the validator.\n\n    Raises\n    ------\n    ValidationError\n        If the object could not be validated.\n\n    Returns\n    -------\n    Config\n        The validated model instance.\n    \"\"\"\n    # detect if there are any new RmSteps and reload the Config class\n    # to ensure they are properly registered\n    reloaded_class = cls\n    for k in RmStepBase._get_subclasses():\n        if k not in cls.__rm_steps_loaded:\n            # reload these to refresh for any newly defined RmSteps\n            module_parent = \".\".join(__name__.split(\".\")[:-1])\n            importlib.reload(sys.modules.get(f\"{module_parent}.rm_systems\"))\n            importlib.reload(sys.modules.get(__name__))\n            module = importlib.reload(sys.modules.get(module_parent))\n            reloaded_class = getattr(module, cls.__name__)\n    # `__tracebackhide__` tells pytest and some other tools to omit this\n    # function from tracebacks\n    __tracebackhide__ = True\n    return reloaded_class.__pydantic_validator__.validate_python(*args, **kwargs)\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.OptionalPath", "title": "OptionalPath", "text": "<p>               Bases: <code>Path</code></p> <p>A pathlib.Path that, if missing, is ignored by the Yaml loader.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>class OptionalPath(pathlib.Path):\n    \"\"\"A pathlib.Path that, if missing, is ignored by the Yaml loader.\"\"\"\n\n    pass\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig", "title": "YamlConfig", "text": "<p>               Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/base.py</code> <pre><code>class YamlConfig(PrettyModel):\n    @classmethod\n    def _load_unformatted_yaml(\n        cls: type[TConfig],\n        filenames: str | pathlib.Path | list[str] | list[pathlib.Path],\n    ) -&gt; addicty.Dict:\n        \"\"\"\n        Read from YAML to an unvalidated addicty.Dict.\n\n        Parameters\n        ----------\n        filenames : path-like or list[path-like]\n            If multiple filenames are provided, they are loaded in order\n            and values with matching keys defined in later files will overwrite\n            the ones found in earlier files.\n\n        Returns\n        -------\n        addicty.Dict\n        \"\"\"\n        if isinstance(filenames, str | bytes | os.PathLike):\n            filenames = [filenames]\n        raw_config = addicty.Dict()\n        for filename in filenames:\n            t = time.time()\n            if isinstance(filename, str) and \"\\n\" in filename:\n                # explicit YAML content cannot have include statements\n                content = addicty.Dict.load(\n                    filename, freeze=False, Loader=yaml.CSafeLoader\n                )\n                raw_config.update(content)\n                continue\n            if not isinstance(filename, pathlib.Path):\n                filename = pathlib.Path(filename)\n            if filename.suffix in (\".pem\", \".crt\", \".cert\"):\n                # license certificate\n                with open(filename, \"rb\") as f:\n                    raw_config.raw_license_certificate = f.read()\n            else:\n                opener = smart_open\n                if filename.parts[0] in {\"https:\", \"http:\", \"s3:\"}:\n                    opener = web_opener\n                    if filename.suffix == \".gz\" or filename.suffix == \".lz4\":\n                        raise NotImplementedError(\n                            \"cannot load compressed files from web yet\"\n                        )\n                if isinstance(filename, OptionalPath) and not filename.exists():\n                    continue\n                with opener(filename) as f:\n                    content = addicty.Dict.load(\n                        f, freeze=False, Loader=yaml.CSafeLoader\n                    )\n                    if content is None:\n                        warnings.warn(\n                            f\"Empty file {filename}\",\n                            skip_file_prefixes=_warn_skips,\n                            stacklevel=1,\n                        )\n                        continue\n                    include = content.pop(\"include\", None)\n                    if include is not None:\n                        if isinstance(include, str):\n                            filename.parent.joinpath(include)\n                            inclusions = [filename.parent.joinpath(include)]\n                        else:\n                            inclusions = [filename.parent.joinpath(i) for i in include]\n                        raw_config.update(cls._load_unformatted_yaml(inclusions))\n                    raw_config.update(content)\n            logger.info(\"loaded config from %s in %.2f secs\", filename, time.time() - t)\n        return raw_config\n\n    @classmethod\n    def from_yaml(\n        cls: type[TConfig],\n        filenames: pathlib.Path | list[pathlib.Path],\n        *,\n        cache_file: pathlib.Path | None = None,\n        on_validation_error: Literal[\"raise\", \"warn\"] = \"raise\",\n    ) -&gt; TConfig | addicty.Dict:\n        \"\"\"\n        Read from YAML.\n\n        Parameters\n        ----------\n        filenames : path-like or list[path-like]\n            If multiple filenames are provided, they are loaded in order\n            and values with matching keys defined in later files will overwrite\n            the ones found in earlier files.\n        cache_file : path-like, optional\n            If provided, the validated config will be cached to this file in\n            binary format using pickle.  If the cache file exists and is\n            newer than the YAML files, the cached config will be loaded\n            instead of reloading and revalidating the YAML files, which can be\n            considerably faster.\n        on_validation_error : {'raise', 'warn'}, default 'raise'\n            Whether to raise an exception or log a warning when a validation\n            error is encountered. If 'warn', the error is logged and the\n            unvalidated raw loaded yaml content (not a Config object) is returned.\n\n        Returns\n        -------\n        Config or addicty.Dict\n        \"\"\"\n        cache_is_outdated = True\n        if cache_file:\n            cache_is_outdated = check_modification_times(filenames, cache_file)\n            if cache_is_outdated:\n                logger.info(\"cache file is outdated, will reload YAML files\")\n        if not cache_file or cache_is_outdated:\n            raw_config = cls._load_unformatted_yaml(filenames)\n            t = time.time()\n            try:\n                result = cls.model_validate(raw_config.to_dict())\n            except ValidationError as e:\n                if on_validation_error == \"raise\":\n                    raise\n                warnings.warn(str(e), stacklevel=2)\n                return raw_config\n            logger.info(\"validated config in %.2f secs\", time.time() - t)\n            if cache_file:\n                t = time.time()\n                serialize_to_file(cache_file, result)\n                logger.info(\"cached config in %.2f secs\", time.time() - t)\n            return result\n        else:\n            t = time.time()\n            result = deserialize_from_file(cache_file)\n            logger.info(\"loaded config from cache in %.2f secs\", time.time() - t)\n            return result\n\n    @classmethod\n    def from_raw_yaml(cls, content: str | bytes) -&gt; Self:\n        \"\"\"\n        Read from raw YAML content.\n\n        Parameters\n        ----------\n        content : str or bytes\n            The YAML content to parse.\n\n        Returns\n        -------\n        Config\n        \"\"\"\n        if isinstance(content, bytes):\n            content = content.decode(\"utf8\")\n        raw_config = addicty.Dict.load(content, freeze=False, Loader=yaml.CSafeLoader)\n        return cls.model_validate(raw_config.to_dict())\n\n    tags: dict[str, Any] = {}\n    \"\"\"Tags that can be used in format strings in the config.\"\"\"\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _parse_format_tags(cls, data: Any) -&gt; Any:\n        \"\"\"Parse format tags in the config.\"\"\"\n        tags = {}\n        if \"tags\" in data:\n            tags.update(data[\"tags\"])\n        if \"scenario\" in data:\n            tags[\"scenario\"] = data[\"scenario\"]\n        tags[\"date_Ymd\"] = time.strftime(\"%Y-%m-%d\")\n        tags[\"time_HM\"] = time.strftime(\"%H%M\")\n\n        def apply_tags(x):\n            if isinstance(x, dict):\n                return {k: apply_tags(v) for k, v in x.items()}\n            if isinstance(x, list):\n                return [apply_tags(i) for i in x]\n            if isinstance(x, str):\n                return x.format(**tags)\n            return x\n\n        return apply_tags(data)\n\n    def to_yaml(\n        self,\n        stream: os.PathLike | io.FileIO | None = None,\n        *,\n        include: IncEx = None,\n        exclude: IncEx = None,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        warnings: bool = True,\n    ) -&gt; None | bytes:\n        \"\"\"\n        Write a config to YAML format.\n\n        Parameters\n        ----------\n        stream : Path-like or File-like, optional\n            Write the results here.  If given as a path, a new file is written\n            at this location, or give a File-like object open for writing.\n        include : list[int | str]\n            A list of fields to include in the output.\n        exclude : list[int | str]\n            A list of fields to exclude from the output.\n        exclude_unset : bool, default False\n            Whether to exclude fields that are unset or None from the output.\n        exclude_defaults : bool, default False\n            Whether to exclude fields that are set to their default value from\n            the output.\n        exclude_none : bool, default False\n            Whether to exclude fields that have a value of `None` from the output.\n        warnings : bool, default True\n            Whether to log warnings when invalid fields are encountered.\n\n        Returns\n        -------\n        bytes or None\n            When no stream is given, the YAML content is returned as bytes,\n            otherwise this method returns nothing.\n        \"\"\"\n\n        def path_to_str(x):\n            if isinstance(x, dict):\n                return {k: path_to_str(v) for k, v in x.items()}\n            if isinstance(x, list):\n                return list(path_to_str(i) for i in x)\n            if isinstance(x, tuple):\n                return list(path_to_str(i) for i in x)\n            if isinstance(x, pathlib.Path):\n                return str(x)\n            else:\n                return x\n\n        y = path_to_str(\n            self.model_dump(\n                include=include,\n                exclude=exclude,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n                warnings=warnings,\n            )\n        )\n        b = yaml.dump(y, encoding=\"utf8\", Dumper=yaml.CSafeDumper)\n        if isinstance(stream, str):\n            stream = pathlib.Path(stream)\n        if isinstance(stream, pathlib.Path):\n            stream.write_bytes(b)\n        elif isinstance(stream, io.RawIOBase):\n            stream.write(b)\n        elif isinstance(stream, io.TextIOBase):\n            stream.write(b.decode())\n        else:\n            return b\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig.tags", "title": "tags  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tags: dict[str, Any] = {}\n</code></pre> <p>Tags that can be used in format strings in the config.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig.from_raw_yaml", "title": "from_raw_yaml  <code>classmethod</code>", "text": "<pre><code>from_raw_yaml(content: str | bytes) -&gt; Self\n</code></pre> <p>Read from raw YAML content.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str or bytes</code>)           \u2013            <p>The YAML content to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config</code>           \u2013            </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>@classmethod\ndef from_raw_yaml(cls, content: str | bytes) -&gt; Self:\n    \"\"\"\n    Read from raw YAML content.\n\n    Parameters\n    ----------\n    content : str or bytes\n        The YAML content to parse.\n\n    Returns\n    -------\n    Config\n    \"\"\"\n    if isinstance(content, bytes):\n        content = content.decode(\"utf8\")\n    raw_config = addicty.Dict.load(content, freeze=False, Loader=yaml.CSafeLoader)\n    return cls.model_validate(raw_config.to_dict())\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig.from_yaml", "title": "from_yaml  <code>classmethod</code>", "text": "<pre><code>from_yaml(\n    filenames: Path | list[Path],\n    *,\n    cache_file: Path | None = None,\n    on_validation_error: Literal[\"raise\", \"warn\"] = \"raise\",\n) -&gt; TConfig | Dict\n</code></pre> <p>Read from YAML.</p> <p>Parameters:</p> <ul> <li> <code>filenames</code>               (<code>path - like or list[path - like]</code>)           \u2013            <p>If multiple filenames are provided, they are loaded in order and values with matching keys defined in later files will overwrite the ones found in earlier files.</p> </li> <li> <code>cache_file</code>               (<code>path - like</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the validated config will be cached to this file in binary format using pickle.  If the cache file exists and is newer than the YAML files, the cached config will be loaded instead of reloading and revalidating the YAML files, which can be considerably faster.</p> </li> <li> <code>on_validation_error</code>               (<code>('raise', 'warn')</code>, default:                   <code>'raise'</code> )           \u2013            <p>Whether to raise an exception or log a warning when a validation error is encountered. If 'warn', the error is logged and the unvalidated raw loaded yaml content (not a Config object) is returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config or Dict</code>           \u2013            </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>@classmethod\ndef from_yaml(\n    cls: type[TConfig],\n    filenames: pathlib.Path | list[pathlib.Path],\n    *,\n    cache_file: pathlib.Path | None = None,\n    on_validation_error: Literal[\"raise\", \"warn\"] = \"raise\",\n) -&gt; TConfig | addicty.Dict:\n    \"\"\"\n    Read from YAML.\n\n    Parameters\n    ----------\n    filenames : path-like or list[path-like]\n        If multiple filenames are provided, they are loaded in order\n        and values with matching keys defined in later files will overwrite\n        the ones found in earlier files.\n    cache_file : path-like, optional\n        If provided, the validated config will be cached to this file in\n        binary format using pickle.  If the cache file exists and is\n        newer than the YAML files, the cached config will be loaded\n        instead of reloading and revalidating the YAML files, which can be\n        considerably faster.\n    on_validation_error : {'raise', 'warn'}, default 'raise'\n        Whether to raise an exception or log a warning when a validation\n        error is encountered. If 'warn', the error is logged and the\n        unvalidated raw loaded yaml content (not a Config object) is returned.\n\n    Returns\n    -------\n    Config or addicty.Dict\n    \"\"\"\n    cache_is_outdated = True\n    if cache_file:\n        cache_is_outdated = check_modification_times(filenames, cache_file)\n        if cache_is_outdated:\n            logger.info(\"cache file is outdated, will reload YAML files\")\n    if not cache_file or cache_is_outdated:\n        raw_config = cls._load_unformatted_yaml(filenames)\n        t = time.time()\n        try:\n            result = cls.model_validate(raw_config.to_dict())\n        except ValidationError as e:\n            if on_validation_error == \"raise\":\n                raise\n            warnings.warn(str(e), stacklevel=2)\n            return raw_config\n        logger.info(\"validated config in %.2f secs\", time.time() - t)\n        if cache_file:\n            t = time.time()\n            serialize_to_file(cache_file, result)\n            logger.info(\"cached config in %.2f secs\", time.time() - t)\n        return result\n    else:\n        t = time.time()\n        result = deserialize_from_file(cache_file)\n        logger.info(\"loaded config from cache in %.2f secs\", time.time() - t)\n        return result\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig.to_yaml", "title": "to_yaml", "text": "<pre><code>to_yaml(\n    stream: PathLike | FileIO | None = None,\n    *,\n    include: IncEx = None,\n    exclude: IncEx = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    warnings: bool = True,\n) -&gt; None | bytes\n</code></pre> <p>Write a config to YAML format.</p> <p>Parameters:</p> <ul> <li> <code>stream</code>               (<code>Path - like or File - like</code>, default:                   <code>None</code> )           \u2013            <p>Write the results here.  If given as a path, a new file is written at this location, or give a File-like object open for writing.</p> </li> <li> <code>include</code>               (<code>list[int | str]</code>, default:                   <code>None</code> )           \u2013            <p>A list of fields to include in the output.</p> </li> <li> <code>exclude</code>               (<code>list[int | str]</code>, default:                   <code>None</code> )           \u2013            <p>A list of fields to exclude from the output.</p> </li> <li> <code>exclude_unset</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to exclude fields that are unset or None from the output.</p> </li> <li> <code>exclude_defaults</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to exclude fields that are set to their default value from the output.</p> </li> <li> <code>exclude_none</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to exclude fields that have a value of <code>None</code> from the output.</p> </li> <li> <code>warnings</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to log warnings when invalid fields are encountered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes or None</code>           \u2013            <p>When no stream is given, the YAML content is returned as bytes, otherwise this method returns nothing.</p> </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>def to_yaml(\n    self,\n    stream: os.PathLike | io.FileIO | None = None,\n    *,\n    include: IncEx = None,\n    exclude: IncEx = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    warnings: bool = True,\n) -&gt; None | bytes:\n    \"\"\"\n    Write a config to YAML format.\n\n    Parameters\n    ----------\n    stream : Path-like or File-like, optional\n        Write the results here.  If given as a path, a new file is written\n        at this location, or give a File-like object open for writing.\n    include : list[int | str]\n        A list of fields to include in the output.\n    exclude : list[int | str]\n        A list of fields to exclude from the output.\n    exclude_unset : bool, default False\n        Whether to exclude fields that are unset or None from the output.\n    exclude_defaults : bool, default False\n        Whether to exclude fields that are set to their default value from\n        the output.\n    exclude_none : bool, default False\n        Whether to exclude fields that have a value of `None` from the output.\n    warnings : bool, default True\n        Whether to log warnings when invalid fields are encountered.\n\n    Returns\n    -------\n    bytes or None\n        When no stream is given, the YAML content is returned as bytes,\n        otherwise this method returns nothing.\n    \"\"\"\n\n    def path_to_str(x):\n        if isinstance(x, dict):\n            return {k: path_to_str(v) for k, v in x.items()}\n        if isinstance(x, list):\n            return list(path_to_str(i) for i in x)\n        if isinstance(x, tuple):\n            return list(path_to_str(i) for i in x)\n        if isinstance(x, pathlib.Path):\n            return str(x)\n        else:\n            return x\n\n    y = path_to_str(\n        self.model_dump(\n            include=include,\n            exclude=exclude,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            warnings=warnings,\n        )\n    )\n    b = yaml.dump(y, encoding=\"utf8\", Dumper=yaml.CSafeDumper)\n    if isinstance(stream, str):\n        stream = pathlib.Path(stream)\n    if isinstance(stream, pathlib.Path):\n        stream.write_bytes(b)\n    elif isinstance(stream, io.RawIOBase):\n        stream.write(b)\n    elif isinstance(stream, io.TextIOBase):\n        stream.write(b.decode())\n    else:\n        return b\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.find_differences", "title": "find_differences", "text": "<pre><code>find_differences(left, right)\n</code></pre> <p>Find the differences between two nested dictionaries.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>def find_differences(left, right):\n    \"\"\"Find the differences between two nested dictionaries.\"\"\"\n    if isinstance(left, dict) and isinstance(right, dict):\n        diff = {}\n        for key in left.keys() | right.keys():\n            if key not in right:\n                diff[key] = \"missing in right\"\n            elif key not in left:\n                diff[key] = \"missing in left\"\n            else:\n                sub_diff = find_differences(left[key], right[key])\n                if sub_diff:\n                    diff[key] = sub_diff\n        return diff\n    if isinstance(left, list) and isinstance(right, list):\n        if len(left) != len(right):\n            return \"different lengths\"\n        diff = {}\n        for i, (left_item, right_item) in enumerate(zip(left, right)):\n            sub_diff = find_differences(left_item, right_item)\n            if sub_diff:\n                diff[i] = sub_diff\n        return diff\n    if isinstance(left, dict) and not isinstance(right, dict):\n        return \"left is dict and right is not\"\n    if isinstance(right, dict) and not isinstance(left, dict):\n        return \"right is dict and left is not\"\n    if isinstance(left, list) and not isinstance(right, list):\n        return \"left is list and right is not\"\n    if isinstance(right, list) and not isinstance(left, list):\n        return \"right is list and left is not\"\n    if left == right:\n        return {}\n    return f\"{left} != {right}\"\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html", "title": "Simulation Controls", "text": ""}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings", "title": "SimulationSettings", "text": "<p>               Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/simulation_controls.py</code> <pre><code>class SimulationSettings(PrettyModel, extra=\"allow\", validate_assignment=True):\n    num_trials: conint(ge=1, le=1000) = 1\n    \"\"\"The overall number of trials to run.\n\n    Each trial is a complete simulation, including burn-in training time as well\n    as study time.  It will have a number of sequentially developed samples, each of\n    which represents one \"typical\" day of travel.\n\n    See [Counting Simulations][counting-simulations] for more details.\n    \"\"\"\n\n    num_samples: conint(ge=1, le=10000) = 600\n    \"\"\"The number of samples to run within each trial.\n\n    Each sample represents one \"typical\" day of travel.\n    See [Counting Simulations][counting-simulations] for more details.\n    \"\"\"\n\n    burn_samples: conint(ge=0, le=10000) = 100\n    \"\"\"The number of samples to burn when starting each trial.\n\n    Burned samples are used to populate a stable history of data to support\n    forecasting and optimization algorithms, but are not used to evaluate\n    performance results.\n\n    See [Counting Simulations][counting-simulations] for more details.\n    \"\"\"\n\n    double_capacity_until: int | None = None\n    \"\"\"\n    Double the capacity on all legs until this sample.\n\n    The extra capacity may reduce the statistical noise of untruncation\n    within the burn period and allow the simulation to achieve a stable\n    steady state faster.  If used, this should be set to a value at least\n    26 below the `burn_samples` value to avoid polluting the results.\n    \"\"\"\n\n    @field_validator(\"double_capacity_until\")\n    @classmethod\n    def _avoid_capacity_pollution(cls, v: int | None, info: ValidationInfo):\n        if v and v &gt;= info.data[\"burn_samples\"] - 25:\n            raise ValueError(\"doubled capacity will pollute results\")\n        return v\n\n    sys_k_factor: confloat(ge=0, le=5.0) = 0.10\n    \"\"\"\n    System-level randomness factor.\n\n    This factor controls the level of correlation in demand levels across the\n    entire system.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    mkt_k_factor: confloat(ge=0, le=5.0) = 0.20\n    \"\"\"\n    Market-level randomness factor.\n\n    This factor controls the level of correlation in demand levels across origin-\n    destination markets.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    pax_type_k_factor: confloat(ge=0, le=5.0) = 0.0\n    \"\"\"\n    Passenger-type randomness factor.\n\n    This factor controls the level of correlation in demand levels across passenger\n    types.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    simple_k_factor: confloat(ge=0, le=5.0) = 0.40\n    \"\"\"\n    Passenger-type randomness factor.\n\n    This factor add uncorrelated variance to every demand.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    tf_k_factor: confloat(ge=0) = 0.1\n    \"\"\"\n    Time frame randomness factor.\n\n    This factor controls the dispersion of bookings over time, given a previously\n    identified level of total demand. See [k-factors]() for more details.\n    \"\"\"\n\n    tot_z_factor: confloat(ge=0, le=100.0) = 2.0\n    \"\"\"\n    Base level demand variance control.\n\n    This factor scales the variance in the amount of total demand for any given\n    market segment.\n\n    See [k-factors][demand-generation-k-factors] for more details.\n    \"\"\"\n\n    tf_z_factor: confloat(ge=0, le=100.0) = 2.0\n    \"\"\"\n    Timeframe demand variance control.\n\n    This factor scales the variance in the allocation of total demand to the\n    various arrival timeframes.\n\n    See [k-factors][demand-generation-k-factors] for more details.\n    \"\"\"\n\n    prorate_revenue: bool = True\n\n    dwm_lite: bool = True\n    \"\"\"\n    Use the \"lite\" decision window model.\n\n    The structure of this model is the same as that use by Boeing.\n    \"\"\"\n\n    max_connect_time: conint(ge=0) = 240\n    \"\"\"\n    Maximum connection time for automatically generated paths.\n\n    Any generated path that has a connection time greater than this value (expressed\n    in minutes) is invalidated.\n    \"\"\"\n\n    disable_ap: bool = False\n    \"\"\"\n    Remove all advance purchase settings used in the simulation.\n\n    This applies to all carriers and all fare products.  If active, this filter\n    is applied to all Fare definitions at the time the Config is loaded into to a\n    Simulation object.\n    \"\"\"\n\n    demand_multiplier: confloat(gt=0) = 1.0\n    \"\"\"\n    Scale all demand by this value.\n\n    Setting to a value other than 1.0 will increase or decrease\n    all demand inputs uniformly by the same multiplicative amount.\n    This is helpful when exploring how simulation results vary\n    when you have \"low demand\" scenarios\n    (e.g, demand_multiplier = 0.8), or \"high demand\" scenarios\n    (e.g., demand multiplier = 1.1).\n    \"\"\"\n\n    capacity_multiplier: confloat(gt=0) = 1.0\n    \"\"\"\n    Scale all capacities by this value.\n\n    Setting to a value other than 1.0 will increase or decrease all capacity inputs\n    uniformly by the same multiplicative amount.\n    Business class and/or first class can be quickly simulated with this option\n    \"\"\"\n\n    manual_paths: bool = False\n    \"\"\"\n    The user has provided explicit paths and connections.\n\n    If set to False, the automatic path generation algorithm is applied.\n    \"\"\"\n\n    use_3seg: bool | None = False\n    generate_3seg: bool | None = False\n    \"\"\"\n    Use the new A* search to build connections, it can create 3seg connects\n\n    \"\"\"\n\n    write_raw_files: bool = False\n\n    random_seed: int | None = None\n    \"\"\"\n    Integer used to control the reproducibility of simulation results.\n\n    A seed is base value used by a pseudo-random generator to generate random\n    numbers. A fixed random seed is used to ensure the same randomness pattern\n    is reproducible and does not change between simulation runs, i.e. allows\n    subsequent runs to be conducted with the same randomness pattern as a\n    previous one. Any value set here will allow results to be repeated.\n\n    The random number generator is re-seeded at the beginning of every sample\n    in every trial with a fixed tuple of three values: this \"global\" random seed,\n    plus the sample number and trial number.  This ensures that partial results\n    are also reproducible: the simulation of sample 234 in trial 2 will be the\n    same regardless of how many samples are in trial 1.\n    \"\"\"\n\n    update_frequency: int | None = None\n\n    controller_time_zone: int | float = -21600\n    \"\"\"\n    The reference time zone for the controller (seconds relative to UTC).\n\n    Data collection points will be trigger at approximately midnight in this time zone.\n\n    This value can be input in hours instead of seconds, any absolute value less\n    than or equal to 12 will be assumed to be hours and scaled to seconds.\n\n    The default value is -6 hours, or US Central Standard Time.\n    \"\"\"\n\n    base_date: str = \"2020-03-01\"\n    \"\"\"\n    The default date used to compute relative times for travel.\n\n    Future enhancements may include multi-day modeling.\n    \"\"\"\n\n    dcp_hour: float = 0.0\n    \"\"\"\n    The hour of the day that the RM recalculation events are triggered.\n\n    If set to zero, the events happen at midnight.  Other values can\n    delay the recalculation into later in the night (or the next day).\n    \"\"\"\n\n    capture_competitor_data: bool = False\n    \"\"\"\n    Turns on the capturing of competitor data.\n\n    This feature captures lowest available fare data captured by market, for potential\n    use in competitive analysis RM strategies.\n    \"\"\"\n\n    capture_choice_set_file: str = \"\"\n    \"\"\"\n    Turns on the capturing of the choice set and writes the data to the specified file\n    \"\"\"\n\n    capture_choice_set_obs: int | None = None\n    \"\"\"\n    If this is set, PassengerSim will randomly sample the ChoiceSet data and output\n    APPROXIMATELY this many choice sets (each will have multiple items and all items\n    for the choice set will be saved and output)\n    \"\"\"\n\n    show_progress_bar: bool = True\n    \"\"\"\n    Show a progress bar while running.\n\n    The progress display requires `rich` is installed.\n    \"\"\"\n\n    # A bunch of debug flags, these are only used for development !!!\n    debug_availability: bool | None = False\n    debug_choice: bool | None = False\n    debug_connections: bool | None = False\n    debug_events: bool | None = False\n    debug_fares: bool | None = False\n    debug_offers: bool | None = False\n    debug_orders: bool | None = False\n\n    @field_validator(\"controller_time_zone\", mode=\"before\")\n    def _time_zone_convert_hours_to_seconds(cls, v):\n        if -12 &lt;= v &lt;= 12:\n            v *= 3600\n        return v\n\n    def reference_epoch(self) -&gt; int:\n        \"\"\"Get the reference travel datetime in unix time.\"\"\"\n        return iso_to_unix(self.base_date) - self.controller_time_zone\n\n    timeframe_demand_allocation: Literal[\"v2\", \"pods\"] = \"v2\"\n    \"\"\"\n    Which algorithm to use for time frame demand allocation.\n    \"\"\"\n\n    allow_unused_restrictions: bool = False\n    \"\"\"\n    Allow restrictions to be defined but not used.\n\n    If set to False, any restriction that is defined as a parameter of a choice\n    model but not present on any fare, or vice versa, will raise a ValueError.\n    Users may override this behavior by setting this parameter to True, which\n    will emit a warning instead of an error.\n    \"\"\"\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.allow_unused_restrictions", "title": "allow_unused_restrictions  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>allow_unused_restrictions: bool = False\n</code></pre> <p>Allow restrictions to be defined but not used.</p> <p>If set to False, any restriction that is defined as a parameter of a choice model but not present on any fare, or vice versa, will raise a ValueError. Users may override this behavior by setting this parameter to True, which will emit a warning instead of an error.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.base_date", "title": "base_date  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>base_date: str = '2020-03-01'\n</code></pre> <p>The default date used to compute relative times for travel.</p> <p>Future enhancements may include multi-day modeling.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.burn_samples", "title": "burn_samples  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>burn_samples: conint(ge=0, le=10000) = 100\n</code></pre> <p>The number of samples to burn when starting each trial.</p> <p>Burned samples are used to populate a stable history of data to support forecasting and optimization algorithms, but are not used to evaluate performance results.</p> <p>See Counting Simulations for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.capacity_multiplier", "title": "capacity_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>capacity_multiplier: confloat(gt=0) = 1.0\n</code></pre> <p>Scale all capacities by this value.</p> <p>Setting to a value other than 1.0 will increase or decrease all capacity inputs uniformly by the same multiplicative amount. Business class and/or first class can be quickly simulated with this option</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.capture_choice_set_file", "title": "capture_choice_set_file  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>capture_choice_set_file: str = ''\n</code></pre> <p>Turns on the capturing of the choice set and writes the data to the specified file</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.capture_choice_set_obs", "title": "capture_choice_set_obs  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>capture_choice_set_obs: int | None = None\n</code></pre> <p>If this is set, PassengerSim will randomly sample the ChoiceSet data and output APPROXIMATELY this many choice sets (each will have multiple items and all items for the choice set will be saved and output)</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.capture_competitor_data", "title": "capture_competitor_data  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>capture_competitor_data: bool = False\n</code></pre> <p>Turns on the capturing of competitor data.</p> <p>This feature captures lowest available fare data captured by market, for potential use in competitive analysis RM strategies.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.controller_time_zone", "title": "controller_time_zone  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>controller_time_zone: int | float = -21600\n</code></pre> <p>The reference time zone for the controller (seconds relative to UTC).</p> <p>Data collection points will be trigger at approximately midnight in this time zone.</p> <p>This value can be input in hours instead of seconds, any absolute value less than or equal to 12 will be assumed to be hours and scaled to seconds.</p> <p>The default value is -6 hours, or US Central Standard Time.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.dcp_hour", "title": "dcp_hour  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcp_hour: float = 0.0\n</code></pre> <p>The hour of the day that the RM recalculation events are triggered.</p> <p>If set to zero, the events happen at midnight.  Other values can delay the recalculation into later in the night (or the next day).</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.demand_multiplier", "title": "demand_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>demand_multiplier: confloat(gt=0) = 1.0\n</code></pre> <p>Scale all demand by this value.</p> <p>Setting to a value other than 1.0 will increase or decrease all demand inputs uniformly by the same multiplicative amount. This is helpful when exploring how simulation results vary when you have \"low demand\" scenarios (e.g, demand_multiplier = 0.8), or \"high demand\" scenarios (e.g., demand multiplier = 1.1).</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.disable_ap", "title": "disable_ap  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>disable_ap: bool = False\n</code></pre> <p>Remove all advance purchase settings used in the simulation.</p> <p>This applies to all carriers and all fare products.  If active, this filter is applied to all Fare definitions at the time the Config is loaded into to a Simulation object.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.double_capacity_until", "title": "double_capacity_until  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>double_capacity_until: int | None = None\n</code></pre> <p>Double the capacity on all legs until this sample.</p> <p>The extra capacity may reduce the statistical noise of untruncation within the burn period and allow the simulation to achieve a stable steady state faster.  If used, this should be set to a value at least 26 below the <code>burn_samples</code> value to avoid polluting the results.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.dwm_lite", "title": "dwm_lite  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dwm_lite: bool = True\n</code></pre> <p>Use the \"lite\" decision window model.</p> <p>The structure of this model is the same as that use by Boeing.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.generate_3seg", "title": "generate_3seg  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>generate_3seg: bool | None = False\n</code></pre> <p>Use the new A* search to build connections, it can create 3seg connects</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.manual_paths", "title": "manual_paths  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>manual_paths: bool = False\n</code></pre> <p>The user has provided explicit paths and connections.</p> <p>If set to False, the automatic path generation algorithm is applied.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.max_connect_time", "title": "max_connect_time  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>max_connect_time: conint(ge=0) = 240\n</code></pre> <p>Maximum connection time for automatically generated paths.</p> <p>Any generated path that has a connection time greater than this value (expressed in minutes) is invalidated.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.mkt_k_factor", "title": "mkt_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>mkt_k_factor: confloat(ge=0, le=5.0) = 0.2\n</code></pre> <p>Market-level randomness factor.</p> <p>This factor controls the level of correlation in demand levels across origin- destination markets.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.num_samples", "title": "num_samples  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>num_samples: conint(ge=1, le=10000) = 600\n</code></pre> <p>The number of samples to run within each trial.</p> <p>Each sample represents one \"typical\" day of travel. See Counting Simulations for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.num_trials", "title": "num_trials  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>num_trials: conint(ge=1, le=1000) = 1\n</code></pre> <p>The overall number of trials to run.</p> <p>Each trial is a complete simulation, including burn-in training time as well as study time.  It will have a number of sequentially developed samples, each of which represents one \"typical\" day of travel.</p> <p>See Counting Simulations for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.pax_type_k_factor", "title": "pax_type_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>pax_type_k_factor: confloat(ge=0, le=5.0) = 0.0\n</code></pre> <p>Passenger-type randomness factor.</p> <p>This factor controls the level of correlation in demand levels across passenger types.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.prorate_revenue", "title": "prorate_revenue  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>prorate_revenue: bool = True\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.random_seed", "title": "random_seed  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>random_seed: int | None = None\n</code></pre> <p>Integer used to control the reproducibility of simulation results.</p> <p>A seed is base value used by a pseudo-random generator to generate random numbers. A fixed random seed is used to ensure the same randomness pattern is reproducible and does not change between simulation runs, i.e. allows subsequent runs to be conducted with the same randomness pattern as a previous one. Any value set here will allow results to be repeated.</p> <p>The random number generator is re-seeded at the beginning of every sample in every trial with a fixed tuple of three values: this \"global\" random seed, plus the sample number and trial number.  This ensures that partial results are also reproducible: the simulation of sample 234 in trial 2 will be the same regardless of how many samples are in trial 1.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.show_progress_bar", "title": "show_progress_bar  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>show_progress_bar: bool = True\n</code></pre> <p>Show a progress bar while running.</p> <p>The progress display requires <code>rich</code> is installed.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.simple_k_factor", "title": "simple_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>simple_k_factor: confloat(ge=0, le=5.0) = 0.4\n</code></pre> <p>Passenger-type randomness factor.</p> <p>This factor add uncorrelated variance to every demand.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.sys_k_factor", "title": "sys_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>sys_k_factor: confloat(ge=0, le=5.0) = 0.1\n</code></pre> <p>System-level randomness factor.</p> <p>This factor controls the level of correlation in demand levels across the entire system.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.tf_k_factor", "title": "tf_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tf_k_factor: confloat(ge=0) = 0.1\n</code></pre> <p>Time frame randomness factor.</p> <p>This factor controls the dispersion of bookings over time, given a previously identified level of total demand. See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.tf_z_factor", "title": "tf_z_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tf_z_factor: confloat(ge=0, le=100.0) = 2.0\n</code></pre> <p>Timeframe demand variance control.</p> <p>This factor scales the variance in the allocation of total demand to the various arrival timeframes.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.timeframe_demand_allocation", "title": "timeframe_demand_allocation  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>timeframe_demand_allocation: Literal['v2', 'pods'] = 'v2'\n</code></pre> <p>Which algorithm to use for time frame demand allocation.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.tot_z_factor", "title": "tot_z_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tot_z_factor: confloat(ge=0, le=100.0) = 2.0\n</code></pre> <p>Base level demand variance control.</p> <p>This factor scales the variance in the amount of total demand for any given market segment.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.update_frequency", "title": "update_frequency  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>update_frequency: int | None = None\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.use_3seg", "title": "use_3seg  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>use_3seg: bool | None = False\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.write_raw_files", "title": "write_raw_files  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>write_raw_files: bool = False\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.reference_epoch", "title": "reference_epoch", "text": "<pre><code>reference_epoch() -&gt; int\n</code></pre> <p>Get the reference travel datetime in unix time.</p> Source code in <code>passengersim/config/simulation_controls.py</code> <pre><code>def reference_epoch(self) -&gt; int:\n    \"\"\"Get the reference travel datetime in unix time.\"\"\"\n    return iso_to_unix(self.base_date) - self.controller_time_zone\n</code></pre>"}, {"location": "API/config/blf_curves.html", "title": "Booked Load Factor Curves", "text": ""}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve", "title": "BlfCurve", "text": "<p>               Bases: <code>PrettyModel</code></p> <p>Define a Booked Load Factor Curve. Used for UserAction.</p> Source code in <code>passengersim/config/blf_curves.py</code> <pre><code>class BlfCurve(PrettyModel, extra=\"forbid\"):\n    \"\"\"Define a Booked Load Factor Curve. Used for UserAction.\"\"\"\n\n    name: str = \"???\"\n    type: str\n    min_distance: int = 0\n    max_distance: int = 25000\n    min_duration: float = 0.0\n    max_duration: float = 25.0\n    k_factor: float = 3.0\n    curve: dict[int, float] | list[float] = None\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.curve", "title": "curve  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>curve: dict[int, float] | list[float] = None\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.k_factor", "title": "k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>k_factor: float = 3.0\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.max_distance", "title": "max_distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>max_distance: int = 25000\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.max_duration", "title": "max_duration  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>max_duration: float = 25.0\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.min_distance", "title": "min_distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>min_distance: int = 0\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.min_duration", "title": "min_duration  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>min_duration: float = 0.0\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.name", "title": "name  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>name: str = '???'\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.type", "title": "type  <code>instance-attribute</code>", "text": "<pre><code>type: str\n</code></pre>"}, {"location": "API/config/booking_curves.html", "title": "Booking Curves", "text": ""}, {"location": "API/config/booking_curves.html#passengersim.config.booking_curves.BookingCurve", "title": "BookingCurve", "text": "<p>               Bases: <code>Named</code></p> <p>A mathematical description of the relative arrival rate of customers over time.</p> Source code in <code>passengersim/config/booking_curves.py</code> <pre><code>class BookingCurve(Named, extra=\"forbid\"):\n    \"\"\"\n    A mathematical description of the relative arrival rate of customers over time.\n    \"\"\"\n\n    curve: dict[int, float]\n    \"\"\"Define a booking curve.\n\n    For a given customer type, the booking curve gives the cumulative fraction\n    of those customers who are expected to have already \"arrived\" at any given\n    data collection point (DCP / days_prior to departure).\n    An \"arriving\" customer is one who is interested\n    in booking, but may or may not actually purchase a travel product from one\n    of the carriers, depending on the availability of products at the time of their\n    arrival.\n\n    The values (cumulative fraction of customers arriving) should increase\n    monotonically as the keys (days_prior, e.g. days to departure) decrease.\n\n    Example\n    -------\n    ```{yaml}\n    - name: business\n      curve:\n        63: 0.01\n        56: 0.02\n        49: 0.05\n        42: 0.13\n        35: 0.19\n        31: 0.23\n        28: 0.29\n        24: 0.35\n        21: 0.45\n        17: 0.54\n        14: 0.67\n        10: 0.79\n        7: 0.86\n        5: 0.91\n        3: 0.96\n        1: 1.0\n    ```\n    \"\"\"\n\n    @field_validator(\"curve\")\n    def _booking_curves_accumulate(cls, v: dict[int, float], info: ValidationInfo):\n        \"\"\"Check that all curve values do not decrease as DCP keys decrease.\"\"\"\n        sorted_days_prior = reversed(sorted(v.keys()))\n        i = 0\n        for days_prior in sorted_days_prior:\n            assert (\n                v[days_prior] &gt;= i\n            ), f\"booking curve {info.data['name']} moves backwards at dcp {days_prior}\"\n            i = v[days_prior]\n        return v\n</code></pre>"}, {"location": "API/config/booking_curves.html#passengersim.config.booking_curves.BookingCurve.curve", "title": "curve  <code>instance-attribute</code>", "text": "<pre><code>curve: dict[int, float]\n</code></pre> <p>Define a booking curve.</p> <p>For a given customer type, the booking curve gives the cumulative fraction of those customers who are expected to have already \"arrived\" at any given data collection point (DCP / days_prior to departure). An \"arriving\" customer is one who is interested in booking, but may or may not actually purchase a travel product from one of the carriers, depending on the availability of products at the time of their arrival.</p> <p>The values (cumulative fraction of customers arriving) should increase monotonically as the keys (days_prior, e.g. days to departure) decrease.</p> Example <pre><code>- name: business\n  curve:\n    63: 0.01\n    56: 0.02\n    49: 0.05\n    42: 0.13\n    35: 0.19\n    31: 0.23\n    28: 0.29\n    24: 0.35\n    21: 0.45\n    17: 0.54\n    14: 0.67\n    10: 0.79\n    7: 0.86\n    5: 0.91\n    3: 0.96\n    1: 1.0\n</code></pre>"}, {"location": "API/config/carriers.html", "title": "Carriers", "text": ""}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier", "title": "Carrier", "text": "<p>               Bases: <code>Named</code></p> <p>Configuration for passengersim.Carrier object.</p> Source code in <code>passengersim/config/carriers.py</code> <pre><code>class Carrier(Named, extra=\"forbid\"):\n    \"\"\"Configuration for passengersim.Carrier object.\"\"\"\n\n    rm_system: str\n    \"\"\"Name of the revenue management system used by this carrier.\"\"\"\n\n    control: str = \"\"\n    \"\"\"Deprecated.  No effect\"\"\"\n\n    cp_algorithm: str | None = \"None\"\n    \"\"\"Used to select continuous pricing\"\"\"\n\n    cp_quantize: int | None = 0\n    \"\"\"Controls quantization (rounding) for Continuous Pricing\n       Example: If you set it to 5, the price will be rounded to the nearest $5\"\"\"\n\n    cp_bounds: float = 0.5\n    \"\"\"Controls upper and lower bounds for continuous pricing.\n       Example:  Y1 fare = $400, Y2 fare = $300\n                 The difference is $100, and a 0.25 multiplier will set the lower bound\n                 for Y1 as $375 and the upper bound for Y2 as $325\"\"\"\n\n    cp_scale: float = 1.0\n    \"\"\"Scales the fare modifier, which was computed using WTP\"\"\"\n\n    cp_record: str = \"highest_closed\"\n    \"\"\"Do we record the sale in the highest_closed class, lowest_open or nearest?\"\"\"\n\n    cp_elasticity: dict | None = None\n    \"\"\"Parameters to esimate customer price elasticity for CP\n         - Defaults to being off\n         - {'accuracy': 0.8, 'multiplier': 0.5} will guess 80% accurate and multiply\n             the Frat5 value for *leisure* by 0.5\n         - Other algorithms to come in the future :-) \"\"\"\n\n    frat5: str | None = \"\"\n    \"\"\"Name of the FRAT5 curve to use.\n\n    This is the default that will be applied if not found at a more detailed level.\n    If not specified, the default frat5 from the carrier's RM system is used.\n    \"\"\"\n\n    fare_adjustment_scale: float | None = 1.0\n\n    load_factor_curve: Any | None = None\n    \"\"\"Named Load Factor curve.\n    This is the default that will be applied if not found at a more detailed level\n    \"\"\"\n\n    brand_preference: float | None = 1.0\n    \"\"\"Used for airline preference to give premium airlines a bump\"\"\"\n\n    ancillaries: dict[str, float] | None = {}\n    \"\"\"Specifies ancillaries offered by the carrier, codes are ANC1 .. ANC4\"\"\"\n\n    classes: list[str] | list[tuple[str, str]] = []\n    \"\"\"A list of fare classes.\n\n    This list can be a simple list of fare classes, or a list of 2-tuples where\n    the first element is the fare class and the second element is the cabin.\n\n    One convention is to use Y0, Y1, ... to label fare classes from the highest\n    fare (Y0) to the lowest fare (Yn).  You can also use Y, B, M, H,... etc.\n    An example of classes is below.\n\n    Example\n    -------\n    ```{yaml}\n    classes:\n      - Y0\n      - Y1\n      - Y2\n      - Y3\n      - Y4\n      - Y5\n    ```\n\n    If using cabins, it is reasonable to name the classes in consistent manner,\n    but this is optional, and arbitrary class names are still allowed. All class\n    names should still be unique, and cabin identifiers should be replicated\n    identically for classes that share a cabin.  Thus the list might look like this:\n\n    ```{yaml}\n    classes:\n      - (F0, F)\n      - (F1, F)\n      - (Y0, Y)\n      - (Y1, Y)\n      - (Y2, Y)\n      - (Y3, Y)\n    ```\n    \"\"\"\n\n    truncation_rule: Literal[1, 2, 3] = 3\n    \"\"\"How to handle marking truncation of demand in timeframes.\n\n    If 1, then the demand is marked as truncated if the bucket or pathclass is closed at\n    the DCP that is the beginning of the timeframe.\n\n    If 2, then the demand is marked as truncated if the bucket or pathclass is closed at\n    the DCP that is the end of the timeframe.\n\n    If 3, then the demand is marked as truncated if the bucket or pathclass is closed at\n    either of the DCPs that are at the beginning or the end of the timeframe.\n    \"\"\"\n\n    proration_rule: Literal[\"distance\", \"sqrt_distance\"] = \"distance\"\n    \"\"\"How to prorate revenue to legs and buckets for connecting paths.\n\n    If \"distance\", then the revenue is prorated based on the relatives distance\n    of the legs.  So if the first leg is 100 miles and the second leg is 400 miles,\n    then the first leg gets 20% of the revenue and the second leg gets 80%.\n\n    If \"sqrt_distance\", then the revenue is prorated based on the relative square\n    root of distance of the legs.  So if the first leg is 100 miles and the\n    second leg is 400 miles, then the first leg gets 1/3 of the revenue and the\n    second leg gets 2/3.\n    \"\"\"\n\n    history_length: int = 26\n    \"\"\"The number of samples to keep in the carrier's history buffers.\"\"\"\n</code></pre>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.ancillaries", "title": "ancillaries  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>ancillaries: dict[str, float] | None = {}\n</code></pre> <p>Specifies ancillaries offered by the carrier, codes are ANC1 .. ANC4</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.brand_preference", "title": "brand_preference  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>brand_preference: float | None = 1.0\n</code></pre> <p>Used for airline preference to give premium airlines a bump</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.classes", "title": "classes  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>classes: list[str] | list[tuple[str, str]] = []\n</code></pre> <p>A list of fare classes.</p> <p>This list can be a simple list of fare classes, or a list of 2-tuples where the first element is the fare class and the second element is the cabin.</p> <p>One convention is to use Y0, Y1, ... to label fare classes from the highest fare (Y0) to the lowest fare (Yn).  You can also use Y, B, M, H,... etc. An example of classes is below.</p> Example <pre><code>classes:\n  - Y0\n  - Y1\n  - Y2\n  - Y3\n  - Y4\n  - Y5\n</code></pre> <p>If using cabins, it is reasonable to name the classes in consistent manner, but this is optional, and arbitrary class names are still allowed. All class names should still be unique, and cabin identifiers should be replicated identically for classes that share a cabin.  Thus the list might look like this:</p> <pre><code>classes:\n  - (F0, F)\n  - (F1, F)\n  - (Y0, Y)\n  - (Y1, Y)\n  - (Y2, Y)\n  - (Y3, Y)\n</code></pre>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.control", "title": "control  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>control: str = ''\n</code></pre> <p>Deprecated.  No effect</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.cp_algorithm", "title": "cp_algorithm  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cp_algorithm: str | None = 'None'\n</code></pre> <p>Used to select continuous pricing</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.cp_bounds", "title": "cp_bounds  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cp_bounds: float = 0.5\n</code></pre> <p>Controls upper and lower bounds for continuous pricing. Example:  Y1 fare = $400, Y2 fare = $300           The difference is $100, and a 0.25 multiplier will set the lower bound           for Y1 as $375 and the upper bound for Y2 as $325</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.cp_elasticity", "title": "cp_elasticity  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cp_elasticity: dict | None = None\n</code></pre> <p>Parameters to esimate customer price elasticity for CP - Defaults to being off - {'accuracy': 0.8, 'multiplier': 0.5} will guess 80% accurate and multiply     the Frat5 value for leisure by 0.5 - Other algorithms to come in the future :-)</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.cp_quantize", "title": "cp_quantize  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cp_quantize: int | None = 0\n</code></pre> <p>Controls quantization (rounding) for Continuous Pricing Example: If you set it to 5, the price will be rounded to the nearest $5</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.cp_record", "title": "cp_record  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cp_record: str = 'highest_closed'\n</code></pre> <p>Do we record the sale in the highest_closed class, lowest_open or nearest?</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.cp_scale", "title": "cp_scale  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cp_scale: float = 1.0\n</code></pre> <p>Scales the fare modifier, which was computed using WTP</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.fare_adjustment_scale", "title": "fare_adjustment_scale  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>fare_adjustment_scale: float | None = 1.0\n</code></pre>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.frat5", "title": "frat5  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frat5: str | None = ''\n</code></pre> <p>Name of the FRAT5 curve to use.</p> <p>This is the default that will be applied if not found at a more detailed level. If not specified, the default frat5 from the carrier's RM system is used.</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.history_length", "title": "history_length  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>history_length: int = 26\n</code></pre> <p>The number of samples to keep in the carrier's history buffers.</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.load_factor_curve", "title": "load_factor_curve  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>load_factor_curve: Any | None = None\n</code></pre> <p>Named Load Factor curve. This is the default that will be applied if not found at a more detailed level</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.proration_rule", "title": "proration_rule  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>proration_rule: Literal[\"distance\", \"sqrt_distance\"] = (\n    \"distance\"\n)\n</code></pre> <p>How to prorate revenue to legs and buckets for connecting paths.</p> <p>If \"distance\", then the revenue is prorated based on the relatives distance of the legs.  So if the first leg is 100 miles and the second leg is 400 miles, then the first leg gets 20% of the revenue and the second leg gets 80%.</p> <p>If \"sqrt_distance\", then the revenue is prorated based on the relative square root of distance of the legs.  So if the first leg is 100 miles and the second leg is 400 miles, then the first leg gets 1/3 of the revenue and the second leg gets 2/3.</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.rm_system", "title": "rm_system  <code>instance-attribute</code>", "text": "<pre><code>rm_system: str\n</code></pre> <p>Name of the revenue management system used by this carrier.</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.truncation_rule", "title": "truncation_rule  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>truncation_rule: Literal[1, 2, 3] = 3\n</code></pre> <p>How to handle marking truncation of demand in timeframes.</p> <p>If 1, then the demand is marked as truncated if the bucket or pathclass is closed at the DCP that is the beginning of the timeframe.</p> <p>If 2, then the demand is marked as truncated if the bucket or pathclass is closed at the DCP that is the end of the timeframe.</p> <p>If 3, then the demand is marked as truncated if the bucket or pathclass is closed at either of the DCPs that are at the beginning or the end of the timeframe.</p>"}, {"location": "API/config/choice_model.html", "title": "Choice Models", "text": ""}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.ChoiceModel", "title": "ChoiceModel  <code>module-attribute</code>", "text": "<pre><code>ChoiceModel = Annotated[\n    PodsChoiceModel | LogitChoiceModel,\n    Field(discriminator=\"kind\"),\n]\n</code></pre> <p>Two types of choice models are available in PassengerSim.</p> <p>Use the <code>kind</code> key to select which kind of choice model you wish to parameterize.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.CommonChoiceModel", "title": "CommonChoiceModel", "text": "<p>               Bases: <code>Named</code></p> <p>A common base class for choice models.</p> <p>Defines restrictions and other parameters that are common to all choice models.</p> Source code in <code>passengersim/config/choice_model.py</code> <pre><code>class CommonChoiceModel(Named, extra=\"forbid\"):\n    \"\"\"A common base class for choice models.\n\n    Defines restrictions and other parameters that are common to all\n    choice models.\"\"\"\n\n    restrictions: dict[str, float] | None = None\n\n    @property\n    def r1(self):\n        \"\"\"Restriction 1.\n\n        This is deprecated in favor of the `restrictions` dictionary.\"\"\"\n        return self.restrictions.get(\"r1\", None)\n\n    @r1.setter\n    def r1(self, value: float):\n        self.restrictions[\"r1\"] = value\n\n    @property\n    def r2(self):\n        \"\"\"Restriction 2.\n\n        This is deprecated in favor of the `restrictions` dictionary.\"\"\"\n        return self.restrictions.get(\"r2\", None)\n\n    @r2.setter\n    def r2(self, value: float):\n        self.restrictions[\"r2\"] = value\n\n    @property\n    def r3(self):\n        \"\"\"Restriction 3.\n\n        This is deprecated in favor of the `restrictions` dictionary.\"\"\"\n        return self.restrictions.get(\"r3\", None)\n\n    @r3.setter\n    def r3(self, value: float):\n        self.restrictions[\"r3\"] = value\n\n    @property\n    def r4(self):\n        \"\"\"Restriction 4.\n\n        This is deprecated in favor of the `restrictions` dictionary.\"\"\"\n        return self.restrictions.get(\"r4\", None)\n\n    @r4.setter\n    def r4(self, value: float):\n        self.restrictions[\"r4\"] = value\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _named_restrictions(cls, data: Any) -&gt; Any:\n        restricts = data.get(\"restrictions\", {})\n        if \"r1\" in data:\n            restricts[\"r1\"] = data.pop(\"r1\")\n        if \"r2\" in data:\n            restricts[\"r2\"] = data.pop(\"r2\")\n        if \"r3\" in data:\n            restricts[\"r3\"] = data.pop(\"r3\")\n        if \"r4\" in data:\n            restricts[\"r4\"] = data.pop(\"r4\")\n        data[\"restrictions\"] = restricts\n        return data\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.CommonChoiceModel.r1", "title": "r1  <code>property</code> <code>writable</code>", "text": "<pre><code>r1\n</code></pre> <p>Restriction 1.</p> <p>This is deprecated in favor of the <code>restrictions</code> dictionary.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.CommonChoiceModel.r2", "title": "r2  <code>property</code> <code>writable</code>", "text": "<pre><code>r2\n</code></pre> <p>Restriction 2.</p> <p>This is deprecated in favor of the <code>restrictions</code> dictionary.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.CommonChoiceModel.r3", "title": "r3  <code>property</code> <code>writable</code>", "text": "<pre><code>r3\n</code></pre> <p>Restriction 3.</p> <p>This is deprecated in favor of the <code>restrictions</code> dictionary.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.CommonChoiceModel.r4", "title": "r4  <code>property</code> <code>writable</code>", "text": "<pre><code>r4\n</code></pre> <p>Restriction 4.</p> <p>This is deprecated in favor of the <code>restrictions</code> dictionary.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.CommonChoiceModel.restrictions", "title": "restrictions  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>restrictions: dict[str, float] | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel", "title": "LogitChoiceModel", "text": "<p>               Bases: <code>CommonChoiceModel</code></p> Source code in <code>passengersim/config/choice_model.py</code> <pre><code>class LogitChoiceModel(CommonChoiceModel, extra=\"forbid\"):\n    kind: Literal[\"logit\"]\n\n    emult: float | None = None\n    \"\"\"Using for WTP, a bit of a quick and dirty until we have a better approach\"\"\"\n\n    anc1_relevance: float | None = None\n    anc2_relevance: float | None = None\n    anc3_relevance: float | None = None\n    anc4_relevance: float | None = None\n\n    intercept: float = 0\n    \"\"\"This is the alternative specific constant for the no-purchase alternative.\"\"\"\n\n    nonstop: float = 0\n    duration: float = 0\n    price: float = 0\n    \"\"\"This is the parameter for the price of each alternative.\"\"\"\n\n    tod_sin2p: float = 0\n    r\"\"\"Schedule parameter.\n\n    If $t$ is departure time (in minutes after midnight local time) divided\n    by 1440, this parameter is multiplied by $sin( 2 \\pi t)$ and the result is\n    added to the utility of the particular alternative.\"\"\"\n\n    tod_sin4p: float = 0\n    r\"\"\"Schedule parameter.\n\n    If $t$ is departure time (in minutes after midnight local time) divided\n    by 1440, this parameter is multiplied by $sin( 4 \\pi t)$ and the result is\n    added to the utility of the particular alternative.\"\"\"\n\n    tod_sin6p: float = 0\n    tod_cos2p: float = 0\n    tod_cos4p: float = 0\n    tod_cos6p: float = 0\n    free_bag: float = 0\n    early_boarding: float = 0\n    same_day_change: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.anc1_relevance", "title": "anc1_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc1_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.anc2_relevance", "title": "anc2_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc2_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.anc3_relevance", "title": "anc3_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc3_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.anc4_relevance", "title": "anc4_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc4_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.duration", "title": "duration  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>duration: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.early_boarding", "title": "early_boarding  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>early_boarding: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.emult", "title": "emult  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>emult: float | None = None\n</code></pre> <p>Using for WTP, a bit of a quick and dirty until we have a better approach</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.free_bag", "title": "free_bag  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>free_bag: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.intercept", "title": "intercept  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>intercept: float = 0\n</code></pre> <p>This is the alternative specific constant for the no-purchase alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.kind", "title": "kind  <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['logit']\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.nonstop", "title": "nonstop  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>nonstop: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.price", "title": "price  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>price: float = 0\n</code></pre> <p>This is the parameter for the price of each alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.same_day_change", "title": "same_day_change  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>same_day_change: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_cos2p", "title": "tod_cos2p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_cos2p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_cos4p", "title": "tod_cos4p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_cos4p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_cos6p", "title": "tod_cos6p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_cos6p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_sin2p", "title": "tod_sin2p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_sin2p: float = 0\n</code></pre> <p>Schedule parameter.</p> <p>If \\(t\\) is departure time (in minutes after midnight local time) divided by 1440, this parameter is multiplied by \\(sin( 2 \\pi t)\\) and the result is added to the utility of the particular alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_sin4p", "title": "tod_sin4p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_sin4p: float = 0\n</code></pre> <p>Schedule parameter.</p> <p>If \\(t\\) is departure time (in minutes after midnight local time) divided by 1440, this parameter is multiplied by \\(sin( 4 \\pi t)\\) and the result is added to the utility of the particular alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_sin6p", "title": "tod_sin6p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_sin6p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel", "title": "PodsChoiceModel", "text": "<p>               Bases: <code>CommonChoiceModel</code></p> Source code in <code>passengersim/config/choice_model.py</code> <pre><code>class PodsChoiceModel(CommonChoiceModel, extra=\"forbid\"):\n    kind: Literal[\"pods\"]\n\n    emult: float | None = None\n\n    basefare_mult: float | None = None\n    connect_disutility: float | None = None\n    path_quality: tuple[float, float] | None = None\n    airline_pref_pods: tuple[float, float] | None = None\n    airline_pref_hhi: tuple[float, float] | None = None\n    airline_pref_seat_share: tuple[float, float] | None = None\n    elapsed_time: tuple[float, float] | None = None\n    buffer_threshold: int | None = None\n    buffer_time: tuple[float, float] | None = None\n    tolerance: float | None = None\n    non_stop_multiplier: float | None = None\n    connection_multiplier: float | None = None\n    todd_curve: str | None = None\n\n    anc1_relevance: float | None = None\n    anc2_relevance: float | None = None\n    anc3_relevance: float | None = None\n    anc4_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.airline_pref_hhi", "title": "airline_pref_hhi  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>airline_pref_hhi: tuple[float, float] | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.airline_pref_pods", "title": "airline_pref_pods  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>airline_pref_pods: tuple[float, float] | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.airline_pref_seat_share", "title": "airline_pref_seat_share  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>airline_pref_seat_share: tuple[float, float] | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.anc1_relevance", "title": "anc1_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc1_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.anc2_relevance", "title": "anc2_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc2_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.anc3_relevance", "title": "anc3_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc3_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.anc4_relevance", "title": "anc4_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc4_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.basefare_mult", "title": "basefare_mult  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>basefare_mult: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.buffer_threshold", "title": "buffer_threshold  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>buffer_threshold: int | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.buffer_time", "title": "buffer_time  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>buffer_time: tuple[float, float] | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.connect_disutility", "title": "connect_disutility  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>connect_disutility: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.connection_multiplier", "title": "connection_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>connection_multiplier: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.elapsed_time", "title": "elapsed_time  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>elapsed_time: tuple[float, float] | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.emult", "title": "emult  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>emult: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.kind", "title": "kind  <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['pods']\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.non_stop_multiplier", "title": "non_stop_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>non_stop_multiplier: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.path_quality", "title": "path_quality  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>path_quality: tuple[float, float] | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.todd_curve", "title": "todd_curve  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>todd_curve: str | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.tolerance", "title": "tolerance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tolerance: float | None = None\n</code></pre>"}, {"location": "API/config/circuity_rules.html", "title": "Circuity rules", "text": ""}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule", "title": "CircuityRule", "text": "<p>               Bases: <code>Named</code></p> Source code in <code>passengersim/config/circuity_rules.py</code> <pre><code>class CircuityRule(Named, extra=\"forbid\"):\n    carrier: str | None = None\n    orig_airport: str | None = None\n    connect_airport: str | None = None\n    dest_airport: str | None = None\n    orig_state: str | None = None\n    dest_state: str | None = None\n\n    # The max circuity will be:  alpha + beta * market_distance\n    # To make it unlimited, set a really high beta value, like 1000.0\n    # To prohibit a conection, set alpha and beta to 0.0\n    alpha: float\n    beta: float\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.alpha", "title": "alpha  <code>instance-attribute</code>", "text": "<pre><code>alpha: float\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.beta", "title": "beta  <code>instance-attribute</code>", "text": "<pre><code>beta: float\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.carrier", "title": "carrier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier: str | None = None\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.connect_airport", "title": "connect_airport  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>connect_airport: str | None = None\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.dest_airport", "title": "dest_airport  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dest_airport: str | None = None\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.dest_state", "title": "dest_state  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dest_state: str | None = None\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.orig_airport", "title": "orig_airport  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>orig_airport: str | None = None\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.orig_state", "title": "orig_state  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>orig_state: str | None = None\n</code></pre>"}, {"location": "API/config/database.html", "title": "Database", "text": ""}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig", "title": "DatabaseConfig", "text": "<p>               Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/database.py</code> <pre><code>class DatabaseConfig(PrettyModel, extra=\"forbid\", validate_assignment=True):\n    engine: Literal[\"sqlite\", \"mysql\", None] = \"sqlite\"\n    \"\"\"Database engine to use.\n\n    Currently only `sqlite` is fully implemented.\"\"\"\n\n    filename: pathlib.Path | None = \"passengersim-output.sqlite\"\n    \"\"\"Name of file for SQLite output.\n\n    When using the sqlite engine, an in-memory database can be created by\n    setting this to ':memory:'.  Note that in-memory databases are not\n    persistent and will be lost when the database connection is closed.  Also,\n    in-memory databases cannot be shared between multiple processes.  When\n    using multiprocessing, all database operations must be performed in the\n    same process that created the database connection. Be sure to run summary\n    queries before closing the database connection, by identifying all database\n    summary tables in the `outputs.reports` configuration option.\n    \"\"\"\n\n    fast: bool = False\n    \"\"\"Whether to use pre-compiled SQL write instructions.\"\"\"\n\n    pragmas: list[str] = []\n    \"\"\"A list of PRAGMA commands to execute upon opening a database connection.\"\"\"\n\n    commit_count_delay: int | None = 250\n    \"\"\"Commit transactions to the database will only be honored this frequently.\n\n    By setting this number greater than 1, the transaction frequency will be reduced,\n    improving overall runtime performance by storing more data in RAM and writing to\n    persistent storage less frequently.\n    \"\"\"\n\n    write_items: set[\n        Literal[\n            \"leg\",\n            \"bucket\",\n            \"edgar\",\n            \"fare\",\n            \"demand\",\n            \"leg_daily\",\n            \"leg_final\",\n            \"bucket_final\",\n            \"fare_final\",\n            \"demand_final\",\n            \"bookings\",\n            \"pathclass\",\n            \"pathclass_daily\",\n            \"pathclass_final\",\n        ]\n    ] = {\"leg_final\", \"fare_final\", \"demand_final\", \"bookings\"}\n    \"\"\"Which items should be written to the database.\n\n    The following values can be provided in this set:\n\n    - *leg*: write every leg to the `leg_detail` table at every DCP.\n    - *leg_final*: write every leg to the `leg_detail` table only at DCP 0.\n    - *bucket*: write every leg bucket to the `leg_bucket_detail` table at every DCP.\n    - *bucket_final*: write every leg bucket to the `leg_bucket_detail` table only\n        at DCP 0.\n    - *fare*: write every fare to the `fare_detail` table at every DCP.\n    - *fare_final*: write every fare to the `fare_detail` table only at DCP 0.\n    - *demand*: write every demand to the `demand_detail` table at every DCP.\n    - *bookings*: store booking summary data at every DCP and write an aggregate\n        summary of bookings by DCP to the `bookings_by_timeframe` table at the end\n        of the simulation.\n    \"\"\"\n\n    dcp_write_hooks: list[Callable] = []\n    \"\"\"Additional callable functions that write to the database at each DCP.\n\n    Each should have a signature matching `f(db, sim, dcp)`.\n    \"\"\"\n\n    @field_validator(\"engine\", mode=\"before\")\n    def _interpret_none(cls, v):\n        \"\"\"Allow engine to be \"none\".\"\"\"\n        if isinstance(v, str) and v.lower() == \"none\":\n            v = None\n        return v\n\n    store_leg_bid_prices: bool = True\n    \"\"\"Should leg bid prices be stored in the database.\"\"\"\n\n    store_displacements: bool = True\n    \"\"\"Should leg displacements be stored in the database.\"\"\"\n</code></pre>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.commit_count_delay", "title": "commit_count_delay  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>commit_count_delay: int | None = 250\n</code></pre> <p>Commit transactions to the database will only be honored this frequently.</p> <p>By setting this number greater than 1, the transaction frequency will be reduced, improving overall runtime performance by storing more data in RAM and writing to persistent storage less frequently.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.dcp_write_hooks", "title": "dcp_write_hooks  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcp_write_hooks: list[Callable] = []\n</code></pre> <p>Additional callable functions that write to the database at each DCP.</p> <p>Each should have a signature matching <code>f(db, sim, dcp)</code>.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.engine", "title": "engine  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>engine: Literal['sqlite', 'mysql', None] = 'sqlite'\n</code></pre> <p>Database engine to use.</p> <p>Currently only <code>sqlite</code> is fully implemented.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.fast", "title": "fast  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>fast: bool = False\n</code></pre> <p>Whether to use pre-compiled SQL write instructions.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.filename", "title": "filename  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>filename: Path | None = 'passengersim-output.sqlite'\n</code></pre> <p>Name of file for SQLite output.</p> <p>When using the sqlite engine, an in-memory database can be created by setting this to ':memory:'.  Note that in-memory databases are not persistent and will be lost when the database connection is closed.  Also, in-memory databases cannot be shared between multiple processes.  When using multiprocessing, all database operations must be performed in the same process that created the database connection. Be sure to run summary queries before closing the database connection, by identifying all database summary tables in the <code>outputs.reports</code> configuration option.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.pragmas", "title": "pragmas  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>pragmas: list[str] = []\n</code></pre> <p>A list of PRAGMA commands to execute upon opening a database connection.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.store_displacements", "title": "store_displacements  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>store_displacements: bool = True\n</code></pre> <p>Should leg displacements be stored in the database.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.store_leg_bid_prices", "title": "store_leg_bid_prices  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>store_leg_bid_prices: bool = True\n</code></pre> <p>Should leg bid prices be stored in the database.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.write_items", "title": "write_items  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>write_items: set[\n    Literal[\n        \"leg\",\n        \"bucket\",\n        \"edgar\",\n        \"fare\",\n        \"demand\",\n        \"leg_daily\",\n        \"leg_final\",\n        \"bucket_final\",\n        \"fare_final\",\n        \"demand_final\",\n        \"bookings\",\n        \"pathclass\",\n        \"pathclass_daily\",\n        \"pathclass_final\",\n    ]\n] = {\"leg_final\", \"fare_final\", \"demand_final\", \"bookings\"}\n</code></pre> <p>Which items should be written to the database.</p> <p>The following values can be provided in this set:</p> <ul> <li>leg: write every leg to the <code>leg_detail</code> table at every DCP.</li> <li>leg_final: write every leg to the <code>leg_detail</code> table only at DCP 0.</li> <li>bucket: write every leg bucket to the <code>leg_bucket_detail</code> table at every DCP.</li> <li>bucket_final: write every leg bucket to the <code>leg_bucket_detail</code> table only     at DCP 0.</li> <li>fare: write every fare to the <code>fare_detail</code> table at every DCP.</li> <li>fare_final: write every fare to the <code>fare_detail</code> table only at DCP 0.</li> <li>demand: write every demand to the <code>demand_detail</code> table at every DCP.</li> <li>bookings: store booking summary data at every DCP and write an aggregate     summary of bookings by DCP to the <code>bookings_by_timeframe</code> table at the end     of the simulation.</li> </ul>"}, {"location": "API/config/demands.html", "title": "Demands", "text": ""}, {"location": "API/config/demands.html#passengersim.config.demands.Demand", "title": "Demand", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/demands.py</code> <pre><code>class Demand(BaseModel, extra=\"forbid\"):\n    orig: str\n    \"\"\"Origin location for this demand.\n\n    This is commonly a three letter airport code, but it need not be limited\n    to airports.  It can be any location that is relevant to the simulation.\n\n    If using 'places' for locations, this should match the 'name' field of\n    a Place object.\"\"\"\n\n    dest: str\n    \"\"\"Destination location for this demand.\n\n    This is commonly a three letter airport code, but it need not be limited\n    to airports.  It can be any location that is relevant to the simulation.\n\n    If using 'places' for locations, this should match the 'name' field of\n    a Place object.\"\"\"\n\n    segment: str\n    \"\"\"Customer segment that this demand belongs to.\n\n    For many applications, segments include 'business' and 'leisure', but\n    they are not limited to these two categories.\"\"\"\n\n    @property\n    def identifier(self):\n        \"\"\"Unique identifier for this demand.\"\"\"\n        return f\"{self.orig}~{self.dest}@{self.segment}\"\n\n    base_demand: float\n    reference_fare: float\n    distance: float | None = 0.0\n    choice_model: str | None = None\n    \"\"\"The name of the choice model that is applied for this demand.\"\"\"\n\n    todd_curve: str | None = None\n    \"\"\"Time Of Day curve to be used in the choice model.  These\n       can vary by length of haul, day of week, E-W directionality, etc.\n       If specified here, it will override the curve in the ChoiceModel\"\"\"\n\n    curve: str | None = None\n    \"\"\"The name of the booking curve that is applied for this demand.\n\n    Each demand is attached to a booking curve that describes the temporal\n    distribution of customer arrivals.\"\"\"\n\n    group_sizes: list[float] | None = None\n    \"\"\"Probability of each group size.\n\n    i.e. [0.5, 0.3, 0.2] will give 50% one pax, 30% 2 pax, etc\"\"\"\n\n    prob_saturday_night: bool = False\n    \"\"\"Probability that the customer has a R/T itinerary with a Saturday night stay.\n       Using this for choice modeling and CP experiments\"\"\"\n\n    prob_num_days: list[float] = []\n    \"\"\"Probability of durations.\n       [0.1, 0.3, 0.4, 0.2] will have durations of 1, 2, 3, 4 days\n       and probability of each is specified explicitly\n       Using this for choice modeling and CP experiments\"\"\"\n\n    @property\n    def choice_model_(self):\n        \"\"\"Choice model, falling back to segment name if not set explicitly.\"\"\"\n        return self.choice_model or self.segment\n\n    @field_validator(\"curve\", mode=\"before\")\n    def curve_integer_name(cls, v):\n        \"\"\"Booking curves can have integer names, treat as string.\"\"\"\n        if isinstance(v, int):\n            v = str(v)\n        return v\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.base_demand", "title": "base_demand  <code>instance-attribute</code>", "text": "<pre><code>base_demand: float\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.choice_model", "title": "choice_model  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>choice_model: str | None = None\n</code></pre> <p>The name of the choice model that is applied for this demand.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.choice_model_", "title": "choice_model_  <code>property</code>", "text": "<pre><code>choice_model_\n</code></pre> <p>Choice model, falling back to segment name if not set explicitly.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.curve", "title": "curve  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>curve: str | None = None\n</code></pre> <p>The name of the booking curve that is applied for this demand.</p> <p>Each demand is attached to a booking curve that describes the temporal distribution of customer arrivals.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre> <p>Destination location for this demand.</p> <p>This is commonly a three letter airport code, but it need not be limited to airports.  It can be any location that is relevant to the simulation.</p> <p>If using 'places' for locations, this should match the 'name' field of a Place object.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.distance", "title": "distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>distance: float | None = 0.0\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.group_sizes", "title": "group_sizes  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>group_sizes: list[float] | None = None\n</code></pre> <p>Probability of each group size.</p> <p>i.e. [0.5, 0.3, 0.2] will give 50% one pax, 30% 2 pax, etc</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.identifier", "title": "identifier  <code>property</code>", "text": "<pre><code>identifier\n</code></pre> <p>Unique identifier for this demand.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre> <p>Origin location for this demand.</p> <p>This is commonly a three letter airport code, but it need not be limited to airports.  It can be any location that is relevant to the simulation.</p> <p>If using 'places' for locations, this should match the 'name' field of a Place object.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.prob_num_days", "title": "prob_num_days  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>prob_num_days: list[float] = []\n</code></pre> <p>Probability of durations. [0.1, 0.3, 0.4, 0.2] will have durations of 1, 2, 3, 4 days and probability of each is specified explicitly Using this for choice modeling and CP experiments</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.prob_saturday_night", "title": "prob_saturday_night  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>prob_saturday_night: bool = False\n</code></pre> <p>Probability that the customer has a R/T itinerary with a Saturday night stay. Using this for choice modeling and CP experiments</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.reference_fare", "title": "reference_fare  <code>instance-attribute</code>", "text": "<pre><code>reference_fare: float\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.segment", "title": "segment  <code>instance-attribute</code>", "text": "<pre><code>segment: str\n</code></pre> <p>Customer segment that this demand belongs to.</p> <p>For many applications, segments include 'business' and 'leisure', but they are not limited to these two categories.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.todd_curve", "title": "todd_curve  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>todd_curve: str | None = None\n</code></pre> <p>Time Of Day curve to be used in the choice model.  These can vary by length of haul, day of week, E-W directionality, etc. If specified here, it will override the curve in the ChoiceModel</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.curve_integer_name", "title": "curve_integer_name", "text": "<pre><code>curve_integer_name(v)\n</code></pre> <p>Booking curves can have integer names, treat as string.</p> Source code in <code>passengersim/config/demands.py</code> <pre><code>@field_validator(\"curve\", mode=\"before\")\ndef curve_integer_name(cls, v):\n    \"\"\"Booking curves can have integer names, treat as string.\"\"\"\n    if isinstance(v, int):\n        v = str(v)\n    return v\n</code></pre>"}, {"location": "API/config/fares.html", "title": "Fares", "text": ""}, {"location": "API/config/fares.html#passengersim.config.fares.Fare", "title": "Fare", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/fares.py</code> <pre><code>class Fare(BaseModel, extra=\"forbid\"):\n    carrier: str\n    orig: str\n    dest: str\n    booking_class: str\n    price: float\n    advance_purchase: int\n    restrictions: list[str] = []\n    category: str | None = None\n    cabin: str | None = \"Y\"\n\n    @field_validator(\"restrictions\", mode=\"before\")\n    @classmethod\n    def allow_unrestricted(cls, v):\n        \"\"\"Allow restrictions to be None or missing.\"\"\"\n        if v is None:\n            v = []\n        return v\n\n    @field_validator(\"restrictions\", mode=\"before\")\n    @classmethod\n    def allow_pipe_sep(cls, v):\n        \"\"\"Allow restrictions to be a string of pipe or slash separated values.\"\"\"\n        if isinstance(v, str):\n            v = list(filter(None, re.split(r\"[|/]\", v)))\n        return v\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.advance_purchase", "title": "advance_purchase  <code>instance-attribute</code>", "text": "<pre><code>advance_purchase: int\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.booking_class", "title": "booking_class  <code>instance-attribute</code>", "text": "<pre><code>booking_class: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.cabin", "title": "cabin  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cabin: str | None = 'Y'\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.category", "title": "category  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>category: str | None = None\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.restrictions", "title": "restrictions  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>restrictions: list[str] = []\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.allow_pipe_sep", "title": "allow_pipe_sep  <code>classmethod</code>", "text": "<pre><code>allow_pipe_sep(v)\n</code></pre> <p>Allow restrictions to be a string of pipe or slash separated values.</p> Source code in <code>passengersim/config/fares.py</code> <pre><code>@field_validator(\"restrictions\", mode=\"before\")\n@classmethod\ndef allow_pipe_sep(cls, v):\n    \"\"\"Allow restrictions to be a string of pipe or slash separated values.\"\"\"\n    if isinstance(v, str):\n        v = list(filter(None, re.split(r\"[|/]\", v)))\n    return v\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.allow_unrestricted", "title": "allow_unrestricted  <code>classmethod</code>", "text": "<pre><code>allow_unrestricted(v)\n</code></pre> <p>Allow restrictions to be None or missing.</p> Source code in <code>passengersim/config/fares.py</code> <pre><code>@field_validator(\"restrictions\", mode=\"before\")\n@classmethod\ndef allow_unrestricted(cls, v):\n    \"\"\"Allow restrictions to be None or missing.\"\"\"\n    if v is None:\n        v = []\n    return v\n</code></pre>"}, {"location": "API/config/frat5_curves.html", "title": "Frat5 Curves", "text": ""}, {"location": "API/config/frat5_curves.html#passengersim.config.frat5_curves.Frat5Curve", "title": "Frat5Curve", "text": "<p>               Bases: <code>Named</code></p> <p>FRAT5 = Fare Ratio at which 50% of customers will buy up to the higher fare.</p> Source code in <code>passengersim/config/frat5_curves.py</code> <pre><code>class Frat5Curve(Named, extra=\"forbid\"):\n    \"\"\"\n    FRAT5 = Fare Ratio at which 50% of customers will buy up to the higher fare.\n    \"\"\"\n\n    curve: dict[int, float]\n    \"\"\"Define a Frat5 curve.\n\n    To be consistent with the econometric interpretation of the Frat5 curve,\n    the values should increase as the keys (DCPs, e.g. days to departure) decrease.\n    This implies that average willingness to pay increases as the departure date\n    approaches.\n\n    Example\n    -------\n    ```{yaml}\n    - name: curve_C\n      curve:\n        63: 1.4\n        56: 1.4\n        49: 1.5\n        42: 1.5\n        35: 1.6\n        31: 1.7\n        28: 1.8\n        24: 1.9\n        21: 2.3\n        17: 2.7\n        14: 3.2\n        10: 3.3\n        7: 3.4\n        5: 3.4\n        3: 3.5\n        1: 3.5\n    ```\n    \"\"\"\n\n    max_cap: float = 10.0\n    \"\"\"\n    Maximum Q-equivalent demand implied by any unit of demand in any fare class.\n\n    This cap is applied only on the creation of Q-equivalent demand that occurs\n    at the end of each DCP, and is not used in any RM step.\n    \"\"\"\n\n    @field_validator(\"curve\")\n    def _frat5_curves_accumulate(cls, v: dict[int, float], info: ValidationInfo):\n        \"\"\"Check that all curve values do not decrease as DCP keys decrease.\"\"\"\n        sorted_dcps = reversed(sorted(v.keys()))\n        i = 0\n        for dcp in sorted_dcps:\n            assert (\n                v[dcp] &gt;= i\n            ), f\"frat5 curve {info.data['name']} moves backwards at dcp {dcp}\"\n            i = v[dcp]\n        return v\n</code></pre>"}, {"location": "API/config/frat5_curves.html#passengersim.config.frat5_curves.Frat5Curve.curve", "title": "curve  <code>instance-attribute</code>", "text": "<pre><code>curve: dict[int, float]\n</code></pre> <p>Define a Frat5 curve.</p> <p>To be consistent with the econometric interpretation of the Frat5 curve, the values should increase as the keys (DCPs, e.g. days to departure) decrease. This implies that average willingness to pay increases as the departure date approaches.</p> Example <pre><code>- name: curve_C\n  curve:\n    63: 1.4\n    56: 1.4\n    49: 1.5\n    42: 1.5\n    35: 1.6\n    31: 1.7\n    28: 1.8\n    24: 1.9\n    21: 2.3\n    17: 2.7\n    14: 3.2\n    10: 3.3\n    7: 3.4\n    5: 3.4\n    3: 3.5\n    1: 3.5\n</code></pre>"}, {"location": "API/config/frat5_curves.html#passengersim.config.frat5_curves.Frat5Curve.max_cap", "title": "max_cap  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>max_cap: float = 10.0\n</code></pre> <p>Maximum Q-equivalent demand implied by any unit of demand in any fare class.</p> <p>This cap is applied only on the creation of Q-equivalent demand that occurs at the end of each DCP, and is not used in any RM step.</p>"}, {"location": "API/config/legs.html", "title": "Legs", "text": ""}, {"location": "API/config/legs.html#passengersim.config.legs.Leg", "title": "Leg", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/legs.py</code> <pre><code>class Leg(BaseModel, extra=\"forbid\"):\n    leg_id: int | None = None\n    \"\"\"A unique identifier for this leg.\n\n    Each leg in a network should have a globally unique identifier (i.e. even\n    if the carrier is different, `leg_id` values should be unique.  Note this\n    is not the same as the `fltno`, which is a label analogous to flight numbers\n    in practice, which don't need to be unique.  If the leg_id is not provided,\n    the `fltno` is used, unless the simulation already has a leg with that\n    `leg_id`, in which case a new unique leg_id will be generated.\n    \"\"\"\n\n    carrier: str\n    \"\"\"The carrier name for this leg.\"\"\"\n\n    fltno: int\n    \"\"\"A flight number identifier for this leg.\n\n    Flight numbers do not need to be unique.\n    \"\"\"\n\n    orig: str\n    \"\"\"Origination location for this leg.\"\"\"\n\n    orig_timezone: str | None = None\n    \"\"\"Timezone name for the origination location for this leg.\"\"\"\n\n    dest: str\n    \"\"\"Destination location for this leg.\"\"\"\n\n    dest_timezone: str | None = None\n    \"\"\"Timezone name for the destination location for this leg.\"\"\"\n\n    date: datetime = datetime.fromisoformat(\"2020-03-01\")\n    \"\"\"Departure date for this leg.\"\"\"\n\n    arr_day: int = 0\n    \"\"\"If the arrival time is on a different day, this is offset in days.\n\n    This will usually be zero (arrival date is same as departure date) but will\n    sometimes be 1 (arrives next day) or in a few pathological cases -1 or +2\n    (for travel across the international dateline).\n    \"\"\"\n\n    dep_time: int\n    \"\"\"Departure time for this leg in Unix time.\n\n    In input files, this can be specified as a string in the format \"HH:MM\",\n    with the hour in 24-hour format.\n\n    Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.\"\"\"\n\n    dep_time_offset: int = 0\n\n    @property\n    def dep_localtime(self) -&gt; datetime:\n        \"\"\"Departure time for this leg in local time at the origin.\"\"\"\n        t = datetime.fromtimestamp(self.dep_time, tz=timezone.utc)\n        if self.orig_timezone is not None:\n            z = ZoneInfo(self.orig_timezone)\n            t = t.astimezone(z)\n        return t\n\n    arr_time: int\n    \"\"\"Arrival time for this leg in Unix time.\n\n    In input files, this can be specified as a string in the format \"HH:MM\",\n    with the hour in 24-hour format.\n\n    Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.\"\"\"\n\n    arr_time_offset: int = 0\n\n    @property\n    def arr_localtime(self) -&gt; datetime:\n        \"\"\"Arrival time for this leg in local time at the destination.\"\"\"\n        t = datetime.fromtimestamp(self.arr_time, tz=timezone.utc)\n        if self.dest_timezone is not None:\n            z = ZoneInfo(self.dest_timezone)\n            t = t.astimezone(z)\n        return t\n\n    time_adjusted: bool = False\n    capacity: int | dict[str, int]\n    distance: float | None = None\n\n    @field_validator(\"date\", mode=\"before\")\n    def _date_from_string(cls, v):\n        if isinstance(v, str):\n            v = datetime.fromisoformat(v)\n        if v.tzinfo is None:\n            # when no timezone is specified, assume UTC (not naive)\n            v = v.replace(tzinfo=timezone.utc)\n        return v\n\n    @field_serializer(\"date\", when_used=\"always\")\n    def serialize_date(self, date: datetime) -&gt; str:\n        if date.tzinfo is None:\n            date = date.replace(tzinfo=timezone.utc)\n        return date.isoformat()\n\n    @field_validator(\"dep_time\", \"arr_time\", mode=\"before\")\n    def _timestring_to_int(cls, v, info: ValidationInfo):\n        if isinstance(v, str) and \":\" in v:\n            dep_time_str = v.split(\":\")\n            hh, mm = int(dep_time_str[0]), int(dep_time_str[1])\n            v = create_timestamp(info.data[\"date\"], 0, hh, mm)\n        if info.field_name == \"arr_time\":\n            if v &lt; info.data[\"dep_time\"] and info.data[\"arr_day\"] == 0:\n                v += 86400  # add a day (in seconds) as arr time is next day\n            elif info.data[\"arr_day\"] != 0:\n                v += 86400 * info.data[\"arr_day\"]  # adjust day[s] (in seconds)\n        return v\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.arr_day", "title": "arr_day  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>arr_day: int = 0\n</code></pre> <p>If the arrival time is on a different day, this is offset in days.</p> <p>This will usually be zero (arrival date is same as departure date) but will sometimes be 1 (arrives next day) or in a few pathological cases -1 or +2 (for travel across the international dateline).</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.arr_localtime", "title": "arr_localtime  <code>property</code>", "text": "<pre><code>arr_localtime: datetime\n</code></pre> <p>Arrival time for this leg in local time at the destination.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.arr_time", "title": "arr_time  <code>instance-attribute</code>", "text": "<pre><code>arr_time: int\n</code></pre> <p>Arrival time for this leg in Unix time.</p> <p>In input files, this can be specified as a string in the format \"HH:MM\", with the hour in 24-hour format.</p> <p>Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.arr_time_offset", "title": "arr_time_offset  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>arr_time_offset: int = 0\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.capacity", "title": "capacity  <code>instance-attribute</code>", "text": "<pre><code>capacity: int | dict[str, int]\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: str\n</code></pre> <p>The carrier name for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.date", "title": "date  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>date: datetime = fromisoformat('2020-03-01')\n</code></pre> <p>Departure date for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.dep_localtime", "title": "dep_localtime  <code>property</code>", "text": "<pre><code>dep_localtime: datetime\n</code></pre> <p>Departure time for this leg in local time at the origin.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.dep_time", "title": "dep_time  <code>instance-attribute</code>", "text": "<pre><code>dep_time: int\n</code></pre> <p>Departure time for this leg in Unix time.</p> <p>In input files, this can be specified as a string in the format \"HH:MM\", with the hour in 24-hour format.</p> <p>Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.dep_time_offset", "title": "dep_time_offset  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dep_time_offset: int = 0\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre> <p>Destination location for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.dest_timezone", "title": "dest_timezone  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dest_timezone: str | None = None\n</code></pre> <p>Timezone name for the destination location for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.distance", "title": "distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>distance: float | None = None\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.fltno", "title": "fltno  <code>instance-attribute</code>", "text": "<pre><code>fltno: int\n</code></pre> <p>A flight number identifier for this leg.</p> <p>Flight numbers do not need to be unique.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.leg_id", "title": "leg_id  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>leg_id: int | None = None\n</code></pre> <p>A unique identifier for this leg.</p> <p>Each leg in a network should have a globally unique identifier (i.e. even if the carrier is different, <code>leg_id</code> values should be unique.  Note this is not the same as the <code>fltno</code>, which is a label analogous to flight numbers in practice, which don't need to be unique.  If the leg_id is not provided, the <code>fltno</code> is used, unless the simulation already has a leg with that <code>leg_id</code>, in which case a new unique leg_id will be generated.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre> <p>Origination location for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.orig_timezone", "title": "orig_timezone  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>orig_timezone: str | None = None\n</code></pre> <p>Timezone name for the origination location for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.time_adjusted", "title": "time_adjusted  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>time_adjusted: bool = False\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.serialize_date", "title": "serialize_date", "text": "<pre><code>serialize_date(date: datetime) -&gt; str\n</code></pre> Source code in <code>passengersim/config/legs.py</code> <pre><code>@field_serializer(\"date\", when_used=\"always\")\ndef serialize_date(self, date: datetime) -&gt; str:\n    if date.tzinfo is None:\n        date = date.replace(tzinfo=timezone.utc)\n    return date.isoformat()\n</code></pre>"}, {"location": "API/config/load_factor_curves.html", "title": "Load Factor Curves", "text": ""}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve", "title": "LoadFactorCurve", "text": "<p>               Bases: <code>Named</code></p> <p>LF Curve specifies the load factor at which to close a booking class. This is designed to simulate a naive LCC that really doesn't have automated RM</p> Source code in <code>passengersim/config/load_factor_curves.py</code> <pre><code>class LoadFactorCurve(Named, extra=\"forbid\"):\n    \"\"\"\n    LF Curve specifies the load factor at which to close a booking class.\n    This is designed to simulate a naive LCC that really doesn't have automated RM\n    \"\"\"\n\n    algorithm: str\n    min_accordion: float\n    max_accordion: float\n    target_load_factor: float\n    convergence_constant: float\n    curve: dict[str, float]\n    \"\"\"Define a Load Factor curve.\n\n    Example\n    -------\n    ```{yaml}\n    - name: lf_curve_1\n      curve:\n        Y0: 1.0\n        Y1: 0.85\n        Y2: 0.75\n    ```\n    \"\"\"\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: str\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.convergence_constant", "title": "convergence_constant  <code>instance-attribute</code>", "text": "<pre><code>convergence_constant: float\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.curve", "title": "curve  <code>instance-attribute</code>", "text": "<pre><code>curve: dict[str, float]\n</code></pre> <p>Define a Load Factor curve.</p> Example <pre><code>- name: lf_curve_1\n  curve:\n    Y0: 1.0\n    Y1: 0.85\n    Y2: 0.75\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.max_accordion", "title": "max_accordion  <code>instance-attribute</code>", "text": "<pre><code>max_accordion: float\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.min_accordion", "title": "min_accordion  <code>instance-attribute</code>", "text": "<pre><code>min_accordion: float\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.target_load_factor", "title": "target_load_factor  <code>instance-attribute</code>", "text": "<pre><code>target_load_factor: float\n</code></pre>"}, {"location": "API/config/manipulate.html", "title": "Manipulate", "text": ""}, {"location": "API/config/manipulate.html#passengersim.config.manipulate.manipulate_config", "title": "manipulate_config", "text": "<pre><code>manipulate_config(\n    cfg: Config, key: str, value: Any\n) -&gt; Config\n</code></pre> <p>Manipulate a config object by setting a key to a value.</p> <p>Parameters:</p> <ul> <li> <code>cfg</code>               (<code>Config</code>)           \u2013            <p>The config object to manipulate.</p> </li> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to set.</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The value to set the key to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config</code>           \u2013            <p>The manipulated config object.</p> </li> </ul> Source code in <code>passengersim/config/manipulate.py</code> <pre><code>def manipulate_config(cfg: Config, key: str, value: Any) -&gt; Config:\n    \"\"\"Manipulate a config object by setting a key to a value.\n\n    Parameters\n    ----------\n    cfg : Config\n        The config object to manipulate.\n    key : str\n        The key to set.\n    value : Any\n        The value to set the key to.\n\n    Returns\n    -------\n    Config\n        The manipulated config object.\n    \"\"\"\n    k, *remainder = key.split(\".\")\n    remainder = \".\".join(remainder)\n    if remainder:\n        try:\n            i = int(k)\n        except ValueError:\n            self = getattr(cfg, k)\n        else:\n            self = cfg[i]\n        manipulate_config(self, remainder, value)\n    else:\n        try:\n            i = int(k)\n        except ValueError:\n            setattr(cfg, k, value)\n        else:\n            cfg[i] = value\n    return cfg\n</code></pre>"}, {"location": "API/config/manipulate.html#passengersim.config.manipulate.revalidate", "title": "revalidate", "text": "<pre><code>revalidate(model: BaseModel) -&gt; None\n</code></pre> <p>Revalidate a model using its schema.</p> Source code in <code>passengersim/config/manipulate.py</code> <pre><code>def revalidate(model: BaseModel) -&gt; None:\n    \"\"\"Revalidate a model using its schema.\"\"\"\n    schema_validator = SchemaValidator(schema=model.__pydantic_core_schema__)\n    schema_validator.validate_python(model.__dict__)\n</code></pre>"}, {"location": "API/config/manipulate.html#passengersim.config.manipulate.strip_all_restrictions", "title": "strip_all_restrictions", "text": "<pre><code>strip_all_restrictions(\n    cfg: Config, inplace: bool = False\n) -&gt; Config\n</code></pre> <p>Remove all restrictions (except APs) from a PassengerSim network.</p> <p>Parameters:</p> <ul> <li> <code>cfg</code>               (<code>Config</code>)           \u2013            <p>The PassengerSim network to strip restrictions from.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to modify the original network in place, by default False. Setting this value to True will modify the original network config, which may be faster than creating a copy, but may also be undesirable if you want to keep the original network available for any reason.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config</code>           \u2013            <p>The PassengerSim network with all restrictions removed.</p> </li> </ul> Source code in <code>passengersim/config/manipulate.py</code> <pre><code>def strip_all_restrictions(cfg: Config, inplace: bool = False) -&gt; Config:\n    \"\"\"Remove all restrictions (except APs) from a PassengerSim network.\n\n    Parameters\n    ----------\n    cfg : Config\n        The PassengerSim network to strip restrictions from.\n    inplace : bool, optional\n        Whether to modify the original network in place, by default False.\n        Setting this value to True will modify the original network config, which\n        may be faster than creating a copy, but may also be undesirable if you\n        want to keep the original network available for any reason.\n\n    Returns\n    -------\n    Config\n        The PassengerSim network with all restrictions removed.\n    \"\"\"\n    if not inplace:\n        cfg = cfg.model_copy(deep=True)\n    for cm in cfg.choice_models.values():\n        cm.restrictions.clear()\n    for fare in cfg.fares:\n        fare.restrictions.clear()\n    return cfg\n</code></pre>"}, {"location": "API/config/markets.html", "title": "Markets", "text": ""}, {"location": "API/config/markets.html#passengersim.config.markets.Market", "title": "Market", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/markets.py</code> <pre><code>class Market(BaseModel, extra=\"forbid\"):\n    orig: str\n    \"\"\"Origin location for this market.\n\n    This is commonly a three letter airport code, but it need not be limited\n    to airports.  It can be any location that is relevant to the simulation.\n\n    If using 'places' for locations, this should match the 'name' field of\n    a Place object.\"\"\"\n\n    dest: str\n    \"\"\"Destination location for this market.\n\n    This is commonly a three letter airport code, but it need not be limited\n    to airports.  It can be any location that is relevant to the simulation.\n\n    If using 'places' for locations, this should match the 'name' field of\n    a Place object.\"\"\"\n\n    demand_multiplier: float = 1.0\n    \"\"\"Multiplier on base demand for all demand segments in this market.\"\"\"\n\n    @property\n    def identifier(self) -&gt; str:\n        return f\"{self.orig}~{self.dest}\"\n</code></pre>"}, {"location": "API/config/markets.html#passengersim.config.markets.Market.demand_multiplier", "title": "demand_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>demand_multiplier: float = 1.0\n</code></pre> <p>Multiplier on base demand for all demand segments in this market.</p>"}, {"location": "API/config/markets.html#passengersim.config.markets.Market.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre> <p>Destination location for this market.</p> <p>This is commonly a three letter airport code, but it need not be limited to airports.  It can be any location that is relevant to the simulation.</p> <p>If using 'places' for locations, this should match the 'name' field of a Place object.</p>"}, {"location": "API/config/markets.html#passengersim.config.markets.Market.identifier", "title": "identifier  <code>property</code>", "text": "<pre><code>identifier: str\n</code></pre>"}, {"location": "API/config/markets.html#passengersim.config.markets.Market.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre> <p>Origin location for this market.</p> <p>This is commonly a three letter airport code, but it need not be limited to airports.  It can be any location that is relevant to the simulation.</p> <p>If using 'places' for locations, this should match the 'name' field of a Place object.</p>"}, {"location": "API/config/named.html", "title": "Named", "text": "<p>This module contains utilities for managing named objects.</p>"}, {"location": "API/config/named.html#passengersim.config.named.DictOfNamed", "title": "DictOfNamed  <code>module-attribute</code>", "text": "<pre><code>DictOfNamed = Annotated[\n    DictAttr[str, T], BeforeValidator(enforce_name)\n]\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.Dict", "title": "Dict", "text": "<p>               Bases: <code>Dict</code></p> Source code in <code>passengersim/config/named.py</code> <pre><code>class Dict(addicty.Dict):\n    def __repr__(self):\n        return dict.__repr__(self)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls: Any, source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; CoreSchema:\n        if (\n            isinstance(source_type, types.GenericAlias)\n            and source_type.__origin__ is Dict\n        ):\n            return core_schema.no_info_after_validator_function(\n                cls, handler(dict[source_type.__args__])\n            )\n        else:\n            return core_schema.no_info_after_validator_function(\n                cls, handler(source_type)\n            )\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.Dict.__get_pydantic_core_schema__", "title": "__get_pydantic_core_schema__  <code>classmethod</code>", "text": "<pre><code>__get_pydantic_core_schema__(\n    source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; CoreSchema\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls: Any, source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; CoreSchema:\n    if (\n        isinstance(source_type, types.GenericAlias)\n        and source_type.__origin__ is Dict\n    ):\n        return core_schema.no_info_after_validator_function(\n            cls, handler(dict[source_type.__args__])\n        )\n    else:\n        return core_schema.no_info_after_validator_function(\n            cls, handler(source_type)\n        )\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.Dict.__repr__", "title": "__repr__", "text": "<pre><code>__repr__()\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>def __repr__(self):\n    return dict.__repr__(self)\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.DictAttr", "title": "DictAttr", "text": "<p>               Bases: <code>dict</code></p> Source code in <code>passengersim/config/named.py</code> <pre><code>class DictAttr(dict):\n    def __getattr__(self, item):\n        if item in self:\n            return self[item]\n        if item.lower() in self:\n            return self[item.lower()]\n        raise AttributeError(f\"no key {item}\")\n\n    def __setattr__(self, item, value):\n        self[item.lower()] = value\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls: Any, source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; CoreSchema:\n        if (\n            isinstance(source_type, types.GenericAlias)\n            and source_type.__origin__ is DictAttr\n        ):\n            return core_schema.no_info_after_validator_function(\n                cls, handler(dict[source_type.__args__])\n            )\n        else:\n            return core_schema.no_info_after_validator_function(\n                cls, handler(source_type)\n            )\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.DictAttr.__get_pydantic_core_schema__", "title": "__get_pydantic_core_schema__  <code>classmethod</code>", "text": "<pre><code>__get_pydantic_core_schema__(\n    source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; CoreSchema\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls: Any, source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; CoreSchema:\n    if (\n        isinstance(source_type, types.GenericAlias)\n        and source_type.__origin__ is DictAttr\n    ):\n        return core_schema.no_info_after_validator_function(\n            cls, handler(dict[source_type.__args__])\n        )\n    else:\n        return core_schema.no_info_after_validator_function(\n            cls, handler(source_type)\n        )\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.DictAttr.__getattr__", "title": "__getattr__", "text": "<pre><code>__getattr__(item)\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>def __getattr__(self, item):\n    if item in self:\n        return self[item]\n    if item.lower() in self:\n        return self[item.lower()]\n    raise AttributeError(f\"no key {item}\")\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.DictAttr.__setattr__", "title": "__setattr__", "text": "<pre><code>__setattr__(item, value)\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>def __setattr__(self, item, value):\n    self[item.lower()] = value\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.ListOfNamed", "title": "ListOfNamed", "text": "<p>               Bases: <code>list</code></p> Source code in <code>passengersim/config/named.py</code> <pre><code>class ListOfNamed(list):\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls: Any, source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; CoreSchema:\n        if (\n            isinstance(source_type, types.GenericAlias)\n            and source_type.__origin__ is ListOfNamed\n        ):\n            return core_schema.no_info_after_validator_function(\n                cls, handler(list[source_type.__args__])\n            )\n        else:\n            return core_schema.no_info_after_validator_function(\n                cls, handler(source_type)\n            )\n\n    def __getattr__(self, item):\n        for step in self:\n            if getattr(step, \"step_type\", None) == item:\n                return step\n        for step in self:\n            if getattr(step, \"name\", None) == item:\n                return step\n        raise AttributeError(f\"no step with step_type or name {item}\")\n\n    def __delattr__(self, item):\n        for i, step in enumerate(self):\n            if getattr(step, \"step_type\", None) == item:\n                del self[i]\n                return\n        for i, step in enumerate(self):\n            if getattr(step, \"name\", None) == item:\n                del self[i]\n                return\n        raise AttributeError(f\"no step with step_type or name {item}\")\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.ListOfNamed.__delattr__", "title": "__delattr__", "text": "<pre><code>__delattr__(item)\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>def __delattr__(self, item):\n    for i, step in enumerate(self):\n        if getattr(step, \"step_type\", None) == item:\n            del self[i]\n            return\n    for i, step in enumerate(self):\n        if getattr(step, \"name\", None) == item:\n            del self[i]\n            return\n    raise AttributeError(f\"no step with step_type or name {item}\")\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.ListOfNamed.__get_pydantic_core_schema__", "title": "__get_pydantic_core_schema__  <code>classmethod</code>", "text": "<pre><code>__get_pydantic_core_schema__(\n    source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; CoreSchema\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls: Any, source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; CoreSchema:\n    if (\n        isinstance(source_type, types.GenericAlias)\n        and source_type.__origin__ is ListOfNamed\n    ):\n        return core_schema.no_info_after_validator_function(\n            cls, handler(list[source_type.__args__])\n        )\n    else:\n        return core_schema.no_info_after_validator_function(\n            cls, handler(source_type)\n        )\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.ListOfNamed.__getattr__", "title": "__getattr__", "text": "<pre><code>__getattr__(item)\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>def __getattr__(self, item):\n    for step in self:\n        if getattr(step, \"step_type\", None) == item:\n            return step\n    for step in self:\n        if getattr(step, \"name\", None) == item:\n            return step\n    raise AttributeError(f\"no step with step_type or name {item}\")\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.Named", "title": "Named", "text": "<p>               Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/named.py</code> <pre><code>class Named(PrettyModel):\n    name: str\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.Named.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.enforce_name", "title": "enforce_name", "text": "<pre><code>enforce_name(x: dict[str, T] | list[T]) -&gt; dict[str, T]\n</code></pre> <p>Enforce that each item has a unique name.</p> <p>If you provide a list, this will ensure that each item in the list has a name. If you provide a dict, the names are given by the keys of the dictionary, and this will ensure that for each value, if it also has an explicitly defined name, that name matches its key-derived name.</p> Source code in <code>passengersim/config/named.py</code> <pre><code>def enforce_name(x: dict[str, T] | list[T]) -&gt; dict[str, T]:\n    \"\"\"Enforce that each item has a unique name.\n\n    If you provide a list, this will ensure that each item in the list has a name.\n    If you provide a dict, the names are given by the keys of the dictionary, and\n    this will ensure that for each value, if it also has an explicitly defined name,\n    that name matches its key-derived name.\n    \"\"\"\n    if isinstance(x, list):\n        x_ = {}\n        for n, i in enumerate(x):\n            k = i.get(\"name\")\n            if k is None:\n                raise ValueError(f\"missing name in position {n}\")\n            x_[k] = i\n        x = x_\n    for k, v in x.items():\n        try:\n            missing_name = \"name\" not in v or not v[\"name\"]\n        except TypeError:\n            missing_name = True\n        if missing_name:\n            try:\n                v[\"name\"] = k\n            except TypeError:\n                try:\n                    v.name = k\n                except AttributeError:\n                    raise ValueError(f\"cannot assign name {k!r} to {type(v)}\") from None\n        try:\n            if v[\"name\"] != k:\n                raise ValueError(f\"explict name {v['name']!r} does not match key {k!r}\")\n        except TypeError:\n            if v.name != k:\n                raise ValueError(\n                    f\"explict name {v.name!r} does not match key {k!r}\"\n                ) from None\n    return x\n</code></pre>"}, {"location": "API/config/outputs.html", "title": "Outputs", "text": ""}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig", "title": "HtmlOutputConfig", "text": "<p>               Bases: <code>PrettyModel</code></p> <p>Configuration for HTML outputs.</p> Source code in <code>passengersim/config/outputs.py</code> <pre><code>class HtmlOutputConfig(PrettyModel, extra=\"forbid\", validate_assignment=True):\n    \"\"\"Configuration for HTML outputs.\"\"\"\n\n    filename: pathlib.Path | None = None\n    \"\"\"Write HTML outputs to this file after a run.\n\n    If this is None, no HTML outputs will be written.\"\"\"\n\n    title: str | None = None\n    \"\"\"Title of the HTML report.\n\n    If this is None, the title will be the scenario name.\"\"\"\n\n    carrier_revenues: bool = True\n    \"\"\"Include carrier revenues in the HTML report.\"\"\"\n\n    carrier_total_bookings: bool = True\n    \"\"\"Include carrier total bookings in the HTML report.\"\"\"\n\n    carrier_revenue_distribution: bool = False\n    \"\"\"Include carrier revenue distribution in the HTML report.\"\"\"\n\n    carrier_load_factors: bool = True\n    \"\"\"Include carrier load factors in the HTML report.\"\"\"\n\n    carrier_yields: bool = True\n    \"\"\"Include carrier yields in the HTML report.\"\"\"\n\n    carrier_rasm: bool = True\n    \"\"\"Include carrier RASM in the HTML report.\"\"\"\n\n    carrier_local_share: bool = True\n    \"\"\"Include carrier local share in the HTML report.\"\"\"\n\n    fare_class_mix: bool = True\n    \"\"\"Include fare class mix in the HTML report.\n\n    This figure is always by carrier.\"\"\"\n\n    bookings_by_timeframe: bool | list[str] = True\n    \"\"\"Include bookings by timeframe in the HTML report.\n\n    If this is a list of strings, include only the specified carriers.\"\"\"\n\n    leg_load_factor_distribution: bool = True\n    \"\"\"Include leg load factor distribution in the HTML report.\"\"\"\n\n    bid_price_history: bool = True\n    \"\"\"Include bid price history in the HTML report.\"\"\"\n\n    displacement_history: bool = True\n    \"\"\"Include displacement history in the HTML report.\"\"\"\n\n    carrier_table: bool = True\n    \"\"\"Include carrier table in the HTML report.\"\"\"\n\n    segmentation_by_timeframe_table: bool = True\n    \"\"\"Include segmentation by timeframe table in the HTML report.\"\"\"\n\n    other: list[str | tuple[str, dict]] = []\n\n    configs: list[str] = [\n        \"carriers\",\n        \"rm_systems\",\n        \"simulation_controls\",\n        \"db\",\n        \"outputs\",\n    ]\n    \"\"\"Include these configuration items in the HTML report.\"\"\"\n\n    metadata: bool = True\n    \"\"\"Include simulation run metadata in the HTML report.\"\"\"\n\n    def __bool__(self) -&gt; bool:\n        return self.filename is not None\n</code></pre>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.bid_price_history", "title": "bid_price_history  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>bid_price_history: bool = True\n</code></pre> <p>Include bid price history in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.bookings_by_timeframe", "title": "bookings_by_timeframe  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>bookings_by_timeframe: bool | list[str] = True\n</code></pre> <p>Include bookings by timeframe in the HTML report.</p> <p>If this is a list of strings, include only the specified carriers.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_load_factors", "title": "carrier_load_factors  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_load_factors: bool = True\n</code></pre> <p>Include carrier load factors in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_local_share", "title": "carrier_local_share  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_local_share: bool = True\n</code></pre> <p>Include carrier local share in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_rasm", "title": "carrier_rasm  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_rasm: bool = True\n</code></pre> <p>Include carrier RASM in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_revenue_distribution", "title": "carrier_revenue_distribution  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_revenue_distribution: bool = False\n</code></pre> <p>Include carrier revenue distribution in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_revenues", "title": "carrier_revenues  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_revenues: bool = True\n</code></pre> <p>Include carrier revenues in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_table", "title": "carrier_table  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_table: bool = True\n</code></pre> <p>Include carrier table in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_total_bookings", "title": "carrier_total_bookings  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_total_bookings: bool = True\n</code></pre> <p>Include carrier total bookings in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_yields", "title": "carrier_yields  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_yields: bool = True\n</code></pre> <p>Include carrier yields in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.configs", "title": "configs  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>configs: list[str] = [\n    \"carriers\",\n    \"rm_systems\",\n    \"simulation_controls\",\n    \"db\",\n    \"outputs\",\n]\n</code></pre> <p>Include these configuration items in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.displacement_history", "title": "displacement_history  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>displacement_history: bool = True\n</code></pre> <p>Include displacement history in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.fare_class_mix", "title": "fare_class_mix  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>fare_class_mix: bool = True\n</code></pre> <p>Include fare class mix in the HTML report.</p> <p>This figure is always by carrier.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.filename", "title": "filename  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>filename: Path | None = None\n</code></pre> <p>Write HTML outputs to this file after a run.</p> <p>If this is None, no HTML outputs will be written.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.leg_load_factor_distribution", "title": "leg_load_factor_distribution  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>leg_load_factor_distribution: bool = True\n</code></pre> <p>Include leg load factor distribution in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.metadata", "title": "metadata  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>metadata: bool = True\n</code></pre> <p>Include simulation run metadata in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.other", "title": "other  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>other: list[str | tuple[str, dict]] = []\n</code></pre>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.segmentation_by_timeframe_table", "title": "segmentation_by_timeframe_table  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>segmentation_by_timeframe_table: bool = True\n</code></pre> <p>Include segmentation by timeframe table in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.title", "title": "title  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>title: str | None = None\n</code></pre> <p>Title of the HTML report.</p> <p>If this is None, the title will be the scenario name.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.__bool__", "title": "__bool__", "text": "<pre><code>__bool__() -&gt; bool\n</code></pre> Source code in <code>passengersim/config/outputs.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    return self.filename is not None\n</code></pre>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig", "title": "OutputConfig", "text": "<p>               Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/outputs.py</code> <pre><code>class OutputConfig(PrettyModel, extra=\"forbid\", validate_assignment=True):\n    log_reports: bool = False\n    \"\"\"Write basic reports directly to the run log.\"\"\"\n\n    excel: pathlib.Path | None = None\n    \"\"\"Write excel outputs to this file after a run.\"\"\"\n\n    reports: set[str | tuple[str, ...]] = set()\n    \"\"\"Reports to include.\n\n    Database queries reports can be included here.  This is important for\n    multiprocessing runs with in-memory databases, as database results will not\n    be available after the database connection is closed in each subprocess.\n\n    If this is a set containing only \"*\", all reports will be included; this\n    may be computationally expensive.\n    \"\"\"\n\n    html: HtmlOutputConfig = HtmlOutputConfig()\n    \"\"\"Configuration for HTML outputs.\"\"\"\n\n    pickle: pathlib.Path | None = None\n    \"\"\"Write a pickle of the SimulationTables output to this file after a run.\"\"\"\n\n    # TODO what reports require what database items?\n    # e.g. demand_to_come requires we store all `demand` not just demand_final\n\n    @field_serializer(\"reports\", when_used=\"always\")\n    def serialize_reports(\n        self, reports: set[str | tuple[str, ...]]\n    ) -&gt; list[str | tuple[str, ...]]:\n        # return a sorted list, first simple strings then tuples\n        return sorted(reports, key=lambda x: (isinstance(x, tuple), x))\n</code></pre>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.excel", "title": "excel  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>excel: Path | None = None\n</code></pre> <p>Write excel outputs to this file after a run.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.html", "title": "html  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>html: HtmlOutputConfig = HtmlOutputConfig()\n</code></pre> <p>Configuration for HTML outputs.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.log_reports", "title": "log_reports  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>log_reports: bool = False\n</code></pre> <p>Write basic reports directly to the run log.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.pickle", "title": "pickle  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>pickle: Path | None = None\n</code></pre> <p>Write a pickle of the SimulationTables output to this file after a run.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.reports", "title": "reports  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>reports: set[str | tuple[str, ...]] = set()\n</code></pre> <p>Reports to include.</p> <p>Database queries reports can be included here.  This is important for multiprocessing runs with in-memory databases, as database results will not be available after the database connection is closed in each subprocess.</p> <p>If this is a set containing only \"*\", all reports will be included; this may be computationally expensive.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.serialize_reports", "title": "serialize_reports", "text": "<pre><code>serialize_reports(\n    reports: set[str | tuple[str, ...]],\n) -&gt; list[str | tuple[str, ...]]\n</code></pre> Source code in <code>passengersim/config/outputs.py</code> <pre><code>@field_serializer(\"reports\", when_used=\"always\")\ndef serialize_reports(\n    self, reports: set[str | tuple[str, ...]]\n) -&gt; list[str | tuple[str, ...]]:\n    # return a sorted list, first simple strings then tuples\n    return sorted(reports, key=lambda x: (isinstance(x, tuple), x))\n</code></pre>"}, {"location": "API/config/paths.html", "title": "Paths", "text": ""}, {"location": "API/config/paths.html#passengersim.config.paths.Path", "title": "Path", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/paths.py</code> <pre><code>class Path(BaseModel, extra=\"forbid\"):\n    path_id: int | None = None\n    orig: str\n    dest: str\n    path_quality_index: float\n\n    legs: list[int]\n    \"\"\"Flight numbers of legs comprising the path.\"\"\"\n\n    @field_validator(\"legs\", mode=\"before\")\n    def allow_single_leg(cls, v):\n        \"\"\"Allow a single leg path to be just an int not a list of one int.\"\"\"\n        if isinstance(v, int):\n            v = [v]\n        return v\n\n    @field_validator(\"legs\")\n    def at_least_one_leg(cls, v):\n        \"\"\"There must be at least one leg.\"\"\"\n        if len(v) &lt; 1:\n            raise ValueError(\"path must have at least one leg\")\n        return v\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.legs", "title": "legs  <code>instance-attribute</code>", "text": "<pre><code>legs: list[int]\n</code></pre> <p>Flight numbers of legs comprising the path.</p>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.path_id", "title": "path_id  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>path_id: int | None = None\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.path_quality_index", "title": "path_quality_index  <code>instance-attribute</code>", "text": "<pre><code>path_quality_index: float\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.allow_single_leg", "title": "allow_single_leg", "text": "<pre><code>allow_single_leg(v)\n</code></pre> <p>Allow a single leg path to be just an int not a list of one int.</p> Source code in <code>passengersim/config/paths.py</code> <pre><code>@field_validator(\"legs\", mode=\"before\")\ndef allow_single_leg(cls, v):\n    \"\"\"Allow a single leg path to be just an int not a list of one int.\"\"\"\n    if isinstance(v, int):\n        v = [v]\n    return v\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.at_least_one_leg", "title": "at_least_one_leg", "text": "<pre><code>at_least_one_leg(v)\n</code></pre> <p>There must be at least one leg.</p> Source code in <code>passengersim/config/paths.py</code> <pre><code>@field_validator(\"legs\")\ndef at_least_one_leg(cls, v):\n    \"\"\"There must be at least one leg.\"\"\"\n    if len(v) &lt; 1:\n        raise ValueError(\"path must have at least one leg\")\n    return v\n</code></pre>"}, {"location": "API/config/places.html", "title": "Places", "text": ""}, {"location": "API/config/places.html#passengersim.config.places.MinConnectTime", "title": "MinConnectTime", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/places.py</code> <pre><code>class MinConnectTime(BaseModel, extra=\"forbid\", validate_assignment=True):\n    domestic_domestic: int\n    \"\"\"Minimum connect time for domestic to domestic connections in minutes.\"\"\"\n\n    domestic_international: int\n    \"\"\"Minimum connect time for domestic to international connections in minutes.\"\"\"\n\n    international_domestic: int\n    \"\"\"Minimum connect time for international to domestic connections in minutes.\"\"\"\n\n    international_international: int\n    \"\"\"Minimum connect time for international to international connects in minutes.\"\"\"\n</code></pre>"}, {"location": "API/config/places.html#passengersim.config.places.MinConnectTime.domestic_domestic", "title": "domestic_domestic  <code>instance-attribute</code>", "text": "<pre><code>domestic_domestic: int\n</code></pre> <p>Minimum connect time for domestic to domestic connections in minutes.</p>"}, {"location": "API/config/places.html#passengersim.config.places.MinConnectTime.domestic_international", "title": "domestic_international  <code>instance-attribute</code>", "text": "<pre><code>domestic_international: int\n</code></pre> <p>Minimum connect time for domestic to international connections in minutes.</p>"}, {"location": "API/config/places.html#passengersim.config.places.MinConnectTime.international_domestic", "title": "international_domestic  <code>instance-attribute</code>", "text": "<pre><code>international_domestic: int\n</code></pre> <p>Minimum connect time for international to domestic connections in minutes.</p>"}, {"location": "API/config/places.html#passengersim.config.places.MinConnectTime.international_international", "title": "international_international  <code>instance-attribute</code>", "text": "<pre><code>international_international: int\n</code></pre> <p>Minimum connect time for international to international connects in minutes.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place", "title": "Place", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/places.py</code> <pre><code>class Place(BaseModel, extra=\"forbid\", validate_assignment=True):\n    name: str\n    \"\"\"Identifying code for this place.\n\n    For airports, typically the three letter code.\"\"\"\n\n    label: str\n    \"\"\"A descriptive label for this place.\"\"\"\n\n    country: str | None = None\n    \"\"\"Country code.\n\n    Recommended to use ISO 3166-1 alpha-2 codes, ie. US / GB / AU / MX / etc.\"\"\"\n\n    state: str | None = None\n    \"\"\"State code\"\"\"\n\n    lat: float | None = None\n    \"\"\"Latitude in degrees.\"\"\"\n\n    lon: float | None = None\n    \"\"\"Longitude in degrees.\"\"\"\n\n    time_zone: str | None = None\n    \"\"\"\n    The time zone for this location.\n    \"\"\"\n\n    tz_offset: int | None = None\n    \"\"\"Hours offset from GMT\"\"\"\n\n    mct: Annotated[\n        MinConnectTime | int | None,\n        AfterValidator(_inflate_simple_mct),\n        BeforeValidator(_reformat_mct),\n    ] = None\n    \"\"\"\n    Default Minimum Connect Time (MCT) in minutes for this location (Airport).\n\n    This can be given as a single integer, which will be applied to all\n    connections, or differentiated by connection type (domestic-domestic,\n    domestic-international, etc.).  Connection types can be given using their\n    full name (with underscore) or using shorthand codes (DD, DI, ID, II), or\n    as a list of 4 integers in the order DD, DI, ID, II.\n\n    Future version of PassengerSim will also allow specific exceptions by\n    airline / route / etc.\n    \"\"\"\n\n    @field_validator(\"time_zone\")\n    def _valid_time_zone(cls, v: str):\n        \"\"\"Check for valid time zones.\"\"\"\n        if isinstance(v, str):\n            ZoneInfo(v)\n        return v\n\n    @property\n    def time_zone_info(self):\n        return ZoneInfo(self.time_zone)\n</code></pre>"}, {"location": "API/config/places.html#passengersim.config.places.Place.country", "title": "country  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>country: str | None = None\n</code></pre> <p>Country code.</p> <p>Recommended to use ISO 3166-1 alpha-2 codes, ie. US / GB / AU / MX / etc.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.label", "title": "label  <code>instance-attribute</code>", "text": "<pre><code>label: str\n</code></pre> <p>A descriptive label for this place.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.lat", "title": "lat  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>lat: float | None = None\n</code></pre> <p>Latitude in degrees.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.lon", "title": "lon  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>lon: float | None = None\n</code></pre> <p>Longitude in degrees.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.mct", "title": "mct  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>mct: Annotated[\n    MinConnectTime | int | None,\n    AfterValidator(_inflate_simple_mct),\n    BeforeValidator(_reformat_mct),\n] = None\n</code></pre> <p>Default Minimum Connect Time (MCT) in minutes for this location (Airport).</p> <p>This can be given as a single integer, which will be applied to all connections, or differentiated by connection type (domestic-domestic, domestic-international, etc.).  Connection types can be given using their full name (with underscore) or using shorthand codes (DD, DI, ID, II), or as a list of 4 integers in the order DD, DI, ID, II.</p> <p>Future version of PassengerSim will also allow specific exceptions by airline / route / etc.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre> <p>Identifying code for this place.</p> <p>For airports, typically the three letter code.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.state", "title": "state  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>state: str | None = None\n</code></pre> <p>State code</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.time_zone", "title": "time_zone  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>time_zone: str | None = None\n</code></pre> <p>The time zone for this location.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.time_zone_info", "title": "time_zone_info  <code>property</code>", "text": "<pre><code>time_zone_info\n</code></pre>"}, {"location": "API/config/places.html#passengersim.config.places.Place.tz_offset", "title": "tz_offset  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tz_offset: int | None = None\n</code></pre> <p>Hours offset from GMT</p>"}, {"location": "API/config/places.html#passengersim.config.places.great_circle", "title": "great_circle", "text": "<pre><code>great_circle(place1: Place, place2: Place)\n</code></pre> <p>Using Haversine formula, to get distance between points in miles.</p> Source code in <code>passengersim/config/places.py</code> <pre><code>def great_circle(place1: Place, place2: Place):\n    \"\"\"Using Haversine formula, to get distance between points in miles.\"\"\"\n    lon1 = math.radians(place1.lon)\n    lat1 = math.radians(place1.lat)\n    lon2 = math.radians(place2.lon)\n    lat2 = math.radians(place2.lat)\n    lon_diff = lon2 - lon1\n    lat_diff = lat2 - lat1\n    a = math.sin((lat_diff) / 2.0) ** 2.0 + (\n        math.cos(lat1) * math.cos(lat2) * (math.sin((lon_diff) / 2.0) ** 2.0)\n    )\n    angle2 = 2.0 * math.asin(min(1.0, math.sqrt(a)))\n    # Convert back to degrees.\n    angle2 = math.degrees(angle2)\n    # Each degree on a great circle of Earth is 69.0468 miles. ( 60 nautical miles )\n    distance2 = 69.0468 * angle2\n    return distance2\n</code></pre>"}, {"location": "API/config/pretty.html", "title": "Pretty", "text": ""}, {"location": "API/config/pretty.html#passengersim.config.pretty.PrettyModel", "title": "PrettyModel", "text": "<p>               Bases: <code>BaseModel</code></p> <p>Pretty-print as YAML style outputs.</p> Source code in <code>passengersim/config/pretty.py</code> <pre><code>class PrettyModel(BaseModel):\n    \"\"\"Pretty-print as YAML style outputs.\"\"\"\n\n    def __repr_with_indent__(self, indent=0):\n        x = []\n        i = \" \" * indent\n        for k, v in self:\n            try:\n                val = v.__repr_with_indent__(0)\n            except AttributeError:\n                if isinstance(v, dict):\n                    val = repr_dict_with_indent(v, indent)\n                else:\n                    val = repr(v)\n                    if isinstance(v, list) and len(val) &gt; 70:\n                        val = \"- \" + \"\\n- \".join(repr(j) for j in v)\n            if \"\\n\" in val:\n                val_lines = val.split(\"\\n\")\n                val = \"\\n  \" + \"\\n  \".join(val_lines)\n            elif isinstance(v, list):\n                val = \"\\n  - \" + \"\\n  - \".join(repr(j) for j in v)\n            x.append(f\"{i}{k}: {val}\")\n        return \"\\n\".join(x)\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}:\\n\" + self.__repr_with_indent__(2)\n</code></pre>"}, {"location": "API/config/pretty.html#passengersim.config.pretty.PrettyModel.__repr__", "title": "__repr__", "text": "<pre><code>__repr__()\n</code></pre> Source code in <code>passengersim/config/pretty.py</code> <pre><code>def __repr__(self):\n    return f\"{self.__class__.__name__}:\\n\" + self.__repr_with_indent__(2)\n</code></pre>"}, {"location": "API/config/pretty.html#passengersim.config.pretty.PrettyModel.__repr_with_indent__", "title": "__repr_with_indent__", "text": "<pre><code>__repr_with_indent__(indent=0)\n</code></pre> Source code in <code>passengersim/config/pretty.py</code> <pre><code>def __repr_with_indent__(self, indent=0):\n    x = []\n    i = \" \" * indent\n    for k, v in self:\n        try:\n            val = v.__repr_with_indent__(0)\n        except AttributeError:\n            if isinstance(v, dict):\n                val = repr_dict_with_indent(v, indent)\n            else:\n                val = repr(v)\n                if isinstance(v, list) and len(val) &gt; 70:\n                    val = \"- \" + \"\\n- \".join(repr(j) for j in v)\n        if \"\\n\" in val:\n            val_lines = val.split(\"\\n\")\n            val = \"\\n  \" + \"\\n  \".join(val_lines)\n        elif isinstance(v, list):\n            val = \"\\n  - \" + \"\\n  - \".join(repr(j) for j in v)\n        x.append(f\"{i}{k}: {val}\")\n    return \"\\n\".join(x)\n</code></pre>"}, {"location": "API/config/pretty.html#passengersim.config.pretty.repr_dict_with_indent", "title": "repr_dict_with_indent", "text": "<pre><code>repr_dict_with_indent(d: dict[str, Any], indent=0)\n</code></pre> Source code in <code>passengersim/config/pretty.py</code> <pre><code>def repr_dict_with_indent(d: dict[str, Any], indent=0):\n    x = []\n    i = \" \" * indent\n    for k, v in d.items():\n        try:\n            val = v.__repr_with_indent__(indent)\n        except AttributeError:\n            if isinstance(v, dict):\n                val = repr_dict_with_indent(v, indent)\n            else:\n                val = repr(v)\n                if isinstance(v, list) and len(val) &gt; 70:\n                    val = \"- \" + \"\\n- \".join(repr(j) for j in v)\n        if \"\\n\" in val:\n            val_lines = val.split(\"\\n\")\n            val = \"\\n  \" + \"\\n  \".join(val_lines)\n        elif isinstance(v, list):\n            val = \"\\n  - \" + \"\\n  - \".join(repr(j) for j in v)\n        x.append(f\"{i}{k}: {val}\")\n    return \"\\n\".join(x)\n</code></pre>"}, {"location": "API/config/rm_steps.html", "title": "RM Steps", "text": ""}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.DummyStep", "title": "DummyStep", "text": "<p>               Bases: <code>RmStepBase</code></p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>class DummyStep(RmStepBase):\n    step_type: Literal[\"dummy\"]\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.DummyStep.step_type", "title": "step_type  <code>instance-attribute</code>", "text": "<pre><code>step_type: Literal['dummy']\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase", "title": "RmStepBase", "text": "<p>               Bases: <code>BaseModel</code></p> <p>Base class for RmSteps.</p> <p>Every non-abstract derived class must have a <code>step_type</code> class attribute, annotated with a <code>Literal</code> value type.</p> <p>See <code>DummyStep</code> below for an example.</p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>class RmStepBase(BaseModel, extra=\"forbid\"):\n    \"\"\"\n    Base class for RmSteps.\n\n    Every non-abstract derived class must have a `step_type` class attribute,\n    annotated with a `Literal` value type.\n\n    See `DummyStep` below for an example.\n    \"\"\"\n\n    __subclasses: ClassVar[set[type[RmStepBase]]] = set()\n\n    @classmethod\n    def _get_subclasses(cls) -&gt; set[type[RmStepBase]]:\n        \"\"\"Return a set of all concrete subclasses\"\"\"\n        return cls.__subclasses.copy()\n\n    def __init_subclass__(cls, **kwargs):\n        \"\"\"Capture a list of all concrete subclasses, including nested levels\"\"\"\n        super().__init_subclass__(**kwargs)\n\n        if inspect.isabstract(cls):\n            return  # do not consider intermediate abstract base classes\n\n        annotations = inspect.get_annotations(cls, eval_str=True)\n        assert \"step_type\" in annotations, \"step_type not in annotations\"\n        annotation_step_type = typing.get_origin(annotations[\"step_type\"])\n        assert annotation_step_type == Literal, (\n            f\"annotation {annotations['step_type']} for `{cls.__name__}.step_type` \"\n            f\"is not Literal but {annotation_step_type}\"\n        )\n        found_step_type = typing.get_args(annotations[\"step_type\"])[0]\n        if cls.__name__.lower().endswith(\"step\"):\n            assert found_step_type == cls.__name__.lower()[:-4], (\n                f\"annotation Literal value {found_step_type!r} \"\n                f\"for `{cls.__name__}.step_type` is not the same as the class name \"\n                f\"(omitting 'step' suffix)\"\n            )\n        else:\n            assert found_step_type == cls.__name__.lower(), (\n                f\"annotation Literal value {found_step_type!r} \"\n                f\"for `{cls.__name__}.step_type` is not the same as the class name\"\n            )\n        cls.__subclasses.add(cls)\n\n    @classmethod\n    def as_pydantic_field(cls):\n        \"\"\"Pydantic field as a union of all subclasses, discriminated on step_type.\"\"\"\n        if len(cls.__subclasses) &gt; 1:\n            return Annotated[\n                reduce(operator.__or__, cls.__subclasses),\n                Field(discriminator=\"step_type\"),\n            ]\n        else:  # only the DummyStep\n            return Annotated[reduce(operator.__or__, cls.__subclasses), Field()]\n\n    def _factory(self):\n        \"\"\"Generate a deep copy of this RmStep.\"\"\"\n        return self.model_copy(deep=True)\n\n    def use_config(self, config):\n        \"\"\"Some RM Steps might want to check parts of the config.\"\"\"\n        pass\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase.__subclasses", "title": "__subclasses  <code>class-attribute</code>", "text": "<pre><code>__subclasses: set[type[RmStepBase]] = set()\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase.__init_subclass__", "title": "__init_subclass__", "text": "<pre><code>__init_subclass__(**kwargs)\n</code></pre> <p>Capture a list of all concrete subclasses, including nested levels</p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>def __init_subclass__(cls, **kwargs):\n    \"\"\"Capture a list of all concrete subclasses, including nested levels\"\"\"\n    super().__init_subclass__(**kwargs)\n\n    if inspect.isabstract(cls):\n        return  # do not consider intermediate abstract base classes\n\n    annotations = inspect.get_annotations(cls, eval_str=True)\n    assert \"step_type\" in annotations, \"step_type not in annotations\"\n    annotation_step_type = typing.get_origin(annotations[\"step_type\"])\n    assert annotation_step_type == Literal, (\n        f\"annotation {annotations['step_type']} for `{cls.__name__}.step_type` \"\n        f\"is not Literal but {annotation_step_type}\"\n    )\n    found_step_type = typing.get_args(annotations[\"step_type\"])[0]\n    if cls.__name__.lower().endswith(\"step\"):\n        assert found_step_type == cls.__name__.lower()[:-4], (\n            f\"annotation Literal value {found_step_type!r} \"\n            f\"for `{cls.__name__}.step_type` is not the same as the class name \"\n            f\"(omitting 'step' suffix)\"\n        )\n    else:\n        assert found_step_type == cls.__name__.lower(), (\n            f\"annotation Literal value {found_step_type!r} \"\n            f\"for `{cls.__name__}.step_type` is not the same as the class name\"\n        )\n    cls.__subclasses.add(cls)\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase.as_pydantic_field", "title": "as_pydantic_field  <code>classmethod</code>", "text": "<pre><code>as_pydantic_field()\n</code></pre> <p>Pydantic field as a union of all subclasses, discriminated on step_type.</p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>@classmethod\ndef as_pydantic_field(cls):\n    \"\"\"Pydantic field as a union of all subclasses, discriminated on step_type.\"\"\"\n    if len(cls.__subclasses) &gt; 1:\n        return Annotated[\n            reduce(operator.__or__, cls.__subclasses),\n            Field(discriminator=\"step_type\"),\n        ]\n    else:  # only the DummyStep\n        return Annotated[reduce(operator.__or__, cls.__subclasses), Field()]\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase.use_config", "title": "use_config", "text": "<pre><code>use_config(config)\n</code></pre> <p>Some RM Steps might want to check parts of the config.</p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>def use_config(self, config):\n    \"\"\"Some RM Steps might want to check parts of the config.\"\"\"\n    pass\n</code></pre>"}, {"location": "API/config/rm_systems.html", "title": "RM Systems", "text": ""}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmProcess", "title": "RmProcess  <code>module-attribute</code>", "text": "<pre><code>RmProcess = ListOfNamed[RmStep]\n</code></pre>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmStep", "title": "RmStep  <code>module-attribute</code>", "text": "<pre><code>RmStep = as_pydantic_field()\n</code></pre>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem", "title": "RmSystem", "text": "<p>               Bases: <code>Named</code></p> Source code in <code>passengersim/config/rm_systems.py</code> <pre><code>class RmSystem(Named, extra=\"forbid\"):\n    processes: DictAttr[str, RmProcess]\n\n    availability_control: Literal[\n        \"infer\", \"leg\", \"cabin\", \"theft\", \"bp\", \"bp_loose\", \"vn\", \"none\"\n    ] = \"infer\"\n    \"\"\"Fare class availability algorithm for carriers using this RmSystem.\n\n    The default value will infer the appropriate control based on the steps in\n    the DCP process (This is pending implementation).\n\n    Allowed values include:\n    - \"leg\" (default): Uses leg-based controls.\n    - \"bp\": Bid price controls with strict resolution (fare must be strictly\n            greater than bid price).\n    - \"bp_loose\": Bid price controls with non-strict resolution (fare must be\n                  greater than *or equal to* bid price).\n    - \"vn\": Virtual nesting.\n    - \"none\": No controls.\n    \"\"\"\n\n    description: str = \"\"\n    \"\"\"Description of the RM system.\n\n    The description is optional and can be used to summarize the RM system.\n    It has no effect on the actual operation of the RM system.\"\"\"\n\n    frat5: str | None = None\n    \"\"\"Name of the FRAT5 curve to use.\n\n    This is the default that will be applied if not found at a more detailed\n    level (e.g. carrier level).\n    \"\"\"\n\n    @field_validator(\"processes\")\n    @classmethod\n    def _require_dcp_process(cls, value: dict[str, RmProcess]):\n        \"\"\"Ensure that every RmSystem is either empty or has a DCP process.\n\n        This validator also converts all keys to lowercase.\n        \"\"\"\n        lower_value = DictAttr()\n        for k, v in value.items():\n            lower_value[k.lower()] = v\n        if len(lower_value) and \"dcp\" not in lower_value:\n            raise ValueError(\"Non-empty RmSystem missing a `dcp` process.\")\n        return lower_value\n</code></pre>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem.availability_control", "title": "availability_control  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>availability_control: Literal[\n    \"infer\",\n    \"leg\",\n    \"cabin\",\n    \"theft\",\n    \"bp\",\n    \"bp_loose\",\n    \"vn\",\n    \"none\",\n] = \"infer\"\n</code></pre> <p>Fare class availability algorithm for carriers using this RmSystem.</p> <p>The default value will infer the appropriate control based on the steps in the DCP process (This is pending implementation).</p> <p>Allowed values include: - \"leg\" (default): Uses leg-based controls. - \"bp\": Bid price controls with strict resolution (fare must be strictly         greater than bid price). - \"bp_loose\": Bid price controls with non-strict resolution (fare must be               greater than or equal to bid price). - \"vn\": Virtual nesting. - \"none\": No controls.</p>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem.description", "title": "description  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>description: str = ''\n</code></pre> <p>Description of the RM system.</p> <p>The description is optional and can be used to summarize the RM system. It has no effect on the actual operation of the RM system.</p>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem.frat5", "title": "frat5  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frat5: str | None = None\n</code></pre> <p>Name of the FRAT5 curve to use.</p> <p>This is the default that will be applied if not found at a more detailed level (e.g. carrier level).</p>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem.processes", "title": "processes  <code>instance-attribute</code>", "text": "<pre><code>processes: DictAttr[str, RmProcess]\n</code></pre>"}, {"location": "API/config/snapshot_filter.html", "title": "Snapshot filter", "text": ""}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter", "title": "SnapshotFilter", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>class SnapshotFilter(BaseModel, validate_assignment=True):\n    type: Literal[\n        \"fare_adj\",\n        \"forecast\",\n        \"leg_untruncation\",\n        \"path_untruncation\",\n        \"rm\",\n        \"pro_bp\",\n        \"forecast_adj\",\n        \"hybrid\",\n        \"udp\",\n        None,\n    ] = None\n    title: str = \"\"\n    carrier: str = \"\"\n    trial: list[int] = []\n    sample: list[int] = []\n    dcp: list[int] = []\n    orig: list[str] = []\n    dest: list[str] = []\n    flt_no: list[int] = []\n    logger: str | None = None\n    directory: pathlib.Path | None = None\n\n    @field_validator(\"trial\", \"sample\", \"dcp\", \"orig\", \"dest\", \"flt_no\", mode=\"before\")\n    def _allow_singletons(cls, v):\n        \"\"\"Allow a singleton value that is converted to a list of one item.\"\"\"\n        if not isinstance(v, list | tuple):\n            v = [v]\n        return v\n\n    def filepath(self, sim, leg=None, path=None) -&gt; pathlib.Path | None:\n        if self.directory is None:\n            return None\n        pth = self.directory\n        if leg is not None:\n            pth = pth.joinpath(f\"carrier-{leg.carrier}\")\n        pth = pth.joinpath(f\"dpc-{sim.last_dcp}\")\n        if leg is not None:\n            pth = pth.joinpath(f\"orig-{leg.orig}\")\n        elif path is not None:\n            pth = pth.joinpath(f\"orig-{path.orig}\")\n        if leg is not None:\n            pth = pth.joinpath(f\"dest-{leg.dest}\")\n        elif path is not None:\n            pth = pth.joinpath(f\"dest-{path.dest}\")\n        if leg is not None:\n            pth = pth.joinpath(f\"fltno-{leg.flt_no}\")\n        elif path is not None:\n            pth = pth.joinpath(f\"fltno-{path.get_leg_fltno(0)}\")\n        if sim.num_trials &gt; 1:\n            pth = pth.joinpath(f\"trial-{sim.trial}\")\n        pth = pth.joinpath(f\"sample-{sim.sample}\")\n        pth.parent.mkdir(parents=True, exist_ok=True)\n        return pth.with_suffix(\".log\")\n\n    def run(\n        self, sim, leg=None, path=None, carrier=None, orig=None, dest=None, why=False\n    ) -&gt; SnapshotInstruction:\n        # Check the filter conditions\n        info = \"\"\n\n        if len(self.trial) &gt; 0 and sim.trial not in self.trial and sim.num_trials &gt; 1:\n            return SnapshotInstruction(False, why=f\"cause {sim.trial=}\")\n        info += f\"  trial={sim.trial}\"\n\n        if len(self.sample) &gt; 0 and sim.sample not in self.sample:\n            return SnapshotInstruction(False, why=f\"cause {sim.sample=}\")\n        info += f\"  sample={sim.sample}\"\n\n        if len(self.dcp) &gt; 0 and sim.last_dcp not in self.dcp:\n            return SnapshotInstruction(False, why=f\"cause {sim.last_dcp=}\")\n        info += f\"  dcp={sim.last_dcp}\"\n\n        if leg is not None:\n            if self.carrier and leg.carrier != self.carrier:\n                return SnapshotInstruction(False, why=f\"cause {leg.carrier=}\")\n            info += f\"  carrier={leg.carrier}\"\n\n            if len(self.orig) &gt; 0 and leg.orig not in self.orig:\n                return SnapshotInstruction(False, why=f\"cause {leg.orig=}\")\n            info += f\"  orig={leg.orig}\"\n\n            if len(self.dest) &gt; 0 and leg.dest not in self.dest:\n                return SnapshotInstruction(False, why=f\"cause {leg.dest=}\")\n            info += f\"  dest={leg.dest}\"\n\n            if len(self.flt_no) &gt; 0 and leg.flt_no not in self.flt_no:\n                return SnapshotInstruction(False, why=f\"cause {leg.flt_no=}\")\n            info += f\"  flt_no={leg.flt_no}\"\n\n        if path is not None:\n            if len(self.orig) &gt; 0 and path.orig not in self.orig:\n                return SnapshotInstruction(False, why=f\"cause {path.orig=}\")\n            info += f\"  orig={path.orig}\"\n\n            if len(self.dest) &gt; 0 and path.dest not in self.dest:\n                return SnapshotInstruction(False, why=f\"cause {path.dest=}\")\n            info += f\"  dest={path.dest}\"\n\n            if len(self.flt_no) &gt; 0 and path.get_leg_fltno(0) not in self.flt_no:\n                return SnapshotInstruction(False, why=f\"cause {path.get_leg_fltno(0)=}\")\n            info += f\"  flt_no={path.get_leg_fltno(0)}\"\n\n        if carrier is not None:\n            if self.carrier and carrier != self.carrier:\n                return SnapshotInstruction(False, why=f\"cause {carrier=}\")\n            info += f\"  carrier={carrier}\"\n\n        if orig is not None:\n            if self.orig and orig not in self.orig:\n                return SnapshotInstruction(False, why=f\"cause {orig=}\")\n            info += f\"  orig={orig}\"\n\n        if dest is not None:\n            if self.carrier and dest not in self.dest:\n                return SnapshotInstruction(False, why=f\"cause {dest=}\")\n            info += f\"  dest={dest}\"\n\n        # Now do something\n        snapshot_file = self.filepath(sim, leg, path)\n        created_date = time.strftime(\"Snapshot created %Y-%m-%d %A %I:%M:%S %p\")\n        title = f\"{self.title}:{info}\\n{created_date}\\n\"\n        if len(self.title) &gt; 0 and not snapshot_file:\n            print(f\"{self.title}:{info}\", flush=True)\n\n        self._last_run_info = info\n\n        if self.type in [\"fare_adj\"]:\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type in [\"leg_untruncation\", \"path_untruncation\"]:\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type in (\"forecast\", \"forecast_adj\"):\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type == \"hybrid\":\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type == \"rm\":\n            bucket_detail = leg.print_bucket_detail()\n            snapshot_file = self.filepath(sim, leg, path)\n            if snapshot_file:\n                with snapshot_file.open(mode=\"a\") as f:\n                    f.write(title)\n                    f.write(bucket_detail)\n            else:\n                print(bucket_detail)\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type == \"pro_bp\":\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type == \"udp\":\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n\n        raise ValueError(\"unknown snapshot filter type\")\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.carrier", "title": "carrier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier: str = ''\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.dcp", "title": "dcp  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcp: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.dest", "title": "dest  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dest: list[str] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.directory", "title": "directory  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>directory: Path | None = None\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.flt_no", "title": "flt_no  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>flt_no: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.orig", "title": "orig  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>orig: list[str] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.sample", "title": "sample  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>sample: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.title", "title": "title  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>title: str = ''\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.trial", "title": "trial  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>trial: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.type", "title": "type  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>type: Literal[\n    \"fare_adj\",\n    \"forecast\",\n    \"leg_untruncation\",\n    \"path_untruncation\",\n    \"rm\",\n    \"pro_bp\",\n    \"forecast_adj\",\n    \"hybrid\",\n    \"udp\",\n    None,\n] = None\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.filepath", "title": "filepath", "text": "<pre><code>filepath(sim, leg=None, path=None) -&gt; Path | None\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def filepath(self, sim, leg=None, path=None) -&gt; pathlib.Path | None:\n    if self.directory is None:\n        return None\n    pth = self.directory\n    if leg is not None:\n        pth = pth.joinpath(f\"carrier-{leg.carrier}\")\n    pth = pth.joinpath(f\"dpc-{sim.last_dcp}\")\n    if leg is not None:\n        pth = pth.joinpath(f\"orig-{leg.orig}\")\n    elif path is not None:\n        pth = pth.joinpath(f\"orig-{path.orig}\")\n    if leg is not None:\n        pth = pth.joinpath(f\"dest-{leg.dest}\")\n    elif path is not None:\n        pth = pth.joinpath(f\"dest-{path.dest}\")\n    if leg is not None:\n        pth = pth.joinpath(f\"fltno-{leg.flt_no}\")\n    elif path is not None:\n        pth = pth.joinpath(f\"fltno-{path.get_leg_fltno(0)}\")\n    if sim.num_trials &gt; 1:\n        pth = pth.joinpath(f\"trial-{sim.trial}\")\n    pth = pth.joinpath(f\"sample-{sim.sample}\")\n    pth.parent.mkdir(parents=True, exist_ok=True)\n    return pth.with_suffix(\".log\")\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.run", "title": "run", "text": "<pre><code>run(\n    sim,\n    leg=None,\n    path=None,\n    carrier=None,\n    orig=None,\n    dest=None,\n    why=False,\n) -&gt; SnapshotInstruction\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def run(\n    self, sim, leg=None, path=None, carrier=None, orig=None, dest=None, why=False\n) -&gt; SnapshotInstruction:\n    # Check the filter conditions\n    info = \"\"\n\n    if len(self.trial) &gt; 0 and sim.trial not in self.trial and sim.num_trials &gt; 1:\n        return SnapshotInstruction(False, why=f\"cause {sim.trial=}\")\n    info += f\"  trial={sim.trial}\"\n\n    if len(self.sample) &gt; 0 and sim.sample not in self.sample:\n        return SnapshotInstruction(False, why=f\"cause {sim.sample=}\")\n    info += f\"  sample={sim.sample}\"\n\n    if len(self.dcp) &gt; 0 and sim.last_dcp not in self.dcp:\n        return SnapshotInstruction(False, why=f\"cause {sim.last_dcp=}\")\n    info += f\"  dcp={sim.last_dcp}\"\n\n    if leg is not None:\n        if self.carrier and leg.carrier != self.carrier:\n            return SnapshotInstruction(False, why=f\"cause {leg.carrier=}\")\n        info += f\"  carrier={leg.carrier}\"\n\n        if len(self.orig) &gt; 0 and leg.orig not in self.orig:\n            return SnapshotInstruction(False, why=f\"cause {leg.orig=}\")\n        info += f\"  orig={leg.orig}\"\n\n        if len(self.dest) &gt; 0 and leg.dest not in self.dest:\n            return SnapshotInstruction(False, why=f\"cause {leg.dest=}\")\n        info += f\"  dest={leg.dest}\"\n\n        if len(self.flt_no) &gt; 0 and leg.flt_no not in self.flt_no:\n            return SnapshotInstruction(False, why=f\"cause {leg.flt_no=}\")\n        info += f\"  flt_no={leg.flt_no}\"\n\n    if path is not None:\n        if len(self.orig) &gt; 0 and path.orig not in self.orig:\n            return SnapshotInstruction(False, why=f\"cause {path.orig=}\")\n        info += f\"  orig={path.orig}\"\n\n        if len(self.dest) &gt; 0 and path.dest not in self.dest:\n            return SnapshotInstruction(False, why=f\"cause {path.dest=}\")\n        info += f\"  dest={path.dest}\"\n\n        if len(self.flt_no) &gt; 0 and path.get_leg_fltno(0) not in self.flt_no:\n            return SnapshotInstruction(False, why=f\"cause {path.get_leg_fltno(0)=}\")\n        info += f\"  flt_no={path.get_leg_fltno(0)}\"\n\n    if carrier is not None:\n        if self.carrier and carrier != self.carrier:\n            return SnapshotInstruction(False, why=f\"cause {carrier=}\")\n        info += f\"  carrier={carrier}\"\n\n    if orig is not None:\n        if self.orig and orig not in self.orig:\n            return SnapshotInstruction(False, why=f\"cause {orig=}\")\n        info += f\"  orig={orig}\"\n\n    if dest is not None:\n        if self.carrier and dest not in self.dest:\n            return SnapshotInstruction(False, why=f\"cause {dest=}\")\n        info += f\"  dest={dest}\"\n\n    # Now do something\n    snapshot_file = self.filepath(sim, leg, path)\n    created_date = time.strftime(\"Snapshot created %Y-%m-%d %A %I:%M:%S %p\")\n    title = f\"{self.title}:{info}\\n{created_date}\\n\"\n    if len(self.title) &gt; 0 and not snapshot_file:\n        print(f\"{self.title}:{info}\", flush=True)\n\n    self._last_run_info = info\n\n    if self.type in [\"fare_adj\"]:\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type in [\"leg_untruncation\", \"path_untruncation\"]:\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type in (\"forecast\", \"forecast_adj\"):\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type == \"hybrid\":\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type == \"rm\":\n        bucket_detail = leg.print_bucket_detail()\n        snapshot_file = self.filepath(sim, leg, path)\n        if snapshot_file:\n            with snapshot_file.open(mode=\"a\") as f:\n                f.write(title)\n                f.write(bucket_detail)\n        else:\n            print(bucket_detail)\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type == \"pro_bp\":\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type == \"udp\":\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n\n    raise ValueError(\"unknown snapshot filter type\")\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction", "title": "SnapshotInstruction", "text": "Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>class SnapshotInstruction:\n    def __init__(\n        self,\n        trigger: bool = False,\n        filepath: pathlib.Path | None = None,\n        why: str | None = None,\n        filter: SnapshotFilter | None = None,\n        mode: Literal[\"w\", \"a\"] = \"w\",\n    ):\n        self.trigger = bool(trigger)\n        \"\"\"Has this snapshot been triggered.\"\"\"\n        self.why = why\n        \"\"\"Explanation of why snapshot is (or is not) triggered.\"\"\"\n        self.filepath = filepath\n        \"\"\"Where to save snapshot content.\"\"\"\n        self.filter = filter\n        \"\"\"A reference to the filter that spawned this instruction.\"\"\"\n        self.mode = mode\n        \"\"\"Write mode for new content, `w` overwrites existing file, `a` appends.\"\"\"\n\n    def __bool__(self) -&gt; bool:\n        return self.trigger\n\n    def write(self, content: str = \"\"):\n        \"\"\"Write snapshot content to a file, or just print it\"\"\"\n        if not content:\n            return\n        if self.filepath:\n            with self.filepath.open(mode=self.mode) as f:\n                f.write(self.why)\n                f.write(\"\\n\")\n                if isinstance(content, bytes):\n                    content = content.decode(\"utf-8\")\n                elif not isinstance(content, str):\n                    content = str(content)\n                f.write(content)\n                if content[-1] != \"\\n\":\n                    f.write(\"\\n\")\n        else:\n            if self.why:\n                print(self.why)\n            print(content)\n\n    def write_more(self, content: str = \"\"):\n        \"\"\"Write additional snapshot content to a file, or just print it\"\"\"\n        if not content:\n            return\n        if self.filepath:\n            with self.filepath.open(mode=\"a\") as f:\n                if isinstance(content, bytes):\n                    content = content.decode(\"utf-8\")\n                elif not isinstance(content, str):\n                    content = str(content)\n                f.write(content)\n                if content[-1] != \"\\n\":\n                    f.write(\"\\n\")\n        else:\n            print(content)\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.filepath", "title": "filepath  <code>instance-attribute</code>", "text": "<pre><code>filepath = filepath\n</code></pre> <p>Where to save snapshot content.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.filter", "title": "filter  <code>instance-attribute</code>", "text": "<pre><code>filter = filter\n</code></pre> <p>A reference to the filter that spawned this instruction.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.mode", "title": "mode  <code>instance-attribute</code>", "text": "<pre><code>mode = mode\n</code></pre> <p>Write mode for new content, <code>w</code> overwrites existing file, <code>a</code> appends.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.trigger", "title": "trigger  <code>instance-attribute</code>", "text": "<pre><code>trigger = bool(trigger)\n</code></pre> <p>Has this snapshot been triggered.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.why", "title": "why  <code>instance-attribute</code>", "text": "<pre><code>why = why\n</code></pre> <p>Explanation of why snapshot is (or is not) triggered.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.__bool__", "title": "__bool__", "text": "<pre><code>__bool__() -&gt; bool\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    return self.trigger\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    trigger: bool = False,\n    filepath: Path | None = None,\n    why: str | None = None,\n    filter: SnapshotFilter | None = None,\n    mode: Literal[\"w\", \"a\"] = \"w\",\n)\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def __init__(\n    self,\n    trigger: bool = False,\n    filepath: pathlib.Path | None = None,\n    why: str | None = None,\n    filter: SnapshotFilter | None = None,\n    mode: Literal[\"w\", \"a\"] = \"w\",\n):\n    self.trigger = bool(trigger)\n    \"\"\"Has this snapshot been triggered.\"\"\"\n    self.why = why\n    \"\"\"Explanation of why snapshot is (or is not) triggered.\"\"\"\n    self.filepath = filepath\n    \"\"\"Where to save snapshot content.\"\"\"\n    self.filter = filter\n    \"\"\"A reference to the filter that spawned this instruction.\"\"\"\n    self.mode = mode\n    \"\"\"Write mode for new content, `w` overwrites existing file, `a` appends.\"\"\"\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.write", "title": "write", "text": "<pre><code>write(content: str = '')\n</code></pre> <p>Write snapshot content to a file, or just print it</p> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def write(self, content: str = \"\"):\n    \"\"\"Write snapshot content to a file, or just print it\"\"\"\n    if not content:\n        return\n    if self.filepath:\n        with self.filepath.open(mode=self.mode) as f:\n            f.write(self.why)\n            f.write(\"\\n\")\n            if isinstance(content, bytes):\n                content = content.decode(\"utf-8\")\n            elif not isinstance(content, str):\n                content = str(content)\n            f.write(content)\n            if content[-1] != \"\\n\":\n                f.write(\"\\n\")\n    else:\n        if self.why:\n            print(self.why)\n        print(content)\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.write_more", "title": "write_more", "text": "<pre><code>write_more(content: str = '')\n</code></pre> <p>Write additional snapshot content to a file, or just print it</p> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def write_more(self, content: str = \"\"):\n    \"\"\"Write additional snapshot content to a file, or just print it\"\"\"\n    if not content:\n        return\n    if self.filepath:\n        with self.filepath.open(mode=\"a\") as f:\n            if isinstance(content, bytes):\n                content = content.decode(\"utf-8\")\n            elif not isinstance(content, str):\n                content = str(content)\n            f.write(content)\n            if content[-1] != \"\\n\":\n                f.write(\"\\n\")\n    else:\n        print(content)\n</code></pre>"}, {"location": "API/config/standards.html", "title": "Standards", "text": ""}, {"location": "API/config/standards.html#passengersim.config.standards.describe_standard_rm_systems", "title": "describe_standard_rm_systems", "text": "<pre><code>describe_standard_rm_systems(stream=stdout) -&gt; str | None\n</code></pre> Source code in <code>passengersim/config/standards.py</code> <pre><code>def describe_standard_rm_systems(stream=sys.stdout) -&gt; str | None:\n    msg = \"\"\n    d = standard_rm_systems_raw()\n    for k in d:\n        msg += f\"{k}:\\n\"\n        msg += textwrap.fill(\n            d[k].get(\"description\", \"no description available\"),\n            70,\n            initial_indent=\"  \",\n            subsequent_indent=\"  \",\n        )\n        msg += \"\\n\"\n    if stream is None:\n        return msg\n    print(msg, file=stream)\n</code></pre>"}, {"location": "API/config/standards.html#passengersim.config.standards.standard_rm_systems_raw", "title": "standard_rm_systems_raw", "text": "<pre><code>standard_rm_systems_raw() -&gt; Dict\n</code></pre> Source code in <code>passengersim/config/standards.py</code> <pre><code>def standard_rm_systems_raw() -&gt; addicty.Dict:\n    with open(demo_network(\"standard-rm-systems.yaml\")) as f:\n        d = addicty.Dict.load(f, freeze=False, Loader=yaml.CSafeLoader)\n    if \"rm_systems\" not in d:\n        d.rm_systems = addicty.Dict()\n    return d.rm_systems\n</code></pre>"}, {"location": "API/config/todd_curves.html", "title": "Booking Curves", "text": ""}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve", "title": "ToddCurve", "text": "<p>               Bases: <code>PrettyModel</code></p> <p>Customer preference data for Time Of Day</p> Source code in <code>passengersim/config/todd_curves.py</code> <pre><code>class ToddCurve(PrettyModel, extra=\"forbid\"):\n    \"\"\"\n    Customer preference data for Time Of Day\n    \"\"\"\n\n    name: str = \"???\"\n    min_distance: int = 0\n    max_distance: int = 25000\n    k_factor: float = 3.0\n    early_dep: dict | None = None\n    late_arr: dict | None = None\n    replanning: tuple[float, float] | None = None\n\n    probabilities: dict[int, float] | list[float] = None\n    \"\"\"Define a TODD curve.\n\n\n    Example\n    -------\n    ```{yaml}\n    - name: business\n      curve:\n        63: 0.01\n        56: 0.02\n        49: 0.05\n        42: 0.13\n        35: 0.19\n        31: 0.23\n        28: 0.29\n        24: 0.35\n        21: 0.45\n        17: 0.54\n        14: 0.67\n        10: 0.79\n        7: 0.86\n        5: 0.91\n        3: 0.96\n        1: 1.0\n    ```\n    \"\"\"\n</code></pre>"}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve.early_dep", "title": "early_dep  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>early_dep: dict | None = None\n</code></pre>"}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve.k_factor", "title": "k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>k_factor: float = 3.0\n</code></pre>"}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve.late_arr", "title": "late_arr  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>late_arr: dict | None = None\n</code></pre>"}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve.max_distance", "title": "max_distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>max_distance: int = 25000\n</code></pre>"}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve.min_distance", "title": "min_distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>min_distance: int = 0\n</code></pre>"}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve.name", "title": "name  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>name: str = '???'\n</code></pre>"}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve.probabilities", "title": "probabilities  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>probabilities: dict[int, float] | list[float] = None\n</code></pre> <p>Define a TODD curve.</p> Example <pre><code>- name: business\n  curve:\n    63: 0.01\n    56: 0.02\n    49: 0.05\n    42: 0.13\n    35: 0.19\n    31: 0.23\n    28: 0.29\n    24: 0.35\n    21: 0.45\n    17: 0.54\n    14: 0.67\n    10: 0.79\n    7: 0.86\n    5: 0.91\n    3: 0.96\n    1: 1.0\n</code></pre>"}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve.replanning", "title": "replanning  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>replanning: tuple[float, float] | None = None\n</code></pre>"}, {"location": "API/database/index.html", "title": "Database", "text": ""}, {"location": "API/database/index.html#passengersim.database.database.leg_bucket_sql", "title": "leg_bucket_sql  <code>module-attribute</code>", "text": "<pre><code>leg_bucket_sql = {}\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.n_commit", "title": "n_commit  <code>module-attribute</code>", "text": "<pre><code>n_commit = 0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database", "title": "Database", "text": "<p>A wrapper to manage transactions for PassengerSim on SQLite.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>class Database:\n    \"\"\"A wrapper to manage transactions for PassengerSim on SQLite.\"\"\"\n\n    def __init__(\n        self,\n        engine: Literal[\"sqlite\", None] = \"sqlite\",\n        filename=None,\n        pragmas: Iterable[str] = (),\n        commit_count_delay: int | None = 250,\n    ):\n        if isinstance(engine, str) and engine.endswith(\".sqlite\") and filename is None:\n            filename = engine\n            engine = \"sqlite\"\n        self._connection = None\n        self.engine = engine\n        self.filename = filename\n        self.pragmas = pragmas\n        self._counter = 0\n        self._commit_count_delay = commit_count_delay\n        if self._commit_count_delay is not None:\n            self.commit = self._commit_by_count\n        else:\n            self.commit = self._commit_raw\n        self.open()\n\n    def __getattr__(self, item):\n        return getattr(self._connection, item)\n\n    def open(self, filename: str | None = None):\n        \"\"\"Open the connection if it is not already open.\"\"\"\n        if self._connection is not None:\n            raise ConnectionError(\"the connection is already open\")\n        self.filename = filename or self.filename\n        if self.engine is None:\n            self._connection = None\n        elif self.engine == \"sqlite\" and self.filename is None:\n            self._connection = None\n        elif self.engine == \"sqlite\":\n            if self.filename != \":memory:\":\n                Path(self.filename).parent.mkdir(exist_ok=True, parents=True)\n            logger.info(f\"connecting to sqlite database: {self.filename}\")\n            self._connection = sqlite3.Connection(self.filename)\n            self._connection.create_aggregate(\"VARIANCE\", 1, _VarianceFunc)\n            self._connection.create_aggregate(\"STDEV\", 1, _StdevFunc)\n            for pragma in self.pragmas:\n                self._connection.execute(f\"PRAGMA {pragma};\")\n            self._connection.execute(\"BEGIN TRANSACTION;\")\n            logger.debug(\"initializing sqlite tables\")\n            from .tables import create_tables\n\n            create_tables(self)\n        else:\n            raise NotImplementedError(f\"unknown engine {self.engine!r}\")\n\n    def close(self):\n        \"\"\"Flush pending operations and close the connection.\"\"\"\n        if self._connection:\n            if self._connection.in_transaction:\n                self._connection.execute(\"COMMIT;\")\n            self._connection.close()\n            self._connection = None\n\n    def _commit_by_count(self):\n        self._counter += 1\n        if self._counter &gt;= self._commit_count_delay:\n            self._commit_raw()\n            self._counter = 0\n\n    def _commit_raw(self):\n        if self._connection:\n            if self._connection.in_transaction:\n                self._connection.execute(\"COMMIT;\")\n            self._connection.execute(\"BEGIN TRANSACTION;\")\n\n    def __enter__(self):\n        if self._connection:\n            return self._connection.__enter__()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self._connection:\n            return self._connection.__exit__(exc_type, exc_val, exc_tb)\n\n    @property\n    def is_open(self) -&gt; bool:\n        return self._connection is not None\n\n    def sql_placeholders(self, n: int):\n        \"\"\"A parenthesis enclosed set of `n` placeholders for the selected engine.\"\"\"\n        if self.engine == \"sqlite\":\n            x = \"?\"\n        else:\n            x = \"%s\"\n        return \"(\" + \", \".join(x for _ in range(n)) + \")\"\n\n    def delete_experiment(self, name: str):\n        if self.is_open:\n            logger.debug(f\"deleting existing scenario {name!r} from database\")\n            self.execute(\"DELETE FROM leg_detail WHERE scenario = ?\", (name,))\n            self.execute(\"DELETE FROM leg_bucket_detail WHERE scenario = ?\", (name,))\n            self.execute(\"DELETE FROM demand_detail WHERE scenario = ?\", (name,))\n            self.execute(\"DELETE FROM fare_detail WHERE scenario = ?\", (name,))\n            self._commit_raw()\n        else:\n            logger.debug(f\"database not open, cannot delete {name!r}\")\n\n    def save_configs(self, cfg: Config) -&gt; None:\n        \"\"\"Save configs into the database.\"\"\"\n        from passengersim import __version__\n\n        self.execute(\n            \"\"\"\n        INSERT OR REPLACE INTO runtime_configs(\n            scenario, pxsim_version, configs\n        ) VALUES (?1, ?2, ?3)\n        \"\"\",\n            (\n                cfg.scenario,\n                str(__version__),\n                cfg.model_dump_json(\n                    exclude={\"db\": \"dcp_write_hooks\", \"raw_license_certificate\": True}\n                ),\n            ),\n        )\n\n    def load_raw_configs(self, scenario=None) -&gt; dict | Any:\n        import json\n\n        if scenario:\n            rawjson = next(\n                self.execute(\n                    \"SELECT configs, max(updated_at) FROM runtime_configs \"\n                    \"WHERE scenario = ?1\",\n                    (scenario,),\n                )\n            )[0]\n        else:\n            rawjson = next(\n                self.execute(\"SELECT configs, max(updated_at) FROM runtime_configs\")\n            )[0]\n        result = json.loads(rawjson)\n        if not isinstance(result, dict):\n            warnings.warn(\"malformed configs, not a mapping\", stacklevel=2)\n        return result\n\n    def load_configs(\n        self, scenario=None, on_validation_error: Literal[\"raise\", \"ignore\"] = \"raise\"\n    ) -&gt; Config | Any:\n        raw = self.load_raw_configs(scenario)\n\n        from pydantic import ValidationError\n\n        try:\n            return Config.model_validate(raw)\n        except ValidationError as err:\n            logger.error(f\"error loading configs: {err}\")\n            if on_validation_error == \"raise\":\n                raise\n            else:\n                return raw\n\n    def save_details(self: Database, db_writer: DbWriter, sim: SimulationEngine, dcp: int):\n        \"\"\"\n        Save details, can be done at each RRD/DCP and at the end of the run\n        \"\"\"\n        if not sim.save_timeframe_details and dcp &gt; 0:\n            return\n        if sim.config.db.fast and isinstance(self._connection, sqlite3.Connection):\n            _internal_log = db_writer.write_to_sqlite(\n                self._connection,\n                dcp,\n                store_bid_prices=sim.config.db.store_leg_bid_prices,\n                store_displacements=sim.config.db.store_displacements,\n            )\n        else:\n            for leg in sim.legs:\n                if \"leg\" in sim.config.db.write_items:\n                    save_leg(self, sim, leg, dcp)\n                if \"bucket\" in sim.config.db.write_items:\n                    save_leg_bucket_multi(self, sim, leg, dcp)\n            if \"fare\" in sim.config.db.write_items:\n                save_fare_multi(self, sim, dcp)\n            if \"demand\" in sim.config.db.write_items:\n                save_demand_multi(self, sim, dcp)\n        # hooks for custom writers written in Python, may be slow\n        for f in sim.config.db.dcp_write_hooks:\n            f(self, sim, dcp)\n        self.commit()\n\n    def save_final(self: Database, sim: SimulationEngine):\n        sim.final_write_to_sqlite(self._connection)\n\n    def dataframe(\n        self, query: str, params: list | tuple | dict | None = None, dtype=None\n    ):\n        \"\"\"Run a SQL query and return the results as a pandas DataFrame.\"\"\"\n        if not self.is_open:\n            raise ValueError(\"database is not open\")\n        import pandas as pd\n\n        return pd.read_sql_query(query, self._connection, params=params, dtype=dtype)\n\n    def schema(self, name: str):\n        \"\"\"Get a table schema from the SQLite database.\"\"\"\n        if not self.is_open:\n            raise ValueError(\"database is not open\")\n        try:\n            return next(\n                self.execute(\"SELECT sql FROM sqlite_master WHERE name = ?1\", (name,))\n            )[0]\n        except Exception:\n            raise\n\n    def save_dataframe(\n        self,\n        name: str,\n        df: pd.DataFrame,\n        if_exists: Literal[\"fail\", \"replace\", \"append\"] = \"replace\",\n    ):\n        \"\"\"Save a dataframe as a table in this database.\"\"\"\n        df.to_sql(name, self._connection, if_exists=if_exists)\n\n    def table_names(self) -&gt; list[str]:\n        \"\"\"List of all tables in the database.\"\"\"\n        qry = \"SELECT name FROM sqlite_master WHERE type=='table'\"\n        return [i[0] for i in self._connection.execute(qry)]\n\n    def table_info(self, table_name: str) -&gt; pd.DataFrame:\n        \"\"\"Get info about a table\"\"\"\n        df = self.dataframe(f\"PRAGMA table_info({table_name})\")\n        return df.set_index(\"cid\")\n\n    def index_names(self, table_name) -&gt; list[str]:\n        \"\"\"List of all named indexes on a given table.\"\"\"\n        qry = \"SELECT name FROM sqlite_master WHERE type=='index' AND tbl_name==?1\"\n        return [i[0] for i in self._connection.execute(qry, (table_name,))]\n\n    def add_indexes(self, fare_detail=True, leg_detail=True):\n        any_work = False\n        if fare_detail and \"fare_detail_idx_2\" not in self.index_names(\"fare_detail\"):\n            logger.info(\"adding index on fare_detail\")\n            idx = \"\"\"\n            CREATE INDEX fare_detail_idx_2\n            ON fare_detail (\n                fare_id, scenario, trial, sample, days_prior\n            );\n            \"\"\"\n            self._connection.execute(idx)\n            self._connection.commit()\n            self._connection.execute(\"BEGIN TRANSACTION;\")\n            any_work = True\n\n        if leg_detail and \"leg_detail_idx_2\" not in self.index_names(\"leg_detail\"):\n            logger.info(\"adding index on leg_detail\")\n            idx = \"\"\"\n            CREATE INDEX leg_detail_idx_2\n            ON leg_detail (scenario, trial, sample, days_prior, leg_id);\n            \"\"\"\n            self._connection.execute(idx)\n            self._connection.commit()\n            self._connection.execute(\"BEGIN TRANSACTION;\")\n            any_work = True\n\n        if any_work:\n            logger.info(\"completed adding indexes\")\n\n    def backup(self, dst: Path | str | sqlite3.Connection, show_progress: bool = True):\n        \"\"\"Back up this database to another copy.\"\"\"\n        if self.engine != \"sqlite\":\n            raise NotImplementedError(f\"no backup available for engine={self.engine!r}\")\n        if not self.is_open:\n            raise OSError(\"database connection is not open\")\n\n        def _progress(status, remaining, total):\n            if remaining:\n                print(f\"Copied {total - remaining} of {total} pages...\")\n            else:\n                print(f\"Copied all {total} pages.\")\n\n        if not isinstance(dst, sqlite3.Connection):\n            dst = sqlite3.connect(dst)\n        if self._connection.in_transaction:\n            self._connection.execute(\"COMMIT;\")\n        with dst:\n            self._connection.backup(\n                dst, pages=10000, progress=_progress if show_progress else None\n            )\n        self._connection.execute(\"BEGIN TRANSACTION;\")\n        dst.close()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._commit_count_delay", "title": "_commit_count_delay  <code>instance-attribute</code>", "text": "<pre><code>_commit_count_delay = commit_count_delay\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._connection", "title": "_connection  <code>instance-attribute</code>", "text": "<pre><code>_connection = None\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._counter", "title": "_counter  <code>instance-attribute</code>", "text": "<pre><code>_counter = 0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.commit", "title": "commit  <code>instance-attribute</code>", "text": "<pre><code>commit = _commit_by_count\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.engine", "title": "engine  <code>instance-attribute</code>", "text": "<pre><code>engine = engine\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.filename", "title": "filename  <code>instance-attribute</code>", "text": "<pre><code>filename = filename\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.is_open", "title": "is_open  <code>property</code>", "text": "<pre><code>is_open: bool\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.pragmas", "title": "pragmas  <code>instance-attribute</code>", "text": "<pre><code>pragmas = pragmas\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.__enter__", "title": "__enter__", "text": "<pre><code>__enter__()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __enter__(self):\n    if self._connection:\n        return self._connection.__enter__()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.__exit__", "title": "__exit__", "text": "<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    if self._connection:\n        return self._connection.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.__getattr__", "title": "__getattr__", "text": "<pre><code>__getattr__(item)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __getattr__(self, item):\n    return getattr(self._connection, item)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    engine: Literal[\"sqlite\", None] = \"sqlite\",\n    filename=None,\n    pragmas: Iterable[str] = (),\n    commit_count_delay: int | None = 250,\n)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __init__(\n    self,\n    engine: Literal[\"sqlite\", None] = \"sqlite\",\n    filename=None,\n    pragmas: Iterable[str] = (),\n    commit_count_delay: int | None = 250,\n):\n    if isinstance(engine, str) and engine.endswith(\".sqlite\") and filename is None:\n        filename = engine\n        engine = \"sqlite\"\n    self._connection = None\n    self.engine = engine\n    self.filename = filename\n    self.pragmas = pragmas\n    self._counter = 0\n    self._commit_count_delay = commit_count_delay\n    if self._commit_count_delay is not None:\n        self.commit = self._commit_by_count\n    else:\n        self.commit = self._commit_raw\n    self.open()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._commit_by_count", "title": "_commit_by_count", "text": "<pre><code>_commit_by_count()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def _commit_by_count(self):\n    self._counter += 1\n    if self._counter &gt;= self._commit_count_delay:\n        self._commit_raw()\n        self._counter = 0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._commit_raw", "title": "_commit_raw", "text": "<pre><code>_commit_raw()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def _commit_raw(self):\n    if self._connection:\n        if self._connection.in_transaction:\n            self._connection.execute(\"COMMIT;\")\n        self._connection.execute(\"BEGIN TRANSACTION;\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.add_indexes", "title": "add_indexes", "text": "<pre><code>add_indexes(fare_detail=True, leg_detail=True)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def add_indexes(self, fare_detail=True, leg_detail=True):\n    any_work = False\n    if fare_detail and \"fare_detail_idx_2\" not in self.index_names(\"fare_detail\"):\n        logger.info(\"adding index on fare_detail\")\n        idx = \"\"\"\n        CREATE INDEX fare_detail_idx_2\n        ON fare_detail (\n            fare_id, scenario, trial, sample, days_prior\n        );\n        \"\"\"\n        self._connection.execute(idx)\n        self._connection.commit()\n        self._connection.execute(\"BEGIN TRANSACTION;\")\n        any_work = True\n\n    if leg_detail and \"leg_detail_idx_2\" not in self.index_names(\"leg_detail\"):\n        logger.info(\"adding index on leg_detail\")\n        idx = \"\"\"\n        CREATE INDEX leg_detail_idx_2\n        ON leg_detail (scenario, trial, sample, days_prior, leg_id);\n        \"\"\"\n        self._connection.execute(idx)\n        self._connection.commit()\n        self._connection.execute(\"BEGIN TRANSACTION;\")\n        any_work = True\n\n    if any_work:\n        logger.info(\"completed adding indexes\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.backup", "title": "backup", "text": "<pre><code>backup(\n    dst: Path | str | Connection, show_progress: bool = True\n)\n</code></pre> <p>Back up this database to another copy.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def backup(self, dst: Path | str | sqlite3.Connection, show_progress: bool = True):\n    \"\"\"Back up this database to another copy.\"\"\"\n    if self.engine != \"sqlite\":\n        raise NotImplementedError(f\"no backup available for engine={self.engine!r}\")\n    if not self.is_open:\n        raise OSError(\"database connection is not open\")\n\n    def _progress(status, remaining, total):\n        if remaining:\n            print(f\"Copied {total - remaining} of {total} pages...\")\n        else:\n            print(f\"Copied all {total} pages.\")\n\n    if not isinstance(dst, sqlite3.Connection):\n        dst = sqlite3.connect(dst)\n    if self._connection.in_transaction:\n        self._connection.execute(\"COMMIT;\")\n    with dst:\n        self._connection.backup(\n            dst, pages=10000, progress=_progress if show_progress else None\n        )\n    self._connection.execute(\"BEGIN TRANSACTION;\")\n    dst.close()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.close", "title": "close", "text": "<pre><code>close()\n</code></pre> <p>Flush pending operations and close the connection.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def close(self):\n    \"\"\"Flush pending operations and close the connection.\"\"\"\n    if self._connection:\n        if self._connection.in_transaction:\n            self._connection.execute(\"COMMIT;\")\n        self._connection.close()\n        self._connection = None\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.dataframe", "title": "dataframe", "text": "<pre><code>dataframe(\n    query: str,\n    params: list | tuple | dict | None = None,\n    dtype=None,\n)\n</code></pre> <p>Run a SQL query and return the results as a pandas DataFrame.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def dataframe(\n    self, query: str, params: list | tuple | dict | None = None, dtype=None\n):\n    \"\"\"Run a SQL query and return the results as a pandas DataFrame.\"\"\"\n    if not self.is_open:\n        raise ValueError(\"database is not open\")\n    import pandas as pd\n\n    return pd.read_sql_query(query, self._connection, params=params, dtype=dtype)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.delete_experiment", "title": "delete_experiment", "text": "<pre><code>delete_experiment(name: str)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def delete_experiment(self, name: str):\n    if self.is_open:\n        logger.debug(f\"deleting existing scenario {name!r} from database\")\n        self.execute(\"DELETE FROM leg_detail WHERE scenario = ?\", (name,))\n        self.execute(\"DELETE FROM leg_bucket_detail WHERE scenario = ?\", (name,))\n        self.execute(\"DELETE FROM demand_detail WHERE scenario = ?\", (name,))\n        self.execute(\"DELETE FROM fare_detail WHERE scenario = ?\", (name,))\n        self._commit_raw()\n    else:\n        logger.debug(f\"database not open, cannot delete {name!r}\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.index_names", "title": "index_names", "text": "<pre><code>index_names(table_name) -&gt; list[str]\n</code></pre> <p>List of all named indexes on a given table.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def index_names(self, table_name) -&gt; list[str]:\n    \"\"\"List of all named indexes on a given table.\"\"\"\n    qry = \"SELECT name FROM sqlite_master WHERE type=='index' AND tbl_name==?1\"\n    return [i[0] for i in self._connection.execute(qry, (table_name,))]\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.load_configs", "title": "load_configs", "text": "<pre><code>load_configs(\n    scenario=None,\n    on_validation_error: Literal[\n        \"raise\", \"ignore\"\n    ] = \"raise\",\n) -&gt; Config | Any\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def load_configs(\n    self, scenario=None, on_validation_error: Literal[\"raise\", \"ignore\"] = \"raise\"\n) -&gt; Config | Any:\n    raw = self.load_raw_configs(scenario)\n\n    from pydantic import ValidationError\n\n    try:\n        return Config.model_validate(raw)\n    except ValidationError as err:\n        logger.error(f\"error loading configs: {err}\")\n        if on_validation_error == \"raise\":\n            raise\n        else:\n            return raw\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.load_raw_configs", "title": "load_raw_configs", "text": "<pre><code>load_raw_configs(scenario=None) -&gt; dict | Any\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def load_raw_configs(self, scenario=None) -&gt; dict | Any:\n    import json\n\n    if scenario:\n        rawjson = next(\n            self.execute(\n                \"SELECT configs, max(updated_at) FROM runtime_configs \"\n                \"WHERE scenario = ?1\",\n                (scenario,),\n            )\n        )[0]\n    else:\n        rawjson = next(\n            self.execute(\"SELECT configs, max(updated_at) FROM runtime_configs\")\n        )[0]\n    result = json.loads(rawjson)\n    if not isinstance(result, dict):\n        warnings.warn(\"malformed configs, not a mapping\", stacklevel=2)\n    return result\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.open", "title": "open", "text": "<pre><code>open(filename: str | None = None)\n</code></pre> <p>Open the connection if it is not already open.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def open(self, filename: str | None = None):\n    \"\"\"Open the connection if it is not already open.\"\"\"\n    if self._connection is not None:\n        raise ConnectionError(\"the connection is already open\")\n    self.filename = filename or self.filename\n    if self.engine is None:\n        self._connection = None\n    elif self.engine == \"sqlite\" and self.filename is None:\n        self._connection = None\n    elif self.engine == \"sqlite\":\n        if self.filename != \":memory:\":\n            Path(self.filename).parent.mkdir(exist_ok=True, parents=True)\n        logger.info(f\"connecting to sqlite database: {self.filename}\")\n        self._connection = sqlite3.Connection(self.filename)\n        self._connection.create_aggregate(\"VARIANCE\", 1, _VarianceFunc)\n        self._connection.create_aggregate(\"STDEV\", 1, _StdevFunc)\n        for pragma in self.pragmas:\n            self._connection.execute(f\"PRAGMA {pragma};\")\n        self._connection.execute(\"BEGIN TRANSACTION;\")\n        logger.debug(\"initializing sqlite tables\")\n        from .tables import create_tables\n\n        create_tables(self)\n    else:\n        raise NotImplementedError(f\"unknown engine {self.engine!r}\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.save_configs", "title": "save_configs", "text": "<pre><code>save_configs(cfg: Config) -&gt; None\n</code></pre> <p>Save configs into the database.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_configs(self, cfg: Config) -&gt; None:\n    \"\"\"Save configs into the database.\"\"\"\n    from passengersim import __version__\n\n    self.execute(\n        \"\"\"\n    INSERT OR REPLACE INTO runtime_configs(\n        scenario, pxsim_version, configs\n    ) VALUES (?1, ?2, ?3)\n    \"\"\",\n        (\n            cfg.scenario,\n            str(__version__),\n            cfg.model_dump_json(\n                exclude={\"db\": \"dcp_write_hooks\", \"raw_license_certificate\": True}\n            ),\n        ),\n    )\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.save_dataframe", "title": "save_dataframe", "text": "<pre><code>save_dataframe(\n    name: str,\n    df: DataFrame,\n    if_exists: Literal[\n        \"fail\", \"replace\", \"append\"\n    ] = \"replace\",\n)\n</code></pre> <p>Save a dataframe as a table in this database.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_dataframe(\n    self,\n    name: str,\n    df: pd.DataFrame,\n    if_exists: Literal[\"fail\", \"replace\", \"append\"] = \"replace\",\n):\n    \"\"\"Save a dataframe as a table in this database.\"\"\"\n    df.to_sql(name, self._connection, if_exists=if_exists)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.save_details", "title": "save_details", "text": "<pre><code>save_details(\n    db_writer: DbWriter, sim: SimulationEngine, dcp: int\n)\n</code></pre> <p>Save details, can be done at each RRD/DCP and at the end of the run</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_details(self: Database, db_writer: DbWriter, sim: SimulationEngine, dcp: int):\n    \"\"\"\n    Save details, can be done at each RRD/DCP and at the end of the run\n    \"\"\"\n    if not sim.save_timeframe_details and dcp &gt; 0:\n        return\n    if sim.config.db.fast and isinstance(self._connection, sqlite3.Connection):\n        _internal_log = db_writer.write_to_sqlite(\n            self._connection,\n            dcp,\n            store_bid_prices=sim.config.db.store_leg_bid_prices,\n            store_displacements=sim.config.db.store_displacements,\n        )\n    else:\n        for leg in sim.legs:\n            if \"leg\" in sim.config.db.write_items:\n                save_leg(self, sim, leg, dcp)\n            if \"bucket\" in sim.config.db.write_items:\n                save_leg_bucket_multi(self, sim, leg, dcp)\n        if \"fare\" in sim.config.db.write_items:\n            save_fare_multi(self, sim, dcp)\n        if \"demand\" in sim.config.db.write_items:\n            save_demand_multi(self, sim, dcp)\n    # hooks for custom writers written in Python, may be slow\n    for f in sim.config.db.dcp_write_hooks:\n        f(self, sim, dcp)\n    self.commit()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.save_final", "title": "save_final", "text": "<pre><code>save_final(sim: SimulationEngine)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_final(self: Database, sim: SimulationEngine):\n    sim.final_write_to_sqlite(self._connection)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.schema", "title": "schema", "text": "<pre><code>schema(name: str)\n</code></pre> <p>Get a table schema from the SQLite database.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def schema(self, name: str):\n    \"\"\"Get a table schema from the SQLite database.\"\"\"\n    if not self.is_open:\n        raise ValueError(\"database is not open\")\n    try:\n        return next(\n            self.execute(\"SELECT sql FROM sqlite_master WHERE name = ?1\", (name,))\n        )[0]\n    except Exception:\n        raise\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.sql_placeholders", "title": "sql_placeholders", "text": "<pre><code>sql_placeholders(n: int)\n</code></pre> <p>A parenthesis enclosed set of <code>n</code> placeholders for the selected engine.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def sql_placeholders(self, n: int):\n    \"\"\"A parenthesis enclosed set of `n` placeholders for the selected engine.\"\"\"\n    if self.engine == \"sqlite\":\n        x = \"?\"\n    else:\n        x = \"%s\"\n    return \"(\" + \", \".join(x for _ in range(n)) + \")\"\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.table_info", "title": "table_info", "text": "<pre><code>table_info(table_name: str) -&gt; DataFrame\n</code></pre> <p>Get info about a table</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def table_info(self, table_name: str) -&gt; pd.DataFrame:\n    \"\"\"Get info about a table\"\"\"\n    df = self.dataframe(f\"PRAGMA table_info({table_name})\")\n    return df.set_index(\"cid\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.table_names", "title": "table_names", "text": "<pre><code>table_names() -&gt; list[str]\n</code></pre> <p>List of all tables in the database.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def table_names(self) -&gt; list[str]:\n    \"\"\"List of all tables in the database.\"\"\"\n    qry = \"SELECT name FROM sqlite_master WHERE type=='table'\"\n    return [i[0] for i in self._connection.execute(qry)]\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._StdevFunc", "title": "_StdevFunc", "text": "<p>               Bases: <code>_VarianceFunc</code></p> Source code in <code>passengersim/database/database.py</code> <pre><code>class _StdevFunc(_VarianceFunc):\n    def finalize(self):\n        if self.k &lt; 3:\n            return None\n        return math.sqrt(self.S / (self.k - 2))\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._StdevFunc.finalize", "title": "finalize", "text": "<pre><code>finalize()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def finalize(self):\n    if self.k &lt; 3:\n        return None\n    return math.sqrt(self.S / (self.k - 2))\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc", "title": "_VarianceFunc", "text": "Source code in <code>passengersim/database/database.py</code> <pre><code>class _VarianceFunc:\n    def __init__(self):\n        self.M = 0.0\n        self.S = 0.0\n        self.k = 1\n\n    def step(self, value):\n        if value is None:\n            return\n        tM = self.M\n        self.M += (value - tM) / self.k\n        self.S += (value - tM) * (value - self.M)\n        self.k += 1\n\n    def finalize(self):\n        if self.k &lt; 3:\n            return None\n        return self.S / (self.k - 2)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.M", "title": "M  <code>instance-attribute</code>", "text": "<pre><code>M = 0.0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.S", "title": "S  <code>instance-attribute</code>", "text": "<pre><code>S = 0.0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.k", "title": "k  <code>instance-attribute</code>", "text": "<pre><code>k = 1\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.__init__", "title": "__init__", "text": "<pre><code>__init__()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __init__(self):\n    self.M = 0.0\n    self.S = 0.0\n    self.k = 1\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.finalize", "title": "finalize", "text": "<pre><code>finalize()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def finalize(self):\n    if self.k &lt; 3:\n        return None\n    return self.S / (self.k - 2)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.step", "title": "step", "text": "<pre><code>step(value)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def step(self, value):\n    if value is None:\n        return\n    tM = self.M\n    self.M += (value - tM) / self.k\n    self.S += (value - tM) * (value - self.M)\n    self.k += 1\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.compute_rrd", "title": "compute_rrd", "text": "<pre><code>compute_rrd(sim: SimulationEngine, dep_time: float)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def compute_rrd(sim: SimulationEngine, dep_time: float):\n    tmp = int(dep_time / 86400) * 86400\n    days_prior = int((tmp - sim.last_event_time) / 86400)\n    if sim.num_events() == 0:\n        days_prior = 0\n    return days_prior\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.delete_experiment", "title": "delete_experiment", "text": "<pre><code>delete_experiment(cnx: Database, name)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def delete_experiment(cnx: Database, name):\n    with cnx:\n        logger.info(f\"deleting existing scenario {name!r} from database\")\n        cnx.execute(f\"DELETE FROM leg_detail WHERE scenario = '{name}' \")\n        cnx.execute(f\"DELETE FROM leg_bucket_detail WHERE scenario = '{name}' \")\n        cnx.execute(f\"DELETE FROM demand_detail WHERE scenario = '{name}' \")\n        cnx.execute(f\"DELETE FROM fare_detail WHERE scenario = '{name}' \")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.get_database_connection", "title": "get_database_connection", "text": "<pre><code>get_database_connection(\n    engine: Literal[\"sqlite\", None] = \"sqlite\",\n    filename: Path = None,\n    pragmas: Iterable[str] = (),\n    commit_count_delay: int | None = 250,\n)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def get_database_connection(\n    engine: Literal[\"sqlite\", None] = \"sqlite\",\n    filename: Path = None,\n    pragmas: Iterable[str] = (),\n    commit_count_delay: int | None = 250,\n):\n    return Database(\n        engine=engine,\n        filename=filename,\n        pragmas=pragmas,\n        commit_count_delay=commit_count_delay,\n    )\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.save_demand_multi", "title": "save_demand_multi", "text": "<pre><code>save_demand_multi(\n    cnx: Database, sim: SimulationEngine, dcp\n) -&gt; string\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_demand_multi(cnx: Database, sim: SimulationEngine, dcp) -&gt; string:\n    data_list = []\n    for dmd in sim.demands:\n        data_list.append(\n            (\n                sim.name,\n                sim.iteration,\n                sim.trial,\n                sim.sample,\n                dcp,\n                dmd.orig,\n                dmd.dest,\n                dmd.segment,\n                dmd.scenario_demand,\n                dmd.sold,\n                dmd.revenue,\n            )\n        )\n        # if dmd.sold &gt; dmd.scenario_demand:\n        #     print(f\"{dmd.orig=}, {dmd.dest=}, {dmd.segment},\n        #     {dmd.sold}, {dmd.scenario_demand}\")\n\n    try:\n        cursor = cnx.cursor()\n        sql = f\"\"\"INSERT INTO demand_detail\n                (scenario, iteration, trial, sample, days_prior,\n                 orig, dest, segment, sample_demand, sold, revenue)\n                VALUES ({sql_placeholders(cnx, 11)})\"\"\"\n        cursor.executemany(sql, data_list)\n        return True\n    except Exception as err:\n        print(f\"Doh !!! demand_detail: {err}\")\n        return False\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.save_fare_multi", "title": "save_fare_multi", "text": "<pre><code>save_fare_multi(\n    cnx: Database, sim: SimulationEngine, dcp\n) -&gt; string\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_fare_multi(cnx: Database, sim: SimulationEngine, dcp) -&gt; string:\n    data_list = []\n    for fare in sim.fares:\n        data_list.append(\n            (\n                sim.name,\n                sim.iteration,\n                sim.trial,\n                sim.sample,\n                dcp,\n                fare.sold,\n                fare.sold_business,\n                fare.fare_id,\n            )\n        )\n    try:\n        cursor = cnx.cursor()\n        sql = f\"\"\"INSERT INTO fare_detail\n                (scenario, iteration, trial, sample, days_prior,\n                 sold, sold_business, fare_id)\n                VALUES ({sql_placeholders(cnx, 8)})\"\"\"\n        cursor.executemany(sql, data_list)\n        return True\n    except Exception as err:\n        print(f\"Doh !!! fare: {err}\")\n        return False\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.save_leg", "title": "save_leg", "text": "<pre><code>save_leg(cnx, sim, leg, dcp) -&gt; string\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_leg(cnx, sim, leg, dcp) -&gt; string:\n    _dep_time = datetime.utcfromtimestamp(leg.dep_time).strftime(\"%Y-%m-%d %H:%M:%S\")\n    try:\n        cursor = cnx.cursor()\n        sql = f\"\"\"INSERT INTO leg_detail\n                (scenario, iteration, trial, sample, days_prior, leg_id, sold, revenue)\n                VALUES ({sql_placeholders(cnx, 8)})\"\"\"\n        cursor.execute(\n            sql,\n            (\n                sim.name,\n                sim.iteration,\n                sim.trial,\n                sim.sample,\n                dcp,\n                leg.leg_id,\n                leg.sold,\n                leg.revenue,\n            ),\n        )\n        return True\n    except Exception as err:\n        print(f\"Doh !!! leg_detail: {err}\")\n        return False\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.save_leg_bucket_multi", "title": "save_leg_bucket_multi", "text": "<pre><code>save_leg_bucket_multi(\n    cnx: Database,\n    sim: SimulationEngine,\n    leg,\n    dcp,\n    commit=False,\n) -&gt; string\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_leg_bucket_multi(\n    cnx: Database, sim: SimulationEngine, leg, dcp, commit=False\n) -&gt; string:\n    try:\n        cursor = cnx.cursor()\n        cnx_type = type(cnx).__name__\n        if cnx_type not in leg_bucket_sql:\n            sql = leg_bucket_sql[cnx_type] = f\"\"\"INSERT INTO leg_bucket_detail\n                (scenario, iteration, trial, sample, days_prior, leg_id,\n                bucket_number, name, auth, revenue, sold, untruncated_demand,\n                forecast_mean) VALUES ({sql_placeholders(cnx, 13)})\"\"\"\n        else:\n            sql = leg_bucket_sql.get(cnx_type)\n        data_list = []\n        for n, bkt in enumerate(leg.buckets):\n            data = (\n                sim.name,\n                sim.iteration,\n                sim.trial,\n                sim.sample,\n                dcp,\n                leg.leg_id,\n                n,\n                bkt.name,\n                bkt.alloc,\n                bkt.revenue,\n                bkt.sold,\n                bkt.untruncated_demand,\n                bkt.fcst_mean,\n            )\n            data_list.append(data)\n\n        cursor.executemany(sql, data_list)\n        if commit:\n            cnx.commit()\n        cursor.close()\n        return True\n    except Exception as err:\n        print(f\"Doh !!! leg_bucket_detail: {err}\")\n        return False\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.sql_placeholders", "title": "sql_placeholders", "text": "<pre><code>sql_placeholders(cnx, n: int)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def sql_placeholders(cnx, n: int):\n    if isinstance(cnx, Database):\n        return sql_placeholders(cnx._connection, n)\n    elif isinstance(cnx, sqlite3.Connection):\n        x = \"?\"\n    else:\n        x = \"%s\"\n    return \", \".join(x for _ in range(n))\n</code></pre>"}, {"location": "API/database/common-queries.html", "title": "Common Queries", "text": ""}, {"location": "API/database/common-queries.html#passengersim.database.common_queries._leg_bucket_trace", "title": "_leg_bucket_trace", "text": "<pre><code>_leg_bucket_trace(\n    target_cols: str,\n    cnx: Database,\n    scenario: str | None = None,\n    burn_samples: int = 100,\n    carrier: str | None = None,\n    leg_id: int | None = None,\n    booking_class: str | None = None,\n    days_prior: int | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Recorded forecast of demand by leg.</p> <p>This query requires that the simulation was run while recording leg bucket details (i.e. with the <code>bucket</code> flag set on <code>Config.db.write_items</code>).  This function is provided primarily for testing and debugging purposes.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The forecasts will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> <li> <code>carrier</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this carrier.</p> </li> <li> <code>leg_id</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this leg.</p> </li> <li> <code>booking_class</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this booking class.</p> </li> <li> <code>days_prior</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this many days prior to departure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by any of <code>carrier</code>, <code>leg_id</code>, <code>booking_class</code>, and/or <code>days_prior</code> that were not filtered, and has these columns: - <code>forecast_mean</code>: Forecast mean (mu). - <code>forecast_stdev</code>: Forecast standard deviation (sigma). - <code>forecast_closed_in_tf</code>: Fraction of time the timeframe was     closed in the data used to make a forecast. - <code>forecast_closed_in_tf</code>: Fraction of time any future timeframe     was closed in the data used to make a forecast.</p> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def _leg_bucket_trace(\n    target_cols: str,\n    cnx: \"Database\",\n    scenario: str | None = None,\n    burn_samples: int = 100,\n    carrier: str | None = None,\n    leg_id: int | None = None,\n    booking_class: str | None = None,\n    days_prior: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Recorded forecast of demand by leg.\n\n    This query requires that the simulation was run while recording leg bucket\n    details (i.e. with the `bucket` flag set on `Config.db.write_items`).  This\n    function is provided primarily for testing and debugging purposes.\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The forecasts will be analyzed ignoring this many samples from the\n        beginning of each trial.\n    carrier : str, optional\n        If provided, only return forecasts for this carrier.\n    leg_id : int, optional\n        If provided, only return forecasts for this leg.\n    booking_class : str, optional\n        If provided, only return forecasts for this booking class.\n    days_prior : int, optional\n        If provided, only return forecasts for this many days prior to departure.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by any of `carrier`, `leg_id`,\n        `booking_class`, and/or `days_prior` that were not filtered, and has\n        these columns:\n        - `forecast_mean`: Forecast mean (mu).\n        - `forecast_stdev`: Forecast standard deviation (sigma).\n        - `forecast_closed_in_tf`: Fraction of time the timeframe was\n            closed in the data used to make a forecast.\n        - `forecast_closed_in_tf`: Fraction of time any future timeframe\n            was closed in the data used to make a forecast.\n    \"\"\"\n    conditions = []\n    indexers = []\n    columns = []\n    if scenario is not None:\n        conditions.append(\"scenario = @scenario\")\n    if burn_samples is not None:\n        conditions.append(\"sample &gt;= @burn_samples\")\n    if carrier is not None:\n        conditions.append(\"carrier = @carrier\")\n    elif leg_id is None:\n        indexers.append(\"carrier\")\n        columns.append(\"carrier\")\n    if leg_id is not None:\n        conditions.append(\"leg_id = @leg_id\")\n    else:\n        indexers.append(\"leg_id\")\n        columns.append(\"leg_id\")\n    if booking_class is not None:\n        conditions.append(\"name = @booking_class\")\n    else:\n        indexers.append(\"booking_class\")\n        columns.append(\"name as booking_class\")\n    if days_prior is not None:\n        conditions.append(\"days_prior = @days_prior\")\n    else:\n        indexers.append(\"days_prior\")\n        columns.append(\"days_prior\")\n    qry = \"\"\"\n    SELECT\n        {cols}{comma}\n        sample,\n        {target_cols}\n    FROM\n        leg_bucket_detail LEFT JOIN leg_defs USING (leg_id)\n    WHERE\n        {conds}\n    \"\"\".format(\n        target_cols=target_cols,\n        cols=\", \".join(columns),\n        conds=\" AND \".join(conditions),\n        comma=\",\" if columns else \"\",\n    )\n    return cnx.dataframe(\n        qry,\n        dict(\n            scenario=scenario,\n            burn_samples=burn_samples,\n            carrier=carrier,\n            leg_id=leg_id,\n            booking_class=booking_class,\n            days_prior=days_prior,\n        ),\n    ).set_index(indexers + [\"sample\"])\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.bid_price_history", "title": "bid_price_history", "text": "<pre><code>bid_price_history(\n    cnx: Database,\n    scenario: str,\n    burn_samples: int = 100,\n    weighting: Literal[\"equal\", \"capacity\"] = \"equal\",\n) -&gt; DataFrame\n</code></pre> <p>Compute average bid price history over all legs for each carrier.</p> <p>This query requires that the simulation was run while recording leg details (i.e. with the <code>leg</code> flag set on <code>Config.db.write_items</code>), including bid prices.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The bid prices will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> <li> <code>weighting</code>               (<code>(equal, capacity)</code>, default:                   <code>'equal'</code> )           \u2013            <p>How to weight the bid prices.  If 'equal', then each leg is weighted equally.  If 'capacity', then each leg is weighted by its total capacity.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>carrier</code> and <code>days_prior</code>, and has these columns:</p> <ul> <li><code>bid_price_mean</code>: Average bid price across all samples and all legs</li> <li><code>bid_price_stdev</code>: Sample standard deviation of bid prices across all     samples and all legs</li> <li><code>fraction_some_cap</code>: Fraction of all legs across all samples that have     non-zero capacity available for sale.</li> <li><code>fraction_zero_cap</code>: Fraction of all legs across all samples that have     zero capacity available for sale.  Bid prices are computed for these     legs but are not really meaningful.</li> <li><code>some_cap_bid_price_mean</code>: Average bid price across all samples and     all legs conditional on the leg having non-zero capacity.</li> <li><code>some_cap_bid_price_stdev</code>: Sample standard deviation of bid prices     across all samples and all legs conditional on the leg having     non-zero capacity.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def bid_price_history(\n    cnx: Database,\n    scenario: str,\n    burn_samples: int = 100,\n    weighting: Literal[\"equal\", \"capacity\"] = \"equal\",\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute average bid price history over all legs for each carrier.\n\n    This query requires that the simulation was run while recording leg\n    details (i.e. with the `leg` flag set on `Config.db.write_items`),\n    including bid prices.\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The bid prices will be analyzed ignoring this many samples from the\n        beginning of each trial.\n    weighting : {'equal', 'capacity'}, default 'equal'\n        How to weight the bid prices.  If 'equal', then each leg is weighted\n        equally.  If 'capacity', then each leg is weighted by its total capacity.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `carrier` and `days_prior`, and has\n        these columns:\n\n        - `bid_price_mean`: Average bid price across all samples and all legs\n        - `bid_price_stdev`: Sample standard deviation of bid prices across all\n            samples and all legs\n        - `fraction_some_cap`: Fraction of all legs across all samples that have\n            non-zero capacity available for sale.\n        - `fraction_zero_cap`: Fraction of all legs across all samples that have\n            zero capacity available for sale.  Bid prices are computed for these\n            legs but are not really meaningful.\n        - `some_cap_bid_price_mean`: Average bid price across all samples and\n            all legs conditional on the leg having non-zero capacity.\n        - `some_cap_bid_price_stdev`: Sample standard deviation of bid prices\n            across all samples and all legs conditional on the leg having\n            non-zero capacity.\n\n    \"\"\"\n    if weighting not in (\"equal\", \"capacity\"):\n        raise ValueError(f\"unknown weighting {weighting}\")\n    preqry = \"\"\"\n    CREATE TABLE IF NOT EXISTS bid_price_general_summary AS\n    SELECT\n        scenario,\n        carrier,\n        days_prior,\n        avg(bid_price) as bid_price_mean,\n        stdev(bid_price) as bid_price_stdev,\n        avg(CASE WHEN leg_detail.sold &lt; leg_defs.capacity THEN 1.0 ELSE 0.0 END)\n            as fraction_some_cap,\n        avg(CASE WHEN leg_detail.sold &lt; leg_defs.capacity THEN 0.0 ELSE 1.0 END)\n            as fraction_zero_cap\n    FROM leg_detail\n        LEFT JOIN leg_defs ON leg_detail.leg_id = leg_defs.leg_id\n    WHERE\n        sample &gt;= ?1\n    GROUP BY\n        carrier, days_prior\n    \"\"\"\n    cnx.execute(preqry, (burn_samples,))\n    try:\n        cnx._commit_raw()\n    except sqlite3.OperationalError:\n        preqry = preqry.replace(\n            \"CREATE TABLE IF NOT EXISTS\", \"CREATE TEMP TABLE IF NOT EXISTS\"\n        )\n        cnx.execute(preqry, (burn_samples,))\n    qry = \"\"\"\n    SELECT\n        carrier,\n        days_prior,\n        bid_price_mean,\n        bid_price_stdev,\n        fraction_some_cap,\n        fraction_zero_cap\n    FROM bid_price_general_summary WHERE scenario == ?1\n    \"\"\"\n    bph = cnx.dataframe(\n        qry,\n        (scenario,),\n    )\n    preqry2 = \"\"\"\n    CREATE TABLE IF NOT EXISTS bid_price_somecap_summary AS\n    SELECT\n        scenario,\n        carrier,\n        days_prior,\n        avg(bid_price) as some_cap_bid_price_mean_unweighted,\n        stdev(bid_price) as some_cap_bid_price_stdev,\n        (SUM(bid_price * leg_defs.capacity) / SUM(leg_defs.capacity))\n            as some_cap_bid_price_mean_capweighted\n    FROM leg_detail\n        LEFT JOIN leg_defs ON leg_detail.leg_id = leg_defs.leg_id\n    WHERE\n        sample &gt;= ?1\n        AND leg_detail.sold &lt; leg_defs.capacity\n    GROUP BY\n        carrier, days_prior\n    \"\"\"\n    cnx.execute(preqry2, (burn_samples,))\n    try:\n        cnx._commit_raw()\n    except sqlite3.OperationalError:\n        preqry2 = preqry2.replace(\n            \"CREATE TABLE IF NOT EXISTS\", \"CREATE TEMP TABLE IF NOT EXISTS\"\n        )\n        cnx.execute(preqry2, (burn_samples,))\n    qry2 = \"\"\"\n    SELECT\n        carrier, days_prior,\n        some_cap_bid_price_mean_unweighted,\n        some_cap_bid_price_stdev,\n        some_cap_bid_price_mean_capweighted\n    FROM bid_price_somecap_summary WHERE scenario == ?1\n    \"\"\"\n    bph_some_cap = cnx.dataframe(\n        qry2,\n        (scenario,),\n    ).set_index([\"carrier\", \"days_prior\"])\n    bph = bph.set_index([\"carrier\", \"days_prior\"]).join(bph_some_cap)\n    bph = bph.sort_index(ascending=(True, False))\n    if weighting == \"equal\":\n        bph[\"some_cap_bid_price_mean\"] = bph[\"some_cap_bid_price_mean_unweighted\"]\n    elif weighting == \"capacity\":\n        bph[\"some_cap_bid_price_mean\"] = bph[\"some_cap_bid_price_mean_capweighted\"]\n    else:\n        raise ValueError(f\"unknown weighting {weighting}\")\n    return bph\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.bookings_by_timeframe", "title": "bookings_by_timeframe", "text": "<pre><code>bookings_by_timeframe(\n    cnx: Database,\n    scenario: str,\n    from_fare_detail: bool = False,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Average bookings and revenue by carrier, booking class, and timeframe.</p> <p>This query requires that the simulation was run while recording supporting details (i.e. with the <code>bookings</code> or <code>fare</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>from_fare_detail</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Reconstruct this table from the <code>fare_detail</code> table.  This is generally slower than accessing the <code>bookings</code> table directly, and also requires substantially more data to have been saved into the database by setting the <code>fare</code> flag on <code>Config.db.write_items</code></p> </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The bookings will be computed ignoring this many samples from the beginning of each trial. This argument is nominally ignored by this query unless <code>from_fare_detail</code> is true, although the simulator will have already ignored the burned samples when storing the data in the bookings table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>trial</code>, <code>carrier</code>, <code>class</code>, and <code>days_prior</code>, and has these columns:</p> <ul> <li><code>avg_sold</code>: Average number of sales.</li> <li><code>avg_business</code>: Average number of sales to passengers in the business segment.</li> <li><code>avg_leisure</code>: Average number of sales to leisure passengers.</li> <li><code>avg_revenue</code>: Average total revenue earned from customers booking in this     booking class in this time period.</li> <li><code>avg_price</code>: Average price per ticket from customers booking in this booking     class in this time period</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def bookings_by_timeframe(\n    cnx: Database,\n    scenario: str,\n    from_fare_detail: bool = False,\n    burn_samples: int = 100,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Average bookings and revenue by carrier, booking class, and timeframe.\n\n    This query requires that the simulation was run while recording supporting\n    details (i.e. with the `bookings` or `fare` flags set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    from_fare_detail : bool, default False\n        Reconstruct this table from the `fare_detail` table.  This is generally\n        slower than accessing the `bookings` table directly, and also requires\n        substantially more data to have been saved into the database by setting\n        the `fare` flag on `Config.db.write_items`\n    burn_samples : int, default 100\n        The bookings will be computed ignoring this many samples from the\n        beginning of each trial. This argument is nominally ignored by this query\n        unless `from_fare_detail` is true, although the simulator will have already\n        ignored the burned samples when storing the data in the bookings table.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `trial`, `carrier`, `class`,\n        and `days_prior`, and has these columns:\n\n        - `avg_sold`: Average number of sales.\n        - `avg_business`: Average number of sales to passengers in the business segment.\n        - `avg_leisure`: Average number of sales to leisure passengers.\n        - `avg_revenue`: Average total revenue earned from customers booking in this\n            booking class in this time period.\n        - `avg_price`: Average price per ticket from customers booking in this booking\n            class in this time period\n    \"\"\"\n    qry_fare = \"\"\"\n    SELECT trial, carrier, booking_class, days_prior,\n           (AVG(sold)) AS avg_sold,\n           (AVG(sold_business)) AS avg_business,\n           (AVG(sold_leisure)) AS avg_leisure,\n           (AVG(revenue)) AS avg_revenue,\n           (AVG(revenue) / AVG(sold)) AS avg_price,\n           (SUM(sold)) AS tot_sold\n    FROM (SELECT trial, scenario, carrier, booking_class, days_prior,\n                 SUM(sold) AS sold,\n                 SUM(sold_business) AS sold_business,\n                 SUM(sold - sold_business) AS sold_leisure,\n                 SUM(sold * price) AS revenue\n          FROM fare_detail LEFT JOIN fare_defs USING (fare_id)\n          WHERE\n                sample &gt;= ?2\n                AND scenario = ?1\n          GROUP BY trial, sample, carrier, booking_class, days_prior) a\n    GROUP BY carrier, booking_class, days_prior, trial\n    ORDER BY carrier, booking_class, days_prior, trial;\n    \"\"\"\n\n    if from_fare_detail:\n        return cnx.dataframe(qry_fare, (scenario, burn_samples)).set_index(\n            [\"trial\", \"carrier\", \"booking_class\", \"days_prior\"]\n        )\n\n    qry_bookings = \"\"\"\n    SELECT\n        trial,\n        carrier,\n        booking_class,\n        days_prior,\n        avg_sold,\n        avg_business,\n        avg_leisure,\n        avg_revenue,\n        avg_price\n    FROM\n        bookings_by_timeframe\n    WHERE\n        scenario = ?1\n    GROUP BY\n        carrier, booking_class, days_prior, trial\n    ORDER BY\n        carrier, booking_class, days_prior, trial;\n    \"\"\"\n    return cnx.dataframe(qry_bookings, (scenario,)).set_index(\n        [\"trial\", \"carrier\", \"booking_class\", \"days_prior\"]\n    )\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.carrier_history", "title": "carrier_history", "text": "<pre><code>carrier_history(\n    cnx: Database,\n    *,\n    scenario: str = None,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Sample-level details of carrier-level measures.</p> <p>This query delivers sample-by-sample aggregated summary results for the various carriers in the simulation. It requires that the simulation was run while recording leg bucket details (i.e. with the <code>bucket</code> flag set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The history will be returned ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>iteration</code>, <code>trial</code> and <code>sample</code>, and columns defined with a two-level MultiIndex.  The second level of the columns MultiIndex represents the carriers, while the top level includes these columns:</p> <ul> <li><code>forecast_mean</code>: Forecast mean (mu) at the beginning of the booking     curve, summed over all this carrier's legs in this sample.</li> <li><code>forecast_stdev</code>: Forecast standard deviation (sigma) at the beginning     of the booking curve, aggregated over all this carrier's legs in this     sample.</li> <li><code>sold</code>: Total bookings accepted by this carrier in this sample.</li> <li><code>revenue</code>: Total revenue for this carrier in this sample.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def carrier_history(\n    cnx: Database, *, scenario: str = None, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Sample-level details of carrier-level measures.\n\n    This query delivers sample-by-sample aggregated summary results for the\n    various carriers in the simulation. It requires that the simulation was\n    run while recording leg bucket details (i.e. with the `bucket` flag set\n    on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str, optional\n    burn_samples : int, default 100\n        The history will be returned ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `iteration`, `trial` and `sample`,\n        and columns defined with a two-level MultiIndex.  The second level of\n        the columns MultiIndex represents the carriers, while the top level\n        includes these columns:\n\n        - `forecast_mean`: Forecast mean (mu) at the beginning of the booking\n            curve, summed over all this carrier's legs in this sample.\n        - `forecast_stdev`: Forecast standard deviation (sigma) at the beginning\n            of the booking curve, aggregated over all this carrier's legs in this\n            sample.\n        - `sold`: Total bookings accepted by this carrier in this sample.\n        - `revenue`: Total revenue for this carrier in this sample.\n    \"\"\"\n    # Provides content similar to PODS *.HST output file.\n    qry_params = {\"burn_samples\": burn_samples}\n    if scenario is not None:\n        qry_params[\"scenario\"] = scenario\n        max_days_prior = int(\n            cnx.dataframe(\n                \"\"\"\n                SELECT max(days_prior) FROM leg_bucket_detail WHERE scenario == ?1\n                \"\"\",\n                (scenario,),\n            ).iloc[0, 0]\n        )\n    else:\n        max_days_prior = int(\n            cnx.dataframe(\n                \"\"\"\n                SELECT max(days_prior) FROM leg_bucket_detail\n                \"\"\",\n            ).iloc[0, 0]\n        )\n    qry_params[\"max_days_prior\"] = max_days_prior\n    qry1 = \"\"\"\n    SELECT\n        iteration, trial, sample, carrier,\n        sum(forecast_mean) as forecast_mean,\n        sqrt(sum(forecast_stdev*forecast_stdev)) as forecast_stdev\n    FROM leg_bucket_detail LEFT JOIN leg_defs USING (leg_id)\n    WHERE days_prior == @max_days_prior\n      AND scenario == @scenario\n      AND sample &gt;= @burn_samples\n    GROUP BY iteration, trial, sample, carrier\n    \"\"\"\n    if scenario is None:\n        qry1 = qry1.replace(\"AND scenario == @scenario\", \"\")\n    bd1 = cnx.dataframe(qry1, qry_params).set_index(\n        [\"iteration\", \"trial\", \"sample\", \"carrier\"]\n    )\n    qry2 = \"\"\"\n    SELECT\n        iteration, trial, sample, carrier,\n        sum(sold) as sold,\n        sum(revenue) as revenue\n    FROM leg_bucket_detail LEFT JOIN leg_defs USING (leg_id)\n    WHERE days_prior == 0\n      AND scenario == @scenario\n      AND sample &gt;= @burn_samples\n    GROUP BY iteration, trial, sample, carrier\n    \"\"\"\n    if scenario is None:\n        qry2 = qry2.replace(\"AND scenario == @scenario\", \"\")\n    bd2 = cnx.dataframe(qry2, qry_params).set_index(\n        [\"iteration\", \"trial\", \"sample\", \"carrier\"]\n    )\n    return pd.concat([bd1, bd2], axis=1).unstack(\"carrier\")\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.demand_to_come", "title": "demand_to_come", "text": "<pre><code>demand_to_come(\n    cnx: Database,\n    *,\n    scenario: str = None,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Demand by market and timeframe across each sample.</p> <p>This query delivers sample-by-sample timeframe demand results for the various markets (origin, destination, passenger type) in the simulation. It requires that the simulation was run while recording demand details (i.e. with the <code>demand</code> flag set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The demand will be returned ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>iteration</code>, <code>trial</code>, <code>sample</code>, <code>segment</code>, <code>orig</code>, and <code>dest</code>; and has columns defined by the DCPs. The values stored are the total remaining demand to come at each DCP.</p> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def demand_to_come(\n    cnx: Database, *, scenario: str = None, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Demand by market and timeframe across each sample.\n\n    This query delivers sample-by-sample timeframe demand results for the\n    various markets (origin, destination, passenger type) in the simulation.\n    It requires that the simulation was run while recording demand details\n    (i.e. with the `demand` flag set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str, optional\n    burn_samples : int, default 100\n        The demand will be returned ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `iteration`, `trial`, `sample`,\n        `segment`, `orig`, and `dest`; and has columns defined by the DCPs.\n        The values stored are the total remaining demand to come at each DCP.\n    \"\"\"\n    # Provides content similar to PODS *.DHS output file, but with market level detail\n    qry = \"\"\"\n    SELECT\n        iteration, trial, sample, segment, orig, dest, days_prior, sold, no_go,\n        (round(sample_demand) - sold - no_go) AS future_demand\n    FROM\n        demand_detail\n    WHERE\n        sample &gt;= ?1\n        AND scenario = ?2\n    \"\"\"\n    if scenario is None:\n        qry = qry.replace(\"AND scenario = ?2\", \"\")\n        params = (burn_samples,)\n    else:\n        params = (burn_samples, scenario)\n    dmd = cnx.dataframe(qry, params, dtype={\"future_demand\": np.int32})\n    dhs = (\n        dmd.set_index(\n            [\"iteration\", \"trial\", \"sample\", \"segment\", \"orig\", \"dest\", \"days_prior\"]\n        )[\"future_demand\"]\n        .unstack(\"days_prior\")\n        .sort_values(by=\"days_prior\", axis=1, ascending=False)\n    )\n    return dhs\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.demand_to_come_summary", "title": "demand_to_come_summary", "text": "<pre><code>demand_to_come_summary(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; DataFrame\n</code></pre> <p>Demand by market and timeframe across each sample.</p> <p>This query delivers sample-by-sample timeframe demand results for the various markets (origin, destination, passenger type) in the simulation. It requires that the simulation was run while recording demand details (i.e. with the <code>demand</code> flag set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The demand will be returned ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>iteration</code>, <code>trial</code>, <code>sample</code>, <code>segment</code>, <code>orig</code>, and <code>dest</code>; and has columns defined by the DCPs. The values stored are the total remaining demand to come at each DCP.</p> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def demand_to_come_summary(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Demand by market and timeframe across each sample.\n\n    This query delivers sample-by-sample timeframe demand results for the\n    various markets (origin, destination, passenger type) in the simulation.\n    It requires that the simulation was run while recording demand details\n    (i.e. with the `demand` flag set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The demand will be returned ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `iteration`, `trial`, `sample`,\n        `segment`, `orig`, and `dest`; and has columns defined by the DCPs.\n        The values stored are the total remaining demand to come at each DCP.\n    \"\"\"\n    # Provides content similar to PODS *.DHS output file, but with market level detail\n    qry = \"\"\"\n    CREATE TABLE IF NOT EXISTS demand_to_come_summary AS\n    WITH tmp_demand_summary AS (\n        SELECT\n            scenario, iteration, trial, sample, segment, days_prior,\n            SUM(round(sample_demand) - sold - no_go) AS future_demand\n        FROM\n            demand_detail\n        GROUP BY\n            scenario, iteration, trial, sample, segment, days_prior\n    )\n    SELECT\n        scenario, segment, days_prior,\n        AVG(future_demand) as mean_future_demand,\n        STDEV(future_demand) as stdev_future_demand\n    FROM\n        tmp_demand_summary\n    WHERE\n        sample &gt;= ?1\n    GROUP BY\n        segment, days_prior\n    ORDER BY\n        segment, days_prior DESC\n    \"\"\"\n    cnx.execute(qry, (burn_samples,))\n    cnx._commit_raw()\n\n    qry = \"\"\"\n    SELECT\n        segment, days_prior, mean_future_demand, stdev_future_demand\n    FROM demand_to_come_summary\n    WHERE scenario = ?1\n    \"\"\"\n    dmd = cnx.dataframe(qry, (scenario,))\n    dhs = dmd.set_index([\"segment\", \"days_prior\"])\n    return dhs\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.displacement_history", "title": "displacement_history", "text": "<pre><code>displacement_history(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; DataFrame\n</code></pre> <p>Compute average displacement cost history over all legs for each carrier.</p> <p>This query requires that the simulation was run while recording leg details (i.e. with the <code>leg</code> flag set on <code>Config.db.write_items</code>), including displacement costs.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The bid prices will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>carrier</code> and <code>days_prior</code>, and has these columns:</p> <ul> <li><code>displacement_mean</code>: Average displacement cost across all samples and     all legs</li> <li><code>displacement_stdev</code>: Sample standard deviation of displacement cost     across all samples and all legs</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def displacement_history(\n    cnx: Database,\n    scenario: str,\n    burn_samples: int = 100,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute average displacement cost history over all legs for each carrier.\n\n    This query requires that the simulation was run while recording leg\n    details (i.e. with the `leg` flag set on `Config.db.write_items`),\n    including displacement costs.\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The bid prices will be analyzed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `carrier` and `days_prior`, and has\n        these columns:\n\n        - `displacement_mean`: Average displacement cost across all samples and\n            all legs\n        - `displacement_stdev`: Sample standard deviation of displacement cost\n            across all samples and all legs\n    \"\"\"\n    preqry = \"\"\"\n    CREATE TABLE IF NOT EXISTS displacement_summary AS\n    SELECT\n        scenario,\n        carrier,\n        days_prior,\n        avg(displacement) as displacement_mean,\n        stdev(displacement) as displacement_stdev\n    FROM leg_detail\n        LEFT JOIN leg_defs ON leg_detail.leg_id = leg_defs.leg_id\n    WHERE\n        sample &gt;= ?1\n    GROUP BY\n        scenario, carrier, days_prior\n    ORDER BY\n        carrier, days_prior DESC\n    \"\"\"\n    cnx.execute(preqry, (burn_samples,))\n    try:\n        cnx._commit_raw()\n    except sqlite3.OperationalError:\n        preqry = preqry.replace(\n            \"CREATE TABLE IF NOT EXISTS\", \"CREATE TEMP TABLE IF NOT EXISTS\"\n        )\n        cnx.execute(preqry, (burn_samples,))\n    qry = \"\"\"\n    SELECT carrier, days_prior, displacement_mean, displacement_stdev\n    FROM displacement_summary\n    WHERE scenario == ?1\n    \"\"\"\n    df = cnx.dataframe(\n        qry,\n        (scenario,),\n    )\n    df = df.set_index([\"carrier\", \"days_prior\"])\n    return df\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.edgar", "title": "edgar", "text": "<pre><code>edgar(\n    cnx: Database,\n    *,\n    scenario: str = None,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Forecast accuracy information.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The demand will be returned ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>iteration</code>, <code>trial</code>, <code>sample</code>, <code>segment</code>, <code>orig</code>, and <code>dest</code>; and has columns defined by the DCPs. The values stored are the total remaining demand to come at each DCP.</p> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def edgar(\n    cnx: Database, *, scenario: str = None, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Forecast accuracy information.\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str, optional\n    burn_samples : int, default 100\n        The demand will be returned ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `iteration`, `trial`, `sample`,\n        `segment`, `orig`, and `dest`; and has columns defined by the DCPs.\n        The values stored are the total remaining demand to come at each DCP.\n    \"\"\"\n    # Provides content similar to PODS *.DHS output file, but with market level detail\n\n    qry = \"\"\"\n        SELECT\n            iteration, trial, sample, timeframe, path_id, booking_class, sold,\n            sold_priceable, forecast_mean, forecast_stdev, closed\n        FROM\n            edgar\n        WHERE\n            sample &gt;= ?1\n            AND scenario = ?2\n        \"\"\"\n\n    if scenario is None:\n        qry = qry.replace(\"AND scenario = ?2\", \"\")\n        params = (burn_samples,)\n    else:\n        params = (burn_samples, scenario)\n    e = cnx.dataframe(qry, params)  # , dtype={\"edgar\": np.int32})\n    return e\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.fare_class_mix", "title": "fare_class_mix", "text": "<pre><code>fare_class_mix(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; DataFrame\n</code></pre> <p>Fare class mix by carrier.</p> <p>This query requires that the simulation was run while recording final fare details (i.e. with the <code>fare</code> or <code>fare_final</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The average total demand will be computed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>carrier</code> and <code>booking_class</code>, and has these columns:</p> <ul> <li><code>avg_sold</code>: Average number of sales in this booking class.</li> <li><code>avg_revenue</code>: Average total revenue earned from customers booking in     this booking class.</li> <li><code>avg_price</code>: Average price per ticket from customers booking in this     booking class.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def fare_class_mix(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fare class mix by carrier.\n\n    This query requires that the simulation was run while recording final fare\n    details (i.e. with the `fare` or `fare_final` flags set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The average total demand will be computed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `carrier` and `booking_class`, and\n        has these columns:\n\n        - `avg_sold`: Average number of sales in this booking class.\n        - `avg_revenue`: Average total revenue earned from customers booking in\n            this booking class.\n        - `avg_price`: Average price per ticket from customers booking in this\n            booking class.\n    \"\"\"\n    pre_qry = \"\"\"\n    CREATE TABLE IF NOT EXISTS fare_summary AS\n    SELECT\n        trial, sample, scenario, carrier, booking_class,\n        SUM(sold) AS sold,\n        SUM(sold * price) AS revenue\n    FROM\n        fare_detail LEFT JOIN fare_defs USING (fare_id)\n    WHERE\n        days_prior = 0\n    GROUP BY\n        trial, sample, scenario, carrier, booking_class\n    \"\"\"\n    cnx.execute(pre_qry)\n    cnx._commit_raw()\n\n    qry = \"\"\"\n    SELECT carrier, booking_class,\n           (AVG(sold)) AS avg_sold,\n           (AVG(revenue)) AS avg_revenue,\n           (AVG(revenue) / AVG(sold)) AS avg_price\n    FROM\n        fare_summary\n    WHERE\n        sample &gt;= ?2\n        AND scenario = ?1\n    GROUP BY carrier, booking_class\n    ORDER BY carrier, booking_class;\n    \"\"\"\n    return cnx.dataframe(qry, (scenario, burn_samples)).set_index(\n        [\"carrier\", \"booking_class\"]\n    )\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.leg_forecast_trace", "title": "leg_forecast_trace", "text": "<pre><code>leg_forecast_trace(\n    cnx: Database,\n    scenario: str | None = None,\n    burn_samples: int = 100,\n    carrier: str | None = None,\n    leg_id: int | None = None,\n    booking_class: str | None = None,\n    days_prior: int | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Recorded forecast of demand by leg.</p> <p>This query requires that the simulation was run while recording leg bucket details (i.e. with the <code>bucket</code> flag set on <code>Config.db.write_items</code>).  This function is provided primarily for testing and debugging purposes.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The forecasts will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> <li> <code>carrier</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this carrier.</p> </li> <li> <code>leg_id</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this leg.</p> </li> <li> <code>booking_class</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this booking class.</p> </li> <li> <code>days_prior</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this many days prior to departure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by any of <code>carrier</code>, <code>leg_id</code>, <code>booking_class</code>, and/or <code>days_prior</code> that were not filtered, and has these columns: - <code>forecast_mean</code>: Forecast mean (mu). - <code>forecast_stdev</code>: Forecast standard deviation (sigma). - <code>forecast_closed_in_tf</code>: Fraction of time the timeframe was     closed in the data used to make a forecast. - <code>forecast_closed_in_tf</code>: Fraction of time any future timeframe     was closed in the data used to make a forecast.</p> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def leg_forecast_trace(\n    cnx: \"Database\",\n    scenario: str | None = None,\n    burn_samples: int = 100,\n    carrier: str | None = None,\n    leg_id: int | None = None,\n    booking_class: str | None = None,\n    days_prior: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Recorded forecast of demand by leg.\n\n    This query requires that the simulation was run while recording leg bucket\n    details (i.e. with the `bucket` flag set on `Config.db.write_items`).  This\n    function is provided primarily for testing and debugging purposes.\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The forecasts will be analyzed ignoring this many samples from the\n        beginning of each trial.\n    carrier : str, optional\n        If provided, only return forecasts for this carrier.\n    leg_id : int, optional\n        If provided, only return forecasts for this leg.\n    booking_class : str, optional\n        If provided, only return forecasts for this booking class.\n    days_prior : int, optional\n        If provided, only return forecasts for this many days prior to departure.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by any of `carrier`, `leg_id`,\n        `booking_class`, and/or `days_prior` that were not filtered, and has\n        these columns:\n        - `forecast_mean`: Forecast mean (mu).\n        - `forecast_stdev`: Forecast standard deviation (sigma).\n        - `forecast_closed_in_tf`: Fraction of time the timeframe was\n            closed in the data used to make a forecast.\n        - `forecast_closed_in_tf`: Fraction of time any future timeframe\n            was closed in the data used to make a forecast.\n    \"\"\"\n    return _leg_bucket_trace(\n        \"forecast_mean, forecast_stdev, \"\n        \"forecast_closed_in_tf, forecast_closed_in_future\",\n        cnx,\n        scenario=scenario,\n        burn_samples=burn_samples,\n        carrier=carrier,\n        leg_id=leg_id,\n        booking_class=booking_class,\n        days_prior=days_prior,\n    )\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.leg_forecasts", "title": "leg_forecasts", "text": "<pre><code>leg_forecasts(\n    cnx: Database,\n    *,\n    scenario: str = None,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Average forecasts of demand by leg, bucket, and days to departure.</p> <p>This query requires that the simulation was run while recording leg bucket details (i.e. with the <code>bucket</code> flag set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The forecasts will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>carrier</code>, <code>leg_id</code>, <code>bucket_number</code>, <code>booking_class</code> and <code>days_prior</code>, and has these columns:</p> <ul> <li><code>forecast_mean</code>: Average forecast mean (mu).</li> <li><code>forecast_stdev</code>: Average forecast standard deviation (sigma).</li> <li><code>forecast_closed_in_tf</code>: Average fraction of time the timeframe was     closed in the data used to make a forecast.</li> <li><code>forecast_closed_in_tf</code>: Average fraction of time any future timeframe     was closed in the data used to make a forecast.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def leg_forecasts(\n    cnx: Database, *, scenario: str = None, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Average forecasts of demand by leg, bucket, and days to departure.\n\n    This query requires that the simulation was run while recording leg bucket\n    details (i.e. with the `bucket` flag set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The forecasts will be analyzed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `carrier`, `leg_id`,\n        `bucket_number`, `booking_class` and `days_prior`, and has these columns:\n\n        - `forecast_mean`: Average forecast mean (mu).\n        - `forecast_stdev`: Average forecast standard deviation (sigma).\n        - `forecast_closed_in_tf`: Average fraction of time the timeframe was\n            closed in the data used to make a forecast.\n        - `forecast_closed_in_tf`: Average fraction of time any future timeframe\n            was closed in the data used to make a forecast.\n    \"\"\"\n    qry = \"\"\"\n    SELECT\n        carrier,\n        leg_id,\n        bucket_number,\n        name as booking_class,\n        days_prior,\n        AVG(forecast_mean) as forecast_mean,\n        AVG(forecast_stdev) as forecast_stdev,\n        AVG(forecast_closed_in_tf) as forecast_closed_in_tf,\n        AVG(forecast_closed_in_future) as forecast_closed_in_future\n    FROM\n        leg_bucket_detail LEFT JOIN leg_defs USING (leg_id)\n    WHERE\n        sample &gt;= ?1\n        AND scenario = ?2\n    GROUP BY\n        carrier, leg_id, bucket_number, name, days_prior\n    \"\"\"\n    if scenario is None:\n        qry = qry.replace(\"AND scenario = ?2\", \"\")\n        params = (burn_samples,)\n    else:\n        params = (burn_samples, scenario)\n    return cnx.dataframe(qry, params).set_index(\n        [\"carrier\", \"leg_id\", \"bucket_number\", \"booking_class\", \"days_prior\"]\n    )\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.leg_local_and_flow_by_class", "title": "leg_local_and_flow_by_class", "text": "<pre><code>leg_local_and_flow_by_class(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; DataFrame\n</code></pre> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def leg_local_and_flow_by_class(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    logger.info(\"creating pthcls temp table\")\n    cnx.execute(\n        \"\"\"\n        CREATE TEMP TABLE IF NOT EXISTS pthcls AS\n        SELECT\n            sold, leg1, booking_class, iteration, trial, sample\n        FROM\n            path_class_detail LEFT JOIN path_defs USING(path_id)\n        WHERE\n            days_prior == 0\n            AND leg2 IS NULL\n            AND scenario == ?1\n            AND sample &gt;= ?2\n        \"\"\",\n        (\n            scenario,\n            burn_samples,\n        ),\n    )\n\n    logger.info(\"indexing pthcls temp table\")\n    cnx.execute(\n        \"\"\"\n        CREATE INDEX IF NOT EXISTS idx_pthcls_1 ON pthcls (\n            iteration, trial, sample, leg1, booking_class\n        );\n        \"\"\"\n    )\n\n    logger.info(\"running leg_local_and_flow_by_class query\")\n    qry = \"\"\"\n    SELECT\n        leg_id,\n        leg_defs.carrier,\n        leg_defs.orig,\n        leg_defs.dest,\n        leg_bucket_detail.name as booking_class,\n        AVG(leg_bucket_detail.sold) AS carried_all,\n        IFNULL(AVG(pthcls.sold), 0) AS carried_loc\n    FROM\n        leg_bucket_detail\n        LEFT JOIN leg_defs USING (leg_id)\n        LEFT JOIN pthcls ON\n            leg_id == pthcls.leg1\n            AND leg_bucket_detail.name == pthcls.booking_class\n            AND leg_bucket_detail.iteration == pthcls.iteration\n            AND leg_bucket_detail.trial == pthcls.trial\n            AND leg_bucket_detail.sample == pthcls.sample\n    WHERE\n        leg_bucket_detail.scenario == ?1\n        AND leg_bucket_detail.sample &gt;= ?2\n        AND days_prior == 0\n    GROUP BY\n        leg_id,\n        leg_defs.carrier,\n        leg_defs.orig,\n        leg_defs.dest,\n        leg_bucket_detail.name\n    \"\"\"\n    df = cnx.dataframe(\n        qry,\n        (\n            scenario,\n            burn_samples,\n        ),\n    )\n    return df\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.leg_sales_trace", "title": "leg_sales_trace", "text": "<pre><code>leg_sales_trace(\n    cnx: Database,\n    scenario: str | None = None,\n    burn_samples: int = 100,\n    carrier: str | None = None,\n    leg_id: int | None = None,\n    booking_class: str | None = None,\n    days_prior: int | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Recorded forecast of demand by leg.</p> <p>This query requires that the simulation was run while recording leg bucket details (i.e. with the <code>bucket</code> flag set on <code>Config.db.write_items</code>).  This function is provided primarily for testing and debugging purposes.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The forecasts will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> <li> <code>carrier</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this carrier.</p> </li> <li> <code>leg_id</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this leg.</p> </li> <li> <code>booking_class</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this booking class.</p> </li> <li> <code>days_prior</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this many days prior to departure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by any of <code>carrier</code>, <code>leg_id</code>, <code>booking_class</code>, and/or <code>days_prior</code> that were not filtered, and has these columns: <code>sold</code>, <code>revenue</code>, <code>auth</code></p> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def leg_sales_trace(\n    cnx: \"Database\",\n    scenario: str | None = None,\n    burn_samples: int = 100,\n    carrier: str | None = None,\n    leg_id: int | None = None,\n    booking_class: str | None = None,\n    days_prior: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Recorded forecast of demand by leg.\n\n    This query requires that the simulation was run while recording leg bucket\n    details (i.e. with the `bucket` flag set on `Config.db.write_items`).  This\n    function is provided primarily for testing and debugging purposes.\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The forecasts will be analyzed ignoring this many samples from the\n        beginning of each trial.\n    carrier : str, optional\n        If provided, only return forecasts for this carrier.\n    leg_id : int, optional\n        If provided, only return forecasts for this leg.\n    booking_class : str, optional\n        If provided, only return forecasts for this booking class.\n    days_prior : int, optional\n        If provided, only return forecasts for this many days prior to departure.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by any of `carrier`, `leg_id`,\n        `booking_class`, and/or `days_prior` that were not filtered, and has\n        these columns: `sold`, `revenue`, `auth`\n    \"\"\"\n    return _leg_bucket_trace(\n        \"sold, revenue, auth\",\n        cnx,\n        scenario=scenario,\n        burn_samples=burn_samples,\n        carrier=carrier,\n        leg_id=leg_id,\n        booking_class=booking_class,\n        days_prior=days_prior,\n    )\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.load_factor_distribution", "title": "load_factor_distribution", "text": "<pre><code>load_factor_distribution(\n    cnx: Database,\n    scenario: str,\n    burn_samples: int = 100,\n    cutoffs=(0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95),\n) -&gt; DataFrame\n</code></pre> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def load_factor_distribution(\n    cnx: Database,\n    scenario: str,\n    burn_samples: int = 100,\n    cutoffs=(0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95),\n) -&gt; pd.DataFrame:\n    cutoffs = sorted([float(j) for j in cutoffs])\n    if 0.0 not in cutoffs:\n        cutoffs = [0.0] + cutoffs\n    if 1.0 not in cutoffs:\n        cutoffs = cutoffs + [1.0]\n    vars = []\n    for i in range(len(cutoffs) - 2):\n        vars.append(\n            f\"count(CASE WHEN lf&gt;= {cutoffs[i]} AND lf &lt; {cutoffs[i+1]} THEN 1 END) \"\n            f\"AS '{cutoffs[i]} - {cutoffs[i+1]}'\"\n        )\n    vars.append(\n        f\"count(CASE WHEN lf&gt;= {cutoffs[-2]} AND lf &lt;= {cutoffs[-1]} THEN 1 END) \"\n        f\"AS '{cutoffs[-2]} - {cutoffs[-1]}'\"\n    )\n    vars = \",\\n        \".join(vars)\n    qry = f\"\"\"\n    SELECT\n        carrier,\n        {vars}\n    FROM (\n        SELECT carrier, sold, capacity, (1.0*sold)/capacity AS lf\n        FROM leg_detail\n                   JOIN leg_defs USING (leg_id)\n          WHERE days_prior = 0  -- only after all sales are recorded\n            AND sample &gt;= ?2    -- only after burn period\n            AND scenario = ?1   -- only for this scenario\n    )\n    GROUP BY carrier\n    \"\"\"\n    return cnx.dataframe(qry, (scenario, burn_samples))\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.load_factors", "title": "load_factors", "text": "<pre><code>load_factors(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; DataFrame\n</code></pre> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def load_factors(cnx: Database, scenario: str, burn_samples: int = 100) -&gt; pd.DataFrame:\n    qry = \"\"\"\n    SELECT carrier,\n           ROUND(AVG(sold)) AS avg_legs_sold,\n           ROUND(AVG(100.0 * sold / cap), 2) AS avg_leg_lf,\n           ROUND(AVG(100.0 * rpm / asm), 2) AS sys_lf,\n           ROUND(AVG(revenue), 2) AS avg_rev,\n           ROUND(AVG(revenue / asm), 3) AS yield,\n           ROUND(AVG(revenue) / AVG(sold)) AS avg_leg_price,\n           COUNT(*) AS n_obs\n    FROM (SELECT trial, sample, carrier,\n                 SUM(sold) AS sold,\n                 SUM(capacity) AS cap,\n                 SUM(sold * distance) AS rpm,\n                 SUM(capacity * distance) AS asm,\n                 SUM(revenue) AS revenue\n          FROM leg_detail\n                   JOIN leg_defs USING (leg_id)\n          WHERE days_prior = 0\n            AND sample &gt;= ?2\n            AND scenario = ?1\n          GROUP BY trial, sample, carrier\n         ) tmp\n    GROUP BY carrier\n    \"\"\"\n    return cnx.dataframe(qry, (scenario, burn_samples))\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.local_and_flow_yields", "title": "local_and_flow_yields", "text": "<pre><code>local_and_flow_yields(\n    cnx: Database,\n    *,\n    scenario: str = None,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Compute yields for local (nonstop) and flow (connecting) passengers.</p> <p>This query requires that the simulation was run while recording path class details (i.e. with the <code>pathclass</code> or <code>pathclass_final</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The yields will be computed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def local_and_flow_yields(\n    cnx: Database, *, scenario: str = None, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute yields for local (nonstop) and flow (connecting) passengers.\n\n    This query requires that the simulation was run while recording path class\n    details (i.e. with the `pathclass` or `pathclass_final` flags set on\n    `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str, optional\n    burn_samples : int, default 100\n        The yields will be computed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n    \"\"\"\n    qry = \"\"\"\n    WITH path_yields AS (\n        SELECT\n            iteration, trial, sample, path_id, leg1, leg2,\n            SUM(sold) as total_sold,\n            SUM(revenue) as total_revenue,\n            distance,\n            SUM(revenue) / (SUM(sold) * distance) AS yield,\n            leg2 IS NULL AS local\n        FROM\n            path_class_detail\n            LEFT JOIN path_defs USING (path_id)\n        WHERE\n            days_prior == 0\n            AND sample &gt;= ?1\n            AND scenario == ?2\n        GROUP BY\n            path_id\n    )\n    SELECT\n        leg_id, carrier, orig, dest, capacity, leg_defs.distance,\n        yield AS local_yield,\n        CAST(total_sold AS REAL) /\n            (total_sold + IFNULL(f1.flow_sold, 0) + IFNULL(f2.flow_sold, 0))\n            AS local_fraction,\n        (IFNULL(f1.flow_revenue, 0) + IFNULL(f2.flow_revenue, 0))\n            / (IFNULL(f1.flow_rpm, 0) + IFNULL(f2.flow_rpm, 0))\n            AS flow_yield\n    FROM\n        leg_defs\n        LEFT JOIN path_yields locals\n        ON locals.leg1 == leg_id AND locals.leg2 IS NULL\n        LEFT JOIN (\n            SELECT\n                leg1,\n                SUM(total_sold) AS flow_sold,\n                SUM(total_revenue) AS flow_revenue,\n                SUM(total_sold * distance) AS flow_rpm\n            FROM\n                path_yields\n            WHERE\n                leg2 IS NOT NULL\n            GROUP BY leg1\n        ) f1 ON f1.leg1 == leg_defs.leg_id\n        LEFT JOIN (\n            SELECT\n                leg2,\n                SUM(total_sold) AS flow_sold,\n                SUM(total_revenue) AS flow_revenue,\n                SUM(total_sold * distance) AS flow_rpm\n            FROM\n                path_yields\n            GROUP BY leg2\n        ) f2 ON f2.leg2 == leg_defs.leg_id\n    \"\"\"\n    if scenario is None:\n        qry = qry.replace(\"AND scenario == ?2\", \"\")\n        params = (burn_samples,)\n    else:\n        params = (burn_samples, scenario)\n    df = cnx.dataframe(qry, params)\n    return df\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.od_fare_class_mix", "title": "od_fare_class_mix", "text": "<pre><code>od_fare_class_mix(\n    cnx: Database,\n    orig: str,\n    dest: str,\n    scenario: str,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Fare class mix by carrier for a particular origin-destination market.</p> <p>This query requires that the simulation was run while recording final fare details (i.e. with the <code>fare</code> or <code>fare_final</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>orig</code>               (<code>str</code>)           \u2013            <p>Origin and destination to query.</p> </li> <li> <code>dest</code>               (<code>str</code>)           \u2013            <p>Origin and destination to query.</p> </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The average total demand will be computed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>carrier</code> and <code>booking_class</code>, and has these columns:</p> <ul> <li><code>avg_sold</code>: Average number of sales in this booking class.</li> <li><code>avg_revenue</code>: Average total revenue earned from customers booking in     this booking class.</li> <li><code>avg_price</code>: Average price per ticket from customers booking in this     booking class.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def od_fare_class_mix(\n    cnx: Database, orig: str, dest: str, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fare class mix by carrier for a particular origin-destination market.\n\n    This query requires that the simulation was run while recording final fare\n    details (i.e. with the `fare` or `fare_final` flags set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    orig, dest : str\n        Origin and destination to query.\n    scenario : str\n    burn_samples : int, default 100\n        The average total demand will be computed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `carrier` and `booking_class`, and\n        has these columns:\n\n        - `avg_sold`: Average number of sales in this booking class.\n        - `avg_revenue`: Average total revenue earned from customers booking in\n            this booking class.\n        - `avg_price`: Average price per ticket from customers booking in this\n            booking class.\n    \"\"\"\n\n    qry = \"\"\"\n    SELECT carrier, booking_class,\n           (AVG(sold)) AS avg_sold,\n           (AVG(revenue)) AS avg_revenue,\n           (AVG(revenue) / AVG(sold)) AS avg_price\n    FROM (\n            SELECT\n                trial, scenario, carrier, booking_class,\n                SUM(sold) AS sold,\n                SUM(sold * price) AS revenue,\n                COUNT(*) AS nobs\n            FROM\n                fare_detail LEFT JOIN fare_defs USING (fare_id)\n            WHERE\n                days_prior = 0\n                AND sample &gt;= ?2\n                AND scenario = ?1\n                AND orig = ?3\n                AND dest = ?4\n            GROUP BY\n                trial, sample, carrier, booking_class\n    ) tmp\n    GROUP BY carrier, booking_class\n    ORDER BY carrier, booking_class;\n    \"\"\"\n    return cnx.dataframe(qry, (scenario, burn_samples, orig, dest)).set_index(\n        [\"carrier\", \"booking_class\"]\n    )\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.path_forecasts", "title": "path_forecasts", "text": "<pre><code>path_forecasts(\n    cnx: Database,\n    *,\n    scenario: str = None,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Average forecasts of demand by path, class, and days to departure.</p> <p>This query requires that the simulation was run while recording path-class details (i.e. with the <code>pathclass</code> flag set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The forecasts will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>path_id</code>, <code>booking_class</code> and <code>days_prior</code>, and has these columns:</p> <ul> <li><code>forecast_mean</code>: Average forecast mean (mu).</li> <li><code>forecast_stdev</code>: Average forecast standard deviation (sigma).</li> <li><code>forecast_closed_in_tf</code>: Average fraction of time the timeframe was     closed in the data used to make a forecast.</li> <li><code>forecast_closed_in_tf</code>: Average fraction of time any future timeframe     was closed in the data used to make a forecast.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def path_forecasts(\n    cnx: Database, *, scenario: str = None, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Average forecasts of demand by path, class, and days to departure.\n\n    This query requires that the simulation was run while recording path-class\n    details (i.e. with the `pathclass` flag set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The forecasts will be analyzed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `path_id`, `booking_class` and\n        `days_prior`, and has these columns:\n\n        - `forecast_mean`: Average forecast mean (mu).\n        - `forecast_stdev`: Average forecast standard deviation (sigma).\n        - `forecast_closed_in_tf`: Average fraction of time the timeframe was\n            closed in the data used to make a forecast.\n        - `forecast_closed_in_tf`: Average fraction of time any future timeframe\n            was closed in the data used to make a forecast.\n    \"\"\"\n    qry = \"\"\"\n    SELECT\n        path_id,\n        booking_class,\n        days_prior,\n        AVG(forecast_mean) as forecast_mean,\n        AVG(forecast_stdev) as forecast_stdev,\n        AVG(forecast_closed_in_tf) as forecast_closed_in_tf,\n        AVG(forecast_closed_in_future) as forecast_closed_in_future,\n        AVG(adjusted_price) as adjusted_price\n    FROM\n        path_class_detail\n    WHERE\n        sample &gt;= ?1\n        AND scenario = ?2\n    GROUP BY\n        path_id, booking_class, days_prior\n    \"\"\"\n    if scenario is None:\n        qry = qry.replace(\"AND scenario = ?2\", \"\")\n        params = (burn_samples,)\n    else:\n        params = (burn_samples, scenario)\n    return cnx.dataframe(qry, params).set_index(\n        [\"path_id\", \"booking_class\", \"days_prior\"]\n    )\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.total_demand", "title": "total_demand", "text": "<pre><code>total_demand(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; float\n</code></pre> <p>Average total demand.</p> <p>This query requires that the simulation was run while recording final demand details (i.e. with the <code>demand</code> or <code>demand_final</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The average total demand will be computed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def total_demand(cnx: Database, scenario: str, burn_samples: int = 100) -&gt; float:\n    \"\"\"\n    Average total demand.\n\n    This query requires that the simulation was run while recording final demand\n    details (i.e. with the `demand` or `demand_final` flags set on\n    `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The average total demand will be computed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    float\n    \"\"\"\n    qry = \"\"\"\n    SELECT AVG(sample_demand)\n    FROM (\n        SELECT\n            SUM(sample_demand) AS sample_demand\n        FROM\n            demand_detail\n        WHERE\n            days_prior = 0\n            AND sample &gt;= ?2\n            AND scenario = ?1\n        GROUP BY\n            trial, sample) tmp;\n    \"\"\"\n    return cnx.dataframe(qry, (scenario, burn_samples)).iloc[0, 0]\n</code></pre>"}, {"location": "API/database/tables.html", "title": "Tables", "text": ""}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_booking_curve", "title": "create_table_booking_curve", "text": "<pre><code>create_table_booking_curve(\n    cnx: Database, primary_key: bool = True\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_booking_curve(cnx: Database, primary_key: bool = True):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS booking_curve (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        carrier\t\t\tVARCHAR(10) NOT NULL,\n        orig\t\t\tVARCHAR(10) NOT NULL,\n        dest\t\t\tVARCHAR(10) NOT NULL,\n        flt_no\t\t\tINT NOT NULL,\n        days_prior  \tINT NOT NULL,\n        ratio           FLOAT NOT NULL\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, carrier, \"\n            \"orig, dest, flt_no, days_prior)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_bookings_by_timeframe", "title": "create_table_bookings_by_timeframe", "text": "<pre><code>create_table_bookings_by_timeframe(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_bookings_by_timeframe(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS bookings_by_timeframe\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        trial       \tINT NOT NULL,\n        carrier\t\t\tVARCHAR(10) NOT NULL,\n        booking_class   VARCHAR(10) NOT NULL,\n        days_prior\t\tINT NOT NULL,\n        tot_sold\t\tFLOAT,\n        avg_sold\t\tFLOAT,\n        avg_business\tFLOAT,\n        avg_leisure     FLOAT,\n        avg_revenue     FLOAT,\n        avg_price       FLOAT,\n        updated_at\t\tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, carrier, booking_class, days_prior)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_configs", "title": "create_table_configs", "text": "<pre><code>create_table_configs(cnx: Database)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_configs(cnx: Database):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS runtime_configs (\n        scenario\t\tTEXT PRIMARY KEY,\n        pxsim_version   TEXT,\n        configs         TEXT,\n        updated_at\t    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n    );\n    \"\"\"\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_demand_detail", "title": "create_table_demand_detail", "text": "<pre><code>create_table_demand_detail(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_demand_detail(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS demand_detail\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        iteration\t\tINT NOT NULL,\n        trial\t    \tINT NOT NULL,\n        sample  \t\tINT NOT NULL,\n        days_prior\t    INT NOT NULL,\n        segment\t\t\tVARCHAR(10) NOT NULL,\n        orig\t\t\tVARCHAR(10) NOT NULL,\n        dest\t\t\tVARCHAR(10) NOT NULL,\n        updated_at\t\tDATETIME NOT NULL DEFAuLT CURRENT_TIMESTAMP,\n        sample_demand   FLOAT,\n        sold\t\t\tINT,\n        no_go\t\t\tINT,\n        revenue\t\t\tFLOAT\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, \"\n            \"sample, days_prior, segment, orig, dest)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_distance", "title": "create_table_distance", "text": "<pre><code>create_table_distance(\n    cnx: Database, primary_key: bool = True\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_distance(cnx: Database, primary_key: bool = True):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS distance (\n        orig\t\t\tVARCHAR(10) NOT NULL,\n        dest\t\t\tVARCHAR(10) NOT NULL,\n        miles           FLOAT\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(primary_key=\", PRIMARY KEY(orig, dest)\")\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_edgar", "title": "create_table_edgar", "text": "<pre><code>create_table_edgar(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> <p>Forecast accuracy data, modeled after UA's EDGAR approach</p> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_edgar(cnx: Database, primary_key: bool = False):\n    \"\"\"Forecast accuracy data, modeled after UA's EDGAR approach\"\"\"\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS edgar\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        iteration\t\tINT NOT NULL,\n        trial\t    \tINT NOT NULL,\n        sample  \t\tINT NOT NULL,\n        timeframe   \tINT NOT NULL,\n        path_id\t\t\tINT NOT NULL,\n        booking_class   VARCHAR(10) NOT NULL,\n        sold\t\t\tINT,\n        sold_priceable  INT,\n        forecast_mean   FLOAT,\n        forecast_stdev  FLOAT,\n        closed          FLOAT,\n        updated_at\t\tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, timeframe, \"\n            \"path_id, booking_class)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_fare_defs", "title": "create_table_fare_defs", "text": "<pre><code>create_table_fare_defs(\n    cnx: Database, fares: Iterable | None = None\n) -&gt; None\n</code></pre> <p>Create and populate a static database table of fares.</p> <p>The contents of this table is static input data, used but not mutated by the simulator.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>fares</code>               (<code>Iterable[Fare]</code>, default:                   <code>None</code> )           \u2013            <p>The fares to store in the database.</p> </li> </ul> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_fare_defs(cnx: Database, fares: Iterable | None = None) -&gt; None:\n    \"\"\"\n    Create and populate a static database table of fares.\n\n    The contents of this table is static input data, used but not mutated\n    by the simulator.\n\n    Parameters\n    ----------\n    cnx : Database\n    fares : Iterable[Fare]\n        The fares to store in the database.\n    \"\"\"\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS fare_defs\n    (\n        fare_id       INTEGER PRIMARY KEY,\n        carrier       VARCHAR(10) NOT NULL,\n        orig          VARCHAR(10) NOT NULL,\n        dest          VARCHAR(10) NOT NULL,\n        booking_class VARCHAR(10) NOT NULL,\n        price         FLOAT NOT NULL,\n        restrictions  VARCHAR(20) NOT NULL,\n        category      VARCHAR(20)\n    );\n    \"\"\"\n    cnx.execute(sql)\n    sql2 = \"\"\"\n    CREATE INDEX IF NOT EXISTS fare_defs_idx_2\n    ON fare_defs (\n        carrier, booking_class\n    );\n    \"\"\"\n    cnx.execute(sql2)\n    for fare in fares:\n        cnx.execute(\n            \"\"\"\n            INSERT OR REPLACE INTO fare_defs(\n                fare_id,\n                carrier,\n                orig,\n                dest,\n                booking_class,\n                price,\n                restrictions,\n                category\n            ) VALUES (\n                ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8\n            )\n            \"\"\",\n            (\n                fare.fare_id,\n                fare.carrier_name,\n                fare.orig,\n                fare.dest,\n                fare.booking_class,\n                fare.price,\n                \",\".join([str(r) for r in fare.get_restrictions()]),\n                fare.category,\n            ),\n        )\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_fare_detail", "title": "create_table_fare_detail", "text": "<pre><code>create_table_fare_detail(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_fare_detail(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS fare_detail\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        iteration\t\tINT NOT NULL,\n        trial\t    \tINT NOT NULL,\n        sample  \t\tINT NOT NULL,\n        days_prior \t\tINT NOT NULL,\n        fare_id         INT NOT NULL,\n        sold\t\t\tINT,\n        sold_business\tINT,\n        updated_at\t\tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, \"\n            \"days_prior, carrier, orig, dest, booking_class)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_fare_restriction_defs", "title": "create_table_fare_restriction_defs", "text": "<pre><code>create_table_fare_restriction_defs(\n    cnx: Database, restrictions: list[str]\n) -&gt; None\n</code></pre> <p>Create and populate a static database table of fare restrictions.</p> <p>The contents of this table is static input data, used but not mutated by the simulator.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>restrictions</code>               (<code>list[str]</code>)           \u2013            <p>The restrictions to store in the database.</p> </li> </ul> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_fare_restriction_defs(cnx: Database, restrictions: list[str]) -&gt; None:\n    \"\"\"\n    Create and populate a static database table of fare restrictions.\n\n    The contents of this table is static input data, used but not mutated\n    by the simulator.\n\n    Parameters\n    ----------\n    cnx : Database\n    restrictions : list[str]\n        The restrictions to store in the database.\n    \"\"\"\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS fare_restriction_defs\n    (\n        restriction_id INTEGER PRIMARY KEY,\n        restriction TEXT NOT NULL\n    );\n    \"\"\"\n    cnx.execute(sql)\n    for idx, restriction in enumerate(restrictions, start=1):\n        cnx.execute(\n            \"\"\"\n            INSERT OR REPLACE INTO fare_restriction_defs(\n                restriction_id,\n                restriction\n            ) VALUES (\n                ?1, ?2\n            )\n            \"\"\",\n            (idx, restriction),\n        )\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_leg_bucket_detail", "title": "create_table_leg_bucket_detail", "text": "<pre><code>create_table_leg_bucket_detail(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_leg_bucket_detail(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS leg_bucket_detail\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        iteration\t\tINT NOT NULL,\n        trial\t    \tINT NOT NULL,\n        sample  \t\tINT NOT NULL,\n        days_prior   \tINT NOT NULL,\n        leg_id          INT NOT NULL,\n        bucket_number   INT NOT NULL,\n        name            VARCHAR(10) NOT NULL,\n        auth    \t\tINT,\n        revenue    \t\tFLOAT,\n        sold\t\t\tINT,\n        untruncated_demand     FLOAT,\n        forecast_mean   FLOAT,\n        forecast_stdev  FLOAT,\n        forecast_closed_in_tf FLOAT,\n        forecast_closed_in_future FLOAT,\n        updated_at\t\tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, days_prior, \"\n            \"carrier, orig, dest, flt_no, dep_date, bucket_number)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_leg_defs", "title": "create_table_leg_defs", "text": "<pre><code>create_table_leg_defs(\n    cnx: Database, legs: Iterable | None = None\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_leg_defs(cnx: Database, legs: Iterable | None = None):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS leg_defs\n    (\n        leg_id INTEGER PRIMARY KEY,\n        flt_no INTEGER,\n        carrier TEXT,\n        orig TEXT,\n        dest TEXT,\n        dep_time INTEGER,\n        arr_time INTEGER,\n        capacity INTEGER,\n        distance FLOAT\n    );\n    \"\"\"\n    cnx.execute(sql)\n    for leg in legs:\n        cnx.execute(\n            \"\"\"\n            INSERT OR REPLACE INTO leg_defs(\n                leg_id,\n                flt_no,\n                carrier,\n                orig,\n                dest,\n                dep_time,\n                arr_time,\n                capacity,\n                distance\n            ) VALUES (\n                ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9\n            )\n            \"\"\",\n            (\n                leg.leg_id,\n                leg.flt_no,\n                leg.carrier_name\n                if hasattr(leg, \"carrier_name\")\n                else leg.carrier,  # TODO remove this\n                leg.orig,\n                leg.dest,\n                leg.dep_time,\n                leg.arr_time,\n                leg.capacity,\n                leg.distance,\n            ),\n        )\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_leg_detail", "title": "create_table_leg_detail", "text": "<pre><code>create_table_leg_detail(\n    cnx: Database, primary_key: bool = False\n) -&gt; None\n</code></pre> <p>Create the <code>leg_detail</code> table in the database.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>primary_key</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> </ul> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_leg_detail(cnx: Database, primary_key: bool = False) -&gt; None:\n    \"\"\"\n    Create the `leg_detail` table in the database.\n\n    Parameters\n    ----------\n    cnx : Database\n    primary_key : bool, default False\n    \"\"\"\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS leg_detail\n    (\n        scenario\t    \tVARCHAR(20) NOT NULL,\n        iteration\t    \tINT NOT NULL,\n        trial\t        \tINT NOT NULL,\n        sample  \t    \tINT NOT NULL,\n        days_prior       \tINT NOT NULL,\n        leg_id\t\t    \tINT NOT NULL,\n        updated_at\t    \tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        sold\t    \t\tINT,\n        revenue             FLOAT,\n        q_demand            FLOAT,\n        untruncated_demand  FLOAT,\n        forecast_mean       FLOAT,\n        bid_price           FLOAT,\n        displacement        FLOAT\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, \"\n            \"carrier, orig, dest, flt_no, days_prior, dep_date)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_path_class_detail", "title": "create_table_path_class_detail", "text": "<pre><code>create_table_path_class_detail(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_path_class_detail(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS path_class_detail\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        iteration\t\tINT NOT NULL,\n        trial\t    \tINT NOT NULL,\n        sample  \t\tINT NOT NULL,\n        days_prior   \tINT NOT NULL,\n        path_id\t\t\tINT NOT NULL,\n        booking_class   VARCHAR(10) NOT NULL,\n        sold\t\t\tINT,\n        sold_priceable  INT,\n        revenue         FLOAT,\n        forecast_mean   FLOAT,\n        forecast_stdev  FLOAT,\n        forecast_closed_in_tf FLOAT,\n        forecast_closed_in_future FLOAT,\n        adjusted_price  FLOAT,\n        updated_at\t\tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, days_prior, \"\n            \"path_id, booking_class)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_path_defs", "title": "create_table_path_defs", "text": "<pre><code>create_table_path_defs(\n    cnx: Database, paths: Iterable | None = None\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_path_defs(cnx: Database, paths: Iterable | None = None):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS path_defs\n    (\n        path_id INTEGER PRIMARY KEY,\n        carrier TEXT,\n        orig TEXT,\n        stop1 TEXT,\n        dest TEXT,\n        leg1 INTEGER,\n        leg2 INTEGER,\n        distance FLOAT\n    );\n    \"\"\"\n    cnx.execute(sql)\n    for pth in paths:\n        connects = pth.num_legs() &gt; 1\n        cnx.execute(\n            \"\"\"\n            INSERT OR REPLACE INTO path_defs(\n                path_id,\n                carrier,\n                orig,\n                stop1,\n                dest,\n                leg1,\n                leg2,\n                distance\n            ) VALUES (\n                ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8\n            )\n            \"\"\",\n            (\n                pth.path_id,\n                pth.get_leg_carrier(0),\n                pth.orig,\n                pth.get_leg_dest(0) if connects else None,\n                pth.dest,\n                pth.get_leg_id(0),\n                pth.get_leg_id(1) if connects else None,\n                pth.get_total_distance(),\n            ),\n        )\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_tables", "title": "create_tables", "text": "<pre><code>create_tables(\n    cnx: Database,\n    primary_keys: dict[str, bool] | None = None,\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_tables(cnx: Database, primary_keys: dict[str, bool] | None = None):\n    pk = dict(\n        leg=False,\n        leg_bucket=False,\n        demand=False,\n        edgar=False,\n        fare=False,\n        booking_curve=True,\n        distance=True,\n        bookings=False,\n        path_class=False,\n    )\n    if primary_keys is not None:\n        pk.update(primary_keys)\n    create_table_configs(cnx)\n    create_table_leg_detail(cnx, pk[\"leg\"])\n    create_table_leg_bucket_detail(cnx, pk[\"leg_bucket\"])\n    create_table_demand_detail(cnx, pk[\"demand\"])\n    create_table_fare_detail(cnx, pk[\"fare\"])\n    create_table_bookings_by_timeframe(cnx, pk[\"bookings\"])\n    create_table_booking_curve(cnx, pk[\"booking_curve\"])\n    create_table_path_class_detail(cnx, pk[\"path_class\"])\n    create_table_edgar(cnx, pk[\"edgar\"])\n    create_table_distance(cnx, pk[\"distance\"])\n    cnx._commit_raw()\n</code></pre>"}, {"location": "Tutorials/index.html", "title": "Tutorials", "text": "<p>This section includes some tutorials to demonstrate some of the capabilities of PassengerSim.  These examples are built upon a very simple three market network with two carriers.  Each airline offers a pair of flights from BOS to ORD, and another pair from ORD to LAX.  Passenger demands are constructed for each single-leg market, as well as for the connecting market BOS-LAX.</p>"}, {"location": "Tutorials/index.html#3mkt-al1", "title": "3MKT AL1", "text": "<pre><code>graph LR\n    BOS--&gt;|101| ORD;\n    BOS--&gt;|102| ORD;\n    ORD--&gt;|111| LAX;\n    ORD--&gt;|112| LAX;</code></pre>"}, {"location": "Tutorials/index.html#3mkt-al2", "title": "3MKT AL2", "text": "<pre><code>graph LR\n    BOS--&gt;|201| ORD;\n    BOS--&gt;|202| ORD;\n    ORD--&gt;|211| LAX;\n    ORD--&gt;|212| LAX;</code></pre>"}, {"location": "Tutorials/3MKT/3mkt-01.nbconvert.html", "title": "Simple FCFS", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.41\npassengersim.core 0.42.dev89+g5ac994e\n</pre> <p>This example uses network/01-base.yaml configuration file. Within a Jupyter notebook, we can directly initialize a PassengerSim <code>Simulation</code> instance from this file using the <code>from_yaml</code> class constructor:</p> In\u00a0[2]: Copied! <pre>sim = pax.Simulation.from_yaml(\"network/01-base.yaml\")\n</pre> sim = pax.Simulation.from_yaml(\"network/01-base.yaml\") <p>Running the simulation is as simple as calling the <code>run</code> command, which runs the simulation and returns a summary output object.</p> In\u00a0[3]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 2.55 seconds\n</pre> <p>The contents of the final summary is controlled by <code>Config.outputs.reports</code>, which allows the user to add reports for more detail, or drop some unneccessary reports to improve runtime (sometimes substantially).</p> In\u00a0[4]: Copied! <pre>sim.config.outputs.reports\n</pre> sim.config.outputs.reports Out[4]: <pre>{'bookings_by_timeframe',\n 'carrier_history',\n 'demand_to_come',\n 'fare_class_mix',\n 'leg_forecasts',\n 'load_factors',\n 'total_demand'}</pre> <p>For this example, several default reports are included, which allows us to access a number of pre-packaged visualizations for the results.</p> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_carrier_mileage()\n</pre> summary.fig_carrier_mileage() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[8]: <p>All demand is in the lowest fare class, because the simulation has no restrictions against customers simply buying the least expensive fare.</p> In\u00a0[9]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[9]: <p>We are not limited to the pre-packaged visualizations. The various summary tables available in the <code>summary</code> object are all just regular pandas DataFrames, so we can use all the usual Python and Pandas tools for analysis. For example, the <code>demand_to_come</code> table summarizes the total demand to come at each timeframe for every simulation sample.</p> In\u00a0[10]: Copied! <pre>summary.demand_to_come\n</pre> summary.demand_to_come Out[10]: days_prior 63 56 49 42 35 31 28 24 21 17 14 10 7 5 3 1 0 iteration trial sample segment orig dest 0 0 100 business BOS LAX 65 61 57 55 51 51 49 48 42 39 39 31 25 19 14 4 0 ORD 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ORD LAX 68 63 59 59 54 52 50 48 47 44 36 32 25 20 16 4 0 leisure BOS LAX 71 58 56 49 43 39 35 30 28 21 16 12 7 7 4 1 0 ORD 49 43 39 34 32 31 27 24 19 15 13 11 11 10 6 1 0 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 499 business BOS ORD 83 77 75 72 70 66 65 62 59 56 55 45 36 27 21 2 0 ORD LAX 155 141 134 131 120 115 114 111 106 99 91 81 62 46 32 12 0 leisure BOS LAX 215 182 165 148 126 113 109 89 84 64 51 42 35 35 20 7 0 ORD 133 111 105 91 76 65 58 49 47 33 26 18 18 15 6 2 0 ORD LAX 198 165 146 132 114 102 95 74 57 51 43 32 24 21 11 4 0 <p>2400 rows \u00d7 17 columns</p> <p>With this data, we can do whatever analysis we like.  Here we'll compute the correlation between total demands (from the beginning of the booking curve at DCP 63 all the way to the end) of different passenger types in different markets.</p> In\u00a0[11]: Copied! <pre>summary.demand_to_come[63].unstack([\"segment\", \"orig\", \"dest\"]).corr()\n</pre> summary.demand_to_come[63].unstack([\"segment\", \"orig\", \"dest\"]).corr() Out[11]: segment business leisure orig BOS ORD BOS ORD dest LAX ORD LAX LAX ORD LAX segment orig dest business BOS LAX 1.000000 0.083927 0.231989 0.337721 0.109801 0.136725 ORD 0.083927 1.000000 0.132940 0.117638 0.371579 0.111497 ORD LAX 0.231989 0.132940 1.000000 0.190033 0.217089 0.352117 leisure BOS LAX 0.337721 0.117638 0.190033 1.000000 0.156787 0.140052 ORD 0.109801 0.371579 0.217089 0.156787 1.000000 0.147393 ORD LAX 0.136725 0.111497 0.352117 0.140052 0.147393 1.000000 <p>The <code>summary</code> object also has a command to dump all the summary tables to an Excel workbook, if you prefer to analyze the results there instead of in Jupyter.</p> In\u00a0[12]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-01.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-01.xlsx\") <p>Download 3mkt-01.xlsx</p> In\u00a0[13]: Copied! <pre>import targets\n\ntarget = targets.load(1, sim.config)\n</pre> import targets  target = targets.load(1, sim.config) In\u00a0[14]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[15]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_segmentation_by_timeframe(\"bookings\", by_carrier=False, by_class=True)\n</pre> comps.fig_segmentation_by_timeframe(\"bookings\", by_carrier=False, by_class=True) Out[17]: <p>We can look at carrier forecasts of demand on individual legs.</p> In\u00a0[18]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"]) Out[18]: <p>We can compare the mean and standard deviation of demand to come.</p> In\u00a0[19]: Copied! <pre>comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\") Out[19]: <p>We can even take arbitrary functions that apply pandas tools, and have them run automatically against multiple summary objects. For example, we can look at the variance-covariance matrix of aggregate demand by passenger type, and compare those matrices for both the simulation and the target.</p> In\u00a0[20]: Copied! <pre>comps.apply(\n    lambda s: s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov()\n)\n</pre> comps.apply(     lambda s: s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov() ) Out[20]: segment business leisure source segment simulation business 3665.319273 2224.550439 leisure 2224.550439 5590.625157 target business 3249.598992 1955.419868 leisure 1955.419868 5359.555328"}, {"location": "Tutorials/3MKT/3mkt-01.nbconvert.html#simple-fcfs", "title": "Simple FCFS\u00b6", "text": "<p>This is a very simple network, with only 3 markets, used to demonstrate some features of PassengerSim.</p>"}, {"location": "Tutorials/3MKT/3mkt-01.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": "<p>In addition to summary reports for a single run, we can also use PassengerSim's <code>contrast</code> package to compare simulation runs to each other, or against exogenously defined target results.</p>"}, {"location": "Tutorials/3MKT/3mkt-02.nbconvert.html", "title": "FCFS with Product Restrictions", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.41\npassengersim.core 0.42.dev89+g5ac994e\n</pre> <p>This example adds the network/02-buyup.yaml configuration file, to enable the product restrictions.</p> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml([\"network/01-base.yaml\", \"network/02-buyup.yaml\"])\n</pre> cfg = pax.Config.from_yaml([\"network/01-base.yaml\", \"network/02-buyup.yaml\"]) <p>The configuration can be manipulated in Python after loading.  This allows for a more interactive experience, where individual input values can readily be altered for a given analysis.</p> In\u00a0[3]: Copied! <pre>cfg.simulation_controls.num_trials = 4\n</pre> cfg.simulation_controls.num_trials = 4 <p>After all the desired changes have been completed, we use the <code>Config</code> to initialize the <code>Simulation</code>.</p> In\u00a0[4]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[5]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 11.08 seconds\n</pre> In\u00a0[6]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[9]: In\u00a0[10]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-02.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-02.xlsx\") <p>Download 3mkt-02.xlsx</p> In\u00a0[11]: Copied! <pre>import targets\n\ntarget = targets.load(2, cfg)\n</pre> import targets  target = targets.load(2, cfg) In\u00a0[12]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[13]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_segmentation_by_timeframe(\"bookings\", by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_segmentation_by_timeframe(\"bookings\", by_carrier=\"AL1\", by_class=True) Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=111)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=111) Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=111, agg_booking_classes=True)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=111, agg_booking_classes=True) Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=101)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=101) Out[19]:"}, {"location": "Tutorials/3MKT/3mkt-02.nbconvert.html#fcfs-with-product-restrictions", "title": "FCFS with Product Restrictions\u00b6", "text": "<p>In this example, we add product restrictions to the simulation.  These restrictions will cause some passengers to \"buy up\" to a fare product other than the lowest price.</p>"}, {"location": "Tutorials/3MKT/3mkt-02.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-03.nbconvert.html", "title": "FCFS with AP and Product Restrictions", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.41\npassengersim.core 0.42.dev89+g5ac994e\n</pre> <p>In prior examples, the configuration were given in one or more external file, passed to the <code>from_yaml</code> constructor as arguments.  We can also craft multi-line yaml content directly in a Python string, and pass that directly to the same contructor.  Here, we will turn the <code>disable_ap</code> switch off, and add a snapshot filter.</p> In\u00a0[2]: Copied! <pre>with_AP = \"\"\"\nsimulation_controls:\n  disable_ap: false\n\nsnapshot_filters:\n- type: leg_untruncation\n  airline: AL1\n  sample: 400\n  flt_no: 101\n  directory: snapshots/em\n\"\"\"\n</pre> with_AP = \"\"\" simulation_controls:   disable_ap: false  snapshot_filters: - type: leg_untruncation   airline: AL1   sample: 400   flt_no: 101   directory: snapshots/em \"\"\" <p>Snapshot filters can be triggered at limited specific points within a large simulation, and they will write out details intermediate results for that specific point.  The example snapshot filter here will provide extra output into the leg untruncation for a single flight on a single sample in the simulation.  Storing this level of detail for every flight for every sample would generally be gratuitous, slowing the simulation significantly and writing out excessively large files, but the snapshots give the ability to see and explore details from deep inside the simulation.</p> In\u00a0[3]: Copied! <pre>cfg = pax.Config.from_yaml([\"network/01-base.yaml\", \"network/02-buyup.yaml\", with_AP])\n</pre> cfg = pax.Config.from_yaml([\"network/01-base.yaml\", \"network/02-buyup.yaml\", with_AP]) In\u00a0[4]: Copied! <pre>cfg.simulation_controls.num_trials = 4\n</pre> cfg.simulation_controls.num_trials = 4 In\u00a0[5]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[6]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 11.44 seconds\n</pre> In\u00a0[7]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[10]: In\u00a0[11]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-03.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-03.xlsx\") <p>Download 3mkt-03.xlsx</p> In\u00a0[12]: Copied! <pre>import targets\n\ntarget = targets.load(3, cfg)\n</pre> import targets  target = targets.load(3, cfg) In\u00a0[13]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[14]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=101)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=101) Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=111)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=111) Out[19]: In\u00a0[20]: Copied! <pre>contrast.fig_leg_forecasts(\n    comps, of=[\"mu\", \"sigma\"], by_leg_id=101, agg_booking_classes=True\n)\n</pre> contrast.fig_leg_forecasts(     comps, of=[\"mu\", \"sigma\"], by_leg_id=101, agg_booking_classes=True ) Out[20]:"}, {"location": "Tutorials/3MKT/3mkt-03.nbconvert.html#fcfs-with-ap-and-product-restrictions", "title": "FCFS with AP and Product Restrictions\u00b6", "text": "<p>In this example, on top of product restrictions we also add advance purchase (AP) restrictions to the simulation.  These restrictions close lower priced fare class products as the day of departure approaches.</p> <p>In this example, we will also demostrate adding yaml configuration content in a Jupyter notebook before loading configs, and adding a snapshot filter to the simulation.</p>"}, {"location": "Tutorials/3MKT/3mkt-03.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-04.nbconvert.html", "title": "EMSR-B with Low Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.41\npassengersim.core 0.42.dev89+g5ac994e\n</pre> <p>The yaml file for this example contains an explicit <code>include</code> instruction directly in the file. This emulates calling multiple file names in the <code>from_yaml</code> command, but the other file references are written directly into the code, so that groups of configurations can be managed together easily, without necessarily needing the user to carefully assemble the correct set of filenames every time they run the simulation.</p> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n\nshow_file(\"network/04-emsrb-low-demand.yaml\")\n</pre> from passengersim.utils.codeview import show_file  show_file(\"network/04-emsrb-low-demand.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 0.5\n\ncarriers:\n  - name: AL1\n    rm_system: rm_no_detruncation\n  - name: AL2\n    rm_system: rm_no_detruncation\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml(\n    [\n        \"network/04-emsrb-low-demand.yaml\",\n    ]\n)\n</pre> sim = pax.Simulation.from_yaml(     [         \"network/04-emsrb-low-demand.yaml\",     ] ) In\u00a0[4]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 1.73 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-04.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-04.xlsx\") <p>Download 3mkt-04.xlsx</p> In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(4, sim.config)\n</pre> import targets  target = targets.load(4, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[12]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[12]: In\u00a0[13]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[15]:"}, {"location": "Tutorials/3MKT/3mkt-04.nbconvert.html#emsr-b-with-low-demand", "title": "EMSR-B with Low Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Demand is simulated at a level 50% lower than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-04.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-05.nbconvert.html", "title": "EMSR-B", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.41\npassengersim.core 0.42.dev89+g5ac994e\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n\nshow_file(\"network/05-emsrb.yaml\")\n</pre> from passengersim.utils.codeview import show_file  show_file(\"network/05-emsrb.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.0\n\ncarriers:\n  - name: AL1\n    rm_system: rm_no_detruncation\n  - name: AL2\n    rm_system: rm_no_detruncation\n\ndb:\n  write_items:\n    - leg_final\n    - fare_final\n    - demand_final\n    - bookings\n    - bucket\n\noutputs:\n  reports:\n    - leg_forecasts\n    - fare_class_mix\n    - load_factors\n    - bookings_by_timeframe\n    - total_demand\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml(\n    [\n        \"network/05-emsrb.yaml\",\n    ]\n)\n</pre> sim = pax.Simulation.from_yaml(     [         \"network/05-emsrb.yaml\",     ] ) In\u00a0[4]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 1.92 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-05.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-05.xlsx\") In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(5, sim.config)\n</pre> import targets  target = targets.load(5, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[12]: Copied! <pre>contrast.fig_carrier_revenues(comps)\n</pre> contrast.fig_carrier_revenues(comps) Out[12]: In\u00a0[13]: Copied! <pre>contrast.fig_carrier_load_factors(comps)\n</pre> contrast.fig_carrier_load_factors(comps) Out[13]: In\u00a0[14]: Copied! <pre>contrast.fig_fare_class_mix(comps)\n</pre> contrast.fig_fare_class_mix(comps) Out[14]: In\u00a0[15]: Copied! <pre>contrast.fig_leg_forecasts(comps, by_leg_id=101)\n</pre> contrast.fig_leg_forecasts(comps, by_leg_id=101) Out[15]: In\u00a0[16]: Copied! <pre>contrast.fig_leg_forecasts(comps, by_leg_id=111, of=[\"mu\", \"sigma\"])\n</pre> contrast.fig_leg_forecasts(comps, by_leg_id=111, of=[\"mu\", \"sigma\"]) Out[16]: In\u00a0[17]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_class=True, by_carrier=\"AL1\")\n</pre> contrast.fig_bookings_by_timeframe(comps, by_class=True, by_carrier=\"AL1\") Out[17]:"}, {"location": "Tutorials/3MKT/3mkt-05.nbconvert.html#emsr-b", "title": "EMSR-B\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Demand is simulated at normal levels.</p>"}, {"location": "Tutorials/3MKT/3mkt-05.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-06.nbconvert.html", "title": "EMSR-B with High Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.41\npassengersim.core 0.42.dev89+g5ac994e\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n\nshow_file(\"network/06-emsrb-high-demand.yaml\")\n</pre> from passengersim.utils.codeview import show_file  show_file(\"network/06-emsrb-high-demand.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.1\n\ncarriers:\n  - name: AL1\n    rm_system: rm_no_detruncation\n  - name: AL2\n    rm_system: rm_no_detruncation\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml(\n    [\n        \"network/06-emsrb-high-demand.yaml\",\n    ]\n)\n</pre> sim = pax.Simulation.from_yaml(     [         \"network/06-emsrb-high-demand.yaml\",     ] ) In\u00a0[4]: Copied! <pre>summary = sim.run(log_reports=False)\n</pre> summary = sim.run(log_reports=False) <pre></pre> <pre>Task Completed after 2.09 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-06.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-06.xlsx\") In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(6, sim.config)\n</pre> import targets  target = targets.load(6, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[12]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[12]: In\u00a0[13]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"]) Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=211, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=211, of=[\"mu\", \"sigma\"]) Out[17]:"}, {"location": "Tutorials/3MKT/3mkt-06.nbconvert.html#emsr-b-with-high-demand", "title": "EMSR-B with High Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Demand is simulated at a level 10% higher than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-06.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-07.nbconvert.html", "title": "EM Untruncation with Low Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.41\npassengersim.core 0.42.dev89+g5ac994e\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n\nshow_file(\"network/07-untrunc-em-low-demand.yaml\")\n</pre> from passengersim.utils.codeview import show_file  show_file(\"network/07-untrunc-em-low-demand.yaml\") <pre>include:\n  - 08-untrunc-em.yaml\n\nsimulation_controls:\n  demand_multiplier: 0.5\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml(\n    [\n        \"network/07-untrunc-em-low-demand.yaml\",\n    ]\n)\n</pre> sim = pax.Simulation.from_yaml(     [         \"network/07-untrunc-em-low-demand.yaml\",     ] ) In\u00a0[4]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 1.96 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-07.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-07.xlsx\") In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(7, sim.config)\n</pre> import targets  target = targets.load(7, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[12]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\")\n</pre> contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\") Out[12]: In\u00a0[13]: Copied! <pre>contrast.fig_carrier_revenues(comps)\n</pre> contrast.fig_carrier_revenues(comps) Out[13]: In\u00a0[14]: Copied! <pre>contrast.fig_fare_class_mix(comps)\n</pre> contrast.fig_fare_class_mix(comps) Out[14]: In\u00a0[15]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\", by_class=True)\n</pre> contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\", by_class=True) Out[15]:"}, {"location": "Tutorials/3MKT/3mkt-07.nbconvert.html#em-untruncation-with-low-demand", "title": "EM Untruncation with Low Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Additionally, the EM algorithm is employed to detruncate censored demand. Demand is simulated at a level 50% lower than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-07.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-08.nbconvert.html", "title": "EM Untruncation", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.41\npassengersim.core 0.42.dev89+g5ac994e\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/08-untrunc-em.yaml\")\n</pre> show_file(\"network/08-untrunc-em.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.0\n\nrm_systems:\n  rm_test1:\n    availability_control: leg\n    processes:\n      DCP:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        name: forecast\n        algorithm: additive_pickup\n        alpha: 0.15\n        kind: leg\n      - step_type: emsr\n        name: optimization\n        algorithm: emsrb\n        kind: leg\n\ncarriers:\n  - name: AL1\n    rm_system: rm_test1\n  - name: AL2\n    rm_system: rm_test1\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml(\n    [\n        \"network/08-untrunc-em.yaml\",\n    ]\n)\n</pre> cfg = pax.Config.from_yaml(     [         \"network/08-untrunc-em.yaml\",     ] ) In\u00a0[5]: Copied! <pre>cfg.simulation_controls.num_trials = 6\n</pre> cfg.simulation_controls.num_trials = 6 In\u00a0[6]: Copied! <pre>cfg.outputs.reports.add(\"local_and_flow_yields\")\n</pre> cfg.outputs.reports.add(\"local_and_flow_yields\") In\u00a0[7]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[8]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 15.24 seconds\n</pre> In\u00a0[9]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[11]: In\u00a0[12]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[12]: In\u00a0[13]: Copied! <pre>summary.local_and_flow_yields\n</pre> summary.local_and_flow_yields Out[13]: leg_id carrier orig dest capacity distance local_yield local_fraction flow_yield 0 101 AL1 BOS ORD 100 863.753282 0.227482 0.418117 0.161239 1 102 AL1 BOS ORD 100 863.753282 0.228197 0.420482 0.160945 2 111 AL1 ORD LAX 120 1739.799337 0.175858 0.545889 0.161239 3 112 AL1 ORD LAX 120 1739.799337 0.176321 0.547027 0.160945 4 201 AL2 BOS ORD 100 863.753282 0.228448 0.419410 0.160955 5 202 AL2 BOS ORD 100 863.753282 0.227963 0.418427 0.161525 6 211 AL2 ORD LAX 120 1739.799337 0.175946 0.546921 0.160955 7 212 AL2 ORD LAX 120 1739.799337 0.176034 0.546186 0.161525 In\u00a0[14]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-08.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-08.xlsx\") In\u00a0[15]: Copied! <pre>import targets\n\ntarget = targets.load(8, cfg)\n</pre> import targets  target = targets.load(8, cfg) In\u00a0[16]: Copied! <pre>from passengersim import contrast\n</pre> from passengersim import contrast In\u00a0[17]: Copied! <pre>comps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[18]: Copied! <pre>comps.fig_demand_to_come(\"mean\")\n</pre> comps.fig_demand_to_come(\"mean\") Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"std\") Out[19]: In\u00a0[20]: Copied! <pre>comps.apply(\n    lambda s: (s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov())\n)\n</pre> comps.apply(     lambda s: (s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov()) ) Out[20]: segment business leisure source segment simulation business 3263.099012 1976.758878 leisure 1976.758878 5291.913397 target business 3249.598992 1955.419868 leisure 1955.419868 5359.555328 In\u00a0[21]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\", by_class=True)\n</pre> contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\", by_class=True) Out[21]: In\u00a0[22]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[22]: In\u00a0[23]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[23]: In\u00a0[24]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[24]: In\u00a0[25]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[25]: In\u00a0[26]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"]) Out[26]: In\u00a0[27]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"]) Out[27]: In\u00a0[28]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"]) Out[28]:"}, {"location": "Tutorials/3MKT/3mkt-08.nbconvert.html#em-untruncation", "title": "EM Untruncation\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Additionally, the EM algorithm is employed to detruncate censored demand. Demand is simulated at normal levels.</p>"}, {"location": "Tutorials/3MKT/3mkt-08.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-09.nbconvert.html", "title": "EM Untruncation with High Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.41\npassengersim.core 0.42.dev89+g5ac994e\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/09-untrunc-em-high-demand.yaml\")\n</pre> show_file(\"network/09-untrunc-em-high-demand.yaml\") <pre>include:\n  - 08-untrunc-em.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.1\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml(\n    [\n        \"network/09-untrunc-em-high-demand.yaml\",\n    ]\n)\n</pre> cfg = pax.Config.from_yaml(     [         \"network/09-untrunc-em-high-demand.yaml\",     ] ) In\u00a0[5]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[6]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 2.54 seconds\n</pre> In\u00a0[7]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[10]: In\u00a0[11]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-09.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-09.xlsx\") In\u00a0[12]: Copied! <pre>import targets\n\ntarget = targets.load(9, cfg)\n</pre> import targets  target = targets.load(9, cfg) In\u00a0[13]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[14]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=False, by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=False, by_class=True) Out[19]: In\u00a0[20]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"]) Out[20]: In\u00a0[21]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"]) Out[21]: In\u00a0[22]: Copied! <pre>from passengersim.utils.targets import computed_targets\n\nc_targets = computed_targets(cfg)\n</pre> from passengersim.utils.targets import computed_targets  c_targets = computed_targets(cfg) In\u00a0[23]: Copied! <pre>contrast.fig_bookings_by_timeframe(\n    {\n        \"c_targets\": c_targets,\n        \"simulation\": summary,\n        \"target\": target,\n    },\n    by_carrier=False,\n    by_class=True,\n)\n</pre> contrast.fig_bookings_by_timeframe(     {         \"c_targets\": c_targets,         \"simulation\": summary,         \"target\": target,     },     by_carrier=False,     by_class=True, ) Out[23]:"}, {"location": "Tutorials/3MKT/3mkt-09.nbconvert.html#em-untruncation-with-high-demand", "title": "EM Untruncation with High Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Additionally, the EM algorithm is employed to detruncate censored demand. Demand is simulated at a level 10% higher than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-09.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-10.nbconvert.html", "title": "ProBP", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.41\npassengersim.core 0.42.dev89+g5ac994e\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/10-probp.yaml\")\n</pre> show_file(\"network/10-probp.yaml\") <pre>include:\n  - 08-untrunc-em.yaml\n\nscenario: 3MKTproBP\n\ndb:\n  write_items:\n    - leg_final\n    - fare_final\n    - demand_final\n    - bookings\n    - bucket\n    - pathclass\n    - leg\n    - demand\n\nsimulation_controls:\n  num_trials: 10\n  show_progress_bar: false\n\nrm_systems:\n  rm_probp:\n    availability_control: bp\n    processes:\n      DCP:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: em\n        kind: path\n      - step_type: forecast\n        name: path_forecast\n        algorithm: additive_pickup\n        kind: path\n      - step_type: probp\n        name: optimization\n      - step_type: aggregation  # not needed for algorithm, but gives leg forecast data for output\n        name: aggregate\n\ncarriers:\n  - name: AL1\n    rm_system: rm_probp\n  - name: AL2\n    rm_system: rm_probp\n\nsnapshot_filters:\n   - type: pro_bp\n     title: ProBP Snapshot\n     sample: [120, 290, 499]\n     dcp: [63, 56, 21]\n     flt_no: 111\n     airline: AL1\n     directory: snapshots/probp\n\noutputs:\n  reports:\n    - fare_class_mix\n    - load_factors\n    - bookings_by_timeframe\n    - total_demand\n    - leg_forecasts\n    - path_forecasts\n    - [od_fare_class_mix, BOS, ORD]\n    - [od_fare_class_mix, BOS, LAX]\n    - [od_fare_class_mix, ORD, LAX]\n    - demand_to_come\n    - carrier_history\n    - bid_price_history\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml([\"network/10-probp.yaml\"])\n</pre> cfg = pax.Config.from_yaml([\"network/10-probp.yaml\"]) In\u00a0[5]: Copied! <pre>cfg.simulation_controls.num_trials = 2\n</pre> cfg.simulation_controls.num_trials = 2 In\u00a0[6]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[7]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() In\u00a0[8]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[11]: In\u00a0[12]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-10.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-10.xlsx\") In\u00a0[13]: Copied! <pre>import targets\n\ntarget = targets.load(10, cfg)\n</pre> import targets  target = targets.load(10, cfg) In\u00a0[14]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[15]: Copied! <pre>comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\") Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[19]: In\u00a0[20]: Copied! <pre>comps.fig_segmentation_by_timeframe(\n    \"bookings\", by_carrier=\"AL1\", by_class=True, source_labels=True\n)\n</pre> comps.fig_segmentation_by_timeframe(     \"bookings\", by_carrier=\"AL1\", by_class=True, source_labels=True ) Out[20]: In\u00a0[21]: Copied! <pre>print(sim.path_names()[1])\ncomps.fig_path_forecasts(by_path_id=1, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[1]) comps.fig_path_forecasts(by_path_id=1, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path: BOS~ORD, (AL1:101 BOS-ORD)\n</pre> Out[21]: In\u00a0[22]: Copied! <pre>print(sim.path_names()[5])\ncomps.fig_path_forecasts(by_path_id=5, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[5]) comps.fig_path_forecasts(by_path_id=5, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path: ORD~LAX, (AL1:111 ORD-LAX)\n</pre> Out[22]: In\u00a0[23]: Copied! <pre>print(sim.path_names()[9])\ncomps.fig_path_forecasts(by_path_id=9, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[9]) comps.fig_path_forecasts(by_path_id=9, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path: BOS~LAX, (AL1:101 BOS-ORD) (AL1:111 ORD-LAX)\n</pre> Out[23]: In\u00a0[24]: Copied! <pre>comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\")\n</pre> comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\") Out[24]: In\u00a0[25]: Copied! <pre>comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\", show_stdev=1)\n</pre> comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\", show_stdev=1) Out[25]: In\u00a0[26]: Copied! <pre>from passengersim.extra.forecast_viz import fig_forecasts_and_bid_prices\n</pre> from passengersim.extra.forecast_viz import fig_forecasts_and_bid_prices In\u00a0[27]: Copied! <pre>fig_forecasts_and_bid_prices(\n    sim,\n    trial=0,\n    days_prior=63,\n    leg_id=111,\n)\n</pre> fig_forecasts_and_bid_prices(     sim,     trial=0,     days_prior=63,     leg_id=111, ) Out[27]:"}, {"location": "Tutorials/3MKT/3mkt-10.nbconvert.html#probp", "title": "ProBP\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-10.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-11.nbconvert.html", "title": "ProBP with Daily Reoptimization", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.41\npassengersim.core 0.42.dev89+g5ac994e\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/11-probp-daily.yaml\")\n</pre> show_file(\"network/11-probp-daily.yaml\") <pre>include:\n  - 10-probp.yaml\n\nscenario: 3MKTproBP-Daily\n\nrm_systems:\n  rm_probp:\n    processes:\n      DAILY:\n        - step_type: forecastadjustment\n          algorithm: timeframe\n          kind: path\n        - step_type: probp\n          name: optimization\n\nsimulation_controls:\n  show_progress_bar: true\n\ndb:\n  write_items:\n    - leg_final\n    - fare_final\n    - demand_final\n    - bookings\n    - bucket\n    - pathclass\n    - leg\n    - demand\n    - leg_daily\n    - pathclass_daily\n\nsnapshot_filters:\n  - type: pro_bp\n    title: ProBP Snapshot\n    sample: [ 120, 290, 499 ]\n    dcp: [ 63, 56, 21 ]\n    flt_no: 111\n    airline: AL1\n    directory: snapshots/probp\n  - type: forecast_adj\n    title: Forecast Adj Snapshot\n    sample: [ 120, 290, 499 ]\n    flt_no: 111\n    airline: AL1\n    directory: snapshots/fcst-adj\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml(\"network/11-probp-daily.yaml\")\ncfg.simulation_controls.num_trials = 1\n</pre> cfg = pax.Config.from_yaml(\"network/11-probp-daily.yaml\") cfg.simulation_controls.num_trials = 1 In\u00a0[5]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[6]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 5.95 seconds\n</pre> In\u00a0[7]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[10]: In\u00a0[11]: Copied! <pre>import targets\n\ntarget = targets.load(11, cfg)\n</pre> import targets  target = targets.load(11, cfg) In\u00a0[12]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[13]: Copied! <pre>comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\") Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_segmentation_by_timeframe(\n    \"bookings\", by_carrier=\"AL1\", by_class=True, source_labels=True\n)\n</pre> comps.fig_segmentation_by_timeframe(     \"bookings\", by_carrier=\"AL1\", by_class=True, source_labels=True ) Out[18]: In\u00a0[19]: Copied! <pre>print(sim.path_names()[1])\ncomps.fig_path_forecasts(by_path_id=1, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[1]) comps.fig_path_forecasts(by_path_id=1, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path: BOS~ORD, (AL1:101 BOS-ORD)\n</pre> Out[19]: In\u00a0[20]: Copied! <pre>print(sim.path_names()[5])\ncomps.fig_path_forecasts(by_path_id=5, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[5]) comps.fig_path_forecasts(by_path_id=5, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path: ORD~LAX, (AL1:111 ORD-LAX)\n</pre> Out[20]: In\u00a0[21]: Copied! <pre>print(sim.path_names()[9])\ncomps.fig_path_forecasts(by_path_id=9, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[9]) comps.fig_path_forecasts(by_path_id=9, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path: BOS~LAX, (AL1:101 BOS-ORD) (AL1:111 ORD-LAX)\n</pre> Out[21]: In\u00a0[22]: Copied! <pre>comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\")\n</pre> comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\") Out[22]: In\u00a0[23]: Copied! <pre>comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\", show_stdev=1)\n</pre> comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\", show_stdev=1) Out[23]: In\u00a0[24]: Copied! <pre>from passengersim.extra.forecast_viz import fig_forecasts_and_bid_prices\n</pre> from passengersim.extra.forecast_viz import fig_forecasts_and_bid_prices In\u00a0[25]: Copied! <pre>fig_forecasts_and_bid_prices(\n    sim,\n    trial=0,\n    days_prior=63,\n    leg_id=111,\n)\n</pre> fig_forecasts_and_bid_prices(     sim,     trial=0,     days_prior=63,     leg_id=111, ) Out[25]: In\u00a0[26]: Copied! <pre>fig_forecasts_and_bid_prices(\n    sim,\n    trial=0,\n    days_prior=63,\n    leg_id=101,\n)\n</pre> fig_forecasts_and_bid_prices(     sim,     trial=0,     days_prior=63,     leg_id=101, ) Out[26]:"}, {"location": "Tutorials/3MKT/3mkt-11.nbconvert.html#probp-with-daily-reoptimization", "title": "ProBP with Daily Reoptimization\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-11.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-12.nbconvert.html", "title": "ProBP Deprecated Approach", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.41\npassengersim.core 0.42.dev89+g5ac994e\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/11-probp-daily.yaml\")\n</pre> show_file(\"network/11-probp-daily.yaml\") <pre>include:\n  - 10-probp.yaml\n\nscenario: 3MKTproBP-Daily\n\nrm_systems:\n  rm_probp:\n    processes:\n      DAILY:\n        - step_type: forecastadjustment\n          algorithm: timeframe\n          kind: path\n        - step_type: probp\n          name: optimization\n\nsimulation_controls:\n  show_progress_bar: true\n\ndb:\n  write_items:\n    - leg_final\n    - fare_final\n    - demand_final\n    - bookings\n    - bucket\n    - pathclass\n    - leg\n    - demand\n    - leg_daily\n    - pathclass_daily\n\nsnapshot_filters:\n  - type: pro_bp\n    title: ProBP Snapshot\n    sample: [ 120, 290, 499 ]\n    dcp: [ 63, 56, 21 ]\n    flt_no: 111\n    airline: AL1\n    directory: snapshots/probp\n  - type: forecast_adj\n    title: Forecast Adj Snapshot\n    sample: [ 120, 290, 499 ]\n    flt_no: 111\n    airline: AL1\n    directory: snapshots/fcst-adj\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml(\"network/11-probp-daily.yaml\")\ncfg.simulation_controls.num_trials = 1\n</pre> cfg = pax.Config.from_yaml(\"network/11-probp-daily.yaml\") cfg.simulation_controls.num_trials = 1 In\u00a0[5]: Copied! <pre>cfg.rm_systems[\"rm_probp\"].processes[\"daily\"][0].algorithm = \"days_to_departure\"\n</pre> cfg.rm_systems[\"rm_probp\"].processes[\"daily\"][0].algorithm = \"days_to_departure\" In\u00a0[6]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[7]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 6.24 seconds\n</pre> In\u00a0[8]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[11]: In\u00a0[12]: Copied! <pre>import targets\n\ntarget = targets.load(12, cfg)\n</pre> import targets  target = targets.load(12, cfg) In\u00a0[13]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[14]: Copied! <pre>comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\") Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True, source_labels=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True, source_labels=True) Out[19]: <p>Interpolation to departure is not advised because customer arrival rates are often very far from uniformly distributed, resulting in forecasts that exhibit a sawtooth pattern.</p> In\u00a0[20]: Copied! <pre>print(sim.path_names()[1])\ncomps.fig_path_forecasts(by_path_id=1, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[1]) comps.fig_path_forecasts(by_path_id=1, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path: BOS~ORD, (AL1:101 BOS-ORD)\n</pre> Out[20]: In\u00a0[21]: Copied! <pre>print(sim.path_names()[5])\ncomps.fig_path_forecasts(by_path_id=5, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[5]) comps.fig_path_forecasts(by_path_id=5, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path: ORD~LAX, (AL1:111 ORD-LAX)\n</pre> Out[21]: In\u00a0[22]: Copied! <pre>print(sim.path_names()[9])\ncomps.fig_path_forecasts(by_path_id=9, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[9]) comps.fig_path_forecasts(by_path_id=9, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path: BOS~LAX, (AL1:101 BOS-ORD) (AL1:111 ORD-LAX)\n</pre> Out[22]: In\u00a0[23]: Copied! <pre>comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\")\n</pre> comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\") Out[23]: In\u00a0[24]: Copied! <pre>comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\", show_stdev=1)\n</pre> comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\", show_stdev=1) Out[24]: In\u00a0[25]: Copied! <pre>from passengersim.extra.forecast_viz import fig_forecasts_and_bid_prices\n</pre> from passengersim.extra.forecast_viz import fig_forecasts_and_bid_prices In\u00a0[26]: Copied! <pre>fig_forecasts_and_bid_prices(\n    sim,\n    trial=0,\n    days_prior=63,\n    leg_id=111,\n)\n</pre> fig_forecasts_and_bid_prices(     sim,     trial=0,     days_prior=63,     leg_id=111, ) Out[26]: In\u00a0[27]: Copied! <pre>fig_forecasts_and_bid_prices(\n    sim,\n    trial=0,\n    days_prior=63,\n    leg_id=101,\n)\n</pre> fig_forecasts_and_bid_prices(     sim,     trial=0,     days_prior=63,     leg_id=101, ) Out[27]:"}, {"location": "Tutorials/3MKT/3mkt-12.nbconvert.html#probp-deprecated-approach", "title": "ProBP Deprecated Approach\u00b6", "text": "<p>In this example, ProBP is applied with daily re-optimization, using a forecast adjusted by linear interpolation between the forecast point and departure.  This is provided as a technical demonstration, but for actual implementations and analysis of ProBP reoptimization, users are recommended to employ the timeframe-based adjustment algorithm instead.</p>"}, {"location": "Tutorials/3MKT/3mkt-12.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-50.nbconvert.html", "title": "Custom Forecaster", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.41\npassengersim.core 0.42.dev89+g5ac994e\n</pre> <p>We'll first run a simulation without the change as a baseline.  As this tutorial is meant as a technology demonstration and not for serious statistical analysis, we'll only run one trial so it goes fast, and we won't worry about statistical validity.</p> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(\"network/08-untrunc-em.yaml\")\ncfg.simulation_controls.num_trials = 1\n</pre> cfg = pax.Config.from_yaml(\"network/08-untrunc-em.yaml\") cfg.simulation_controls.num_trials = 1 In\u00a0[3]: Copied! <pre>sim = pax.Simulation(cfg)\nbaseline_summary = sim.run()\n</pre> sim = pax.Simulation(cfg) baseline_summary = sim.run() <pre></pre> <pre>Task Completed after 2.63 seconds\n</pre> In\u00a0[4]: Copied! <pre>baseline_summary.fig_carrier_revenues()\n</pre> baseline_summary.fig_carrier_revenues() Out[4]: <p>Now we swap in our custom forecast algorithm.</p> In\u00a0[5]: Copied! <pre>from passengersim.extra.olympic_forecast import OlympicForecastStep  # noqa: F401\n\nextra_config = \"\"\"\nrm_systems:\n  rm_test2:\n    availability_control: leg\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: olympicforecast\n      - step_type: emsr\n        algorithm: emsrb\ncarriers:\n  - name: AL1\n    rm_system: rm_test2\n  - name: AL2\n    rm_system: rm_test1\n\"\"\"\n\ncfg = pax.Config.from_yaml(\n    [\n        \"network/08-untrunc-em.yaml\",\n        extra_config,\n    ]\n)\ncfg.simulation_controls.num_trials = 1\n</pre> from passengersim.extra.olympic_forecast import OlympicForecastStep  # noqa: F401  extra_config = \"\"\" rm_systems:   rm_test2:     availability_control: leg     processes:       DCP:       - step_type: untruncation         algorithm: em         kind: leg       - step_type: olympicforecast       - step_type: emsr         algorithm: emsrb carriers:   - name: AL1     rm_system: rm_test2   - name: AL2     rm_system: rm_test1 \"\"\"  cfg = pax.Config.from_yaml(     [         \"network/08-untrunc-em.yaml\",         extra_config,     ] ) cfg.simulation_controls.num_trials = 1 In\u00a0[6]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[7]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 2.41 seconds\n</pre> In\u00a0[8]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[8]: In\u00a0[9]: Copied! <pre>from passengersim.contrast import Contrast\n\ncomp = Contrast(Baseline=baseline_summary, Olympic=summary)\n</pre> from passengersim.contrast import Contrast  comp = Contrast(Baseline=baseline_summary, Olympic=summary) In\u00a0[10]: Copied! <pre>comp.fig_carrier_revenues()\n</pre> comp.fig_carrier_revenues() Out[10]: In\u00a0[11]: Copied! <pre>comp.fig_carrier_load_factors()\n</pre> comp.fig_carrier_load_factors() Out[11]: In\u00a0[12]: Copied! <pre>comp.fig_fare_class_mix()\n</pre> comp.fig_fare_class_mix() Out[12]: In\u00a0[13]: Copied! <pre>comp.fig_segmentation_by_timeframe(\n    \"bookings\", by_carrier=\"AL1\", by_class=True, source_labels=True\n)\n</pre> comp.fig_segmentation_by_timeframe(     \"bookings\", by_carrier=\"AL1\", by_class=True, source_labels=True ) Out[13]: In\u00a0[14]: Copied! <pre>comp.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"])\n</pre> comp.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"]) Out[14]: In\u00a0[15]: Copied! <pre>comp.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"])\n</pre> comp.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"]) Out[15]:"}, {"location": "Tutorials/3MKT/3mkt-50.nbconvert.html#custom-forecaster", "title": "Custom Forecaster\u00b6", "text": "<p>In this example, we use a custom forecast algorithm, the \"Olympic Average\", implemented in Python.  In this forecast, the mean (mu) forecast for any bucket is computed by taking the 26 historical values, discarding the highest and lowest, and taking the mean of the remaining 24 values.</p>"}, {"location": "Tutorials/3MKT/3mkt-50.nbconvert.html#comparing-results", "title": "Comparing Results\u00b6", "text": ""}, {"location": "Tutorials/3MKT/gallery/EE.nbconvert.html", "title": "EMSR-B Optimization", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n</pre> import passengersim as pax In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\"))\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\")) In\u00a0[3]: Copied! <pre>cfg.carriers.AL1.rm_system = \"E\"\ncfg.carriers.AL2.rm_system = \"E\"\n\ncfg.simulation_controls.num_trials = 1\ncfg.simulation_controls.num_samples = 600\n\ncfg.outputs.reports.clear()\ncfg.db = None\n</pre> cfg.carriers.AL1.rm_system = \"E\" cfg.carriers.AL2.rm_system = \"E\"  cfg.simulation_controls.num_trials = 1 cfg.simulation_controls.num_samples = 600  cfg.outputs.reports.clear() cfg.db = None In\u00a0[4]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[5]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 1.87 seconds\n</pre> In\u00a0[6]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_carrier_rasm()\n</pre> summary.fig_carrier_rasm() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_bookings_by_timeframe(by_class=True, by_carrier=\"AL1\")\n</pre> summary.fig_bookings_by_timeframe(by_class=True, by_carrier=\"AL1\") Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\")\n</pre> summary.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\") Out[11]: In\u00a0[12]: Copied! <pre>summary.fig_select_leg_analysis(101)\n</pre> summary.fig_select_leg_analysis(101) Out[12]:"}, {"location": "Tutorials/3MKT/gallery/EE.nbconvert.html#emsr-b-optimization", "title": "EMSR-B Optimization\u00b6", "text": ""}, {"location": "Tutorials/3MKT/gallery/NL.nbconvert.html", "title": "Leg-based Hybrid Optimization", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n</pre> import passengersim as pax <pre>/Users/jpn/Git/umbrella/passengersim-core/environments/.pixi/envs/default/lib/python3.12/site-packages/xmle/elem.py:226: SyntaxWarning: invalid escape sequence '\\g'\n  \"colspan=\\\"\\g&lt;1&gt;\\\"&gt;\",\n/Users/jpn/Git/umbrella/passengersim-core/environments/.pixi/envs/default/lib/python3.12/site-packages/xmle/reporter.py:50: SyntaxWarning: invalid escape sequence '\\s'\n  i.text = re.sub(f\"{caption_class}(\\s?[0-9]*):\", f\"{caption_class} {n+1}:\", i.text, count=0, flags=0)\n</pre> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\"))\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\")) In\u00a0[3]: Copied! <pre>cfg.carriers.AL1.rm_system = \"F\"\ncfg.carriers.AL2.rm_system = \"E\"\n\ncfg.simulation_controls.num_trials = 1\ncfg.simulation_controls.num_samples = 1600\n\ncfg.outputs.reports.clear()\ncfg.db = None\n</pre> cfg.carriers.AL1.rm_system = \"F\" cfg.carriers.AL2.rm_system = \"E\"  cfg.simulation_controls.num_trials = 1 cfg.simulation_controls.num_samples = 1600  cfg.outputs.reports.clear() cfg.db = None In\u00a0[4]: Copied! <pre>pax.config.standards.describe_standard_rm_systems()\n</pre> pax.config.standards.describe_standard_rm_systems() <pre>E:\n  Leg-based additive pickup forecast, EM detruncation, EMSR-B\n  optimization.\nP:\n  Path-based additive pickup forecast, EM detruncation, ProBP\n  optimization.\nU:\n  Path-based additive pickup forecast, EM detruncation, UDP\n  optimization.\nC:\n  Path-based additive pickup conditional forecast, EM detruncation of\n  yieldable demand, ProBP optimization.\nM:\n  Path-based additive pickup conditional forecast, EM detruncation of\n  yieldable demand, MR fare adjustment with 25% scaling, ProBP\n  optimization.\nK:\n  Path-based additive pickup conditional forecast, EM detruncation of\n  yieldable demand, KI fare adjustment with 25% scaling, ProBP\n  optimization.\nQ:\n  Path-based additive pickup PODS-style Q-hybrid forecast (with no\n  fare restrictions this becomes Q-only), EM detruncation of priceable\n  and yieldable demand (separately), ProBP optimization.\nF:\n  Path-based additive pickup PODS-style Q-hybrid forecast (with no\n  fare restrictions this becomes Q-only), EM detruncation of priceable\n  and yieldable demand (separately), MR fare adjustment with 25%\n  scaling, ProBP optimization.\nQ_PAX:\n  Path-based additive pickup PassengerSim-style Q forecast, Assume no\n  fare restrictions and thus no yieldable demand, ProBP optimization.\nL:\n  Leg-based additive pickup conditional forecast, EM detruncation of\n  yieldable demand, EMSR-B optimization.\nJ:\n  Leg-based additive pickup conditional forecast, EM detruncation of\n  yieldable demand, LegDP optimization.\n\n</pre> In\u00a0[5]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[6]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 8.12 seconds\n</pre> In\u00a0[7]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_carrier_rasm()\n</pre> summary.fig_carrier_rasm() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_bookings_by_timeframe(by_class=True, by_carrier=\"AL1\")\n</pre> summary.fig_bookings_by_timeframe(by_class=True, by_carrier=\"AL1\") Out[11]: In\u00a0[12]: Copied! <pre>summary.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\")\n</pre> summary.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\") Out[12]: In\u00a0[13]: Copied! <pre>summary.fig_select_leg_analysis(101)\n</pre> summary.fig_select_leg_analysis(101) Out[13]:"}, {"location": "Tutorials/3MKT/gallery/NL.nbconvert.html#leg-based-hybrid-optimization", "title": "Leg-based Hybrid Optimization\u00b6", "text": ""}, {"location": "Tutorials/3MKT/gallery/PE.nbconvert.html", "title": "ProBP Optimization", "text": "In\u00a0[1]: Copied! <pre>from textwrap import fill\n\nimport passengersim as pax\n\npax.versions()\n</pre> from textwrap import fill  import passengersim as pax  pax.versions() <pre>passengersim 0.46.dev64+g38512c5.d20250205\npassengersim.core 0.46.dev129+gf305fba\n</pre> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\"))\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\")) In\u00a0[3]: Copied! <pre>cfg.carriers.AL1.rm_system = \"P\"\ncfg.carriers.AL2.rm_system = \"E\"\n\ncfg.simulation_controls.num_trials = 1\ncfg.simulation_controls.num_samples = 600\n\ncfg.outputs.reports.clear()\ncfg.db = None\n</pre> cfg.carriers.AL1.rm_system = \"P\" cfg.carriers.AL2.rm_system = \"E\"  cfg.simulation_controls.num_trials = 1 cfg.simulation_controls.num_samples = 600  cfg.outputs.reports.clear() cfg.db = None In\u00a0[4]: Copied! <pre>cfg = cfg.model_revalidate()\n</pre> cfg = cfg.model_revalidate() In\u00a0[5]: Copied! <pre>print(fill(cfg.rm_systems.E.description))\n</pre> print(fill(cfg.rm_systems.E.description)) <pre>Leg-based additive pickup forecast, EM detruncation, EMSR-B\noptimization.\n</pre> In\u00a0[6]: Copied! <pre>print(fill(cfg.rm_systems.P.description))\n</pre> print(fill(cfg.rm_systems.P.description)) <pre>Path-based additive pickup forecast, EM detruncation, ProBP\noptimization.\n</pre> In\u00a0[7]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[8]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 3.06 seconds\n</pre> In\u00a0[9]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_carrier_rasm()\n</pre> summary.fig_carrier_rasm() Out[11]: In\u00a0[12]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[12]: In\u00a0[13]: Copied! <pre>summary.fig_bookings_by_timeframe(by_class=True, by_carrier=\"AL1\")\n</pre> summary.fig_bookings_by_timeframe(by_class=True, by_carrier=\"AL1\") Out[13]: In\u00a0[14]: Copied! <pre>summary.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\")\n</pre> summary.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\") Out[14]: In\u00a0[15]: Copied! <pre>summary.fig_select_leg_analysis(101)\n</pre> summary.fig_select_leg_analysis(101) Out[15]:"}, {"location": "Tutorials/3MKT/gallery/PE.nbconvert.html#probp-optimization", "title": "ProBP Optimization\u00b6", "text": ""}, {"location": "Tutorials/3MKT/gallery/QC.nbconvert.html", "title": "Q Forecasting", "text": "In\u00a0[1]: Copied! <pre>from textwrap import fill\n\nimport numpy as np\nimport pandas as pd\n\nimport passengersim as pax\n\npax.versions()\n</pre> from textwrap import fill  import numpy as np import pandas as pd  import passengersim as pax  pax.versions() <pre>passengersim 0.48.dev1+g32f2bc5\npassengersim.core 0.48.dev7+gcf5e66b\n</pre> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\"))\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\")) <p>In this example, we will work with a completely fenceless marketplace.  To convert the typical 3MKT network into a restriction-free network, we can use a tool to strip the restrictions.</p> In\u00a0[3]: Copied! <pre>from passengersim.config.manipulate import strip_all_restrictions\n\ncfg = strip_all_restrictions(cfg)\n</pre> from passengersim.config.manipulate import strip_all_restrictions  cfg = strip_all_restrictions(cfg) In\u00a0[4]: Copied! <pre>cfg.carriers.AL1.rm_system = \"Q\"\ncfg.carriers.AL2.rm_system = \"C\"\n</pre> cfg.carriers.AL1.rm_system = \"Q\" cfg.carriers.AL2.rm_system = \"C\" <p>We need to revalidate the congfiguration to be able to view or modify the RM system definitions prior to initializing the simulation.</p> In\u00a0[5]: Copied! <pre>cfg = cfg.model_revalidate()\n</pre> cfg = cfg.model_revalidate() In\u00a0[6]: Copied! <pre>print(fill(cfg.rm_systems.Q.description))\n</pre> print(fill(cfg.rm_systems.Q.description)) <pre>Path-based additive pickup PODS-style Q-hybrid forecast (with no fare\nrestrictions this becomes Q-only), EM detruncation of priceable and\nyieldable demand (separately), ProBP optimization.\n</pre> In\u00a0[7]: Copied! <pre>print(fill(cfg.rm_systems.C.description))\n</pre> print(fill(cfg.rm_systems.C.description)) <pre>Path-based additive pickup conditional forecast, EM detruncation of\nyieldable demand, ProBP optimization.\n</pre> In\u00a0[8]: Copied! <pre>cfg.simulation_controls.num_trials = 1\ncfg.simulation_controls.num_samples = 600\n</pre> cfg.simulation_controls.num_trials = 1 cfg.simulation_controls.num_samples = 600 In\u00a0[9]: Copied! <pre>sim = pax.Simulation(cfg)\nsummary = sim.run()\n</pre> sim = pax.Simulation(cfg) summary = sim.run() <pre>Output()</pre> <pre></pre> <pre>Task Completed after 8.35 seconds\n</pre> In\u00a0[10]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[11]: In\u00a0[12]: Copied! <pre>summary.fig_carrier_rasm()\n</pre> summary.fig_carrier_rasm() Out[12]: In\u00a0[13]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[13]: In\u00a0[14]: Copied! <pre>summary.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\")\n</pre> summary.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\") Out[14]: In\u00a0[15]: Copied! <pre>cfg2 = cfg.model_copy(deep=True)\ndel cfg2.rm_systems.Q.processes.dcp.q_untruncation\n</pre> cfg2 = cfg.model_copy(deep=True) del cfg2.rm_systems.Q.processes.dcp.q_untruncation In\u00a0[16]: Copied! <pre>summary2 = pax.Simulation(cfg2).run()\n</pre> summary2 = pax.Simulation(cfg2).run() <pre>Output()</pre> <pre></pre> <pre>Task Completed after 4.70 seconds\n</pre> In\u00a0[17]: Copied! <pre>summary2.fig_carrier_revenues()\n</pre> summary2.fig_carrier_revenues() Out[17]: In\u00a0[18]: Copied! <pre>summary2.fig_carrier_load_factors()\n</pre> summary2.fig_carrier_load_factors() Out[18]: In\u00a0[19]: Copied! <pre>summary2.fig_carrier_rasm()\n</pre> summary2.fig_carrier_rasm() Out[19]: In\u00a0[20]: Copied! <pre>summary2.fig_fare_class_mix()\n</pre> summary2.fig_fare_class_mix() Out[20]: In\u00a0[21]: Copied! <pre>summary2.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\")\n</pre> summary2.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\") Out[21]: In\u00a0[22]: Copied! <pre>cfg3 = cfg.model_copy(deep=True)\ncfg3.carriers.AL1.rm_system = \"F\"\ncfg3.carriers.AL2.rm_system = \"M\"\n</pre> cfg3 = cfg.model_copy(deep=True) cfg3.carriers.AL1.rm_system = \"F\" cfg3.carriers.AL2.rm_system = \"M\" In\u00a0[23]: Copied! <pre>cfg3 = cfg3.model_revalidate()\n</pre> cfg3 = cfg3.model_revalidate() In\u00a0[24]: Copied! <pre>print(fill(cfg3.rm_systems.F.description))\n</pre> print(fill(cfg3.rm_systems.F.description)) <pre>Path-based additive pickup PODS-style Q-hybrid forecast (with no fare\nrestrictions this becomes Q-only), EM detruncation of priceable and\nyieldable demand (separately), MR fare adjustment with 25% scaling,\nProBP optimization.\n</pre> In\u00a0[25]: Copied! <pre>print(fill(cfg3.rm_systems.M.description))\n</pre> print(fill(cfg3.rm_systems.M.description)) <pre>Path-based additive pickup conditional forecast, EM detruncation of\nyieldable demand, MR fare adjustment with 25% scaling, ProBP\noptimization.\n</pre> In\u00a0[26]: Copied! <pre>sim3 = pax.Simulation(cfg3)\nsummary3 = sim3.run()\n</pre> sim3 = pax.Simulation(cfg3) summary3 = sim3.run() <pre>Output()</pre> <pre></pre> <pre>Task Completed after 4.78 seconds\n</pre> In\u00a0[27]: Copied! <pre>summary3.fig_carrier_revenues()\n</pre> summary3.fig_carrier_revenues() Out[27]: In\u00a0[28]: Copied! <pre>summary3.fig_carrier_load_factors()\n</pre> summary3.fig_carrier_load_factors() Out[28]: In\u00a0[29]: Copied! <pre>summary3.fig_carrier_rasm()\n</pre> summary3.fig_carrier_rasm() Out[29]: In\u00a0[30]: Copied! <pre>summary3.fig_fare_class_mix()\n</pre> summary3.fig_fare_class_mix() <pre>\n---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\nCell In[30], line 1\n----&gt; 1 summary3.fig_fare_class_mix()\n\nFile ~/Git/umbrella/passengersim-public/passengersim/reporting/__init__.py:50, in report_figure.&lt;locals&gt;.report_figure_wrapper(report, trace, *args, **kwargs)\n     48 @wraps(func)\n     49 def report_figure_wrapper(*args, report=None, trace=None, **kwargs):\n---&gt; 50     fig = func(*args, **kwargs)\n     51     if report is not None:\n     52         report.add_figure(fig)\n\nFile ~/Git/umbrella/passengersim-public/passengersim/summaries/fare_class_mix.py:131, in SimTabFareClassMix.fig_fare_class_mix(self, raw_df, label_threshold)\n    129 if raw_df:\n    130     return df\n--&gt; 131 return _fig_fare_class_mix(\n    132     df,\n    133     label_threshold=label_threshold,\n    134     title=\"Fare Class Mix\",\n    135 )\n\nFile ~/Git/umbrella/passengersim-public/passengersim/summaries/fare_class_mix.py:72, in _fig_fare_class_mix(df, label_threshold, title)\n     59 chart = alt.Chart(df, **({\"title\": title} if title else {})).transform_calculate(\n     60     halfsold=\"datum.avg_sold / 2.0\",\n     61 )\n     62 bars = chart.mark_bar().encode(\n     63     x=alt.X(\"carrier:N\", title=\"Carrier\"),\n     64     y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n   (...)\n     70     ],\n     71 )\n---&gt; 72 text = chart.mark_text(dx=0, dy=3, color=\"white\", baseline=\"top\").encode(\n     73     x=alt.X(\"carrier:N\", title=\"Carrier\"),\n     74     y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n     75     text=alt.Text(\"avg_sold:Q\", format=\".2f\"),\n     76     opacity=alt.condition(\n     77         f\"datum.avg_sold &lt; {label_threshold_value:.3f}\",\n     78         alt.value(0),\n     79         alt.value(1),\n     80     ),\n     81     order=alt.Order(\"booking_class:N\", sort=\"descending\"),\n     82     tooltip=[\n     83         \"carrier\",\n     84         \"booking_class\",\n     85         alt.Tooltip(\"avg_sold\", format=\".2f\"),\n     86     ],\n     87 )\n     88 return (\n     89     (bars + text)\n     90     .properties(\n   (...)\n    101     )\n    102 )\n\nFile ~/Git/umbrella/.pixi/envs/default/lib/python3.12/site-packages/altair/vegalite/v5/schema/channels.py:21788, in _EncodingMixin.encode(self, angle, color, column, description, detail, facet, fill, fillOpacity, href, key, latitude, latitude2, longitude, longitude2, opacity, order, radius, radius2, row, shape, size, stroke, strokeDash, strokeOpacity, strokeWidth, text, theta, theta2, tooltip, url, x, x2, xError, xError2, xOffset, y, y2, yError, yError2, yOffset, *args)\n  21785     kwargs = {k: v for k, v in kwargs.items() if v is not Undefined}\n  21787 # Convert args to kwargs based on their types.\n&gt; 21788 kwargs = _infer_encoding_types(args, kwargs)\n  21789 # get a copy of the dict representation of the previous encoding\n  21790 # ignore type as copy method comes from SchemaBase\n  21791 copy = self.copy(deep=[\"encoding\"])  # type: ignore[attr-defined]\n\nFile ~/Git/umbrella/.pixi/envs/default/lib/python3.12/site-packages/altair/utils/core.py:981, in infer_encoding_types(args, kwargs)\n    978         msg = f\"encoding {encoding!r} specified twice.\"\n    979         raise ValueError(msg)\n--&gt; 981 return cache.infer_encoding_types(kwargs)\n\nFile ~/Git/umbrella/.pixi/envs/default/lib/python3.12/site-packages/altair/utils/core.py:896, in _ChannelCache.infer_encoding_types(self, kwargs)\n    894 def infer_encoding_types(self, kwargs: dict[str, Any], /):\n    895     return {\n--&gt; 896         encoding: self._wrap_in_channel(obj, encoding)\n    897         for encoding, obj in kwargs.items()\n    898         if obj is not Undefined\n    899     }\n\nFile ~/Git/umbrella/.pixi/envs/default/lib/python3.12/site-packages/altair/utils/core.py:886, in _ChannelCache._wrap_in_channel(self, obj, encoding)\n    882 tp = channel[\"value\" if \"value\" in obj else \"field\"]\n    883 try:\n    884     # Don't force validation here; some objects won't be valid until\n    885     # they're created in the context of a chart.\n--&gt; 886     return tp.from_dict(obj, validate=False)\n    887 except jsonschema.ValidationError:\n    888     # our attempts at finding the correct class have failed\n    889     return obj\n\nFile ~/Git/umbrella/.pixi/envs/default/lib/python3.12/site-packages/altair/utils/schemapi.py:1243, in SchemaBase.from_dict(cls, dct, validate)\n   1241 if validate:\n   1242     cls.validate(dct)\n-&gt; 1243 converter = _FromDict(cls._default_wrapper_classes())\n   1244 return converter.from_dict(dct, cls)\n\nFile ~/Git/umbrella/.pixi/envs/default/lib/python3.12/site-packages/altair/utils/schemapi.py:1423, in _FromDict.__init__(self, wrapper_classes)\n   1421 for tp in wrapper_classes:\n   1422     if tp._schema is not None:\n-&gt; 1423         self.class_dict[self.hash_schema(tp._schema)].append(tp)\n\nFile ~/Git/umbrella/.pixi/envs/default/lib/python3.12/site-packages/altair/utils/schemapi.py:1444, in _FromDict.hash_schema(cls, schema, use_json)\n   1438     schema = {\n   1439         key: val\n   1440         for key, val in schema.items()\n   1441         if key not in cls._hash_exclude_keys\n   1442     }\n   1443 if use_json:\n-&gt; 1444     s = json.dumps(schema, sort_keys=True)\n   1445     return hash(s)\n   1446 else:\n\nFile ~/Git/umbrella/.pixi/envs/default/lib/python3.12/json/__init__.py:238, in dumps(obj, skipkeys, ensure_ascii, check_circular, allow_nan, cls, indent, separators, default, sort_keys, **kw)\n    232 if cls is None:\n    233     cls = JSONEncoder\n    234 return cls(\n    235     skipkeys=skipkeys, ensure_ascii=ensure_ascii,\n    236     check_circular=check_circular, allow_nan=allow_nan, indent=indent,\n    237     separators=separators, default=default, sort_keys=sort_keys,\n--&gt; 238     **kw).encode(obj)\n\nFile ~/Git/umbrella/.pixi/envs/default/lib/python3.12/json/encoder.py:200, in JSONEncoder.encode(self, o)\n    196         return encode_basestring(o)\n    197 # This doesn't pass the iterator directly to ''.join() because the\n    198 # exceptions aren't as detailed.  The list call should be roughly\n    199 # equivalent to the PySequence_Fast that ''.join() would do.\n--&gt; 200 chunks = self.iterencode(o, _one_shot=True)\n    201 if not isinstance(chunks, (list, tuple)):\n    202     chunks = list(chunks)\n\nFile ~/Git/umbrella/.pixi/envs/default/lib/python3.12/json/encoder.py:258, in JSONEncoder.iterencode(self, o, _one_shot)\n    253 else:\n    254     _iterencode = _make_iterencode(\n    255         markers, self.default, _encoder, self.indent, floatstr,\n    256         self.key_separator, self.item_separator, self.sort_keys,\n    257         self.skipkeys, _one_shot)\n--&gt; 258 return _iterencode(o, 0)\n\nKeyboardInterrupt: </pre> In\u00a0[\u00a0]: Copied! <pre>summary3.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\")\n</pre> summary3.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\")"}, {"location": "Tutorials/3MKT/gallery/QC.nbconvert.html#q-forecasting", "title": "Q Forecasting\u00b6", "text": ""}, {"location": "Tutorials/3MKT/gallery/QC.nbconvert.html#without-priceable-detruncation", "title": "Without Priceable Detruncation\u00b6", "text": "<p>We can remove the detruncation of priceable demand from the Q system, and re-evaluate to see the difference.</p>"}, {"location": "Tutorials/3MKT/gallery/QC.nbconvert.html#applying-fare-adjustment", "title": "Applying Fare Adjustment\u00b6", "text": ""}, {"location": "user-guide/cli.html", "title": "Command Line Interface", "text": "<p>AirSim Command Line Interface</p> <p>Usage:</p> <pre><code>$ python -m AirSim [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>info</code></li> <li><code>run</code></li> </ul>"}, {"location": "user-guide/cli.html#python-m-airsim-info", "title": "<code>python -m AirSim info</code>", "text": "<p>Usage:</p> <pre><code>$ python -m AirSim info [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul>"}, {"location": "user-guide/cli.html#python-m-airsim-run", "title": "<code>python -m AirSim run</code>", "text": "<p>Usage:</p> <pre><code>$ python -m AirSim run [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>-n, --network-file PATH</code>: A file that defines the network and various simulation options.  [required]</li> <li><code>-a, --airports-file PATH</code>: A file that defines the airports used in the simulation.</li> <li><code>-o, --out-dir PATH</code>: Out files are written to this directory.</li> <li><code>--db-engine TEXT</code>: [default: sqlite]</li> <li><code>--db-filename TEXT</code>: Use this filename for the output database file. Applies to the the SQLite engine only.  [default: airsim-output.sqlite]</li> <li><code>--fast / --slow</code>: For the SQLite engine only, running in 'fast' mode will store everything in an in-memory first, and dump the entire database to disk only when the simulation is complete.  This can be quite advantageous when the write speed of the disk is slow.  [default: slow]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"}, {"location": "user-guide/experiments.nbconvert.html", "title": "Experiments", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.49.dev17+g74942de\npassengersim.core 0.49.dev25+gada6573\n</pre> <p>The experimentation starts with a base config.</p> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/08-untrunc-em\"))\ncfg.simulation_controls.num_trials = 1\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/08-untrunc-em\")) cfg.simulation_controls.num_trials = 1 <p>Then, we create an <code>Experiments</code> object, which will manage our set of experiments somewhat automatically. This object takes our baseline config as an argument, as well as allows us to set a directory where all experimental output will be stored.</p> In\u00a0[4]: Copied! <pre>from passengersim.experiments import Experiments\n\nexperiments = Experiments(cfg, output_dir=\"demo-output\")\n</pre> from passengersim.experiments import Experiments  experiments = Experiments(cfg, output_dir=\"demo-output\") <p>Now we can define one or more experiments, although as you'll see quickly, the real power of this interface comes when there is more than one experiment.</p> <p>Each experiment is defined by a function that accepts a Config as an argument, and returns a possibly modified Config.  Within this function, you can make any modifications desired: changing simulation controls, swapping out revenue management systems for one or more carriers, or even changing the network structure itself.  Each experiment function is prefixed by the experiments object as decorator, and each should have a unique function name that will be used to identify it.</p> In\u00a0[5]: Copied! <pre>@experiments\ndef baseline(cfg: pax.Config) -&gt; pax.Config:\n    return cfg\n\n\n@experiments\ndef low_dmd(cfg: pax.Config) -&gt; pax.Config:\n    cfg.simulation_controls.demand_multiplier = 0.9\n    return cfg\n\n\n@experiments\ndef high_dmd(cfg):\n    cfg.simulation_controls.demand_multiplier = 1.1\n    return cfg\n</pre> @experiments def baseline(cfg: pax.Config) -&gt; pax.Config:     return cfg   @experiments def low_dmd(cfg: pax.Config) -&gt; pax.Config:     cfg.simulation_controls.demand_multiplier = 0.9     return cfg   @experiments def high_dmd(cfg):     cfg.simulation_controls.demand_multiplier = 1.1     return cfg <p>Finally, we can run all the experiments as a batch using the <code>run</code> command on the <code>Experiments</code> object.</p> In\u00a0[6]: Copied! <pre>summaries = experiments.run()\n</pre> summaries = experiments.run() <pre></pre> <p>The return value from this batch run is a passengersim <code>Contrast</code> object, which can be used to review the results interactively in a Jupyter notebook.</p> In\u00a0[7]: Copied! <pre>summaries.fig_carrier_revenues()\n</pre> summaries.fig_carrier_revenues() Out[7]: In\u00a0[8]: Copied! <pre>summaries.fig_fare_class_mix()\n</pre> summaries.fig_fare_class_mix() Out[8]: <p>When we ran the experiments, the <code>demo-output</code> directory was populated with outputs from each experiment, including a pickle file storing the summary results, as well as an HTML output file that includes key figures and metadata describing the results from that experiment.</p> In\u00a0[9]: Copied! <pre>from passengersim.utils.show_dir import display_directory_contents\n\ndisplay_directory_contents(\"demo-output\")\n</pre> from passengersim.utils.show_dir import display_directory_contents  display_directory_contents(\"demo-output\") <pre>demo-output/\n  high_dmd/\n    passengersim_output.20250210-193738.html\n    passengersim_output.20250210-193738.pkl.lz4\n  low_dmd/\n    passengersim_output.20250210-193733.html\n    passengersim_output.20250210-193733.pkl.lz4\n  baseline/\n    passengersim_output.20250210-193729.html\n    passengersim_output.20250210-193729.pkl.lz4\n</pre> <p>We can change an existing experiment explicitly by writing a new experiment with the same tag, or implicitly by editing the Jupyter notebook and re-running the entire notebook.  Here, we will just edit one experiment by overwriting it (note we do get a warning when we do this).</p> In\u00a0[10]: Copied! <pre>@experiments\ndef high_dmd(cfg):  # noqa: F811\n    cfg.simulation_controls.demand_multiplier = 1.2\n    return cfg\n</pre> @experiments def high_dmd(cfg):  # noqa: F811     cfg.simulation_controls.demand_multiplier = 1.2     return cfg <pre>/var/folders/l1/yt63lf3n60b1dc25d_y2d1q80000gn/T/ipykernel_29020/1986293878.py:1: UserWarning: Overwriting existing experiment tag: high_dmd\n  @experiments\n</pre> <p>If we now re-run the set of experiments, PassengerSim will detect that some of the experiments are have been run already, and not re-run them in favor of simply reloading from disk.  The loaded results configurations are compared against the experiment configuration, to confirm it is still the same.  For the first two experiments, this is the case and the simulation is not re-run.  The change we made in the last experiment is detected, and the loaded results are then discarded in favor of re-running the simulation.</p> In\u00a0[11]: Copied! <pre>summaries2 = experiments.run()\n</pre> summaries2 = experiments.run() <pre>Loaded baseline from demo-output/baseline/passengersim_output\n</pre> <pre>Loaded low_dmd from demo-output/low_dmd/passengersim_output\n</pre> <pre>Loaded high_dmd from demo-output/high_dmd/passengersim_output, but the config has changed:\n{'simulation_controls': {'demand_multiplier': '1.2 != 1.1'}}\n</pre> <pre></pre> In\u00a0[12]: Copied! <pre>summaries2.fig_carrier_revenues()\n</pre> summaries2.fig_carrier_revenues() Out[12]: In\u00a0[13]: Copied! <pre>summaries2.fig_fare_class_mix()\n</pre> summaries2.fig_fare_class_mix() Out[13]: <p>If we inspect the <code>demo-output</code> directory, we will see that the results from the old experiment are still available if needed, but they are timestamped so we can clearly identify them as older.</p> In\u00a0[14]: Copied! <pre>display_directory_contents(\"demo-output\")\n</pre> display_directory_contents(\"demo-output\") <pre>demo-output/\n  high_dmd/\n    passengersim_output.20250210-193738.html\n    passengersim_output.20250210-193742.html\n    passengersim_output.20250210-193742.pkl.lz4\n    passengersim_output.20250210-193738.pkl.lz4\n  low_dmd/\n    passengersim_output.20250210-193733.html\n    passengersim_output.20250210-193733.pkl.lz4\n  baseline/\n    passengersim_output.20250210-193729.html\n    passengersim_output.20250210-193729.pkl.lz4\n</pre> <p>We can write out a report of the experiments, which contains a variety of standard outputs.</p> In\u00a0[15]: Copied! <pre>out_file = summaries2.write_report(\"demo-output/meta-summary.html\", base_config=cfg)\n</pre> out_file = summaries2.write_report(\"demo-output/meta-summary.html\", base_config=cfg) In\u00a0[16]: Copied! <pre>from passengersim.utils.iframe import preview_html\n\npreview_html(out_file)\n</pre> from passengersim.utils.iframe import preview_html  preview_html(out_file)"}, {"location": "user-guide/experiments.nbconvert.html#experiments", "title": "Experiments\u00b6", "text": "<p>The experiments interface allows the user to easily run and compare a number of different scenarios.</p>"}, {"location": "user-guide/how-it-works.html", "title": "How PassengerSim Works", "text": "<p>PasengerSim is a tool that simulates several aspects of passenger travel, including airline revenue management operations, market level passenger demand, and individual customer choice processes.</p>"}, {"location": "user-guide/how-it-works.html#counting-simulations", "title": "Counting Simulations", "text": "<p>A simulation run consists of a number of independent trials, and each trial is made up of a sequence of dependent samples -- earlier samples in a trial are used to develop forecasts and train optimization algorithms used by carriers in later samples of the same trial.</p> <p>The number of trials is set by the <code>num_trials</code> configuration, and the number of samples in each trial is set by <code>num_samples</code>. Both values can be found in the <code>simulation_controls</code> configuration inputs.</p> <p>We can think of a sample as a \"typical\" departure day.  When generating results, the first X samples from each trial as these are during a \"burn period\" when the simulation is getting started and sufficient history is being generated to use for forecasts and other steps.  The nuber of samples in the burn period is set by the <code>burn_samples</code> configuration value.</p>"}, {"location": "user-guide/how-it-works.html#simulation-randomness", "title": "Simulation Randomness", "text": ""}, {"location": "user-guide/how-it-works.html#demand-generation-k-factors", "title": "Demand Generation K-Factors", "text": "<p>There are multiple sources of variability that is introduced in the simulation. Variability in the level of demand by passenger type on any given day for any origin-destination pair is controlled by a number of k-factors, which are used to create some correlation across various dimensions of demand.</p> <p>Three k-factors are used to introduce correlation in demand across all markets in the system and between business/leisure demand within a market. The equation to generate the mean demand for a given market and passenger type is given as:</p> <p>\\(\\mu'_{OD-Biz} = \\mu_{OD-Biz} + (SRN \\times k_{sys}) + (MRN \\times k_{mkt}) + (PRN \\times k_{paxtype})\\)</p> <p>where SRN, MRN, and PRN are random numbers associated with the system, market, and passenger k-factors, respectively.</p> <p>The intuition behind using three k-factors is that even across a \"typical\" departure day (like Wednesdays) we may have high demand days across the system and low demand days across the system.  Likewise, if business demand is above average, we expect that leisure demand may also be above average. Intuitively, when generating demands, for a given sample (or departure day in the simulation), we add the term (SRN x <code>sys_k_factor</code>) to every single market and passenger in the system for that departure day, we add a unique (MRN x <code>mkt_k_factor</code>) to each origin-destination market in the sample, and we add a unique (PRN x <code>pax_type_k_factor</code>) for each passenger type within the market. The addition of the (SRN x <code>sys_k_factor</code>) to \"everything\" in the sample creates a system-level correlation (i.e., demand on a given departure date or sample could be \"high\" across the system or \"low\" compared to average).</p> <p>The addition of the (MRN x <code>mkt_k_factor</code>) to a market creates a market-level correlation (i.e., if business demand is running higher than average in the market, we expect leisure demand will run higher than average in general as well).</p> <p>The use of the (PRN x <code>pax_type_k_factor</code>) ensures that there is some random component that is independent between business and leisure passengers in a given market.</p> <p>In addition to the k-factors that are used to introduce correlation, we have a z-factor. We assume that actual demand, given mean demand, will vary across samples (or departure dates) according to a constant z-factor given as \\(\\mu\\) divided by \\(\\sigma^2\\).</p> <p>Given different levels of aggregation, we expect that <code>sys_k_factor</code> &lt; <code>mkt_k_factor</code> &lt; <code>pax_type_k_factor</code>.</p> <p>Once we generate the means and std dev for correlated demands by OD and pax type using the methodology described above, we use these to generate the \u201cactual\u201d demands for a sample using the equation</p> <p>\\(\\mu'_{OD-Biz} + NRV x \\sigma'_{OD-Biz}\\),</p> <p>where NRV is a normal random variable.</p>"}, {"location": "user-guide/how-it-works.html#demand-allocation-to-time-periods", "title": "Demand Allocation to Time Periods", "text": "<p>The demand generation above is used to find the total demand for each passenger type in each market on each travel day.  This total value is subsequently distributed over the booking time periods.</p> <p>While the methodology for this is not (yet) explained here, note that the <code>tf_k_factor</code> is used to generate variability in how demand is allocated to the different time frames (also using the booking curves as a key input).</p>"}, {"location": "user-guide/installation.html", "title": "Installation", "text": "<pre><code>PassengerSim is currently available only for Mac and Linux operating systems.\nSupport for other operating systems is not planned for the near future.\n</code></pre>"}, {"location": "user-guide/installation.html#before-you-begin-install-conda-if-needed", "title": "Before you begin: install <code>conda</code> if needed", "text": "<p>PassengerSim is a Python package that is most easily installed in an environment managed by <code>conda</code>.  To check if you have <code>conda</code> installed, open a terminal and type <code>conda --version</code>.  If you see a version number, you have <code>conda</code>.</p> <p>If you have <code>conda</code>, but with an outdated version (i.e. less than 24), you can update it by running <code>conda update conda</code>.</p> <p>If you don't have <code>conda</code>, you can install it by pasting the following command into your terminal:</p> <pre><code>curl -L -O https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-$(uname)-$(uname -m).sh\nbash Miniforge3-$(uname)-$(uname -m).sh\n</code></pre>"}, {"location": "user-guide/installation.html#installing-passengersim", "title": "Installing PassengerSim", "text": "<p>If you have received a file named something like <code>install-passengersim-mac-v0.0-20240101.sh</code>, you can use it to install PassengerSim in a conda environment.  To do so, open a terminal and navigate to the directory where the file is located.  Then, run the following command:</p> <pre><code>bash install-passengersim-mac-v0.0-20240101.sh\n</code></pre> <p>Tip</p> <p>Don't copy-paste the command above, as the exact filename of the installation script will vary based on the version of PassengerSim and the release data.  Instead, use the filename of the file you have received.</p>"}, {"location": "user-guide/installation.html#changing-the-conda-environment-name", "title": "Changing the conda environment name", "text": "<p>The default install will put PassengerSim in a conda environment named <code>SKY</code>.  If you already have a conda environment named <code>SKY</code>, the installation script will update the environment to the relevant version of PassengerSim.  If you prefer to install PassengerSim in a different environment (e.g. <code>myenv</code>), you can specify the environment name as an argument to the installation script:</p> <pre><code>bash install-passengersim-mac-v0.0-20240101.sh -n myenv\n</code></pre>"}, {"location": "user-guide/installation.html#running-passengersim", "title": "Running PassengerSim", "text": "<p>After the installation is complete, you can start a Jupyter Lab session from the environment by running the following command:</p> <pre><code>conda run -n SKY jupyter lab\n</code></pre> <p>If you installed PassengerSim in an environment named something other than <code>SKY</code>, replace <code>SKY</code> in the command above with the name of the environment you used.</p>"}, {"location": "user-guide/installation.html#alternative-installation-docker", "title": "Alternative Installation: Docker", "text": "<p>Do you have a link to a <code>sky</code> docker image file? If not, these are not the install instructions you are looking for. If you do have a link, go ahead and download the file.  If you are installing on Windows or an Intel-based Mac, you want the amd64 image.  For installing on more recent Apple Silicon-based Macs, use an arm64 image.</p> <p>In addition to the image file, you'll want to download and install Docker Desktop for your computer.  Once it's installed, make sure it's running (you should be able to open and see Docker's dashboard).</p> <p>Then, open a console terminal and change to the directory where the docker image <code>sky.tar</code> file has been saved.  It might be named something slightly different from <code>sky.tar</code>, in which case change the filename in the commands you type to match the filename of the image file you have.  The first step is to run</p> <pre><code>docker load --input sky.tar\n</code></pre> <p>This command may take a few moments to complete, as the content of the downloaded image file will be imported into docker.  You'll need several free gigabytes of hard disk space to complete this step, so if you encounter unexplained EOF errors here that may be the problem.</p> <p>After the docker image is loaded, you should see a <code>sky</code> image in the docker desktop dashboard.  If you can see it, you should then be able to start a container with this image using the following command:</p> Mac/LinuxWindows <pre><code>docker run -p 8899:8899 --rm --volume \"$(pwd)\":/tmp/workplace/work sky:latest\n</code></pre> <pre><code>docker run -p 8899:8899 --rm --volume \"%cd%\":/tmp/workplace/work sky:latest\n</code></pre> <p>Within this command, we have:</p> <ul> <li><code>-p 8899:8899</code> tells docker to expose the container's port 8899 (which has been   configured to be the port served by Jupyter Lab) to localhost.</li> <li><code>--rm</code> means to remove the container when it exits, so there isn't an   extraneous container image file left on your file system.</li> <li><code>--volume \"...\":/tmp/workplace/work</code> makes the current working directory   available inside Jupyter Lab in a directory named <code>work</code> (the container has   been configured with <code>/tmp/workplace</code> as the base location for Jupyter).</li> <li><code>sky:latest</code> tells Docker to use the latest version of the user image   that was installed in the <code>docker load</code> step above.  If your installed   docker image (as shown in the Docker Dashboard) has a different name than   <code>sky</code> then change the command to give the corrent image name.</li> </ul>"}, {"location": "user-guide/untruncation.html", "title": "Untruncation", "text": "<p>Write a description of this concept here.</p>"}, {"location": "user-guide/writing-configs.html", "title": "Config Files", "text": "<p>Most control of the simulation is done via configuration files written in YAML format.</p>"}, {"location": "user-guide/writing-configs.html#simulation-controls", "title": "Simulation Controls", "text": "<pre><code>scenario: Three Market Test Network\nsimulation_controls:\n  random_seed: 42\n  num_trials: 1\n  num_samples: 300\n  sys_k_factor: 0.1\n  mkt_k_factor: 0.2\n  pax_type_k_factor: 0.4\n  tf_k_factor: 0.1\n  tot_z_factor: 2.0\n  tf_z_factor: 2.0\n  prorate_revenue: true\n  dwm_lite: false\n  max_connect_time: 120\n  disable_ap: false\n  demand_multiplier: 1.0\n  manual_paths: true\n</code></pre>"}, {"location": "user-guide/writing-configs.html#rm-systems", "title": "RM Systems", "text": "<p>The <code>rm_systems</code> key allows the user to define one or more revenue management systems that may be used by carriers.</p> <p>These systems can either be defined as a list, where each item in the list defines both a name and steps, or you can write the same instruction as a nested mapping, with the names as keys and the values giving the other attributes of each RM system, (for now, just a list of steps) like this:</p> as listas dict <p><pre><code>rm_systems:\n- name: rm_test1\n  steps:\n  - step_type: untruncation  #(1)!\n    name: untruncation\n    algorithm: em\n    kind: leg\n  - step_type: forecast\n    name: forecast\n    algorithm: exp_smoothing\n    alpha: 0.1\n    kind: leg\n  - step_type: optimization\n    name: optimization\n    algorithm: emsrb  #(2)!\n    kind: leg\n</code></pre></p> <ol> <li> Untruncation allows us to figure out how much demand was censored.</li> <li>If you define different RM systems, you can attach different optimization algorithms, such as     ProBP.</li> </ol> <p><pre><code>rm_systems:\n  rm_test1:\n    steps:\n    - step_type: untruncation  #(1)!\n      name: untruncation\n      algorithm: em\n      kind: leg\n    - step_type: forecast\n      name: forecast\n      algorithm: exp_smoothing\n      alpha: 0.1\n      kind: leg\n    - step_type: optimization\n      name: optimization\n      algorithm: emsrb  #(2)!\n      kind: leg\n</code></pre></p> <ol> <li> Untruncation allows us to figure out how much demand was censored.</li> <li>If you define different RM systems, you can attach different optimization algorithms, such as     ProBP.</li> </ol>"}, {"location": "user-guide/writing-configs.html#passenger-choice-models", "title": "Passenger Choice Models", "text": "<pre><code>choice_models:\n  business:\n    kind: pods\n    emult: 1.6\n    basefare_mult: 2.5\n    path_quality:  [38.30,  0.10]\n    airline_pref_pods:  [-12.29,  0.17]\n    tolerance: 2.0\n    r1: 0.30\n    r2: 0.10\n    r3: 0.20\n    r4: 0.15\n  leisure:\n    kind: pods\n    emult: 1.5\n    basefare_mult: 1.0\n    path_quality:  [2.02, 0.12]\n    airline_pref_pods:  [-1.98, 0.11]\n    tolerance: 5.0\n    r1: 0.30\n    r2: 0.15\n    r3: 0.25\n    r4: 0.20\n</code></pre>"}, {"location": "user-guide/writing-configs.html#define-carriers", "title": "Define Carriers", "text": "<pre><code>carriers:\n- name: AL1\n  rm_system: rm_test1\n- name: AL2\n  rm_system: rm_test1\n- name: AL3\n  rm_system: rm_test1\n- name: AL4\n  rm_system: rm_test1\n</code></pre>"}, {"location": "user-guide/writing-configs.html#define-booking-classes", "title": "Define Booking Classes", "text": "<pre><code>classes:\n- Y0\n- Y1\n- Y2\n- Y3\n- Y4\n- Y5\n- Y6\n- Y7\n- Y8\n- Y9\n</code></pre>"}, {"location": "user-guide/writing-configs.html#data-collection-points-dcps", "title": "Data Collection Points (DCPs)", "text": "<pre><code>dcps:\n- 63\n- 56\n- 49\n- 42\n- 35\n- 31\n- 28\n- 24\n- 21\n- 17\n- 14\n- 10\n- 7\n- 5\n- 3\n- 1\n</code></pre>"}, {"location": "user-guide/writing-configs.html#booking-curves", "title": "Booking Curves", "text": "<pre><code>booking_curves:\n- name: '1'\n  curve:\n    63: 0.01\n    56: 0.02\n    49: 0.05\n    42: 0.13\n    35: 0.19\n    31: 0.23\n    28: 0.29\n    24: 0.35\n    21: 0.45\n    17: 0.54\n    14: 0.67\n    10: 0.79\n    7: 0.86\n    5: 0.91\n    3: 0.96\n    1: 1.0\n- name: '2'\n  curve:\n    63: 0.13\n    56: 0.22\n    49: 0.37\n    42: 0.52\n    35: 0.64\n    31: 0.7\n    28: 0.75\n    24: 0.78\n    21: 0.83\n    17: 0.87\n    14: 0.91\n    10: 0.94\n    7: 0.96\n    5: 0.98\n    3: 0.99\n    1: 1.0\n- name: '3'\n  curve:\n    63: 0.04\n    56: 0.06\n    49: 0.12\n    42: 0.26\n    35: 0.35\n    31: 0.41\n    28: 0.48\n    24: 0.54\n    21: 0.63\n    17: 0.7\n    14: 0.81\n    10: 0.88\n    7: 0.93\n    5: 0.96\n    3: 0.98\n    1: 1.0\n- name: '4'\n  curve:\n    63: 0.21\n    56: 0.35\n    49: 0.53\n    42: 0.67\n    35: 0.76\n    31: 0.8\n    28: 0.83\n    24: 0.85\n    21: 0.88\n    17: 0.91\n    14: 0.94\n    10: 0.96\n    7: 0.97\n    5: 0.98\n    3: 0.99\n    1: 1.0\n</code></pre>"}, {"location": "user-guide/writing-configs.html#legs", "title": "Legs", "text": "<pre><code>legs:\n- carrier: AL1\n  fltno: 1\n  orig: BOS\n  dest: SFO\n  date: '2020-01-01'\n  dep_time: 08:00\n  arr_time: '10:00'\n  capacity: 100\n  distance: 867.0\n- carrier: AL2\n  fltno: 2\n  orig: BOS\n  dest: SFO\n  date: '2020-01-01'\n  dep_time: '14:00'\n  arr_time: '16:00'\n  capacity: 100\n  distance: 867.0\n...\n</code></pre>"}, {"location": "user-guide/writing-configs.html#paths", "title": "Paths", "text": "<pre><code>paths:\n- orig: BOS\n  dest: SFO\n  path_quality_index: 1.0\n  legs:\n  - 1\n- orig: BOS\n  dest: SFO\n  path_quality_index: 1.0\n  legs:\n  - 2\n- orig: BOS\n  dest: ORD\n  path_quality_index: 1.0\n  legs:\n  - 3\n...\n</code></pre>"}, {"location": "user-guide/database/index.html", "title": "Database", "text": "<p>The default data storage solution for PassengerSim is a SQLite database file.</p>"}, {"location": "user-guide/database/index.html#database-tables", "title": "Database Tables", "text": "<p>The following tables are created when running a simulation:</p> Table Description carrier_summary Aggregate summary information on carrier performance. leg_summary Aggregate summary information on legs. leg_defs Static data about network legs leg_detail Simulation data at the leg level leg_bucket_detail Simulation data at the leg-bucket level path_class_detail Simulation data at the path-class level demand_detail Simulation data at the demand level fare_detail Simulation data at the fare level bookings_by_timeframe Aggregate summary simulation data on bookings by timeframe and bookings class"}, {"location": "user-guide/database/index.html#common-queries", "title": "Common Queries", "text": "<p>PassengerSim has a number of pre-packaged functions that query the database of results to provide useful summary tables.</p> Query Description <code>bid_price_history</code> Compute average bid price history over all legs for each carrier <code>bookings_by_timeframe</code> Average bookings and revenue by carrier, booking class, and timeframe <code>carrier_history</code> Sample-level details of carrier-level measures <code>demand_to_come</code> Demand by market and timeframe across each sample <code>fare_class_mix</code> Fare class mix by carrier <code>leg_forecasts</code> Average forecasts of demand by leg, bucket, and days to departure <code>local_and_flow_yields</code> Yields for local (nonstop) and flow (connecting) passengers by leg <code>od_fare_class_mix</code> Fare class mix by carrier for a particular origin-destination market <code>path_forecasts</code> Average forecasts of demand by path, class, and days to departure <code>total_demand</code> Average total demand"}, {"location": "user-guide/database/bookings_by_timeframe.html", "title": "Bookings by Timeframe", "text": "<p>The <code>bookings_by_timeframe</code> database table stores aggregate summary information about simulated bookings by timeframe, carrier, booking class, and passenger segment. Unlike various other \"detail\" tables, it does not store the results from any single sample, but instead has information aggregated over all samples in each trial.</p> <p>The table is created by the <code>create_table_bookings_by_timeframe</code> function, and (potentially) populated during a simulation run.  To be populated with data, the \"bookings\" flag must be set on <code>Config.db.write_items</code>.</p>"}, {"location": "user-guide/database/bookings_by_timeframe.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> trial INT NOT NULL carrier VARCHAR(10) NOT NULL Carrier name booking_class VARCHAR(10) NOT NULL days_prior INT NOT NULL Days before departure tot_sold FLOAT Total sales for the carrier and booking class, through this timeframe avg_sold FLOAT Average number of sales (per sample) avg_business FLOAT Average number of sales to business customers avg_leisure FLOAT Average number of sales to leisure customers avg_revenue FLOAT Average revenue from sales avg_price FLOAT Average price sold updated_at DATETIME NOT NULL Time each row was written to the database <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/carrier_summary.html", "title": "Carrier Summary", "text": "<p>The <code>carrier_summary</code> database table stores aggregate summary information about the various carriers in the simulation.  It is always generated after a simulation run and does not need to be activated by any configuration setting.</p>"}, {"location": "user-guide/database/carrier_summary.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description carrier TEXT Carrier name sold REAL Average number of sold sys_lf REAL Average system load factor avg_leg_lf REAL Average leg load factor avg_rev INTEGER Average revenue avg_price REAL Average price of seats sold asm INTEGER Available seat miles rpm INTEGER Revenue passenger miles yield REAL Average revenue per revenue passenger mile"}, {"location": "user-guide/database/demand_detail.html", "title": "Demand Detail", "text": "<p>The <code>demand_detail</code> database table stores details about the results of the simulation at the demand level.</p> <p>The table is created by the <code>create_table_demand_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"demand\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"demand_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> </ul>"}, {"location": "user-guide/database/demand_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial days_prior INT NOT NULL Days before departure segment VARCHAR(10) NOT NULL Customer segment, typically business or leisure orig VARCHAR(10) NOT NULL Origin (typically an airport code or similar) dest VARCHAR(10) NOT NULL Destination (typically an airport code or similar) updated_at DATETIME NOT NULL Time each row was written to the database sample_demand FLOAT sold INT Number of customers in this demand bucket who bought something no_go INT Number of customers in this demand bucket who bought nothing revenue FLOAT Revenue attributable to these customers <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/distance.html", "title": "Distance", "text": "<p>The <code>distance</code> database table stores the distance between locations (airports and/or other travel nodes). It contains static data not dependent on running the simulation. The table is created by the <code>create_table_distance</code> function.</p>"}, {"location": "user-guide/database/distance.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description orig VARCHAR(10) NOT NULL Origin (typically an airport code or similar) dest VARCHAR(10) NOT NULL Destination (typically an airport code or similar) miles FLOAT Distance between nodes in miles"}, {"location": "user-guide/database/fare_defs.html", "title": "Fare Definitions", "text": "<p>The <code>fare_defs</code> database table stores static details about the fares in the simulation.  Simulation results at the fare level are stored in the <code>fare_details</code> table instead.</p> <p>The <code>fare_defs</code> table is created by the create_table_fare_defs function, which is called in the Simulation initialization step, so it should be available and populated for every simulation run.</p>"}, {"location": "user-guide/database/fare_defs.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description fare_id INTEGER PRIMARY KEY Unique identifier for a given fare <sup>1</sup> carrier VARCHAR(10) NOT NULL Name of carrier for this leg orig VARCHAR(10) NOT NULL Origin (typically an airport code or similar) dest VARCHAR(10) NOT NULL Destination (typically an airport code or similar) booking_class VARCHAR(10) NOT NULL price INTEGER restrictions VARCHAR(20) NOT NULL Comma delimited list of fare restrictions category VARCHAR(20) Optional fare category (e.g. International, Domestic Restricted, etc) <sup>2</sup> <ol> <li> <p><code>fare_id</code> values are not specified in the user's configuration file, but instead unique values are generated as Fare objects are created as the simulation is initialized.\u00a0\u21a9</p> </li> <li> <p>The <code>category</code> has no material effect on the simulation, but is stored in the database table and can be used for analysis of results after a simulation is complete, e.g. to look at results for just international bookings, or just in domestic restricted markets where LCC's are not operating, etc.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/fare_detail.html", "title": "Fare Detail", "text": "<p>The <code>fare_detail</code> database table stores details about the results of the simulation at the fare level.</p> <p>The table is created by the <code>create_table_fare_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"fare\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"fare_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> </ul>"}, {"location": "user-guide/database/fare_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial days_prior INT NOT NULL Days before departure carrier VARCHAR(10) NOT NULL Carrier name orig VARCHAR(10) NOT NULL Origin (typically an airport code or similar) dest VARCHAR(10) NOT NULL Destination (typically an airport code or similar) booking_class VARCHAR(10) NOT NULL sold INT Number of customers buying this fare product sold_business INT Number of businss customers buying this fare product price FLOAT Price of this fare updated_at DATETIME NOT NULL Time each row was written to the database <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/leg_bucket_detail.html", "title": "Leg Bucket Detail", "text": "<p>The <code>leg_bucket_detail</code> database table stores details about the results of the simulation at the leg-bucket level.</p> <p>The table is created by the <code>create_table_leg_bucket_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"bucket\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"bucket_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> </ul>"}, {"location": "user-guide/database/leg_bucket_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial days_prior INT NOT NULL Days before departure flt_no INT NOT NULL Unique identifier for a given leg <sup>2</sup> bucket_number INT NOT NULL Bucket number (sequential from 0) name VARCHAR(10) NOT NULL Bucket name auth INT Number of seats in this bucket (or higher) available to be sold revenue FLOAT Revenue attributed to this bucket from seats sold sold INT Number of seats sold at this point in time untruncated_demand FLOAT forecast_mean FLOAT forecast_stdev FLOAT forecast_closed_in_tf FLOAT forecast_closed_in_future FLOAT updated_at DATETIME NOT NULL Time each row was written to the database <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> <li> <p>In the \"real world\" the limitations of current technology make it such that flight numbers are not necessary unique by leg, as a single carrier may have multiple segments sharing the same flight number, and multiple carriers will have completely unrelated flights with the same flight number.  To simplify data processing, PassengerSim uses a unique id for every travel segment. Networks in PassengerSim that are derived from realistic sources will require some modest preprocessing to create unique flight numbers for every leg.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/leg_defs.html", "title": "Leg Definitions", "text": "<p>The <code>leg_defs</code> database table stores static details about the legs in the simulation.  Simulation results at the leg level are stored in the <code>leg_details</code> table instead.</p> <p>The <code>leg_defs</code> table is created by the create_table_leg_defs function, which is called in the Simulation initialization step, so it should be available and populated for every simulation run.</p>"}, {"location": "user-guide/database/leg_defs.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description leg_id INTEGER PRIMARY KEY Unique identifier for a given leg <sup>1</sup> flt_no INTEGER Flight number label for this leg carrier TEXT Name of carrier for this leg orig TEXT Origin (typically an airport code or similar) dest TEXT Destination (typically an airport code or similar) dep_time INTEGER arr_time INTEGER capacity INTEGER Number of seats on this leg distance FLOAT Distance from <code>orig</code> to <code>dest</code> in miles. <ol> <li> <p>In the \"real world\" the limitations of current technology make it such that flight numbers are not necessary unique by leg, as a single carrier may have multiple segments sharing the same flight number, and multiple carriers will have completely unrelated flights with the same flight number.  To simplify data processing, PassengerSim uses a unique id for every travel segment. Networks in PassengerSim that are derived from realistic sources can still store flight numbers as a nominal label for every leg, but they are not used for anything except certain post-simulation reporting features.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/leg_detail.html", "title": "Leg Detail", "text": "<p>The <code>leg_detail</code> database table stores details about the results of the simulation at the leg level.  Facts about the leg which are not dependent on the simulation are stored in the <code>leg_defs</code> table instead.</p> <p>The table is created by the <code>create_table_leg_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"leg\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"leg_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> <li> <p>\"leg_daily\": The table will be populated at the end of each day during the simulation. Note this will produce a lot of output, and is probably not desirable for most simulation exercises.</p> </li> </ul>"}, {"location": "user-guide/database/leg_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial days_prior INT NOT NULL Days before departure flt_no INT NOT NULL Unique identifier for a given leg <sup>3</sup> updated_at DATETIME NOT NULL Time each row was written to the database sold INT Number of seats sold at this point in time revenue FLOAT Revenue attributed to this leg from seats sold q_demand FLOAT untruncated_demand FLOAT forecast_mean FLOAT Forecast of mean demand to come before departure bid_price FLOAT Computed bid price for this leg at this time <sup>2</sup> <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> <li> <p>Bid prices are only computed if there is a RM that provides an instruction to do the computation.  If there is no calculated bid price, this column will be blank.\u00a0\u21a9</p> </li> <li> <p>In the \"real world\" the limitations of current technology make it such that flight numbers are not necessary unique by leg, as a single carrier may have multiple segments sharing the same flight number, and multiple carriers will have completely unrelated flights with the same flight number.  To simplify data processing, PassengerSim uses a unique id for every travel segment. Networks in PassengerSim that are derived from realistic sources will require some modest preprocessing to create unique flight numbers for every leg.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/leg_summary.html", "title": "Leg Summary", "text": "<p>The <code>leg_summary</code> database table stores aggregate summary information about the various legs in the simulation.  It is always generated after a simulation run and does not need to be activated by any configuration setting.</p>"}, {"location": "user-guide/database/leg_summary.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description carrier TEXT Carrier name flt_no INTEGER Leg identifier orig TEXT Leg Origin dest TEXT Leg Destination avg_sold REAL Average number of seats sold avg_rev INTEGER Average revenue lf REAL Average leg load factor"}, {"location": "user-guide/database/path_class_detail.html", "title": "Path Class Detail", "text": "<p>The <code>path_class_detail</code> database table stores details about the results of the simulation at the path-class level.</p> <p>The table is created by the <code>create_table_path_class_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"pathclass\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"pathclass_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> </ul>"}, {"location": "user-guide/database/path_class_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial days_prior INT NOT NULL Days before departure path_id INT NOT NULL Unique identifier for a given path booking_class VARCHAR(10) NOT NULL Booking class name sold INT Number of seats sold at this point in time revenue FLOAT Revenue attributed to this bucket from seats sold untruncated_demand FLOAT forecast_mean FLOAT forecast_stdev FLOAT forecast_closed_in_tf FLOAT forecast_closed_in_future FLOAT updated_at DATETIME NOT NULL Time each row was written to the database <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/processing-outputs/basic-usage.nbconvert.html", "title": "Summary Outputs", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.46.dev30+g3f4104a.d20250127\npassengersim.core 0.46.dev45+gdc44d5b.d20250127\n</pre> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/08-untrunc-em\"))\ncfg.simulation_controls.num_samples = 300\ncfg.simulation_controls.num_trials = 2\nsim = pax.Simulation(cfg)\nsummary = sim.run()\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/08-untrunc-em\")) cfg.simulation_controls.num_samples = 300 cfg.simulation_controls.num_trials = 2 sim = pax.Simulation(cfg) summary = sim.run() <pre></pre> <pre>Task Completed after 2.99 seconds\n</pre> <p>The simple <code>repr</code> of this object has a bit of information about what data is in there. You can view this in a Jupyter notebook by putting the object as the last line of a cell (or just by itself):</p> In\u00a0[3]: Copied! <pre>summary\n</pre> summary Out[3]: <pre>&lt;passengersim.summaries.SimulationTables created on 2025-01-27&gt;\n * bid_price_history (256 row DataFrame)\n * carriers (2 row DataFrame)\n * carrier_history2 (800 row DataFrame)\n * demand_to_come_summary (34 row DataFrame)\n * demands (6 row DataFrame)\n * displacement_history (68 row DataFrame)\n * fare_class_mix (12 row DataFrame)\n * legbuckets (48 row DataFrame)\n * legs (8 row DataFrame)\n * pathclasses (72 row DataFrame)\n * path_legs (16 row DataFrame)\n * paths (12 row DataFrame)\n * segmentation_by_timeframe (304 row DataFrame)\n&lt;*&gt;</pre> <p>We can see here there are a variety of tables stored as pandas DataFrames. We can access the raw values of any of these dataframes directly in Python as an attribute on the <code>SimulationTables</code> object.</p> In\u00a0[4]: Copied! <pre>summary.carriers\n</pre> summary.carriers Out[4]: control avg_rev avg_sold truncation_rule avg_leg_lf asm rpm ancillary_rev avg_local_leg_pax avg_total_leg_pax avg_price yield sys_lf local_pct_leg_pax local_pct_bookings carrier AL1 leg 90920.1875 285.9675 3 86.790729 590302.497298 519508.421436 0.0 188.8825 383.0525 317.938883 0.175012 88.007153 49.309820 66.050338 AL2 leg 90614.6250 285.3625 3 86.622292 590302.497298 519025.918143 0.0 188.3300 382.3950 317.542161 0.174586 87.925415 49.250121 65.996759 <p>There is also some metadata stored on the summary, which can be accessed via the <code>metadata</code> method.</p> In\u00a0[5]: Copied! <pre>summary.metadata()\n</pre> summary.metadata() Out[5]: <pre>{'time.created': '2025-01-27T21:10:13.879515+00:00',\n 'machine.system': 'Darwin',\n 'machine.release': '24.1.0',\n 'machine.version': 'Darwin Kernel Version 24.1.0: Thu Oct 10 21:02:26 PDT 2024; root:xnu-11215.41.3~2/RELEASE_ARM64_T8122',\n 'machine.machine': 'arm64',\n 'machine.processor': 'arm',\n 'machine.architecture': ('64bit', ''),\n 'machine.node': 'Nightshade.local',\n 'machine.platform': 'macOS-15.1.1-arm64-arm-64bit',\n 'machine.python_version': '3.12.8',\n 'machine.cpu_count': 8,\n 'version.passengersim': '0.46.dev30+g3f4104a.d20250127',\n 'version.passengersim_core': '0.46.dev45+gdc44d5b.d20250127'}</pre> <p>You can access the metadata for a specific key by passing that key as an argument to the method.</p> In\u00a0[6]: Copied! <pre>summary.metadata(\"time\")\n</pre> summary.metadata(\"time\") Out[6]: <pre>{'created': '2025-01-27T21:10:13.879515+00:00'}</pre> In\u00a0[9]: Copied! <pre>summary.to_pickle(\"saved-outputs/summary\")\n</pre> summary.to_pickle(\"saved-outputs/summary\") <p>The method will automatically add the appropriate file extension and write the file to disk. By default, it will also add a timestamp, so that you will not overwrite existing similar files.</p> In\u00a0[10]: Copied! <pre>from passengersim.utils.show_dir import display_directory_contents\n\ndisplay_directory_contents(\"saved-outputs\")\n</pre> from passengersim.utils.show_dir import display_directory_contents  display_directory_contents(\"saved-outputs\") <pre>saved-outputs/\n  summary.20250127-151013.pkl.lz4\n</pre> <p>Restoring from this pickle file can be done, surprisingly enough, using the <code>from_pickle</code> method.  You can call this method with the same filename as <code>to_pickle</code>, and it will load the file with the most recent timestamp if there is one or more matching file(s) with various timestamps.  To load a specific pickle file that may or may not be the most recent, you can call this method with the complete actual filename, including the timestamp and \".pkl\" or \".pkl.lz4\" suffix.</p> In\u00a0[11]: Copied! <pre>resummary = pax.SimulationTables.from_pickle(\"saved-outputs/summary\")\nresummary\n</pre> resummary = pax.SimulationTables.from_pickle(\"saved-outputs/summary\") resummary Out[11]: <pre>&lt;passengersim.summaries.SimulationTables created on 2025-01-27&gt;\n * bid_price_history (256 row DataFrame)\n * carriers (2 row DataFrame)\n * carrier_history2 (800 row DataFrame)\n * demand_to_come_summary (34 row DataFrame)\n * demands (6 row DataFrame)\n * displacement_history (68 row DataFrame)\n * fare_class_mix (12 row DataFrame)\n * legbuckets (48 row DataFrame)\n * legs (8 row DataFrame)\n * pathclasses (72 row DataFrame)\n * path_legs (16 row DataFrame)\n * paths (12 row DataFrame)\n * segmentation_by_timeframe (304 row DataFrame)\n&lt;*&gt;</pre> <p>Once loaded, you can confirm which file was loaded, as that is added to the metadata at load time:</p> In\u00a0[12]: Copied! <pre>resummary.metadata(\"loaded\")\n</pre> resummary.metadata(\"loaded\") Out[12]: <pre>{'filename': 'saved-outputs/summary.20250127-151013.pkl.lz4',\n 'time': '2025-01-27T21:10:13.970645+00:00'}</pre> In\u00a0[13]: Copied! <pre>summary.to_file(\"saved-outputs/summary\")\n\ndisplay_directory_contents(\"saved-outputs\")\n</pre> summary.to_file(\"saved-outputs/summary\")  display_directory_contents(\"saved-outputs\") <pre>saved-outputs/\n  summary.20250127-151013.pkl.lz4\n  summary.20250127-151013.pxsim\n</pre> <p>When opening the file, only the most basic metadata is loaded by the <code>from_file</code> method, and the rest is identified as available on demand from storage.</p> In\u00a0[14]: Copied! <pre>resummary2 = pax.SimulationTables.from_file(\"saved-outputs/summary\")\nresummary2\n</pre> resummary2 = pax.SimulationTables.from_file(\"saved-outputs/summary\") resummary2 Out[14]: <pre>&lt;passengersim.summaries.SimulationTables created on 2025-01-27&gt;\n * bid_price_history (available in file storage)\n * carrier_history2 (available in file storage)\n * carriers (available in file storage)\n * demand_to_come_summary (available in file storage)\n * demands (available in file storage)\n * displacement_history (available in file storage)\n * fare_class_mix (available in file storage)\n * legbuckets (available in file storage)\n * legs (available in file storage)\n * path_legs (available in file storage)\n * pathclasses (available in file storage)\n * paths (available in file storage)\n * segmentation_by_timeframe (available in file storage)\n&lt;*&gt;</pre> <p>The metadata about this file is available under the \"store\" key instead of \"loaded\".</p> In\u00a0[15]: Copied! <pre>resummary2.metadata(\"store\")\n</pre> resummary2.metadata(\"store\") Out[15]: <pre>{'filename': 'saved-outputs/summary.20250127-151013.pxsim'}</pre> <p>Accessing data will load just that table from the file.  this includes accessing a table explicity (by calling for it), or implicitly (e.g. by creating a figure using the data).</p> In\u00a0[16]: Copied! <pre>resummary2.carriers\n</pre> resummary2.carriers Out[16]: control avg_rev avg_sold truncation_rule avg_leg_lf asm rpm ancillary_rev avg_local_leg_pax avg_total_leg_pax avg_price yield sys_lf local_pct_leg_pax local_pct_bookings carrier AL1 leg 90920.1875 285.9675 3 86.790729 590302.497298 519508.421436 0.0 188.8825 383.0525 317.938883 0.175012 88.007153 49.309820 66.050338 AL2 leg 90614.6250 285.3625 3 86.622292 590302.497298 519025.918143 0.0 188.3300 382.3950 317.542161 0.174586 87.925415 49.250121 65.996759 In\u00a0[17]: Copied! <pre>resummary2.fig_fare_class_mix()\n</pre> resummary2.fig_fare_class_mix() Out[17]: <p>We can see in the objects <code>repr</code> that the carriers and fare_class_mix tables have been loaded, but the rest are still only in the storage file.</p> In\u00a0[18]: Copied! <pre>resummary2\n</pre> resummary2 Out[18]: <pre>&lt;passengersim.summaries.SimulationTables created on 2025-01-27&gt;\n * carriers (2 row DataFrame)\n * fare_class_mix (12 row DataFrame)\n * bid_price_history (available in file storage)\n * carrier_history2 (available in file storage)\n * demand_to_come_summary (available in file storage)\n * demands (available in file storage)\n * displacement_history (available in file storage)\n * legbuckets (available in file storage)\n * legs (available in file storage)\n * path_legs (available in file storage)\n * pathclasses (available in file storage)\n * paths (available in file storage)\n * segmentation_by_timeframe (available in file storage)\n&lt;*&gt;</pre>"}, {"location": "user-guide/processing-outputs/basic-usage.nbconvert.html#summary-outputs", "title": "Summary Outputs\u00b6", "text": "<p>When you run a simulation in PassengerSim, you will get a <code>SimulationTables</code> object. This objects embeds a variety of summary infomation from the run.</p>"}, {"location": "user-guide/processing-outputs/basic-usage.nbconvert.html#saving-and-restoring", "title": "Saving and Restoring\u00b6", "text": "<p>Running a PassengerSim simulation on a practical network can take some time, so it is desirable to save your results after a run.  This allows you to come back to the analyze those results later, or compare against other future scenario permutations.  Saving outputs is done efficiently in the <code>pickle</code> format by using the <code>to_pickle</code> method.  This will automatically also use LZ4 compression if available, which will reduce the filesize considerably.</p>"}, {"location": "user-guide/processing-outputs/basic-usage.nbconvert.html#lazy-data-access", "title": "Lazy Data Access\u00b6", "text": "<p>When it is time to load the data, the pickle format is an all-or-nothing file format: if you only need a tiny bit of information from the file (e.g. what was AL1's revenue?) you still need to read all the data in the file: legs, paths, etc. PassengerSim also includes an alternative file format that stores the various data tables from the <code>SimulationTables</code> in independently loadable sections.  This format otherwise works the same as the pickle file, but uses <code>to_file</code> and <code>from_file</code>, and it creates files with a \"*.pxsim\" extension.</p>"}, {"location": "user-guide/processing-outputs/callbacks.nbconvert.html", "title": "Callbacks", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.46.dev30+g3f4104a.d20250127\npassengersim.core 0.46.dev45+gdc44d5b.d20250127\n</pre> <p>Here, we'll run a quick demo using the \"3MKT\" example model.  We'll give AL1 the 'P' RM system to make it interesting.</p> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\"))\n\ncfg.simulation_controls.num_samples = 100\ncfg.simulation_controls.burn_samples = 50\ncfg.simulation_controls.num_trials = 1\ncfg.db = None\ncfg.outputs.reports.clear()\n\ncfg.carriers.AL1.rm_system = \"P\"\n\nsim = pax.Simulation(cfg)\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\"))  cfg.simulation_controls.num_samples = 100 cfg.simulation_controls.burn_samples = 50 cfg.simulation_controls.num_trials = 1 cfg.db = None cfg.outputs.reports.clear()  cfg.carriers.AL1.rm_system = \"P\"  sim = pax.Simulation(cfg) In\u00a0[3]: Copied! <pre>@sim.end_sample_callback\ndef collect_carrier_revenue(sim):\n    if sim.sim.sample &lt; sim.sim.burn_samples:\n        return\n    return {c.name: c.revenue for c in sim.sim.carriers}\n</pre> @sim.end_sample_callback def collect_carrier_revenue(sim):     if sim.sim.sample &lt; sim.sim.burn_samples:         return     return {c.name: c.revenue for c in sim.sim.carriers} <p>The daily callback operates similarly, except it accepts a second argument that gives the number of days prior to departure for this day.  You don't need to use the second argument in the callback function, but you need to including in the function signature (and you can use it if desired, e.g. to collect data only at DCPs instead of every day).  In the example here, we collect daily carrier revenue, but only every 7th sample, which is a good way to reduce the overhead from collecting detailed data.</p> In\u00a0[4]: Copied! <pre>@sim.daily_callback\ndef collect_carrier_revenue_detail(sim, days_prior):\n    if sim.sim.sample &lt; sim.sim.burn_samples:\n        return\n    if sim.sim.sample % 7 == 0:\n        return {c.name: c.revenue for c in sim.sim.carriers}\n</pre> @sim.daily_callback def collect_carrier_revenue_detail(sim, days_prior):     if sim.sim.sample &lt; sim.sim.burn_samples:         return     if sim.sim.sample % 7 == 0:         return {c.name: c.revenue for c in sim.sim.carriers} <p>Multiple callbacks of the same kind can be attached (i.e. there can be two end_sample callbacks).  The only limitation is that the named values in the return values of each callback function must be unique, or else they will overwrite one another.</p> <p>Once we have attached all desired callbacks, we can run the simulation as normal.</p> In\u00a0[5]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 1.33 seconds\n</pre> <p>All the usual summary data remains available for review and analysis.</p> In\u00a0[6]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[6]: In\u00a0[7]: Copied! <pre>summary.callback_data\n</pre> summary.callback_data Out[7]: <pre>&lt;passengersim.callbacks.CallbackData from end_sample, daily&gt;</pre> <p>Because we connected a \"daily\" callback, the data we collected is available under the <code>callback_data.daily</code> accessor.</p> In\u00a0[8]: Copied! <pre>summary.callback_data.daily[:5]\n</pre> summary.callback_data.daily[:5] Out[8]: <pre>[{'trial': 0, 'sample': 56, 'days_prior': 63, 'AL1': 0.0, 'AL2': 0.0},\n {'trial': 0, 'sample': 56, 'days_prior': 62, 'AL1': 600.0, 'AL2': 2125.0},\n {'trial': 0, 'sample': 56, 'days_prior': 61, 'AL1': 1350.0, 'AL2': 4225.0},\n {'trial': 0, 'sample': 56, 'days_prior': 60, 'AL1': 2025.0, 'AL2': 6250.0},\n {'trial': 0, 'sample': 56, 'days_prior': 59, 'AL1': 3125.0, 'AL2': 6825.0}]</pre> <p>As you might expect, the \"begin_sample\" or \"end_sample\" callbacks are available under <code>callback_data.begin_sample</code> or <code>callback_data.end_sample</code>, respectively.</p> In\u00a0[9]: Copied! <pre>summary.callback_data.end_sample[:5]\n</pre> summary.callback_data.end_sample[:5] Out[9]: <pre>[{'trial': 0, 'sample': 50, 'AL1': 100475.0, 'AL2': 103700.0},\n {'trial': 0, 'sample': 51, 'AL1': 101475.0, 'AL2': 97425.0},\n {'trial': 0, 'sample': 52, 'AL1': 108575.0, 'AL2': 95000.0},\n {'trial': 0, 'sample': 53, 'AL1': 104275.0, 'AL2': 98825.0},\n {'trial': 0, 'sample': 54, 'AL1': 101300.0, 'AL2': 97000.0}]</pre> <p>The callback data can include pretty much anything, so it is stored in a very flexible (but inefficient) format: a list of dict's.  If the content of the dicts is fairly simple (numbers, tuples, lists, or nexted dictionaries thereof), it can be converted into a pandas DataFrame using the <code>to_dataframe</code> method on the <code>callback_data</code> attribute.  This may make subsequent analysis easier.</p> In\u00a0[10]: Copied! <pre>summary.callback_data.to_dataframe(\"daily\")\n</pre> summary.callback_data.to_dataframe(\"daily\") Out[10]: trial sample days_prior AL1 AL2 0 0 56 63 0.0 0.0 1 0 56 62 600.0 2125.0 2 0 56 61 1350.0 4225.0 3 0 56 60 2025.0 6250.0 4 0 56 59 3125.0 6825.0 ... ... ... ... ... ... 443 0 98 4 51800.0 61225.0 444 0 98 3 53800.0 63225.0 445 0 98 2 56225.0 66400.0 446 0 98 1 61025.0 70050.0 447 0 98 0 62450.0 73450.0 <p>448 rows \u00d7 5 columns</p> <p>Users are free to process this callback data now however they like, with typical Python tools: analyze, visualize, interpret, etc.</p> In\u00a0[11]: Copied! <pre>import altair as alt\n\nalt.Chart(\n    summary.callback_data.to_dataframe(\"daily\").eval(\"DIFF = AL1 - AL2\")\n).mark_line().encode(\n    x=alt.X(\"days_prior\", scale=alt.Scale(reverse=True)),\n    y=\"DIFF\",\n    color=\"sample:N\",\n)\n</pre> import altair as alt  alt.Chart(     summary.callback_data.to_dataframe(\"daily\").eval(\"DIFF = AL1 - AL2\") ).mark_line().encode(     x=alt.X(\"days_prior\", scale=alt.Scale(reverse=True)),     y=\"DIFF\",     color=\"sample:N\", ) Out[11]:"}, {"location": "user-guide/processing-outputs/callbacks.nbconvert.html#callbacks", "title": "Callbacks\u00b6", "text": "<p>PassengerSim includes a variety of optimized data collection processes that run automatically during a simulation, but these pre-selected data may not be sufficient for every analysis.  To supplement this, users can choose to additionally collect any other data while running a simulation. This is done by writing a \"callback\" function.  Such a function is invoked regularly while the simulation is running, and can inspect and store almost anything from the Simulation object.</p>"}, {"location": "user-guide/processing-outputs/callbacks.nbconvert.html#types-of-callback-functions", "title": "Types of Callback Functions\u00b6", "text": "<p>To collect data, we can write a function that will interrogate the simulation and grab whatever info we are looking for.  There are three different points where we can attach data collection callback functions:</p> <ul> <li><code>begin_sample</code>, which will trigger data collection at the beginning of each sample, after the RM systems for each carrier are initialized (e.g. with forecasts, etc) but before any customers can arrive.</li> <li><code>end_sample</code>, which will trigger data collection at the end of each sample, after customers have arrive and all bookings have be finalized.</li> <li><code>daily</code>, which will trigger data collection once per day during every sample, just after any DCP or daily RM system updates are run.</li> </ul> <p>The first two callbacks (begin and end sample) are written as a function that accepts one argument (the <code>Simulation</code> object), and either returns nothing (to ignore that event) or returns a dictionary of values to store, where the keys are all strings naming what's being stored and the values can be whatever is of interest. We can attach each callback to the Simulation by using a Python decorator.</p>"}, {"location": "user-guide/processing-outputs/callbacks.nbconvert.html#example-callback-functions", "title": "Example Callback Functions\u00b6", "text": "<p>For example, here we create a callback to collect carrier revenue at the end of every sample. Note that we skip the burn period by returning nothing for those samples; this is not required by the callback algorithm but is good practice for analysis.</p>"}, {"location": "user-guide/processing-outputs/callbacks.nbconvert.html#callback-data", "title": "Callback Data\u00b6", "text": "<p>In addition to the usual suspects, the summary object includes the collected callback data from our callback functions.</p>"}, {"location": "user-guide/rm-systems/index.html", "title": "RM Systems", "text": "<p>A revenue management (RM) system is defined by one or more steps. The steps tell the simulation which demand untruncation, demand forecasting, and optimization algorithms to use.  These steps also provide information on the kind of forecast and optimization used (i.e., leg or path) and if path-level information should be aggregated to leg-level information before a step is performed.  Finally, these steps allow the user to specify algorithm-specific parameters, e.g., when using exponential smoothing the user can specify the smoothing constant, alpha.</p> <p>Each carrier should have an RM system that it uses. In PassengerSim, users have the ability to create a single RM system and assign it to all carriers, or to create multiple RM systems and assign different RM systems to different carriers.</p> <p>Below is an example that defines 4 RM systems.  It will be helpful to use these examples to understand the different step_types and options associated with each step_type.</p> <pre><code>rm_systems:\n  fcfs:\n    steps: []\n  rm_no_detruncation:\n    processes:\n      DCP:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: none\n        kind: leg\n      - step_type: forecast\n        name: forecast\n        algorithm: additive_pickup\n        alpha: 0.1\n        kind: leg\n      - step_type: emsr\n        name: optimization\n        algorithm: emsrb\n        kind: leg\n  rm_em:\n    steps:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: none\n        kind: leg\n      - step_type: forecast\n        name: forecast\n        algorithm: additive_pickup\n        alpha: 0.15\n        kind: leg\n      - step_type: fcfs\n        name: optimization\n  rm_probp:\n    steps:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: em\n        kind: path\n      - step_type: forecast\n        name: path_forecast\n        algorithm: exp_smoothing\n        alpha: 0.15\n        kind: path\n      - step_type: probp\n        name: optimization\n      - step_type: aggregation\n        name: aggregate\n      - step_type: emsr\n        name: optimization\n        algorithm: emsrb\n        kind: leg\n</code></pre> <p>The first RM system is based on a first-come, first-serve approach (named <code>fcfs</code>). No steps are defined for <code>fcfs</code> as there is no demand detruncation, demand forecasting, or optimization done with FCFS.  If step_types are defined when <code>fcfs</code> is explicitly specified as the optimization algorithm, they will be ignored.</p> <p>The second RM system, named <code>rm_no_detruncation</code>, is leg-based and uses an <code>additive_pickup</code> forecasting model with EMSRb and no demand detrunction. The alpha parameter that is specified in the forecast <code>step_type</code> will be ignored as it is not used for the additive pick-up model.</p> <p>The third RM system, named <code>rm_em</code>, is using the expectation-maximization (EM) method of detruncation with an exponential smoothing demand forecasting approach that has a smoothing constant of alpha of 0.15 with and EMSRb optimizer. Both the forecasts and optimization are done using leg-level inputs.</p> <p>Finally, the fourth RM system, named <code>rm_probp</code>, is also using the EM method of detruncation with an exponential smoothing dmeand forecasting approach that has a smoothing constant or alpha of 0.15.  Unlike in <code>rm_em</code> however, the untruncation and forecasting steps are done at the path level. The optimization step is based on probp that first finds displacement costs at a path level, then aggregates them to a leg-level in the aggregation step type, and finally calculates protection levels using EMSRb with leg-level demand inputs.</p> <p>Given an overview of how RM systems are constructed, let's now look at each step in detail.</p>"}, {"location": "user-guide/rm-systems/index.html#untruncation", "title": "Untruncation", "text": "<pre><code>- step_type: untruncation\n  name: untruncation\n  algorithm: none, em, naive1, naive2\n  kind: leg, path\n</code></pre> <p>There are three untruncation (also called detruncation) algorithms.  The first, <code>em</code>, is based on the expectation maximization method.  The <code>naive1</code> and <code>naive2</code> methods are based on Shebelov presentation. The untruncation steps can be performed at the path or leg level.</p>"}, {"location": "user-guide/rm-systems/index.html#forecast", "title": "Forecast", "text": "<pre><code>- step_type: 'forecast'\n  algorithm: { additive_pickup, exp_smoothing }\n  alpha: float\n  kind: { leg, path, hybrid }\n</code></pre> <p>There are two forecasting algorithms: exponential smoothing (that uses a smoothing or alpha parameter) and additive pickup model.  The exponential smoothing model does not (currently) incorporate trend or seasonality.</p> <p>The additive pickup model generates a forecast by considering the \"pickup\", or the number of new sales in a booking class, in each time period (DCP).  This model is additive in that the forecast of demand yet to come at given time is computed as the sum of forecast pickups in all future time periods.  This forecasting model does not consider the level of demand already accumulated, only the demand expected in the future.  The forecast is made considering the results from the prior 26 sample days. The additive pickup model ignores the value of the alpha parameter, and it should be omitted when using this algorithm.</p> <p>Either forecast algorithm can be performed based on data collected at either the leg or path level. However, if the forecast is at the leg level then detruncation must also have been performed at the same level.</p>"}, {"location": "user-guide/rm-systems/index.html#emsr-optimization", "title": "EMSR Optimization", "text": "<pre><code>- step_type: emsr\n  name: optimization\n  algorithm: emsra, emsrb\n  kind: leg\n</code></pre> <p>The step_type emsr is used for algorithms based on the expected marginal seat revenue approach and also can be used for fcfs. (although the first RM system defined as fcfs in the example above is a cleaner way to specify the fcfs option).</p>"}, {"location": "user-guide/rm-systems/index.html#probp-optimization", "title": "ProBP Optimization", "text": "<pre><code>- step_type: probp\n  name: optimization\n</code></pre> <p>The step_type probp does just as the name suggests - uses the probabilistic bid price algorithm to determine path-based displacment costs.  After these are found, two more steps are needed - the first is to aggregate path-level information to leg-level information and do the probp proration? and the next is to use the leg-level inputs to find protection levels using emsrb.</p>"}, {"location": "user-guide/rm-systems/emsr.html", "title": "EMSR Optimization", "text": "<p>Optimization is the most fundamental part of revenue management systems, is it is the process used to tailor the set of products being offered to maximize revenue. It typically occurs after untruncation and forecasting.</p> <p>PassengerSim offers several different optimization algorithms. One widely used algorithm is called EMSR (expected marginal seat revenue), which has a few variants, generally labels as \"A\", \"B\", and \"C\".</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b:\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: emsr #(1)!\n        algorithm: b\n        kind: leg\n</code></pre></p> <ol> <li>The <code>step_type</code> for EMSR optimization is <code>emsr</code>, this is how PassengerSim     identifies what to do in this step.</li> </ol>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim.rm.EmsrStep", "title": "EmsrStep", "text": "<p>               Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim.rm.EmsrStep.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: Literal[\n    \"a\", \"b\", \"emsra\", \"emsrb\", \"emsrc\", \"emsrg\"\n]\n</code></pre> <p>Which variant of the EMSR optimization algorithm should be applied.</p> <p>Currently the \"A\" and \"B\" variants are implemented. EMSRc computes the critical EMSR value as a proxy for displacement or bid price The \"G\" variant is EMSRb using a Gamma distribution (experimental)</p>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim.rm.EmsrStep.kind", "title": "kind  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['leg'] = 'leg'\n</code></pre> <p>EMSR (Expected Marginal Seat Revenue) is a leg-based optimization algorithm.</p> <p>The <code>kind</code> parameter is included in the interface for compatability, but setting any value here other than <code>leg</code> will result in an error.</p>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim.rm.EmsrStep.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[Any] = []\n</code></pre>"}, {"location": "user-guide/rm-systems/fcfs.html", "title": "FCFS Allocation", "text": "<p>First come first served (FCFS) is a simple method for allocating capacity to customers, and it operates pretty much as you would expect: customers whom arrive first are offered products, no attempt is made to optimize for anything.</p> <p>This process of capacity allocation will also occur if no RM optimization algorithm is applied, but the explicit FCFS step type allow the user to be intentional about selecting this algorithm, and to attach snapshot filters to the simulation if desired.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b:\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: fcfs #(1)!\n</code></pre></p> <ol> <li>The <code>step_type</code> for first come, first served is <code>fcfs</code>.</li> </ol>"}, {"location": "user-guide/rm-systems/fcfs.html#passengersim.rm.FcfsStep", "title": "FcfsStep", "text": "<p>               Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/fcfs.html#passengersim.rm.FcfsStep.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[Any] = []\n</code></pre>"}, {"location": "user-guide/rm-systems/forecast.html", "title": "Forecasting", "text": "<p>Forecasting is a key part of revenue management systems.  You need to know how many customers of each type you should expect, so you can tailor the set of products being offered to maximize revenue.</p> <p>In PassengerSim, forecasting is included as a step within an RM system, typically within the DCP process, after untruncation and before any optimization.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b:\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast #(1)!\n        algorithm: additive_pickup #(2)!\n        kind: leg #(3)!\n      - step_type: emsr\n        algorithm: b\n        kind: leg\n</code></pre></p> <ol> <li>The <code>step_type</code> for forecasting must be <code>forecast</code>, this is how PassengerSim     identifies what to do in this step.</li> <li>Several different algorithms are available for forecasting, see     below for details.</li> <li>Forecasts can be made at the leg or path level, see     below for details.</li> </ol>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim.rm.ForecastStep", "title": "ForecastStep", "text": "<p>               Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim.rm.ForecastStep.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: Literal[\n    \"exp_smoothing\",\n    \"additive_pickup\",\n    \"multiplicative_pickup\",\n]\n</code></pre> <p>Forecasting algorithm.</p> <p>There are several available forecasting algorithms:</p> <p><code>exp_smoothing</code>     is an exponential smoothing model.  This model uses the <code>alpha</code> parameter     to control the amount of smoothing applied.  It does not (currently)     incorporate trend effects or seasonality.</p> <p><code>additive_pickup</code>     is an additive pickup model, which generates a forecast by considering the     \"pickup\", or the number of new sales in a booking class, in each time     period (DCP).  This model is additive in that the forecast of demand yet     to come at given time is computed as the sum of forecast pickups in all     future time periods.  This forecasting model does not consider the level     of demand already accumulated, only the demand expected in the future. The     forecast is made considering the results from the prior 26 sample days.     The additive pickup model ignores the value of the alpha parameter, and it     can safely be omitted when using this algorithm.</p> <p><code>multiplicative_pickup</code>     is a multiplicative pickup model.  This model is in development.</p>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim.rm.ForecastStep.kind", "title": "kind  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>kind: Literal[\n    \"leg\",\n    \"path\",\n    \"hybrid\",\n    \"conditional\",\n    \"leg-conditional\",\n    \"leg-hybrid\",\n] = \"leg\"\n</code></pre> <p>Level of collected demand data that should be used for forecasting.</p> <p>Hybrid forecasting is primarily a path-based forecast, but it includes EM untruncation of yieldable demand.</p>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim.rm.ForecastStep.alpha", "title": "alpha  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>alpha: float = 0.15\n</code></pre> <p>Exponential smoothing factor.</p> <p>This setting is ignored if the forecast algorithm is not \"exp_smoothing\".</p>"}, {"location": "user-guide/rm-systems/probp.html", "title": "ProBP Optimization", "text": "<p>Optimization is the most fundamental part of revenue management systems, is it is the process used to tailor the set of products being offered to maximize revenue. It typically occurs after untruncation and forecasting.</p> <p>PassengerSim offers several different optimization algorithms, including probabilistic bid price (ProBP) optimization.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_probp:\n    availability_control: bp #(2)!\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: probp #(1)!\n</code></pre></p> <ol> <li>The <code>step_type</code> for probabilistic bid price optimization is <code>probp</code>, this is     how PassengerSim identifies what to do in this step.</li> <li>To apply the ProBP optimization results, the <code>rm_system</code> should be set to use     <code>bp</code> (bid price) availability controls.</li> </ol>"}, {"location": "user-guide/rm-systems/probp.html#passengersim.rm.ProBpStep", "title": "ProBpStep", "text": "<p>               Bases: <code>RmStep</code></p> <p>Implements ProBP as an RM Step</p>"}, {"location": "user-guide/rm-systems/probp.html#passengersim.rm.ProBpStep.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[Any] = []\n</code></pre>"}, {"location": "user-guide/rm-systems/untruncation.html", "title": "Untruncation", "text": "<p>Untruncation is a part of most revenue management systems.  It is a mathematical process whereby we estimate the number of customers there would have been for a particular product, assuming we would have offered the product for sale to all comers.  In the cases where we actually did offer the product to all, then there is nothing for this algorithm to do beyond counting our actual sales.  However, many times our RM systems will limit the number of customers we actually accept, and our actual sales are \"truncated\".  Untruncation is needed to approximate how many customers were lost.</p> <p>In PassengerSim, untruncation is included as a step within an RM system, typically within the DCP process before any forecasting or optimization steps.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b: #(4)!\n    processes:\n      DCP:\n      - step_type: untruncation #(1)!\n        algorithm: em #(2)!\n        kind: leg #(3)!\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: emsr\n        algorithm: b\n        kind: leg\n</code></pre></p> <ol> <li>The <code>step_type</code> must be <code>untruncation</code>, as this is how PassengerSim     identifies what to do in this step.</li> <li>Several different algorithms are available for untruncation, see     below for details.</li> <li>Untruncation can be done at the leg or path level, see     below for details.</li> <li>This is showing that <code>basic_emsr_b</code> is the name of this RM system.     Elsewhere in the configuration (not shown in this example snippet) you will     define carriers, and each will be assigned an RM system using these names.</li> </ol>"}, {"location": "user-guide/rm-systems/untruncation.html#passengersim.rm.UntruncationStep", "title": "UntruncationStep", "text": "<p>               Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/untruncation.html#passengersim.rm.UntruncationStep.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: Literal[\n    \"em\",\n    \"em_py\",\n    \"none\",\n    \"naive1\",\n    \"naive2\",\n    \"naive3\",\n    \"pd\",\n    \"mfem\",\n]\n</code></pre> <p>Untruncation algorithm.</p> <p>There are several available algorithms:</p> <p><code>none</code>     applies no untruncation, and assumes that demand was the same as sales.     Applying this algorithm is still important even if no detruncation is     desired, as PassengerSim tracks historical demand separately from sales     and without \"none\" the historical demand used in forecasting would be     zero.</p> <p><code>em</code>     is an expectation-maximization model.</p> <p><code>em_py</code>     is an expectation-maximization model implemented in Python.  It is slow     but useful for educational purposes.</p> <p><code>naive1</code>     is not recommended for use.</p> <p><code>naive2</code>     is not recommended for use.</p> <p><code>naive3</code>     is not recommended for use.</p> <p><code>pd</code>     is a projection-detruncation model, based on the method developed by     Hopperstad and described by Weatherford &amp; Polt.</p> <p><code>mfem</code>     Multi-Flight Expectation Maximization.  Takes into account spill and recapture across multiple departures</p>"}, {"location": "user-guide/rm-systems/untruncation.html#passengersim.rm.UntruncationStep.kind", "title": "kind  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['leg', 'path', 'hybrid'] = 'leg'\n</code></pre> <p>Level of collected demand data that should be used for untruncation.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html", "title": "Carrier-level Summaries", "text": "In\u00a0[2]: Copied! <pre>from passengersim import SimulationTables\n\nsummary = SimulationTables.from_pickle(\"saved-output/simple-sim\")\n</pre> from passengersim import SimulationTables  summary = SimulationTables.from_pickle(\"saved-output/simple-sim\") In\u00a0[3]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[3]: In\u00a0[4]: Copied! <pre>summary.fig_carrier_mileage()\n</pre> summary.fig_carrier_mileage() Out[4]: In\u00a0[5]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[5]: <p>Alternatively, this function can also display the average leg load factor, which considers the fraction of capacity sold on each leg, and weights all legs uniformly.</p> In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors(load_measure=\"avg_leg_lf\")\n</pre> summary.fig_carrier_load_factors(load_measure=\"avg_leg_lf\") Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_leg_load_factor_distribution()\n</pre> summary.fig_leg_load_factor_distribution() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_carrier_local_share()\n</pre> summary.fig_carrier_local_share() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_carrier_local_share(\"leg_pax\")\n</pre> summary.fig_carrier_local_share(\"leg_pax\") Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_carrier_yields()\n</pre> summary.fig_carrier_yields() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[11]: In\u00a0[12]: Copied! <pre>from passengersim.contrast import Contrast\n\ncomps = Contrast(\n    Simple=summary,\n    Untruncated=SimulationTables.from_pickle(\"saved-output/untruncated-sim\"),\n)\n</pre> from passengersim.contrast import Contrast  comps = Contrast(     Simple=summary,     Untruncated=SimulationTables.from_pickle(\"saved-output/untruncated-sim\"), ) In\u00a0[13]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_carrier_load_factors(load_measure=\"avg_leg_lf\")\n</pre> comps.fig_carrier_load_factors(load_measure=\"avg_leg_lf\") Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_carrier_yields()\n</pre> comps.fig_carrier_yields() Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[17]:"}, {"location": "user-guide/viz/carriers.nbconvert.html#carrier-level-summaries", "title": "Carrier-level Summaries\u00b6", "text": "<p>This page provides an overview of the carrier-level summary visualizations available in PassengerSim.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#one-simulation-run", "title": "One Simulation Run\u00b6", "text": "<p>The results from a simulation run are stored in a <code>SimulationTables</code> instance, which is returned from <code>Simulation.run</code> or can be loaded from a stored database of results. This object has a number of methods to generate visualizations for the results of the simulation.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#revenues", "title": "Revenues\u00b6", "text": "<p><code>SimulationTables.fig_carrier_revenues</code></p> <p>Display the average revenues by carrier.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#mileage", "title": "Mileage\u00b6", "text": "<p><code>SimulationTables.fig_carrier_mileage</code></p> <p>Display the available seat miles (ASM) and average revenue passenger miles (RPM) by carrier.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#load-factors", "title": "Load Factors\u00b6", "text": "<p><code>SimulationTables.fig_carrier_load_factors</code></p> <p>Display the average system load factors by carrier.  The system load factor is calculated based on ASM and RPM figures for the carrier, which weights larger capacity vehicles and longer distance legs more heavily, to reflect their larger relative importance in evaluating carrier performance.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#load-factor-distributions", "title": "Load Factor Distributions\u00b6", "text": "<p><code>SimulationTables.fig_leg_load_factor_distribution</code></p> <p>Display the distribution of leg load factors.  This can be done for all carriers individually (<code>by_carrier=True</code>, or omitted as this is the default), or across carriers in aggregate (<code>by_carrier=False</code>), for a specific carrier (<code>by_carrier='AL1'</code>).</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#local-passenger-percentages", "title": "Local Passenger Percentages\u00b6", "text": "<p>Display the percentage of local passengers by carrier.  By default, this is the percentage of bookings that are local (i.e. flying on only a single leg). Alternatively, this method accepts a <code>load_measure</code> argument that can be set to 'leg_pax', which will report the percentage of leg passengers who are local -- the numerator of this ratio is the same, but the denominator is larger (assuming there are any connecting passengers in the network).</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#yields", "title": "Yields\u00b6", "text": "<p><code>SimulationTables.fig_carrier_yields</code></p> <p>Display the average yield (revenue per passenger mile) by carrier.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#fare-class-mix", "title": "Fare Class Mix\u00b6", "text": "<p><code>SimulationTables.fig_fare_class_mix</code></p> <p>Display the fare class mix by carrier.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#contrasting-multiple-runs", "title": "Contrasting Multiple Runs\u00b6", "text": "<p>Similar figures are available contrasting the results of multiple runs, by bundling multiple <code>SimulationTables</code> objects in a <code>Contrast</code> instance.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#revenues", "title": "Revenues\u00b6", "text": "<p><code>Contrast.fig_carrier_revenues</code>.</p> <p>Display the average revenues by carrier.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#load-factors", "title": "Load Factors\u00b6", "text": "<p><code>Contrast.fig_carrier_load_factors</code>.</p> <p>Display the average system load factors by carrier.  The system load factor is calculated based on ASM and RPM figures for the carrier, which weights larger capacity vehicles and longer distance legs more heavily, to reflect their larger relative importance in evaluating carrier performance.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#yields", "title": "Yields\u00b6", "text": "<p><code>Contrast.fig_carrier_yields</code>.</p> <p>Display the average yield (revenue per passenger mile) by carrier.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#fare-class-mix", "title": "Fare Class Mix\u00b6", "text": "<p><code>Contrast.fig_fare_class_mix</code>.</p> <p>Display the fare class mix by carrier.</p>"}]}