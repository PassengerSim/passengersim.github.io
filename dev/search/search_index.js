var __index = {"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "index.html", "title": "Home", "text": ""}, {"location": "API/index.html", "title": "PassengerSim API", "text": "<p>The main <code>passengersim</code> package includes configuration and analysis tools.  It is freely available for use.</p> <p>The <code>passengersim.core</code> sub-package is only available to authorized users.</p>"}, {"location": "API/contrast.html", "title": "Contrasting Results", "text": ""}, {"location": "API/contrast.html#passengersim.contrast.ForecastOfT", "title": "ForecastOfT  <code>module-attribute</code>", "text": "<pre><code>ForecastOfT = Literal['mu', 'sigma', 'closed', 'adj_price']\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast", "title": "Contrast", "text": "<p>               Bases: <code>dict</code></p> Source code in <code>passengersim/contrast.py</code> <pre><code>class Contrast(dict):\n    def apply(\n        self,\n        func: Callable,\n        axis: int | Literal[\"index\", \"columns\", \"rows\"] = 0,\n        warn_if_missing: bool = False,\n    ) -&gt; pd.DataFrame | pd.Series:\n        data = {}\n        for k, v in self.items():\n            if v is not None:\n                data[k] = func(v)\n            else:\n                if warn_if_missing:\n                    warnings.warn(f\"no data found for {k!r}\", stacklevel=2)\n        try:\n            return pd.concat(data, axis=axis, names=[\"source\"])\n        except TypeError:\n            return pd.Series(data).rename_axis(index=\"source\")\n\n    def __getattr__(self, attr):\n        if attr.startswith(\"fig_\"):\n            g = globals()\n            if attr in g:\n                return partial(g[attr], self)\n                # return lambda *a, **k: g[attr](self, *a, **k)\n        raise AttributeError(attr)\n\n    def __dir__(self):\n        x = set(super().__dir__())\n        x |= {g for g in globals() if g.startswith(\"fig_\")}\n        return sorted(x)\n\n    def write_report(self, filename: PathLike, **kwargs) -&gt; pathlib.Path:\n        from passengersim.reporting.contrast import to_html\n\n        return to_html(self, filename, **kwargs)\n\n    def subset(self, keys=None, *, regex: str = None) -&gt; Self:\n        \"\"\"Subset the contrast to only include the specified keys.\n\n        Parameters\n        ----------\n        keys : str or list of str, optional\n            The keys to include in the subset. If None, use the `regex` filter.\n        regex : str, optional\n            A regular expression to filter the keys. If None, use the `keys` filter.\n\n        Returns\n        -------\n        Contrast\n        \"\"\"\n        if keys is not None and regex is not None:\n            raise ValueError(\"cannot use both keys and regex\")\n        if keys is not None:\n            if isinstance(keys, str):\n                keys = [keys]\n            if not isinstance(keys, list | tuple):\n                raise TypeError(\"keys must be a string or a list of strings\")\n            result = type(self)({key: self[key] for key in keys if key in self})\n        else:\n            import re\n\n            matches = []\n            for k in self.keys():\n                if re.match(regex, k):\n                    matches.append(k)\n            result = type(self)({k: self[k] for k in matches})\n        if len(result) == 0:\n            raise ValueError(\"no matches found\")\n        return result\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.__dir__", "title": "__dir__", "text": "<pre><code>__dir__()\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def __dir__(self):\n    x = set(super().__dir__())\n    x |= {g for g in globals() if g.startswith(\"fig_\")}\n    return sorted(x)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.__getattr__", "title": "__getattr__", "text": "<pre><code>__getattr__(attr)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def __getattr__(self, attr):\n    if attr.startswith(\"fig_\"):\n        g = globals()\n        if attr in g:\n            return partial(g[attr], self)\n            # return lambda *a, **k: g[attr](self, *a, **k)\n    raise AttributeError(attr)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.apply", "title": "apply", "text": "<pre><code>apply(\n    func: Callable,\n    axis: int | Literal[\"index\", \"columns\", \"rows\"] = 0,\n    warn_if_missing: bool = False,\n) -&gt; DataFrame | Series\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def apply(\n    self,\n    func: Callable,\n    axis: int | Literal[\"index\", \"columns\", \"rows\"] = 0,\n    warn_if_missing: bool = False,\n) -&gt; pd.DataFrame | pd.Series:\n    data = {}\n    for k, v in self.items():\n        if v is not None:\n            data[k] = func(v)\n        else:\n            if warn_if_missing:\n                warnings.warn(f\"no data found for {k!r}\", stacklevel=2)\n    try:\n        return pd.concat(data, axis=axis, names=[\"source\"])\n    except TypeError:\n        return pd.Series(data).rename_axis(index=\"source\")\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.subset", "title": "subset", "text": "<pre><code>subset(keys=None, *, regex: str = None) -&gt; Self\n</code></pre> <p>Subset the contrast to only include the specified keys.</p> <p>Parameters:</p> <ul> <li> <code>keys</code>               (<code>str or list of str</code>, default:                   <code>None</code> )           \u2013            <p>The keys to include in the subset. If None, use the <code>regex</code> filter.</p> </li> <li> <code>regex</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>A regular expression to filter the keys. If None, use the <code>keys</code> filter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Contrast</code>           \u2013            </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>def subset(self, keys=None, *, regex: str = None) -&gt; Self:\n    \"\"\"Subset the contrast to only include the specified keys.\n\n    Parameters\n    ----------\n    keys : str or list of str, optional\n        The keys to include in the subset. If None, use the `regex` filter.\n    regex : str, optional\n        A regular expression to filter the keys. If None, use the `keys` filter.\n\n    Returns\n    -------\n    Contrast\n    \"\"\"\n    if keys is not None and regex is not None:\n        raise ValueError(\"cannot use both keys and regex\")\n    if keys is not None:\n        if isinstance(keys, str):\n            keys = [keys]\n        if not isinstance(keys, list | tuple):\n            raise TypeError(\"keys must be a string or a list of strings\")\n        result = type(self)({key: self[key] for key in keys if key in self})\n    else:\n        import re\n\n        matches = []\n        for k in self.keys():\n            if re.match(regex, k):\n                matches.append(k)\n        result = type(self)({k: self[k] for k in matches})\n    if len(result) == 0:\n        raise ValueError(\"no matches found\")\n    return result\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.write_report", "title": "write_report", "text": "<pre><code>write_report(filename: PathLike, **kwargs) -&gt; Path\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def write_report(self, filename: PathLike, **kwargs) -&gt; pathlib.Path:\n    from passengersim.reporting.contrast import to_html\n\n    return to_html(self, filename, **kwargs)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.MultiContrast", "title": "MultiContrast", "text": "<p>               Bases: <code>dict</code></p> Source code in <code>passengersim/contrast.py</code> <pre><code>class MultiContrast(dict):\n    def __getattr__(self, attr):\n        if attr.startswith(\"fig_\"):\n            g = globals()\n            if attr in g:\n                alter_defaults = {}\n                if attr in [\n                    \"fig_carrier_revenues\",\n                    \"fig_carrier_yields\",\n                    \"fig_carrier_total_bookings\",\n                    \"fig_carrier_load_factors\",\n                ]:\n                    alter_defaults[\"width\"] = 300\n\n                def fig_func(*args, **kwargs):\n                    figs = {}\n                    kwargs.update(alter_defaults)\n                    report = kwargs.pop(\"report\", None)\n                    trace = kwargs.pop(\"trace\", None)\n                    if trace:\n                        raise NotImplementedError(\"trace not implemented\")\n                    for k, v in self.items():\n                        if v is not None:\n                            figs[k] = partial(g[attr], v)(*args, **kwargs)\n                    fig, title = self._hconcat(figs)\n                    if report:\n                        report.add_figure(title=title, fig=fig)\n                    return fig\n\n                return fig_func\n        raise AttributeError(attr)\n\n    def __dir__(self):\n        x = set(super().__dir__())\n        x |= {g for g in globals() if g.startswith(\"fig_\")}\n        return sorted(x)\n\n    @staticmethod\n    def _hconcat(charts: dict[str, alt.Chart]) -&gt; tuple[alt.HConcatChart, str]:\n        if not charts:\n            raise ValueError(\"no charts to concatenate\")\n        queue = []\n        title = \"\"\n        for k, c in charts.items():\n            if c is None:\n                warnings.warn(f\"no data found for {k!r}\", stacklevel=2)\n                continue\n            config = c._kwds.get(\"config\", alt.Undefined)\n            c._kwds[\"config\"] = alt.Undefined\n            title = c._kwds.get(\"title\", \"\")\n            c._kwds[\"title\"] = f\"{k} {title}\"\n            queue.append(c)\n        if not queue:\n            raise ValueError(\"no charts to concatenate\")\n        result = alt.hconcat(*queue)\n        result._kwds[\"config\"] = config\n        return result, title\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.MultiContrast.__dir__", "title": "__dir__", "text": "<pre><code>__dir__()\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def __dir__(self):\n    x = set(super().__dir__())\n    x |= {g for g in globals() if g.startswith(\"fig_\")}\n    return sorted(x)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.MultiContrast.__getattr__", "title": "__getattr__", "text": "<pre><code>__getattr__(attr)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def __getattr__(self, attr):\n    if attr.startswith(\"fig_\"):\n        g = globals()\n        if attr in g:\n            alter_defaults = {}\n            if attr in [\n                \"fig_carrier_revenues\",\n                \"fig_carrier_yields\",\n                \"fig_carrier_total_bookings\",\n                \"fig_carrier_load_factors\",\n            ]:\n                alter_defaults[\"width\"] = 300\n\n            def fig_func(*args, **kwargs):\n                figs = {}\n                kwargs.update(alter_defaults)\n                report = kwargs.pop(\"report\", None)\n                trace = kwargs.pop(\"trace\", None)\n                if trace:\n                    raise NotImplementedError(\"trace not implemented\")\n                for k, v in self.items():\n                    if v is not None:\n                        figs[k] = partial(g[attr], v)(*args, **kwargs)\n                fig, title = self._hconcat(figs)\n                if report:\n                    report.add_figure(title=title, fig=fig)\n                return fig\n\n            return fig_func\n    raise AttributeError(attr)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_bid_price_history", "title": "fig_bid_price_history", "text": "<pre><code>fig_bid_price_history(\n    summaries,\n    *,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df: bool = False,\n    title: str | None = \"Bid Price History\",\n    also_df: bool = False,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_bid_price_history(\n    summaries,\n    *,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df: bool = False,\n    title: str | None = \"Bid Price History\",\n    also_df: bool = False,\n):\n    if cap is None:\n        bp_mean = \"bid_price_mean\"\n    elif cap == \"some\":\n        bp_mean = \"some_cap_bid_price_mean\"\n    elif cap == \"zero\":\n        bp_mean = \"zero_cap_bid_price_mean\"\n    else:\n        raise ValueError(f\"cap={cap!r} not in ['some', 'zero', None]\")\n\n    if not isinstance(by_carrier, str) and show_stdev:\n        raise NotImplementedError(\n            \"contrast.fig_bid_price_history with show_stdev requires looking at a single carrier (set `by_carrier`)\"\n        )\n    df = _assemble(\n        summaries,\n        \"bid_price_history\",\n        by_carrier=by_carrier,\n        show_stdev=show_stdev,\n        cap=cap,\n    )\n    if raw_df:\n        return df\n\n    line_encoding = dict(\n        x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n        y=alt.Y(bp_mean, title=\"Bid Price\"),\n        color=\"source:N\",\n    )\n    chart = alt.Chart(df)\n    fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n    if show_stdev:\n        area_encoding = dict(\n            x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"),\n            y2=alt.Y2(\"bid_price_upper:Q\", title=\"Bid Price\"),\n            color=\"source:N\",\n        )\n        bound = chart.mark_area(\n            opacity=0.1,\n            interpolate=\"step-before\",\n        ).encode(**area_encoding)\n        bound_line = chart.mark_line(opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\").encode(\n            x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            color=\"source:N\",\n        )\n        top_line = bound_line.encode(y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"))\n        bottom_line = bound_line.encode(y=alt.Y(\"bid_price_upper:Q\", title=\"Bid Price\"))\n        fig = fig + bound + top_line + bottom_line\n    if not isinstance(by_carrier, str):\n        fig = fig.properties(height=125, width=225).facet(facet=\"carrier:N\", columns=2)\n        if title:\n            fig = fig.properties(title=title)\n    else:\n        if title:\n            title = f\"{title} ({by_carrier})\"\n            fig = fig.properties(title=title)\n    if also_df:\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_bookings_by_timeframe", "title": "fig_bookings_by_timeframe", "text": "<pre><code>fig_bookings_by_timeframe(\n    summaries: dict[str, SummaryTables],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    *,\n    by_segment: str | None = None,\n    raw_df=False,\n    source_labels: bool = False,\n    ratio: str | bool = False,\n    also_df: bool = False,\n) -&gt; Chart | DataFrame\n</code></pre> <p>Generate a figure contrasting bookings by timeframe for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            <p>One or more SummaryTables to compare. The keys of this dictionary are the text names used to label the \"source\" for each set of data in the figure.</p> </li> <li> <code>by_carrier</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>Whether to differentiate carriers by colors (the default) or give the name of a particular carrier as a string to filter the results shown in the figure to only that one carrier.</p> </li> <li> <code>by_class</code>               (<code>bool or str</code>, default:                   <code>False</code> )           \u2013            <p>Whether to differentiate booking class by colors (the default) or give the name of a particular booking class as a string to filter the results shown in the figure to only that one booking class.</p> </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Set to true to return the raw dataframe used to generate the figure, instead of the figure itself.</p> </li> <li> <code>source_labels</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Write source labels above the columns of the figure. Source labels are also available as tool tips, but if the figure is being shared as an image without tooltips, the source labels may make it easier to interpret.</p> </li> <li> <code>ratio</code>               (<code>str or bool</code>, default:                   <code>False</code> )           \u2013            <p>Compute ratios against a reference point and display them in tooltips.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>report</code>               (<code>Reporter</code>)           \u2013            <p>Giving a reporter for this keyword only argument allow you to automatically append this figure to the report (in addition to returning it for display or other processing).</p> </li> <li> <code>trace</code>               (<code>ExcelWriter or (ExcelWriter, str)</code>)           \u2013            <p>Write the raw dataframe backing this figure to the Excel workbook.</p> </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_bookings_by_timeframe(\n    summaries: dict[str, SummaryTables],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    *,\n    by_segment: str | None = None,\n    raw_df=False,\n    source_labels: bool = False,\n    ratio: str | bool = False,\n    also_df: bool = False,\n) -&gt; alt.Chart | pd.DataFrame:\n    \"\"\"\n    Generate a figure contrasting bookings by timeframe for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n        One or more SummaryTables to compare. The keys of this dictionary are the\n        text names used to label the \"source\" for each set of data in the figure.\n    by_carrier : bool or str, default True\n        Whether to differentiate carriers by colors (the default) or give the name\n        of a particular carrier as a string to filter the results shown in the\n        figure to only that one carrier.\n    by_class : bool or str, default False\n        Whether to differentiate booking class by colors (the default) or give the\n        name of a particular booking class as a string to filter the results shown\n        in the figure to only that one booking class.\n    raw_df : bool, default False\n        Set to true to return the raw dataframe used to generate the figure, instead\n        of the figure itself.\n    source_labels : bool, default False\n        Write source labels above the columns of the figure. Source labels are also\n        available as tool tips, but if the figure is being shared as an image without\n        tooltips, the source labels may make it easier to interpret.\n    ratio : str or bool, default False\n        Compute ratios against a reference point and display them in tooltips.\n\n    Other Parameters\n    ----------------\n    report : xmle.Reporter, optional\n        Giving a reporter for this keyword only argument allow you to automatically\n        append this figure to the report (in addition to returning it for display\n        or other processing).\n    trace : pd.ExcelWriter or (pd.ExcelWriter, str), optional\n        Write the raw dataframe backing this figure to the Excel workbook.\n    \"\"\"\n    if by_carrier is True and by_class is True:\n        raise NotImplementedError(\"comparing by both class and carrier is messy\")\n    df = _assemble(summaries, \"bookings_by_timeframe\", by_carrier=by_carrier, by_class=by_class)\n    source_order = list(summaries.keys())\n\n    title = \"Bookings by Timeframe\"\n    if by_class is True:\n        title = \"Bookings by Timeframe and Booking Class\"\n    title_annot = []\n    if isinstance(by_carrier, str):\n        title_annot.append(by_carrier)\n    if isinstance(by_class, str):\n        title_annot.append(f\"Class {by_class}\")\n    if by_segment:\n        title_annot.append(by_segment)\n    if title_annot:\n        title = f\"{title} ({', '.join(title_annot)})\"\n\n    against = source_order[0]\n    ratio_tooltips = ()\n    if ratio:\n        if isinstance(ratio, str):\n            against = ratio\n        idx = list({\"source\", \"carrier\", \"segment\", \"days_prior\", \"booking_class\"} &amp; set(df.columns))\n        df_ = df.set_index(idx)\n        ratios = df_.div(df_.query(f\"source == '{against}'\").droplevel(\"source\")) - 1.0\n        ratios.columns = [\"ratio\"]\n        df = df.join(ratios, on=idx)\n        ratio_tooltips = (alt.Tooltip(\"ratio:Q\", title=f\"vs {against}\", format=\".3%\"),)\n\n    if by_segment:\n        df = df[df[\"segment\"] == by_segment]\n\n    if raw_df:\n        df.attrs[\"title\"] = title\n        return df\n\n    if by_class:\n        if isinstance(by_class, str):\n            color = alt.Color(\"source:N\", title=\"Source\", sort=source_order).title(\"Source\")\n            tooltips = ()\n        else:\n            color = alt.Color(\"booking_class:N\").title(\"Booking Class\")\n            tooltips = (alt.Tooltip(\"booking_class\", title=\"Booking Class\"),)\n        chart = alt.Chart(df.sort_values(\"source\", ascending=False))\n        chart_1 = chart.mark_bar().encode(\n            color=color,\n            x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n            y=alt.Y(\"bookings\", stack=True),\n            tooltip=[\n                alt.Tooltip(\"source:N\", title=\"Source\"),\n                alt.Tooltip(\"segment\", title=\"Passenger Segment\"),\n                *tooltips,\n                alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                alt.Tooltip(\"bookings\", format=\".2f\"),\n                *ratio_tooltips,\n            ],\n        )\n        chart_2 = chart.mark_text(\n            color=\"#616161\",\n            yOffset=-2,\n            angle=270,\n            fontSize=8,\n            baseline=\"middle\",\n            align=\"left\",\n        ).encode(\n            text=alt.Text(\"source:N\", title=\"Source\"),\n            x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n            # shape=alt.Shape(\"source:N\", title=\"Source\", sort=source_order),\n            y=alt.Y(\"sum(bookings)\", title=None),\n        )\n        fig = (\n            ((chart_1 + chart_2) if source_labels else chart_1)\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"segment:N\", title=\"Passenger Segment\"),\n                title=title,\n            )\n        )\n    elif by_carrier is True:\n        fig = (\n            alt.Chart(df.sort_values(\"source\", ascending=False))\n            .mark_bar()\n            .encode(\n                color=alt.Color(\"carrier:N\").title(\"Carrier\"),\n                x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n                xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n                y=alt.Y(\"bookings\", stack=True),\n                tooltip=[\n                    alt.Tooltip(\"source:N\", title=\"Source\"),\n                    alt.Tooltip(\"segment\", title=\"Passenger Segment\"),\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                    alt.Tooltip(\"bookings\", format=\".2f\"),\n                    *ratio_tooltips,\n                ],\n            )\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"segment:N\", title=\"Passenger Segment\"),\n                title=title,\n            )\n        )\n    else:\n        fig = (\n            alt.Chart(df.sort_values(\"source\", ascending=False), title=title)\n            .mark_line()\n            .encode(\n                color=alt.Color(\"source:N\", title=\"Source\", sort=source_order),\n                x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n                y=\"bookings\",\n                strokeDash=alt.StrokeDash(\"segment\").title(\"Passenger Segment\"),\n                strokeWidth=alt.StrokeWidth(\"source:N\", title=\"Source\", sort=source_order),\n                tooltip=[\n                    alt.Tooltip(\"source:N\", title=\"Source\"),\n                    alt.Tooltip(\"segment\", title=\"Passenger Segment\"),\n                    alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                    alt.Tooltip(\"bookings\", format=\".2f\"),\n                    *ratio_tooltips,\n                ],\n            )\n            .properties(\n                width=500,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n    if also_df:\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_load_factors", "title": "fig_carrier_load_factors", "text": "<pre><code>fig_carrier_load_factors(\n    summaries: dict[str, SummaryTables],\n    raw_df: bool = False,\n    load_measure: Literal[\n        \"sys_lf\", \"avg_leg_lf\"\n    ] = \"sys_lf\",\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n    also_df: bool = False,\n    title: str | None = \"_default_\",\n)\n</code></pre> <p>Generate a figure contrasting carrier load factors for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>load_measure</code>               (<code>(sys_lf, avg_leg_lf)</code>, default:                   <code>'sys_lf'</code> )           \u2013            </li> <li> <code>orient</code>               (<code>(h, v)</code>, default:                   <code>'h'</code> )           \u2013            </li> <li> <code>ratio</code>               (<code>bool or str</code>, default:                   <code>\"all\"</code> )           \u2013            <p>Add tooltip(s) giving the percentage change of each carrier's load factor to the load factor of the same carrier in the other summaries.  Can be the key giving a specific summary to compare against, or 'all' to compare against all other summaries.</p> </li> <li> <code>title</code>               (<code>str</code>, default:                   <code>'_default_'</code> )           \u2013            <p>Title of the figure. Set to <code>None</code> for no title, otherwise a default title is used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_load_factors(\n    summaries: dict[str, SummaryTables],\n    raw_df: bool = False,\n    load_measure: Literal[\"sys_lf\", \"avg_leg_lf\"] = \"sys_lf\",\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n    also_df: bool = False,\n    title: str | None = \"_default_\",\n):\n    \"\"\"\n    Generate a figure contrasting carrier load factors for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n    raw_df : bool, default False\n    load_measure : {'sys_lf', 'avg_leg_lf'}, default 'sys_lf'\n    orient : {'h', 'v'}, default 'h'\n    ratio : bool or str, default \"all\"\n        Add tooltip(s) giving the percentage change of each carrier's load factor\n        to the load factor of the same carrier in the other summaries.  Can be\n        the key giving a specific summary to compare against, or 'all' to\n        compare against all other summaries.\n    title : str, optional\n        Title of the figure. Set to `None` for no title, otherwise a default\n        title is used.\n\n    Returns\n    -------\n    alt.Chart or pd.DataFrame\n    \"\"\"\n    measure_name = {\n        \"sys_lf\": \"System Load Factor\",\n        \"avg_leg_lf\": \"Leg Load factor\",\n    }.get(load_measure, \"Load Factor\")\n    if title == \"_default_\":\n        title = f\"Carrier {measure_name}s\"\n    df = _assemble(summaries, \"carrier_load_factors\", load_measure=load_measure)\n    source_order = list(summaries.keys())\n    if raw_df:\n        if title:\n            df.attrs[\"title\"] = title\n        return df\n    fig = _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=load_measure,\n        measure_name=measure_name,\n        measure_format=\".2f\",\n        orient=orient,\n        title=title,\n        ratio=ratio,\n        ratio_all=(ratio == \"all\"),\n        width=width,\n    )\n    if also_df:\n        if title:\n            df.attrs[\"title\"] = title\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_local_share", "title": "fig_carrier_local_share", "text": "<pre><code>fig_carrier_local_share(\n    summaries,\n    load_measure: Literal[\n        \"bookings\", \"leg_pax\"\n    ] = \"bookings\",\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n    also_df: bool = False,\n)\n</code></pre> <p>Generate a figure contrasting carrier local shares for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>orient</code>               (<code>(h, v)</code>, default:                   <code>'h'</code> )           \u2013            </li> <li> <code>ratio</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>Add tooltip(s) giving the percentage change of each carrier's local share to the local share of the same carrier in the other summaries.  Can be the key giving a specific summary to compare against, or 'all' to compare against all other summaries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_local_share(\n    summaries,\n    load_measure: \"Literal['bookings', 'leg_pax']\" = \"bookings\",\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n    also_df: bool = False,\n):\n    \"\"\"\n    Generate a figure contrasting carrier local shares for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n    raw_df : bool, default False\n    orient : {'h', 'v'}, default 'h'\n    ratio : bool or str, default True\n        Add tooltip(s) giving the percentage change of each carrier's local share\n        to the local share of the same carrier in the other summaries.  Can be\n        the key giving a specific summary to compare against, or 'all' to\n        compare against all other summaries.\n\n    Returns\n    -------\n    alt.Chart or pd.DataFrame\n    \"\"\"\n    measure_name = \"Local Percent of Bookings\" if load_measure == \"bookings\" else \"Local Percent of Leg Passengers\"\n    m = \"local_pct_bookings\" if load_measure == \"bookings\" else \"local_pct_leg_pax\"\n    df = _assemble(summaries, \"carrier_local_share\", load_measure=load_measure)\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Local Share\"\n        return df\n    fig = _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=m,\n        measure_name=measure_name,\n        measure_format=\".2f\",\n        orient=orient,\n        title=f\"Carrier {measure_name}\",\n        ratio=ratio,\n        ratio_all=(ratio == \"all\"),\n        width=width,\n    )\n    if also_df:\n        df.attrs[\"title\"] = \"Carrier Local Share\"\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_rasm", "title": "fig_carrier_rasm", "text": "<pre><code>fig_carrier_rasm(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n    also_df: bool = False,\n)\n</code></pre> <p>Generate a figure contrasting carrier RASM for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>orient</code>               (<code>(h, v)</code>, default:                   <code>'h'</code> )           \u2013            </li> <li> <code>ratio</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>Add tooltip(s) giving the percentage change of each carrier's yield to the yield of the same carrier in the other summaries.  Can be the key giving a specific summary to compare against, or 'all' to compare against all other summaries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_rasm(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n    also_df: bool = False,\n):\n    \"\"\"\n    Generate a figure contrasting carrier RASM for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n    raw_df : bool, default False\n    orient : {'h', 'v'}, default 'h'\n    ratio : bool or str, default True\n        Add tooltip(s) giving the percentage change of each carrier's yield\n        to the yield of the same carrier in the other summaries.  Can be\n        the key giving a specific summary to compare against, or 'all' to\n        compare against all other summaries.\n\n    Returns\n    -------\n    alt.Chart or pd.DataFrame\n    \"\"\"\n    df = _assemble(summaries, \"carrier_rasm\")\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier RASM\"\n        return df\n    fig = _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=\"rasm\",\n        measure_name=\"Revenue per Available Seat Mile\",\n        measure_format=\"$.4f\",\n        orient=orient,\n        title=\"Carrier Revenue per Available Seat Mile (RASM)\",\n        ratio=ratio,\n        ratio_all=(ratio == \"all\"),\n        width=width,\n    )\n    if also_df:\n        df.attrs[\"title\"] = \"Carrier RASM\"\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_revenues", "title": "fig_carrier_revenues", "text": "<pre><code>fig_carrier_revenues(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n    also_df: bool = False,\n)\n</code></pre> <p>Generate a figure contrasting carrier revenues for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return only the raw data used to generate the figure.</p> </li> <li> <code>orient</code>               (<code>(h, v)</code>, default:                   <code>'h'</code> )           \u2013            </li> <li> <code>ratio</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>Add tooltip(s) giving the percentage change of each carrier's revenue to the revenue of the same carrier in the other summaries.  Can be the key giving a specific summary to compare against, or 'all' to compare against all other summaries.</p> </li> <li> <code>also_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return the raw data used to generate the figure in addition to the figure itself.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame or tuple[Chart, DataFrame]</code>           \u2013            </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_revenues(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n    also_df: bool = False,\n):\n    \"\"\"\n    Generate a figure contrasting carrier revenues for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n    raw_df : bool, default False\n        Return only the raw data used to generate the figure.\n    orient : {'h', 'v'}, default 'h'\n    ratio : bool or str, default True\n        Add tooltip(s) giving the percentage change of each carrier's revenue\n        to the revenue of the same carrier in the other summaries.  Can be\n        the key giving a specific summary to compare against, or 'all' to\n        compare against all other summaries.\n    also_df : bool, default False\n        Return the raw data used to generate the figure in addition to the\n        figure itself.\n\n    Returns\n    -------\n    alt.Chart or pd.DataFrame or tuple[alt.Chart, pd.DataFrame]\n    \"\"\"\n    df = _assemble(summaries, \"carrier_revenues\")\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Revenues\"\n        return df\n    fig = _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=\"avg_rev\",\n        measure_name=\"Revenue ($)\",\n        measure_format=\"$.4s\",\n        orient=orient,\n        title=\"Carrier Revenues\",\n        ratio=ratio,\n        ratio_all=(ratio == \"all\"),\n        width=width,\n    )\n    if also_df:\n        df.attrs[\"title\"] = \"Carrier Revenues\"\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_total_bookings", "title": "fig_carrier_total_bookings", "text": "<pre><code>fig_carrier_total_bookings(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n    also_df: bool = False,\n)\n</code></pre> <p>Generate a figure contrasting carrier total bookings for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>orient</code>               (<code>(h, v)</code>, default:                   <code>'h'</code> )           \u2013            </li> <li> <code>ratio</code>               (<code>bool or str</code>, default:                   <code>\"all\"</code> )           \u2013            <p>Add tooltip(s) giving the percentage change of each carrier's bookings to the bookings of the same carrier in the other summaries.  Can be the key giving a specific summary to compare against, or 'all' to compare against all other summaries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_total_bookings(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n    also_df: bool = False,\n):\n    \"\"\"\n    Generate a figure contrasting carrier total bookings for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n    raw_df : bool, default False\n    orient : {'h', 'v'}, default 'h'\n    ratio : bool or str, default \"all\"\n        Add tooltip(s) giving the percentage change of each carrier's bookings\n        to the bookings of the same carrier in the other summaries.  Can be\n        the key giving a specific summary to compare against, or 'all' to\n        compare against all other summaries.\n\n    Returns\n    -------\n    alt.Chart or pd.DataFrame\n    \"\"\"\n\n    df = _assemble(summaries, \"carrier_total_bookings\")\n    # correct for variable name differences; the \"avg_sold\" column\n    # is called \"sold\" in some older summaries\n    if \"sold\" in df.columns:\n        if \"avg_sold\" in df.columns:\n            df[\"avg_sold\"] = df[\"avg_sold\"].fillna(df[\"sold\"])\n            df = df.drop(columns=\"sold\")\n        else:\n            df = df.rename(columns={\"sold\": \"avg_sold\"})\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Total Bookings\"\n        return df\n    fig = _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=\"avg_sold\",\n        measure_name=\"Bookings\",\n        measure_format=\".4s\",\n        orient=orient,\n        title=\"Carrier Total Bookings\",\n        ratio=ratio,\n        ratio_all=(ratio == \"all\"),\n        width=width,\n    )\n    if also_df:\n        df.attrs[\"title\"] = \"Carrier Total Bookings\"\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_yields", "title": "fig_carrier_yields", "text": "<pre><code>fig_carrier_yields(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n    also_df: bool = False,\n)\n</code></pre> <p>Generate a figure contrasting carrier yields for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>orient</code>               (<code>(h, v)</code>, default:                   <code>'h'</code> )           \u2013            </li> <li> <code>ratio</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>Add tooltip(s) giving the percentage change of each carrier's yield to the yield of the same carrier in the other summaries.  Can be the key giving a specific summary to compare against, or 'all' to compare against all other summaries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_yields(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = \"all\",\n    *,\n    width: int = 500,\n    also_df: bool = False,\n):\n    \"\"\"\n    Generate a figure contrasting carrier yields for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n    raw_df : bool, default False\n    orient : {'h', 'v'}, default 'h'\n    ratio : bool or str, default True\n        Add tooltip(s) giving the percentage change of each carrier's yield\n        to the yield of the same carrier in the other summaries.  Can be\n        the key giving a specific summary to compare against, or 'all' to\n        compare against all other summaries.\n\n    Returns\n    -------\n    alt.Chart or pd.DataFrame\n    \"\"\"\n\n    df = _assemble(summaries, \"carrier_yields\")\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Yields\"\n        return df\n    fig = _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=\"yield\",\n        measure_name=\"Yield ($)\",\n        measure_format=\"$.4f\",\n        orient=orient,\n        title=\"Carrier Yields\",\n        ratio=ratio,\n        ratio_all=(ratio == \"all\"),\n        width=width,\n    )\n    if also_df:\n        df.attrs[\"title\"] = \"Carrier Yields\"\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_cp_segmentation", "title": "fig_cp_segmentation", "text": "<pre><code>fig_cp_segmentation(\n    summaries: Contrast,\n    *,\n    raw_df: bool = False,\n    title: str | None = \"Continuous Price Segmentation\",\n    also_df: bool = False,\n    height: int = 600,\n    width: int = 300,\n) -&gt; Chart | tuple[Chart, DataFrame] | DataFrame\n</code></pre> <p>Generate a figure contrasting continuous price segmentation for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            <p>A dictionary of summary tables for different runs.</p> </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return the raw data used to generate the figure.</p> </li> <li> <code>title</code>               (<code>str</code>, default:                   <code>\"Continuous Price Segmentation\"</code> )           \u2013            <p>The title of the figure.</p> </li> <li> <code>also_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return the raw data used to generate the figure in addition to the figure itself.</p> </li> <li> <code>height</code>               (<code>int</code>, default:                   <code>600</code> )           \u2013            <p>The height of each facet panel of the figure, in pixels.</p> </li> <li> <code>width</code>               (<code>int</code>, default:                   <code>300</code> )           \u2013            <p>The width of each facet panel of the figure, in pixels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or tuple[Chart, DataFrame] or DataFrame</code>           \u2013            <p>The generated Altair chart or the raw data used to generate the figure.</p> </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_cp_segmentation(\n    summaries: Contrast,\n    *,\n    raw_df: bool = False,\n    title: str | None = \"Continuous Price Segmentation\",\n    also_df: bool = False,\n    height: int = 600,\n    width: int = 300,\n) -&gt; alt.Chart | tuple[alt.Chart, pd.DataFrame] | pd.DataFrame:\n    \"\"\"\n    Generate a figure contrasting continuous price segmentation for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n        A dictionary of summary tables for different runs.\n    raw_df : bool, default False\n        If True, return the raw data used to generate the figure.\n    title : str, default \"Continuous Price Segmentation\"\n        The title of the figure.\n    also_df : bool, default False\n        If True, return the raw data used to generate the figure in addition to the figure itself.\n    height : int, default 600\n        The height of each facet panel of the figure, in pixels.\n    width : int, default 300\n        The width of each facet panel of the figure, in pixels.\n\n    Returns\n    -------\n    alt.Chart or tuple[alt.Chart, pd.DataFrame] or pd.DataFrame\n        The generated Altair chart or the raw data used to generate the figure.\n    \"\"\"\n    import altair as alt\n\n    df = pd.concat(\n        {k: s.cp_segmentation for k, s in summaries.items() if s.cp_segmentation is not None}, names=[\"source\"]\n    )\n    source_order = list(summaries.keys())\n\n    df = df.reset_index()[[\"source\", \"carrier\", \"booking_class\", \"sold\", \"cp_sold\"]]\n    if raw_df:\n        return df\n    df[\"Zero\"] = 0\n\n    base_chart = alt.Chart(df)\n\n    # Add a solid border to the \"Continuous Priced\" bars using stroke/strokeWidth\n    chart = (\n        base_chart.mark_bar()\n        .encode(\n            y=alt.Y(\"booking_class:N\", sort=None, title=\"Booking Class\"),\n            x=alt.X(\"sold:Q\", title=\"Total Sold\", stack=False, axis=alt.Axis()),\n            color=alt.Color(\"source:N\", title=\"Source\"),\n            yOffset=alt.YOffset(\"source:N\", title=\"Source\", sort=source_order),\n            tooltip=[\n                alt.Tooltip(\"source:N\", title=\"Source\"),\n                alt.Tooltip(\"carrier:N\", title=\"Carrier\"),\n                alt.Tooltip(\"booking_class:N\", title=\"Booking Class\"),\n                alt.Tooltip(\"sold:Q\", title=\"Total Sold\", format=\",\"),\n                alt.Tooltip(\"cp_sold:Q\", title=\"Continuous Priced Sold\", format=\",\"),\n            ],\n        )\n        .properties(width=width, height=height)\n    )\n\n    chart_cp = (\n        base_chart.transform_filter(\n            alt.datum.cp_sold &gt; 0  # Only show nonzero counts for cp_sold\n        )\n        .mark_errorbar(extent=\"ci\", ticks=True)\n        .encode(\n            y=alt.Y(\"booking_class:N\", sort=source_order, title=\"Booking Class\"),\n            x=alt.X(\"cp_sold:Q\", title=\"Continuous Priced Sold\"),\n            x2=alt.X2(\"Zero:Q\", title=\"Zero\"),\n            color=alt.value(\"black\"),\n            yOffset=alt.YOffset(\"source:N\", title=\"Source\", sort=source_order),\n            tooltip=[\n                alt.Tooltip(\"source:N\", title=\"Source\"),\n                alt.Tooltip(\"carrier:N\", title=\"Carrier\"),\n                alt.Tooltip(\"booking_class:N\", title=\"Booking Class\"),\n                alt.Tooltip(\"sold:Q\", title=\"Total Sold\", format=\",\"),\n                alt.Tooltip(\"cp_sold:Q\", title=\"Continuous Priced Sold\", format=\",\"),\n            ],\n            strokeWidth=alt.value(2),  # Set stroke width for the error bars\n        )\n        .properties(width=width, height=height)\n    )\n\n    fig = (chart + chart_cp).facet(\n        facet=alt.Facet(\"carrier:N\", title=\"Carrier\"),\n    )\n\n    if title:\n        fig = fig.properties(title=title)\n\n    if also_df:\n        return fig, df\n    else:\n        return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_demand_to_come", "title": "fig_demand_to_come", "text": "<pre><code>fig_demand_to_come(\n    summaries: Contrast,\n    func: Literal[\"mean\", \"std\"]\n    | list[Literal[\"mean\", \"std\"]] = \"mean\",\n    *,\n    raw_df=False,\n    title: str | None = \"Demand to Come\",\n    also_df: bool = False,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_demand_to_come(\n    summaries: Contrast,\n    func: Literal[\"mean\", \"std\"] | list[Literal[\"mean\", \"std\"]] = \"mean\",\n    *,\n    raw_df=False,\n    title: str | None = \"Demand to Come\",\n    also_df: bool = False,\n):\n    def dtc_seg(s):\n        if s is None:\n            return pd.DataFrame(columns=[\"segment\"])\n        sum_on = []\n        if \"orig\" in s.index.names:\n            sum_on.append(\"orig\")\n        if \"dest\" in s.index.names:\n            sum_on.append(\"dest\")\n        if sum_on:\n            s = s.groupby(s.index.names.difference(sum_on)).sum()\n        return s\n\n    def get_values(s, which=\"mean\"):\n        if isinstance(s, SummaryTables):\n            result = getattr(s, \"demand_to_come_summary\", None)\n            if result is None:\n                result = dtc_seg(s.demand_to_come).groupby(\"segment\", observed=False)\n                result = result.mean() if which == \"mean\" else result.std()\n                result = result.stack()\n                return result\n            else:\n                if which == \"mean\":\n                    return result[\"mean_future_demand\"]\n                elif which == \"std\":\n                    return result[\"stdev_future_demand\"]\n                else:\n                    raise ValueError(f\"which must be in [mean, std] not {which}\")\n        elif isinstance(s, SimTabDemandToCome):\n            result = s.demand_to_come_summary\n            if which == \"mean\":\n                return result[\"mean_future_demand\"]\n            elif which == \"std\":\n                return result[\"stdev_future_demand\"]\n            else:\n                raise ValueError(f\"which must be in [mean, std] not {which}\")\n\n    if isinstance(func, list):\n        if raw_df:\n            raise NotImplementedError\n        fig = fig_demand_to_come(summaries, func[0], raw_df=raw_df, title=None)\n        for f in func[1:]:\n            fig |= fig_demand_to_come(summaries, f, raw_df=raw_df, title=None)\n        if title:\n            fig = fig.properties(title=title)\n        return fig\n\n    if func == \"mean\":\n        y_title = \"Mean Demand to Come\"\n        demand_to_come_by_segment = summaries.apply(lambda s: get_values(s, \"mean\"), axis=1, warn_if_missing=True)\n        demand_to_come_by_segment.index.names = [\"segment\", \"days_prior\"]\n        df = demand_to_come_by_segment.stack().rename(\"dtc\").reset_index()\n    elif func == \"std\":\n        y_title = \"Std Dev Demand to Come\"\n        demand_to_come_by_segment = summaries.apply(lambda s: get_values(s, \"std\"), axis=1, warn_if_missing=True)\n        demand_to_come_by_segment.index.names = [\"segment\", \"days_prior\"]\n        df = demand_to_come_by_segment.stack().rename(\"dtc\").reset_index()\n    else:\n        raise ValueError(f\"func must be in [mean, std] not {func}\")\n    if raw_df:\n        return df\n    fig = (\n        alt.Chart(df)\n        .mark_line()\n        .encode(\n            x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            y=alt.Y(\"dtc:Q\").title(y_title),\n            color=\"segment:N\",\n            strokeDash=\"source:N\",\n        )\n    )\n    if title:\n        fig = fig.properties(title=title)\n    if also_df:\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_displacement_history", "title": "fig_displacement_history", "text": "<pre><code>fig_displacement_history(\n    summaries,\n    *,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    raw_df: bool = False,\n    title: str | None = \"Displacement Cost History\",\n    also_df: bool = False,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_displacement_history(\n    summaries,\n    *,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    raw_df: bool = False,\n    title: str | None = \"Displacement Cost History\",\n    also_df: bool = False,\n):\n    if not isinstance(by_carrier, str) and show_stdev:\n        raise NotImplementedError(\n            \"contrast.fig_displacement_history with show_stdev requires looking at a single carrier (set `by_carrier`)\"\n        )\n    df = _assemble(\n        summaries,\n        \"displacement_history\",\n        by_carrier=by_carrier,\n        show_stdev=show_stdev,\n    )\n    if raw_df:\n        return df\n\n    line_encoding = dict(\n        x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n        y=alt.Y(\"displacement_mean\", title=\"Displacement Cost\"),\n        color=\"source:N\",\n    )\n    chart = alt.Chart(df)\n    fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n    if show_stdev:\n        area_encoding = dict(\n            x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            y=alt.Y(\"displacement_lower:Q\", title=\"Displacement Cost\"),\n            y2=alt.Y2(\"displacement_upper:Q\", title=\"Displacement Cost\"),\n            color=\"source:N\",\n        )\n        bound = chart.mark_area(\n            opacity=0.1,\n            interpolate=\"step-before\",\n        ).encode(**area_encoding)\n        bound_line = chart.mark_line(opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\").encode(\n            x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            color=\"source:N\",\n        )\n        top_line = bound_line.encode(y=alt.Y(\"displacement_lower:Q\", title=\"Displacement Cost\"))\n        bottom_line = bound_line.encode(y=alt.Y(\"displacement_upper:Q\", title=\"Displacement Cost\"))\n        fig = fig + bound + top_line + bottom_line\n    if not isinstance(by_carrier, str):\n        fig = fig.properties(height=125, width=225).facet(facet=\"carrier:N\", columns=2)\n        if title:\n            fig = fig.properties(title=title)\n    else:\n        if title:\n            title = f\"{title} ({by_carrier})\"\n            fig = fig.properties(title=title)\n    if also_df:\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_fare_class_mix", "title": "fig_fare_class_mix", "text": "<pre><code>fig_fare_class_mix(\n    summaries,\n    *,\n    raw_df=False,\n    also_df: bool = False,\n    label_threshold: float = 0.06,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_fare_class_mix(summaries, *, raw_df=False, also_df: bool = False, label_threshold: float = 0.06):\n    df = _assemble(summaries, \"fare_class_mix\")\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Fare Class Mix\"\n        return df\n    import altair as alt\n\n    label_threshold_value = df.groupby([\"carrier\", \"source\"]).avg_sold.sum().max() * label_threshold\n    chart = alt.Chart(df).transform_calculate(\n        halfsold=\"datum.avg_sold / 2.0\",\n    )\n    bars = chart.mark_bar().encode(\n        x=alt.X(\"source:N\", title=\"Source\", sort=source_order),\n        y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n        color=\"booking_class\",\n        tooltip=[\n            \"source\",\n            \"booking_class\",\n            alt.Tooltip(\"avg_sold\", format=\".2f\"),\n        ],\n    )\n    text = chart.mark_text(dx=0, dy=3, color=\"white\", baseline=\"top\").encode(\n        x=alt.X(\"source:N\", title=\"Source\", sort=source_order),\n        y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n        text=alt.Text(\"avg_sold:Q\", format=\".2f\"),\n        opacity=alt.condition(\n            f\"datum.avg_sold &lt; {label_threshold_value:.3f}\",\n            alt.value(0),\n            alt.value(1),\n        ),\n        order=alt.Order(\"booking_class:N\", sort=\"descending\"),\n    )\n    fig = (\n        (bars + text)\n        .properties(\n            width=200,\n            height=300,\n        )\n        .facet(\n            column=alt.Column(\"carrier:N\", title=\"Carrier\"),\n            title=\"Carrier Fare Class Mix\",\n        )\n    )\n    if also_df:\n        df.attrs[\"title\"] = \"Carrier Fare Class Mix\"\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_leg_forecasts", "title": "fig_leg_forecasts", "text": "<pre><code>fig_leg_forecasts(\n    summaries,\n    raw_df=False,\n    by_leg_id=None,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"]\n    | list[Literal[\"mu\", \"sigma\"]] = \"mu\",\n    agg_booking_classes: bool = False,\n    also_df: bool = False,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_leg_forecasts(\n    summaries,\n    raw_df=False,\n    by_leg_id=None,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"] | list[Literal[\"mu\", \"sigma\"]] = \"mu\",\n    agg_booking_classes: bool = False,\n    also_df: bool = False,\n):\n    if isinstance(of, list):\n        if raw_df:\n            raise NotImplementedError\n        fig = fig_leg_forecasts(\n            summaries,\n            by_leg_id=by_leg_id,\n            by_class=by_class,\n            of=of[0],\n            agg_booking_classes=agg_booking_classes,\n        )\n        for of_ in of[1:]:\n            fig |= fig_leg_forecasts(\n                summaries,\n                by_leg_id=by_leg_id,\n                by_class=by_class,\n                of=of_,\n                agg_booking_classes=agg_booking_classes,\n            )\n        title = f\"Leg Forecasts {by_leg_id}\"\n        try:\n            if by_leg_id:\n                first_summary = next(iter(summaries.values()))\n                leg_def = first_summary.legs.loc[by_leg_id]\n                title += f\": {leg_def['carrier']} {leg_def['flt_no']}\"\n                title += f\" ({leg_def['orig']}-{leg_def['dest']})\"\n        except Exception:\n            raise\n        return fig.properties(title=title)\n    df = _assemble(summaries, \"leg_forecasts\", by_leg_id=by_leg_id, by_class=by_class, of=of)\n    color = \"booking_class:N\"\n    if isinstance(by_class, str):\n        color = \"source:N\"\n    if agg_booking_classes or not by_class:\n        color = \"source:N\"\n        if of == \"mu\":\n            df = df.groupby([\"source\", \"leg_id\", \"days_prior\"]).forecast_mean.sum().reset_index()\n        elif of == \"sigma\":\n\n            def sum_sigma(x):\n                return np.sqrt(sum(x**2))\n\n            df = df.groupby([\"source\", \"leg_id\", \"days_prior\"]).forecast_stdev.apply(sum_sigma).reset_index()\n    if raw_df:\n        df.attrs[\"title\"] = \"Average Leg Forecasts\"\n        return df\n    fig = _fig_forecasts(\n        df,\n        facet_on=\"flt_no\" if not isinstance(by_leg_id, int) else None,\n        y=\"forecast_mean\" if of == \"mu\" else \"forecast_stdev\",\n        y_title=\"Mean Demand Forecast\" if of == \"mu\" else \"Std Dev Demand Forecast\",\n        color=color,\n    )\n    if also_df:\n        df.attrs[\"title\"] = \"Average Leg Forecasts\"\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_path_forecasts", "title": "fig_path_forecasts", "text": "<pre><code>fig_path_forecasts(\n    summaries,\n    raw_df=False,\n    by_path_id=None,\n    path_names: dict | None = None,\n    agg_booking_classes: bool = False,\n    by_class: bool | str = True,\n    of: ForecastOfT | list[ForecastOfT] = \"mu\",\n    also_df: bool = False,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_path_forecasts(\n    summaries,\n    raw_df=False,\n    by_path_id=None,\n    path_names: dict | None = None,\n    agg_booking_classes: bool = False,\n    by_class: bool | str = True,\n    of: ForecastOfT | list[ForecastOfT] = \"mu\",\n    also_df: bool = False,\n):\n    if isinstance(of, list):\n        if raw_df:\n            df = {\n                _of: fig_path_forecasts(\n                    summaries,\n                    by_path_id=by_path_id,\n                    path_names=path_names,\n                    by_class=by_class,\n                    of=of[0],\n                    raw_df=raw_df,\n                )\n                for _of in of\n            }\n            return pd.concat(df, axis=0, names=[\"measurement\"]).reset_index(0)\n        fig = fig_path_forecasts(\n            summaries,\n            by_path_id=by_path_id,\n            path_names=path_names,\n            by_class=by_class,\n            of=of[0],\n        )\n        for of_ in of[1:]:\n            fig |= fig_path_forecasts(\n                summaries,\n                by_path_id=by_path_id,\n                path_names=path_names,\n                by_class=by_class,\n                of=of_,\n            )\n        if by_path_id:\n            title = f\"Path {by_path_id} Forecasts\"\n        else:\n            title = \"Path Forecasts\"\n        try:\n            if by_path_id:\n                first_summary = next(iter(summaries.values()))\n                path_def = first_summary.paths.loc[by_path_id]\n                title += f\" ({path_def['orig']}~{path_def['dest']})\"\n                for leg_id in first_summary.path_legs.query(f\"path_id == {by_path_id}\").leg_id:\n                    leg_def = first_summary.legs.loc[leg_id]\n                    title += f\", {leg_def['carrier']} {leg_def['flt_no']} ({leg_def['orig']}-{leg_def['dest']})\"\n        except Exception:\n            raise\n        return fig.properties(title=title)\n    df = _assemble(summaries, \"path_forecasts\", by_path_id=by_path_id, of=of, by_class=by_class)\n    list(summaries.keys())\n    if path_names is not None:\n        df[\"path_id\"] = df[\"path_id\"].apply(lambda x: path_names.get(x, str(x)))\n    color = \"booking_class:N\"\n    if isinstance(by_class, str):\n        color = \"source:N\"\n    if agg_booking_classes:\n        if of == \"mu\":\n            df = df.groupby([\"source\", \"path_id\", \"days_prior\"]).forecast_mean.sum().reset_index()\n        elif of == \"sigma\":\n\n            def sum_sigma(x):\n                return np.sqrt(sum(x**2))\n\n            df = df.groupby([\"source\", \"path_id\", \"days_prior\"]).forecast_stdev.apply(sum_sigma).reset_index()\n        elif of == \"closed\":\n            df = df.groupby([\"source\", \"path_id\", \"days_prior\"]).forecast_closed_in_tf.mean().reset_index()\n    if raw_df:\n        if of == \"mu\":\n            df.attrs[\"title\"] = \"Average Path Forecast Means\"\n        elif of == \"sigma\":\n            df.attrs[\"title\"] = \"Average Path Forecast Standard Deviations\"\n        elif of == \"closed\":\n            df.attrs[\"title\"] = \"Average Path Forecast Closed in Timeframe\"\n        return df\n    if of == \"mu\":\n        y = \"forecast_mean\"\n        y_title = \"Mean Demand Forecast\"\n    elif of == \"sigma\":\n        y = \"forecast_stdev\"\n        y_title = \"Std Dev Demand Forecast\"\n    elif of == \"closed\":\n        y = \"forecast_closed_in_tf\"\n        y_title = \"Mean Time Frame Closed of Demand Forecast\"\n    elif of == \"adj_price\":\n        y = \"adjusted_price\"\n        y_title = \"Mean Adjusted Fare\"\n    else:\n        raise NotImplementedError\n\n    # use ordinal data type for DCP labels unless\n    # the underlying data is daily, then use Q\n    rrd_ntype: Literal[\"O\", \"Q\"] = \"O\"\n    if len(df[\"days_prior\"].value_counts()) &gt; 30:\n        rrd_ntype = \"Q\"\n    fig = _fig_forecasts(\n        df,\n        facet_on=\"path_id\" if not isinstance(by_path_id, int) else None,\n        y=y,\n        y_title=y_title,\n        color=color,\n        rrd_ntype=rrd_ntype,\n    )\n    if also_df:\n        if of == \"mu\":\n            df.attrs[\"title\"] = \"Average Path Forecast Means\"\n        elif of == \"sigma\":\n            df.attrs[\"title\"] = \"Average Path Forecast Standard Deviations\"\n        elif of == \"closed\":\n            df.attrs[\"title\"] = \"Average Path Forecast Closed in Timeframe\"\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_segmentation_by_timeframe", "title": "fig_segmentation_by_timeframe", "text": "<pre><code>fig_segmentation_by_timeframe(\n    summaries: dict[str, SummaryTables],\n    metric: Literal[\"bookings\", \"revenue\"],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df=False,\n    source_labels: bool = False,\n    ratio: str | bool = False,\n    also_df: bool = False,\n) -&gt; Chart | DataFrame\n</code></pre> <p>Generate a figure contrasting segmentation by timeframe for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>               (<code>dict[str, SummaryTables]</code>)           \u2013            <p>One or more SummaryTables to compare. The keys of this dictionary are the text names used to label the \"source\" for each set of data in the figure.</p> </li> <li> <code>metric</code>               (<code>(bookings, revenue)</code>, default:                   <code>'bookings'</code> )           \u2013            <p>The metric to display for the segmentation.</p> </li> <li> <code>by_carrier</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>Whether to differentiate carriers by colors (the default) or give the name of a particular carrier as a string to filter the results shown in the figure to only that one carrier.</p> </li> <li> <code>by_class</code>               (<code>bool or str</code>, default:                   <code>False</code> )           \u2013            <p>Whether to differentiate booking class by colors (the default) or give the name of a particular booking class as a string to filter the results shown in the figure to only that one booking class.</p> </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Set to true to return the raw dataframe used to generate the figure, instead of the figure itself.</p> </li> <li> <code>source_labels</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Write source labels above the columns of the figure. Source labels are also available as tool tips, but if the figure is being shared as an image without tooltips, the source labels may make it easier to interpret.</p> </li> <li> <code>ratio</code>               (<code>str or bool</code>, default:                   <code>False</code> )           \u2013            <p>Compute ratios against a reference point and display them in tooltips.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>report</code>               (<code>Reporter</code>)           \u2013            <p>Giving a reporter for this keyword only argument allow you to automatically append this figure to the report (in addition to returning it for display or other processing).</p> </li> <li> <code>trace</code>               (<code>ExcelWriter or (ExcelWriter, str)</code>)           \u2013            <p>Write the raw dataframe backing this figure to the Excel workbook.</p> </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_segmentation_by_timeframe(\n    summaries: dict[str, SummaryTables],\n    metric: Literal[\"bookings\", \"revenue\"],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df=False,\n    source_labels: bool = False,\n    ratio: str | bool = False,\n    also_df: bool = False,\n) -&gt; alt.Chart | pd.DataFrame:\n    \"\"\"\n    Generate a figure contrasting segmentation by timeframe for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n        One or more SummaryTables to compare. The keys of this dictionary are the\n        text names used to label the \"source\" for each set of data in the figure.\n    metric : {'bookings', 'revenue'}\n        The metric to display for the segmentation.\n    by_carrier : bool or str, default True\n        Whether to differentiate carriers by colors (the default) or give the name\n        of a particular carrier as a string to filter the results shown in the\n        figure to only that one carrier.\n    by_class : bool or str, default False\n        Whether to differentiate booking class by colors (the default) or give the\n        name of a particular booking class as a string to filter the results shown\n        in the figure to only that one booking class.\n    raw_df : bool, default False\n        Set to true to return the raw dataframe used to generate the figure, instead\n        of the figure itself.\n    source_labels : bool, default False\n        Write source labels above the columns of the figure. Source labels are also\n        available as tool tips, but if the figure is being shared as an image without\n        tooltips, the source labels may make it easier to interpret.\n    ratio : str or bool, default False\n        Compute ratios against a reference point and display them in tooltips.\n\n    Other Parameters\n    ----------------\n    report : xmle.Reporter, optional\n        Giving a reporter for this keyword only argument allow you to automatically\n        append this figure to the report (in addition to returning it for display\n        or other processing).\n    trace : pd.ExcelWriter or (pd.ExcelWriter, str), optional\n        Write the raw dataframe backing this figure to the Excel workbook.\n    \"\"\"\n    if by_carrier is True and by_class is True:\n        raise NotImplementedError(\"comparing by both class and carrier is messy\")\n    df = _assemble(\n        summaries,\n        \"segmentation_by_timeframe\",\n        metric=metric,\n        by_carrier=by_carrier,\n        by_class=by_class,\n    )\n    source_order = list(summaries.keys())\n\n    title = f\"{metric.title()} by Timeframe\"\n    if by_class is True:\n        title = f\"{metric.title()} by Timeframe and Booking Class\"\n    title_annot = []\n    if isinstance(by_carrier, str):\n        title_annot.append(by_carrier)\n    if isinstance(by_class, str):\n        title_annot.append(f\"Class {by_class}\")\n    if title_annot:\n        title = f\"{title} ({', '.join(title_annot)})\"\n\n    against = source_order[0]\n    ratio_tooltips = ()\n    if ratio:\n        if isinstance(ratio, str):\n            against = ratio\n        idx = list({\"source\", \"carrier\", \"segment\", \"days_prior\", \"booking_class\"} &amp; set(df.columns))\n        df_ = df.set_index(idx)\n        ratios = df_.div(df_.query(f\"source == '{against}'\").droplevel(\"source\")) - 1.0\n        ratios.columns = [\"ratio\"]\n        df = df.join(ratios, on=idx)\n        ratio_tooltips = (alt.Tooltip(\"ratio:Q\", title=f\"vs {against}\", format=\".3%\"),)\n\n    if raw_df:\n        df.attrs[\"title\"] = title\n        return df\n\n    if by_class:\n        if isinstance(by_class, str):\n            color = alt.Color(\"source:N\", title=\"Source\", sort=source_order).title(\"Source\")\n            tooltips = ()\n        else:\n            color = alt.Color(\"booking_class:N\").title(\"Booking Class\")\n            tooltips = (alt.Tooltip(\"booking_class\", title=\"Booking Class\"),)\n        chart = alt.Chart(df.sort_values(\"source\", ascending=False))\n        chart_1 = chart.mark_bar().encode(\n            color=color,\n            x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n            y=alt.Y(metric, stack=True),\n            tooltip=[\n                alt.Tooltip(\"source:N\", title=\"Source\"),\n                alt.Tooltip(\"segment\", title=\"Passenger Type\"),\n                *tooltips,\n                alt.Tooltip(\"days_prior\", title=\"Days Prior\"),\n                alt.Tooltip(metric, format=\".2f\"),\n                *ratio_tooltips,\n            ],\n        )\n        chart_2 = chart.mark_text(\n            color=\"#616161\",\n            yOffset=-2,\n            angle=270,\n            fontSize=8,\n            baseline=\"middle\",\n            align=\"left\",\n        ).encode(\n            text=alt.Text(\"source:N\", title=\"Source\"),\n            x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n            # shape=alt.Shape(\"source:N\", title=\"Source\", sort=source_order),\n            y=alt.Y(f\"sum({metric})\", title=None),\n        )\n        fig = (\n            ((chart_1 + chart_2) if source_labels else chart_1)\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"segment:N\", title=\"Passenger Type\"),\n                title=title,\n            )\n        )\n    elif by_carrier is True:\n        fig = (\n            alt.Chart(df.sort_values(\"source\", ascending=False))\n            .mark_bar()\n            .encode(\n                color=alt.Color(\"carrier:N\").title(\"Carrier\"),\n                x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n                xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n                y=alt.Y(metric, stack=True, title=metric.title()),\n                tooltip=[\n                    alt.Tooltip(\"source:N\", title=\"Source\"),\n                    alt.Tooltip(\"segment\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\"days_prior\", title=\"Days Prior\"),\n                    alt.Tooltip(metric, format=\".2f\"),\n                    *ratio_tooltips,\n                ],\n            )\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"segment:N\", title=\"Passenger Type\"),\n                title=title,\n            )\n        )\n    else:\n        fig = (\n            alt.Chart(df.sort_values(\"source\", ascending=False), title=title)\n            .mark_line()\n            .encode(\n                color=alt.Color(\"source:N\", title=\"Source\", sort=source_order),\n                x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n                y=metric,\n                strokeDash=alt.StrokeDash(\"segment\").title(\"Passenger Type\"),\n                strokeWidth=alt.StrokeWidth(\"source:N\", title=\"Source\", sort=source_order),\n                tooltip=[\n                    alt.Tooltip(\"source:N\", title=\"Source\"),\n                    alt.Tooltip(\"segment\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"days_prior\", title=\"Days Prior\"),\n                    alt.Tooltip(metric, format=\".2f\"),\n                    *ratio_tooltips,\n                ],\n            )\n            .properties(\n                width=500,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n    if also_df:\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/simulation.html", "title": "Simulation", "text": ""}, {"location": "API/simulation.html#passengersim.driver.Simulation", "title": "Simulation", "text": "<p>               Bases: <code>BaseSimulation</code>, <code>CallbackMixin</code></p> Source code in <code>passengersim/driver.py</code> <pre><code>class Simulation(BaseSimulation, CallbackMixin):\n    def __init__(\n        self,\n        config: Config,\n        output_dir: pathlib.Path | None = None,\n    ):\n        \"\"\"\n        Initialize a Simulation instance.\n\n        Parameters\n        ----------\n        config : Config\n            The simulation configuration object. Will be revalidated during\n            initialization.\n        output_dir : pathlib.Path or None, optional\n            Directory for output files. If None, a temporary directory\n            will be created automatically.\n\n        Notes\n        -----\n        This initializes the simulation with default parameters including\n        DCP lists, choice models, and various data structures for tracking\n        simulation results.\n        \"\"\"\n        revalidate(config)\n        super().__init__(config, output_dir)\n        if config.simulation_controls.write_raw_files:\n            try:\n                from passengersim_core.utils import FileWriter\n            except ImportError:\n                self.file_writer = None\n            else:\n                self.file_writer = FileWriter.FileWriter(output_dir)\n        else:\n            self.file_writer = None\n        self.db_writer = None\n        self.dcp_list = [63, 56, 49, 42, 35, 31, 28, 24, 21, 17, 14, 10, 7, 5, 3, 1, 0]\n        self.classes = []\n        self.fare_sales_by_dcp = defaultdict(int)\n        self.fare_sales_by_carrier_dcp = defaultdict(int)\n        self.fare_details_sold = defaultdict(int)\n        self.fare_details_sold_business = defaultdict(int)\n        self.fare_details_revenue = defaultdict(float)\n        self.demand_multiplier = 1.0\n        self.capacity_multiplier = 1.0\n        self.airports = {}\n        self.choice_models = {}\n        self.frat5curves = {}\n        self.load_factor_curves = {}\n        self.todd_curves = {}\n        self.debug = False\n        self.update_frequency = None\n        self.random_generator = passengersim.core.Generator(42)\n        self.sample_done_callback = lambda n, n_total: None\n        self.choice_set_file = None\n        self.choice_set_obs = 0\n        self.choice_set_mkts = []\n        self.segmentation_data_by_timeframe: dict[int, pd.DataFrame] = {}\n        \"\"\"Bookings and revenue segmentation by timeframe.\n\n        The key is the trial number, and the value is a DataFrame with a\n        breakdown of bookings and revenue by timeframe, customer segment,\n        carrier, and booking class.\n        \"\"\"\n\n        self.bid_price_traces: dict[int, Any] = {}\n        \"\"\"Bid price traces for each carrier.\n\n        The key is the trial number, and the value is a dictionary with\n        carrier names as keys and bid price traces as values.\"\"\"\n\n        self.displacement_traces: dict[int, Any] = {}\n        \"\"\"Displacement cost traces for each carrier.\n\n        The key is the trial number, and the value is a dictionary with\n        carrier names as keys and displacement cost traces as values.\"\"\"\n\n        self._fare_restriction_mapping = {}\n        \"\"\"Mapping of fare restriction names to restriction numbers.\"\"\"\n\n        self._fare_restriction_list = []\n        \"\"\"List of fare restriction names in the order they were added.\"\"\"\n\n        self._initialize(config)\n        if not config.db:\n            self.cnx = database.Database()\n        else:\n            self.cnx = database.Database(\n                engine=config.db.engine,\n                filename=config.db.filename,\n                pragmas=config.db.pragmas,\n                commit_count_delay=config.db.commit_count_delay,\n            )\n        if self.cnx.is_open:\n            database.tables.create_table_leg_defs(self.cnx._connection, self.eng.legs)\n            database.tables.create_table_fare_defs(self.cnx._connection, self.eng.fares)\n            database.tables.create_table_fare_restriction_defs(self.cnx._connection, self._fare_restriction_list)\n            database.tables.create_table_path_defs(self.cnx._connection, self.eng.paths)\n            if config.db != \":memory:\":\n                self.cnx.save_configs(config)\n\n        self.callback_data = CallbackData()\n        \"\"\"Data stored from callbacks.\n\n        This allows a user to store arbitrary data during a simulation using callbacks,\n        and access it later.\n        \"\"\"\n\n    @property\n    def _eng(self) -&gt; SimulationEngine:\n        \"\"\"\n        Access to the underlying simulation engine.\n\n        Returns\n        -------\n        SimulationEngine\n            The core simulation engine instance.\n        \"\"\"\n        return self.eng\n\n    @property\n    def base_time(self) -&gt; int:\n        \"\"\"\n        The base time for the simulation.\n\n        Returns\n        -------\n        int\n            The base time in seconds since the epoch.\n        \"\"\"\n        return self.eng.base_time\n\n    @property\n    def snapshot_filters(self) -&gt; list[SnapshotFilter] | None:\n        \"\"\"\n        Get the snapshot filters for the simulation.\n\n        Returns\n        -------\n        list[SnapshotFilter] or None\n            List of snapshot filter objects, or None if simulation\n            is not initialized.\n        \"\"\"\n        try:\n            sim = self.eng\n        except AttributeError:\n            return None\n        return sim.snapshot_filters\n\n    @snapshot_filters.setter\n    def snapshot_filters(self, x: list[SnapshotFilter]):\n        \"\"\"\n        Set the snapshot filters for the simulation.\n\n        Parameters\n        ----------\n        x : list[SnapshotFilter]\n            List of snapshot filter objects to set.\n\n        Raises\n        ------\n        ValueError\n            If the simulation is not initialized.\n        \"\"\"\n        try:\n            sim = self.eng\n        except AttributeError as err:\n            raise ValueError(\"sim not initialized, cannot set snapshot_filters\") from err\n        sim.snapshot_filters = x\n\n    def _initialize(self, config: Config):\n        \"\"\"\n        Initialize all simulation components.\n\n        Parameters\n        ----------\n        config : Config\n            The simulation configuration object containing all settings\n            and parameters for initialization.\n\n        Notes\n        -----\n        This method orchestrates the initialization of all simulation\n        components in the correct order, including the simulation engine,\n        parameters, carriers, airports, demands, fares, and various curves.\n        \"\"\"\n        self._init_sim_and_parms(config)\n        self._init_circuity(config)\n        self._init_rm_systems(config)\n        self._init_todd_curves(config)\n        self._init_choice_models(config)\n        self._init_frat5_curves(config)\n        self._init_blf_curves(config)\n        self._init_load_factor_curves(config)\n        self._init_carriers(config)\n        self._init_booking_curves(config)\n        self._init_airports(config)\n        self._initialize_leg_cabin_bucket(config)\n        self._init_demands(config)\n        self._init_fares(config)\n        logger.info(\"Connecting markets\")\n        self.eng.connect_markets()\n        self.db_writer = DbWriter(\"db\", config, self.eng)\n\n    def _init_sim_and_parms(self, config):\n        \"\"\"\n        Initialize the simulation engine and parameters.\n\n        Parameters\n        ----------\n        config : Config\n            Configuration object containing simulation parameters and settings.\n\n        Notes\n        -----\n        This method creates the core simulation engine instance and configures\n        it with parameters from the config, including demand/capacity multipliers,\n        random seed, DCP settings, and choice set capture options.\n        \"\"\"\n        logger.info(\"Initializing simulation engine parameters\")\n        self.eng = passengersim.core.SimulationEngine(name=config.scenario)\n        self.eng.config = config\n        self.eng.random_generator = self.random_generator\n        self.eng.snapshot_filters = config.snapshot_filters\n        for pname, pvalue in config.simulation_controls:\n            if pname == \"demand_multiplier\":\n                self.demand_multiplier = pvalue\n            elif pname == \"capacity_multiplier\":\n                self.capacity_multiplier = pvalue\n            elif pname == \"write_raw_files\":\n                self.write_raw_files = pvalue\n            elif pname == \"random_seed\":\n                self.random_generator.seed(pvalue)\n            elif pname == \"update_frequency\":\n                self.update_frequency = pvalue\n            elif pname == \"capture_choice_set_file\":\n                if len(pvalue) &gt; 0:\n                    self.eng.set_parm(\"capture_choice_set\", 1)\n                    self.choice_set_file = open(pvalue, \"w\")\n                    cols = self.eng.choice_set_columns()\n                    tmp = \",\".join(cols)\n                    print(tmp, file=self.choice_set_file)\n            elif pname == \"capture_choice_set_obs\":\n                self.choice_set_obs = pvalue\n            elif pname == \"capture_choice_set_mkts\":\n                self.choice_set_mkts = pvalue\n\n            # These parameters are not used directly in the core, but leave them listed\n            # for now to not break config files reading\n            elif pname in [\n                \"base_date\",\n                \"capture_competitor_data\",\n                \"dcp_hour\",\n                \"double_capacity_until\",\n                \"dwm_lite\",\n                \"show_progress_bar\",\n                \"simple_k_factor\",\n                \"segment_k_factor\",\n                \"simple_cv100\",\n                \"timeframe_demand_allocation\",\n                \"tot_z_factor\",\n                \"allow_unused_restrictions\",\n                \"additional_settings\",\n            ]:\n                pass\n            else:\n                self.eng.set_parm(pname, float(pvalue))\n        for pname, pvalue in config.simulation_controls.model_extra.items():\n            print(f\"extra simulation setting: {pname} = \", float(pvalue))\n            self.eng.set_parm(pname, float(pvalue))\n        if config.simulation_controls.additional_settings:\n            self.eng.additional_settings(**config.simulation_controls.additional_settings)\n\n        # There is a default array of DCPs, we'll override it with the data from the\n        # input file (if available)\n        if len(config.dcps) &gt; 0:\n            self.dcp_list = []\n            for dcp_index, days_prior in enumerate(config.dcps):\n                self.eng.add_dcp(dcp_index, days_prior)\n                self.dcp_list.append(days_prior)\n            # We need to add the last DCP, which is always 0, if not already in the list\n            if self.dcp_list[-1] != 0:\n                self.eng.add_dcp(len(self.dcp_list), 0)\n                self.dcp_list.append(0)\n\n    def _init_circuity(self, config):\n        \"\"\"\n        Initialize circuity rules for the simulation.\n\n        Parameters\n        ----------\n        config : Config\n            Configuration object containing circuity rules.\n\n        Notes\n        -----\n        Circuity rules define how passengers can connect through hubs\n        and intermediate airports in their journey.\n        \"\"\"\n        logger.info(\"Initializing circuity rules\")\n        for rule in config.circuity_rules:\n            # Flatten the object into a dictionary,\n            # SimulationEngine will iterate over it\n            self.eng.add_circuity_rule(dict(rule))\n\n    def _init_rm_system(self, rm_name: str, rm_system: RmSystemConfig, config: Config):\n        \"\"\"\n        Initialize a revenue management system.\n\n        Parameters\n        ----------\n        rm_name : str\n            Name identifier for the RM system.\n        rm_system : RmSystemConfig\n            Configuration object for the RM system.\n        config : Config\n            Overall simulation configuration.\n\n        Notes\n        -----\n        This method sets up a revenue management system with its availability\n        control settings and associated processes for demand forecasting,\n        optimization, and other RM functions.\n        \"\"\"\n        from passengersim_core.carrier.rm_system import Rm_System\n\n        logger.info(\"Initializing RM system %s\", rm_name)\n        x = self.rm_systems[rm_name] = Rm_System(rm_name)\n        x.availability_control = rm_system.availability_control\n        for process_name, process in rm_system.processes.items():\n            step_list = [s._factory() for s in process]\n            for s in step_list:\n                s.use_config(config)\n            x.add_process(process_name, step_list)\n\n    def _init_rm_systems(self, config):\n        \"\"\"\n        Initialize all revenue management systems.\n\n        Parameters\n        ----------\n        config : Config\n            Configuration object containing RM system definitions.\n\n        Notes\n        -----\n        This method initializes each RM system defined in the configuration,\n        setting up their availability controls and associated processes.\n        \"\"\"\n        self.rm_systems = {}\n        for rm_name, rm_system in config.rm_systems.items():\n            self._init_rm_system(rm_name, rm_system, config)\n\n    def _init_todd_curves(self, config):\n        \"\"\"\n        Initialize TODD (Time-Of-Departure Demand) curves.\n\n        Parameters\n        ----------\n        config : Config\n            Configuration object containing TODD curve definitions.\n\n        Notes\n        -----\n        TODD curves model how demand varies as the departure time approaches,\n        which is crucial for revenue management optimization.\n        \"\"\"\n        logger.info(\"Initializing TODD curves\")\n        for todd_name, todd in config.todd_curves.items():\n            dwm = DecisionWindow(todd_name)\n            if todd.k_factor:\n                dwm.k_factor = todd.k_factor\n            if todd.min_distance:\n                dwm.min_distance = todd.min_distance\n            if todd.probabilities:\n                dwm.dwm_tod = list(todd.probabilities.values())\n            self.todd_curves[todd_name] = dwm\n\n    def _get_fare_restriction_num(self, restriction_name: str, *, ignore_when_missing: bool = False):\n        \"\"\"\n        Get the numeric identifier for a fare restriction name.\n\n        Parameters\n        ----------\n        restriction_name : str\n            The name of the fare restriction.\n        ignore_when_missing : bool, default False\n            If True, return None when the restriction is not found instead\n            of creating a new mapping.\n\n        Returns\n        -------\n        int or None\n            The numeric identifier for the restriction, or None if\n            ignore_when_missing is True and the restriction is not found.\n        \"\"\"\n        r = str(restriction_name).casefold()\n        if r not in self._fare_restriction_mapping:\n            if ignore_when_missing:\n                return None\n            self._fare_restriction_mapping[r] = len(self._fare_restriction_mapping) + 1\n            self._fare_restriction_list.append(r)\n        return self._fare_restriction_mapping[r]\n\n    def parse_restriction_flags(self, restriction_flags: int) -&gt; list[str]:\n        \"\"\"\n        Convert restriction flags to a list of restriction names.\n\n        Parameters\n        ----------\n        restriction_flags : int\n            Integer bit flags representing which restrictions are active.\n\n        Returns\n        -------\n        list[str]\n            List of restriction names corresponding to the set flags.\n        \"\"\"\n        result = []\n        rest_num = 1\n        rest_names = self._fare_restriction_list\n        while restriction_flags:\n            if restriction_flags &amp; 1:\n                result.append(rest_names[rest_num - 1])\n            rest_num += 1\n            restriction_flags &gt;&gt;= 1\n        return result\n\n    def get_restriction_name(self, restriction_num: int) -&gt; str:\n        \"\"\"\n        Convert restriction number to a restriction name.\n\n        Parameters\n        ----------\n        restriction_num : int\n            The numeric identifier for the restriction (must be &gt;= 1).\n\n        Returns\n        -------\n        str\n            The name of the restriction.\n\n        Raises\n        ------\n        IndexError\n            If restriction_num is less than 1 or exceeds the number\n            of defined restrictions.\n        \"\"\"\n        if restriction_num &lt; 1:\n            raise IndexError(restriction_num)\n        return self._fare_restriction_list[restriction_num - 1]\n\n    def _init_choice_models(self, config):\n        \"\"\"\n        Initialize customer choice models.\n\n        Parameters\n        ----------\n        config : Config\n            Configuration object containing choice model definitions.\n\n        Notes\n        -----\n        Choice models determine how passengers select among available\n        flight options based on factors like price, schedule, and\n        service attributes.\n        \"\"\"\n        logger.info(\"Initializing choice models\")\n        for cm_name, cm in config.choice_models.items():\n            x = passengersim.core.ChoiceModel(cm_name, cm.kind, random_generator=self.random_generator)\n            for pname, pvalue in cm:\n                if pname in (\"kind\", \"name\") or pvalue is None:\n                    continue\n\n                if pname == \"todd_curve\":\n                    tmp_dwm = self.todd_curves[pvalue]\n                    x.add_dwm(tmp_dwm)\n                elif pname == \"early_dep\" and pvalue is not None:\n                    x.early_dep_offset = pvalue[\"offset\"]\n                    x.early_dep_slope = pvalue[\"slope\"]\n                    x.early_dep_beta = pvalue[\"beta\"]\n                elif pname == \"late_arr\" and pvalue is not None:\n                    x.late_arr_offset = pvalue[\"offset\"]\n                    x.late_arr_slope = pvalue[\"slope\"]\n                    x.late_arr_beta = pvalue[\"beta\"]\n                elif pname == \"replanning\" and pvalue is not None:\n                    x.replanning_alpha = pvalue[0]\n                    x.replanning_beta = pvalue[1]\n                elif pname == \"restrictions\":\n                    for rname, rvalue in pvalue.items():\n                        restriction_num = self._get_fare_restriction_num(rname)\n                        if isinstance(rvalue, list | tuple):\n                            x.add_restriction(restriction_num, *rvalue)\n                        else:\n                            x.add_restriction(restriction_num, rvalue)\n                elif isinstance(pvalue, list | tuple):\n                    x.add_parm(pname, *pvalue)\n                else:\n                    x.add_parm(pname, pvalue)\n            self.choice_models[cm_name] = x\n\n    def _init_frat5_curves(self, config):\n        \"\"\"\n        Initialize FRAT5 curves for revenue management.\n\n        Parameters\n        ----------\n        config : Config\n            Configuration object containing FRAT5 curve definitions.\n\n        Notes\n        -----\n        FRAT5 curves define the fare ratio at which half (0.5) of the\n        customers will buy up to the higher fare. These curves define how\n        fare ratios change over time as departure approaches, used for revenue\n        optimization decisions.\n        \"\"\"\n        logger.info(\"Initializing Frat5 curves\")\n        for f5_name, f5_data in config.frat5_curves.items():\n            f5 = Frat5(f5_name)\n            # ensure that the curve is sorted in descending order by days prior\n            sorted_days_prior = reversed(sorted(f5_data.curve.keys()))\n            for days_prior in sorted_days_prior:\n                val = f5_data.curve[days_prior]\n                f5.add_vals(val)\n            f5.max_cap = f5_data.max_cap\n            self.eng.add_frat5(f5)\n            self.frat5curves[f5_name] = f5\n\n    def _init_blf_curves(self, config):\n        \"\"\"These are currently grabbed by the RmStep\"\"\"\n        pass\n\n    def _init_load_factor_curves(self, config):\n        logger.info(\"Initializing load factor curves\")\n        for lf_name, lf_curve in config.load_factor_curves.items():\n            self.load_factor_curves[lf_name] = lf_curve\n\n    def _init_carriers(self, config: Config):\n        \"\"\"\n        Initialize carriers and their revenue management systems.\n\n        Parameters\n        ----------\n        config : Config\n            Configuration object containing carrier definitions including\n            their associated revenue management systems.\n\n        Notes\n        -----\n        This method sets up each carrier with its revenue management system,\n        creating the necessary objects for managing inventory, pricing,\n        and booking decisions.\n        \"\"\"\n        logger.info(\"Initializing carriers\")\n        self.carriers_dict = {}\n        self.rm_callbacks = {}\n        try:\n            old_style_std_rm_systems = standard_rm_systems_raw()\n        except FileNotFoundError:\n            old_style_std_rm_systems = {}\n        for carrier_name, carrier_config in config.carriers.items():\n            rm_is_callback = False\n            # if `carrier_config.rm_system_options` is defined, it is a callback-style RM system\n            if carrier_config.rm_system_options is not None and carrier_config.rm_system_options is not False:\n                # Define a callback-style RM system for this carrier\n                system_def = carrier_config.rm_system_options.copy()\n                system_def.pop(\"name\", None)  # remove name if present\n                system_class = get_registered_rm_system(carrier_config.rm_system)\n                if \"dcps\" not in system_def:\n                    system_def[\"dcps\"] = config.dcps\n                rm_sys = system_class(carrier=carrier_name, **system_def)\n                self.rm_callbacks[carrier_name] = rm_sys\n                rm_is_callback = True\n            # otherwise, if `rm_system_options` is not explicitly False, and\n            # the RM system name is NOT defined in the config nor in the old-style standard RM systems list,\n            # but it IS a registered callback-style RM system, then also treat it as a callback-style RM system\n            elif (\n                carrier_config.rm_system_options is not False\n                and carrier_config.rm_system not in config.rm_systems\n                and carrier_config.rm_system not in old_style_std_rm_systems\n                and check_registered_rm_system(carrier_config.rm_system)\n            ):\n                # Define a callback-style RM system with all default config for this carrier\n                system_class = get_registered_rm_system(carrier_config.rm_system)\n                rm_sys = system_class(carrier=carrier_name, dcps=config.dcps)\n                self.rm_callbacks[carrier_name] = rm_sys\n                rm_is_callback = True\n            else:\n                # Old-style RM system setup\n                try:\n                    rm_sys = self.rm_systems[carrier_config.rm_system]\n                except KeyError:\n                    config._load_std_rm_system(carrier_config.rm_system)\n                    self._init_rm_system(\n                        carrier_config.rm_system,\n                        config.rm_systems[carrier_config.rm_system],\n                        config,\n                    )\n                    rm_sys = self.rm_systems[carrier_config.rm_system]\n            availability_control = rm_sys.availability_control\n            carrier = passengersim.core.Carrier(carrier_name, availability_control)\n            self.carriers_dict[carrier_name] = carrier\n            if rm_is_callback:\n                carrier.rm_system = None\n                self.daily_callback(rm_sys)\n            else:\n                carrier.rm_system = self.rm_systems[carrier_config.rm_system]\n            carrier.truncation_rule = carrier_config.truncation_rule\n            carrier.proration_rule = carrier_config.proration_rule\n            carrier.history_length = carrier_config.history_length\n            carrier.cp_algorithm = carrier_config.cp_algorithm\n            carrier.cp_record_highest_closed_as_open = carrier_config.cp_record_highest_closed_as_open\n            carrier.cp_quantize = carrier_config.cp_quantize\n            carrier.cp_scale = carrier_config.cp_scale\n            carrier.cp_record = carrier_config.cp_record\n            if carrier_config.cp_elasticity is not None:\n                carrier.cp_elasticity = carrier_config.cp_elasticity\n            frat5_name = carrier_config.frat5\n            if not frat5_name and carrier_config.rm_system in config.rm_systems:\n                frat5_name = config.rm_systems[carrier_config.rm_system].frat5\n            if frat5_name is not None and frat5_name != \"\":\n                # We want a deep copy of the Frat5 curve,\n                # in case two carriers are using the same curve,\n                # and we want to adjust one of them using ML\n                try:\n                    f5_data = config.frat5_curves[frat5_name]\n                except KeyError:\n                    config._load_std_frat5(frat5_name)\n                    f5_data = config.frat5_curves[frat5_name]\n                f5 = Frat5(f5_data.name)\n                for _dcp, val in f5_data.curve.items():\n                    f5.add_vals(val)\n                if carrier_config.fare_adjustment_scale is not None:\n                    f5.fare_adjustment_scale = carrier_config.fare_adjustment_scale\n                carrier.frat5 = f5\n            if carrier_config.load_factor_curve is not None and carrier_config.load_factor_curve != \"\":\n                lfc = self.load_factor_curves[carrier_config.load_factor_curve]\n                carrier.load_factor_curve = lfc\n\n            # Frat5 curve by market - experimental code !!!\n            for k, name in carrier_config.frat5_map.items():\n                a = k.split(\"-\")  # orig-dest\n                f5 = self.frat5curves[name]\n                try:\n                    carrier.add_frat5_mkt(a[0], a[1], f5)\n                except Exception as e:\n                    print(e)\n                    print(\"values =\", a[0], a[1], f5)\n            for anc_code, anc_price in carrier_config.ancillaries.items():\n                anc = Ancillary(anc_code, anc_price, 0)\n                carrier.add_ancillary(anc)\n\n            self.eng.add_carrier(carrier)\n\n        self.classes = config.classes\n        self.init_rm = {}  # TODO\n\n    def _init_airports(self, config: Config):\n        \"\"\"\n        Initialize airports and their geographic information.\n\n        Parameters\n        ----------\n        config : Config\n            Configuration object containing airport/place definitions\n            with coordinates and minimum connection times.\n\n        Notes\n        -----\n        This method creates Airport objects with geographic coordinates\n        used for distance calculations and minimum connection time (MCT)\n        data for hub operations.\n        \"\"\"\n        logger.info(\"Initializing airports\")\n        # Load the places into Airport objects.  We use lat/lon to get\n        # great circle distance, and this also has the MCT data\n        for code, p in config.places.items():\n            assert isinstance(p, passengersim.config.Place)\n            a = Airport(code, p.label)\n            if p.lat is not None:\n                a.latitude = p.lat\n            if p.lon is not None:\n                a.longitude = p.lon\n            if p.country is not None:\n                a.country = p.country\n            if p.state is not None:\n                a.state = p.state\n            if p.mct is not None:\n                assert isinstance(p.mct, passengersim.config.MinConnectTime)\n                a.mct_dd = p.mct.domestic_domestic\n                a.mct_di = p.mct.domestic_international\n                a.mct_id = p.mct.international_domestic\n                a.mct_ii = p.mct.international_international\n            self.airports[code] = a\n            self.eng.add_airport(a)\n\n    def _init_booking_curves(self, config):\n        logger.info(\"Initializing booking curves\")\n        self.curves = {}\n        for curve_name, curve_config in config.booking_curves.items():\n            bc = passengersim.core.BookingCurve(curve_name)\n            bc.random_generator = self.random_generator\n            # ensure that the curve is sorted in descending order by days prior\n            sorted_days_prior = reversed(sorted(curve_config.curve.keys()))\n            for days_prior in sorted_days_prior:\n                pct = curve_config.curve[days_prior]\n                bc.add_dcp(days_prior, pct)\n            self.curves[curve_name] = bc\n\n    def _init_demands(self, config):\n        logger.info(\"Initializing demands\")\n        markets = {}\n        market_multipliers = {}\n        for mkt_config in config.markets:\n            market_multipliers[f\"{mkt_config.orig}~{mkt_config.dest}\"] = mkt_config.demand_multiplier\n        # This simulates PODS' favored carrier logic.  The CALP values are\n        # all set to 1.0 in all their networks, so hard-coded for now but\n        # we can load from YAML in the future if we need to\n        if len(config.carriers) &gt; 0:\n            prob = 1.0 / len(config.carriers)\n            calp = {cxr_name: prob for cxr_name in config.carriers.keys()}\n        else:\n            calp = {}\n\n        for dmd_config in config.demands:\n            mkt_ident = f\"{dmd_config.orig}~{dmd_config.dest}\"\n            if mkt_ident not in markets:\n                mkt = passengersim.core.Market(dmd_config.orig, dmd_config.dest)\n                markets[mkt_ident] = mkt\n            else:\n                mkt = markets[mkt_ident]\n            dmd = passengersim.core.Demand(\n                segment=dmd_config.segment, market=mkt, deterministic=dmd_config.deterministic\n            )\n            dmd.base_demand = dmd_config.base_demand * self.demand_multiplier * market_multipliers.get(mkt_ident, 1.0)\n            dmd.price = dmd_config.reference_fare\n            dmd.reference_fare = dmd_config.reference_fare\n            if dmd_config.distance &gt; 0.01:\n                dmd.distance = dmd_config.distance\n            elif dmd.orig in self.airports and dmd.dest in self.airports:\n                dmd.distance = get_mileage(self.airports, dmd.orig, dmd.dest)\n\n            # Get the choice model name to use for this demand.\n            model_name = dmd_config.choice_model or dmd_config.segment\n            cm = self.choice_models.get(model_name, None)\n            if cm is not None:\n                dmd.add_choice_model(cm)\n            else:\n                raise ValueError(f\"Choice model {model_name} not found for demand {dmd}\")\n            if dmd_config.curve:\n                curve_name = str(dmd_config.curve).strip()\n                curve = self.curves[curve_name]\n                dmd.add_curve(curve)\n            if dmd_config.todd_curve in self.todd_curves:\n                dmd.add_dwm(self.todd_curves[dmd_config.todd_curve])\n            if dmd_config.group_sizes is not None:\n                dmd.add_group_sizes(dmd_config.group_sizes)\n            dmd.prob_saturday_night = dmd_config.prob_saturday_night\n            dmd.prob_num_days = dmd_config.prob_num_days\n            dmd.prob_favored_carrier = calp\n\n            for o in dmd_config.overrides:\n                dmd.add_override(o.carrier, o.discount_pct, o.pref_adj)\n\n            if dmd_config.dwm_tolerance &gt; 0.0:\n                dmd.dwm_tolerance = dmd_config.dwm_tolerance\n            elif len(self.config.dwm_tolerance) &gt; 0:\n                for tolerance in self.config.dwm_tolerance:\n                    if tolerance[\"min_dist\"] &lt;= dmd.distance &lt;= tolerance[\"max_dist\"]:\n                        if dmd.segment in tolerance:\n                            dmd.dwm_tolerance = tolerance[dmd.segment]\n                        else:\n                            raise Exception(f\"DWM tolerance data is missing segment '{dmd.segment}'\")\n\n            self.eng.add_demand(dmd)\n            if self.debug:\n                print(f\"Added demand: {dmd}, base_demand = {dmd.base_demand}\")\n        # Hold PyObjects for markets in a dictionary in order to avoid duplicates\n        self._markets = {k: v for k, v in self.markets.items()}\n\n    def _init_fares(self, config: Config):\n        logger.info(\"Initializing fares\")\n        # self.fares = []\n        disable_ap = config.simulation_controls.disable_ap\n\n        discovered_restrictions = set()\n\n        for fare_config in config.fares:\n            fare = passengersim.core.Fare(\n                self.carriers_dict[fare_config.carrier],\n                fare_config.orig,\n                fare_config.dest,\n                fare_config.booking_class,\n                fare_config.price,\n            )\n            fare.cabin = fare_config.cabin\n            fare.min_stay = fare_config.min_stay\n            fare.saturday_night_required = fare_config.saturday_night_required\n            if not disable_ap:\n                fare.adv_purch = fare_config.advance_purchase\n            for rest_code in fare_config.restrictions:\n                rest_num = self._get_fare_restriction_num(rest_code, ignore_when_missing=True)\n                if rest_num:\n                    fare.add_restriction(rest_num)\n                    discovered_restrictions.add(str(rest_code).casefold())\n                else:\n                    if config.simulation_controls.allow_unused_restrictions:\n                        warnings.warn(\n                            f\"Restriction {rest_code!r} found in fares but not used in any choice model\",\n                            skip_file_prefixes=_warn_skips,\n                            stacklevel=1,\n                        )\n                    else:\n                        raise ValueError(f\"Restriction {rest_code!r} found in fares but not used in any choice model\")\n            self.eng.add_fare(fare)\n            if self.debug:\n                print(f\"Added fare: {fare}\")\n            # self.fares.append(fare)\n\n        # check that all restrictions used in choice models are present in fares\n        for r in self._fare_restriction_list:\n            if r not in discovered_restrictions:\n                if config.simulation_controls.allow_unused_restrictions:\n                    warnings.warn(\n                        f\"Restriction {r!r} used in choice models but not found in fares\",\n                        skip_file_prefixes=_warn_skips,\n                        stacklevel=1,\n                    )\n                else:\n                    raise ValueError(f\"Restriction {r!r} used in choice models but not found in fares\")\n\n        carriers = {cxr.name: cxr for cxr in self.eng.carriers}\n        for path_config in config.paths:\n            p = passengersim.core.Path(path_config.orig, path_config.dest, 0.0)\n            p.path_quality_index = path_config.path_quality_index\n            leg_index1 = path_config.legs[0]\n            tmp_leg = self.legs[leg_index1]\n            assert tmp_leg.orig == path_config.orig, \"Path statement is corrupted, orig doesn't match\"\n            assert tmp_leg.flt_no == leg_index1\n            p.add_leg(tmp_leg)\n            if len(path_config.legs) &gt;= 2:\n                leg_index2 = path_config.legs[1]\n                if leg_index2 &gt; 0:\n                    tmp_leg = self.legs[leg_index2]\n                    p.add_leg(self.legs[leg_index2])\n            assert tmp_leg.dest == path_config.dest, \"Path statement is corrupted, dest doesn't match\"\n            path_carrier_name = tmp_leg.carrier_name\n            if path_carrier_name not in carriers:\n                raise ValueError(f\"Carrier {path_carrier_name} not found\")\n            p.add_carrier(carriers[path_carrier_name])\n            self.eng.add_path(p)\n\n        # Go through and make sure things are linked correctly\n        fares_dict = defaultdict(list)\n        lowest_fare_dict = defaultdict(lambda: 9e9)\n        highest_fare_dict = defaultdict(float)\n        for f in self.eng.fares:\n            od_key = (f.orig, f.dest)\n            fares_dict[od_key].append(f)\n            lowest_fare_dict[od_key] = min(lowest_fare_dict[od_key], f.price)\n            highest_fare_dict[od_key] = max(highest_fare_dict[od_key], f.price)\n        for dmd in self.eng.demands:\n            tmp_fares = fares_dict[(dmd.orig, dmd.dest)]\n            tmp_fares = sorted(tmp_fares, reverse=True, key=lambda p: p.price)\n            for fare in tmp_fares:\n                dmd.add_fare(fare)\n\n            # Now set upper and lower bounds, these are used in continuous pricing\n            # CP can never go lower than the lowest published fare\n            lowest_published = lowest_fare_dict[(dmd.orig, dmd.dest)]\n            highest_published = highest_fare_dict[(dmd.orig, dmd.dest)]\n            for cxr in self.eng.carriers:\n                cp_bounds = self.config.carriers[cxr.name].cp_bounds\n                prev_fare = None\n                for fare in tmp_fares:\n                    if fare.carrier_name != cxr.name:\n                        continue\n                    if prev_fare is not None:\n                        diff = prev_fare.price - fare.price\n                        prev_fare.price_lower_bound = max(prev_fare.price - diff * cp_bounds, lowest_published)\n                        fare.price_upper_bound = min(fare.price + diff * cp_bounds, highest_published)\n                        # This provides a price floor, but will be overwritten\n                        # each time through the loop EXCEPT for the lowest fare\n                        fare.price_lower_bound = max(fare.price - diff * cp_bounds, lowest_published)\n                    else:\n                        ub = highest_published * (1.0 + self.config.carriers[cxr.name].cp_upper_bound)\n                        fare.price_upper_bound = min(fare.price, ub)\n                    prev_fare = fare\n\n        logger.info(\"Initializing bucket decision fares\")\n        for leg in self.eng.legs:\n            try:\n                leg_market = self.eng.markets[f\"{leg.orig}~{leg.dest}\"]\n            except KeyError:\n                # no market for this leg, so no fares, that's ok\n                continue\n            assert len(leg_market.fares) &gt; 0, f\"No fares found for market {leg_market}\"\n            for fare in leg_market.fares:\n                if fare.carrier_name == leg.carrier_name:\n                    leg.set_bucket_blank_value(fare.booking_class, fare.price)\n\n        self.eng.base_time = config.simulation_controls.reference_epoch()\n\n    def _initialize_leg_cabin_bucket(self, config: Config):\n        logger.info(\"Initializing legs, cabins, and buckets\")\n        self.legs = {}\n        carriers = {}\n        for carrier in self.eng.carriers:\n            carriers[carrier.name] = carrier\n        next_leg_id = 1\n        for leg_config in config.legs:\n            # if no leg_id is provided, we'll use the fltno if it's not already in use\n            if (\n                leg_config.leg_id is None\n                and leg_config.fltno is not None\n                and not self.eng.leg_id_exists(leg_config.fltno)\n            ):\n                leg_config.leg_id = leg_config.fltno\n            # if still no leg_id, we'll use the next available\n            if leg_config.leg_id is None:\n                while self.eng.leg_id_exists(next_leg_id):\n                    next_leg_id += 1\n                leg_config.leg_id = next_leg_id\n            leg = passengersim.core.Leg(\n                leg_config.leg_id,\n                carriers[leg_config.carrier],\n                leg_config.fltno,\n                leg_config.orig,\n                leg_config.dest,\n            )\n            leg.dep_time = leg_config.dep_time\n            leg.arr_time = leg_config.arr_time\n            leg.dep_time_offset = leg_config.dep_time_offset\n            leg.arr_time_offset = leg_config.arr_time_offset\n            if leg_config.distance:\n                leg.distance = leg_config.distance\n            elif len(self.airports) &gt; 0:\n                leg.distance = get_mileage(self.airports, leg.orig, leg.dest)\n            self.eng.add_leg(leg)\n\n            # Now we do the cabins and buckets\n            if isinstance(leg_config.capacity, int):\n                cap = int(leg_config.capacity * self.capacity_multiplier)\n                leg.capacity = cap\n                cabin = passengersim.core.Cabin(\"Y\", cap)\n                leg.add_cabin(cabin)\n                self.set_classes(leg, cabin)\n            else:\n                tot_cap = 0\n                for cabin_code, tmp_cap in leg_config.capacity.items():\n                    cap = int(tmp_cap * self.capacity_multiplier)\n                    tot_cap += cap\n                    cabin = passengersim.core.Cabin(cabin_code, cap)\n                    leg.add_cabin(cabin)\n                leg.capacity = tot_cap\n                self.set_classes(leg, cabin)\n            if self.debug:\n                print(f\"Added leg: {leg}, dist = {leg.distance}\")\n            self.legs[leg.leg_id] = leg\n\n    def set_classes(self, leg: passengersim.core.Leg, _cabin, debug=False):\n        leg_classes = self.config.carriers[leg.carrier.name].classes\n        cabin_code_list = [c.name for c in leg.cabins]\n        if len(leg_classes) == 0:\n            return\n        cap = float(leg.capacity)\n        if debug:\n            print(leg, \"Capacity = \", cap)\n        history_def = leg.carrier.get_history_def()\n        for bkg_class in leg_classes:\n            # Input as a percentage\n            auth = int(cap * self.init_rm.get(bkg_class, 100.0) / 100.0)\n            if isinstance(bkg_class, tuple):\n                # We are likely using multi-cabin, so unpack it\n                (bkg_class, cabin_code) = bkg_class\n            else:\n                cabin_code = bkg_class[0]\n            if cabin_code not in cabin_code_list:\n                continue\n            b = passengersim.core.Bucket(bkg_class, alloc=auth, history=history_def)\n            b.cabin = cabin_code\n            leg.add_bucket(b)\n            if debug:\n                print(\"    Added Bucket\", leg, bkg_class, auth)\n\n    def setup_scenario(self) -&gt; None:\n        \"\"\"\n        Set up the scenario for the simulation.\n\n        This will delete any existing data in the database under the same simulation\n        name, build the connections if needed, and then call the vn_initial_mapping\n        method to set up the initial mapping for the carriers using virtual nesting.\n        \"\"\"\n        self.cnx.delete_experiment(self.eng.name)\n        logger.debug(\"building connections\")\n        num_paths = self.eng.build_connections()\n        self.eng.compute_hhi()\n        if num_paths and self.cnx.is_open:\n            database.tables.create_table_path_defs(self.cnx._connection, self.eng.paths)\n        logger.debug(f\"Connections done, num_paths = {num_paths}\")\n        self.eng.initialize_bucket_ap_rules()\n\n        # start with default number of timeframes\n        num_timeframes_default = len(self.config.dcps)\n        if len(self.config.dcps) and self.config.dcps[-1] == 0:\n            num_timeframes_default -= 1\n\n        # initialize pathclasses for each carrier, using settings from the carrier\n        # to size the history buffers\n        # Also, Q-demand can be forecasted by pathclass even in the absence of bookings\n        for carrier in self.eng.carriers:\n            self.eng.initialize_pathclasses(carrier.get_history_def(), carrier.name)\n            try:\n                self.vn_initial_mapping(carrier.name)\n            except Exception as e:\n                print(e)\n\n        # TODO: only initialize nonstop linkage when needed?\n        self.eng.initialize_nonstop_path_linkage()\n\n        # Compute a sampling probability to get approximately the number of\n        # choice sets requested\n        if self.choice_set_file is not None and self.choice_set_obs &gt; 0:\n            tot_dmd = 0\n            for d in self.config.demands:\n                if len(self.choice_set_mkts) == 0 or (d.orig, d.dest) in self.choice_set_mkts:\n                    tot_dmd += d.base_demand\n            usable_samples = self.eng.num_trials * (self.eng.num_samples - self.eng.burn_samples)\n            total_choice_sets = tot_dmd * usable_samples\n            prob = self.choice_set_obs / total_choice_sets if total_choice_sets &gt; 0 else 0\n            self.eng.choice_set_sampling_probability = prob\n            self.eng.choice_set_mkts = self.choice_set_mkts\n\n    def vn_initial_mapping(self, carrier_code):\n        \"\"\"\n        Set up initial virtual nesting mapping for a carrier.\n\n        Parameters\n        ----------\n        carrier_code : str\n            The carrier code to set up virtual nesting mapping for.\n\n        Notes\n        -----\n        This method assigns index values to path classes for carriers\n        using virtual nesting, which allows revenue management systems\n        to map between physical and virtual booking classes.\n        \"\"\"\n        for path in self.eng.paths:\n            if path.get_leg_carrier(0) == carrier_code:\n                for i, pc in enumerate(path.pathclasses):\n                    pc.set_index(0, i)\n\n    def begin_sample(self, sample: int | None = None):\n        \"\"\"\n        Begin processing a new sample in the simulation.\n\n        Parameters\n        ----------\n        sample : int or None, optional\n            The sample number to set. If None, the current sample number\n            will be incremented by 1.\n\n        Notes\n        -----\n        This method handles sample initialization including setting the\n        random seed (if configured) and preparing the simulation state\n        for the new sample.\n        \"\"\"\n        if sample is None:\n            # when sample is None, we simply increment the current sample number\n            self.eng.sample += 1\n        else:\n            # otherwise, we set the sample number to the given value\n            self.eng.sample = sample\n        if self.eng.config.simulation_controls.random_seed is not None:\n            self.reseed(\n                [\n                    self.eng.config.simulation_controls.random_seed,\n                    self.eng.trial,\n                    self.eng.sample,\n                ]\n            )\n        self.eng.reset_counters()\n        self.generate_demands()\n\n    def end_sample(self):\n        \"\"\"\n        End processing of the current sample.\n\n        Notes\n        -----\n        This method records departure statistics to carrier-level counters,\n        handles choice set and competitor data capture if configured,\n        and performs other end-of-sample cleanup and data collection tasks.\n        \"\"\"\n\n        # Record the departure statistics to carrier-level counters in the simulation\n        self.eng.record_departure_statistics()\n\n        # Roll histories to next sample\n        self.eng.next_departure()\n\n        # Commit data to the database\n        if self.cnx:\n            try:\n                self.cnx.commit()\n            except AttributeError:\n                pass\n\n        # Are we capturing choice-set data?\n        if self.choice_set_file is not None:\n            if self.eng.sample &gt; self.eng.burn_samples:\n                cs = self.eng.get_choice_set()\n                for line in cs:\n                    tmp = [str(z) for z in line]\n                    tmp2 = \",\".join(tmp)\n                    print(tmp2, file=self.choice_set_file)\n            self.eng.clear_choice_set()\n\n        # Market share computation (MIDT-lite), might move to C++ in a future version\n        alpha = 0.15\n        for m in self.eng.markets.values():\n            sold = float(m.sold)\n            for a in self.eng.carriers:\n                carrier_sold = m.get_carrier_sold(a.name)\n                share = carrier_sold / sold if sold &gt; 0 else 0\n                if self.eng.sample &gt; 1:\n                    try:\n                        old_share = m.get_carrier_share(a.name)\n                    except KeyError:\n                        old_share = 0.0\n                    new_share = alpha * share + (1.0 - alpha) * old_share\n                    m.set_carrier_share(a.name, new_share)\n                else:\n                    m.set_carrier_share(a.name, share)\n\n    def begin_trial(self, trial: int):\n        \"\"\"Beginning of trial processing.\n\n        Parameters\n        ----------\n        trial : int\n            The trial number.\n        \"\"\"\n        self.eng.trial = trial\n        logger.info(\"beginning trial %d\", trial)\n        self.eng.reset_trial_counters()\n\n        for carrier in self.eng.carriers:\n            # Initialize the histories all the various things that need them.\n            # This is by-carrier, as the carriers may eventually have different\n            # data requirements (sizes) for their history arrays.\n            self.eng.initialize_histories(\n                carrier,\n                num_departures=26,  # TODO make this a parameter\n                num_timeframes=len(self.dcp_list) - 1,\n                truncation_rule=carrier.truncation_rule,\n                store_priceable=bool(carrier.frat5),\n                floating_closures=False,\n                wipe_existing=True,\n            )\n\n    def end_trial(self):\n        \"\"\"End of trial processing.\"\"\"\n        self.extract_segmentation_by_timeframe()\n        self.extract_and_reset_bid_price_traces()\n        if self.cnx.is_open:\n            self.db_writer.final_write_to_sqlite(self.cnx._connection)\n            # self.cnx.save_final(self.sim)\n\n    def extract_and_reset_bid_price_traces(self):\n        self.bid_price_traces[self.eng.trial] = {\n            carrier.name: carrier.raw_bid_price_trace() for carrier in self.eng.carriers\n        }\n        self.displacement_traces[self.eng.trial] = {\n            carrier.name: carrier.raw_displacement_cost_trace() for carrier in self.eng.carriers\n        }\n        for carrier in self.eng.carriers:\n            carrier.reset_bid_price_trace()\n            carrier.reset_displacement_cost_trace()\n\n    def extract_segmentation_by_timeframe(\n        self,\n    ):\n        # this should be run, if desired, at the end of each trial\n        num_samples = self.eng.num_samples - self.eng.burn_samples\n        top_level = {}\n        for k in (\"bookings\", \"revenue\"):\n            data = {}\n            for carrier in self.eng.carriers:\n                carrier_data = {}\n                for segment, values in getattr(carrier, f\"raw_{k}_by_segment_fare_dcp\")().items():\n                    carrier_data[segment] = (\n                        pd.DataFrame.from_dict(values, \"columns\")\n                        .rename_axis(index=\"days_prior\", columns=\"booking_class\")\n                        .stack()\n                    )\n                if carrier_data:\n                    data[carrier.name] = pd.concat(carrier_data, axis=1, names=[\"segment\"]).fillna(0) / num_samples\n            # add non-bookings to the data dict\n            if k == \"bookings\":\n                non_bookings = pd.DataFrame.from_dict(self.eng.nonbookings_by_segment_dcp(), \"columns\").rename_axis(\n                    index=\"days_prior\", columns=\"segment\"\n                )\n                non_bookings[\"booking_class\"] = \"XX\"\n                data[\"NONE\"] = non_bookings.reset_index().set_index([\"days_prior\", \"booking_class\"]) / num_samples\n            if len(data) == 0:\n                return None\n            top_level[k] = pd.concat(data, axis=0, names=[\"carrier\"])\n        df = pd.concat(top_level, axis=1, names=[\"metric\"])\n        self.segmentation_data_by_timeframe[self.eng.trial] = df\n        return df\n\n    @contextlib.contextmanager\n    def run_single_sample(self) -&gt; int:\n        \"\"\"Context manager to run the next sample in the current trial.\n\n        On entry, the sample number is run through to departure, so all\n        sales have happened, but per-sample wrap up (e.g. rolling history\n        forward, resetting counters) is deferred until exit.  This is useful\n        for running a single sample in a testing framework.\n\n        Yields\n        ------\n        int\n            The sample number just completed.\n        \"\"\"\n        if self.eng.trial &lt; 0:\n            warnings.warn(\n                \"Trial must be started before running a sample, implicitly starting Trial 0\",\n                skip_file_prefixes=_warn_skips,\n                stacklevel=1,\n            )\n            self.begin_trial(0)\n        self.begin_sample()\n        while True:\n            event = self.eng.go()\n            self.run_carrier_models(event)\n            if event is None or str(event) == \"Done\" or (event[0] == \"Done\"):\n                assert self.eng.num_events() == 0, f\"Event queue still has {self.eng.num_events()} events\"\n                break\n        yield self.eng.sample\n        self.end_sample()\n\n    def _run_single_trial(\n        self,\n        trial: int,\n        n_samples_done: int = 0,\n        n_samples_total: int = 0,\n        progress: ProgressBar | None = None,\n        update_freq: int | None = None,\n    ):\n        \"\"\"Run a single trial of the simulation.\"\"\"\n        memory_log(f\"begin _run_single_trial {trial}\")\n        if not n_samples_total:\n            n_samples_total = self.eng.num_trials * self.eng.num_samples\n\n        self.begin_trial(trial)\n        logger.info(\"running %d samples in trial %d\", self.eng.num_samples, trial)\n        for sample in range(self.eng.num_samples):\n            sample_start_time = time.time()\n            if self.eng.config.simulation_controls.double_capacity_until:\n                # Just trying this, PODS has something similar during burn phase\n                if sample == 0:\n                    for leg in self.eng.legs:\n                        leg.capacity = leg.capacity * 2\n                elif sample == self.eng.config.simulation_controls.double_capacity_until:\n                    for leg in self.eng.legs:\n                        leg.capacity = int(leg.capacity / 2)\n\n            self.begin_sample(sample)\n            if update_freq is not None and self.eng.sample % update_freq == 0:\n                total_rev, n = 0.0, 0\n                carrier_info = \"\"\n                for cxr in self.eng.carriers:\n                    total_rev += cxr.revenue\n                    n += 1\n                    carrier_info += f\"{', ' if n &gt; 0 else ''}{cxr.name}=${cxr.revenue:8.0f}\"\n                dmd_b, dmd_l = 0, 0\n                for dmd in self.eng.demands:\n                    if dmd.business:\n                        dmd_b += dmd.scenario_demand\n                    else:\n                        dmd_l += dmd.scenario_demand\n                d_info = f\", {int(dmd_b)}, {int(dmd_l)}\"\n                logger.info(f\"Trial={self.eng.trial}, Sample={self.eng.sample}{carrier_info}{d_info}\")\n\n            # Loop on passengers\n            while True:\n                event = self.eng.go()\n                memory_log(f\"pre-run_carrier_models {event}\")\n                self.run_carrier_models(event)\n                memory_log(f\"post-run_carrier_models {event}\")\n                if event is None or str(event) == \"Done\" or (event[0] == \"Done\"):\n                    assert self.eng.num_events() == 0, f\"Event queue still has {self.eng.num_events()} events\"\n                    break\n\n            n_samples_done += 1\n            self.sample_done_callback(n_samples_done, n_samples_total)\n            self.end_sample()\n            if progress is not None:\n                progress.tick(refresh=(sample == 0))\n            t = time.time() - sample_start_time\n            logger.info(\"completed sample %i in %.2f secs\", sample, t)\n\n        self.eng.num_trials_completed += 1\n        self.end_trial()\n\n    def _run_sim(self, rich_progress: ProgressBar | None = None):\n        update_freq = self.update_frequency\n        logger.debug(f\"run_sim, num_trials = {self.eng.num_trials}, num_samples = {self.eng.num_samples}\")\n        self.db_writer.update_db_write_flags()\n        n_samples_total = self.eng.num_trials * self.eng.num_samples\n        n_samples_done = 0\n        self.sample_done_callback(n_samples_done, n_samples_total)\n        if rich_progress is None:\n            if self.eng.config.simulation_controls.show_progress_bar:\n                progress = ProgressBar(total=n_samples_total)\n            else:\n                progress = DummyProgressBar()\n        elif isinstance(rich_progress, Progress):\n            if self.eng.config.simulation_controls.show_progress_bar:\n                # if an external Progress object is provided, generate a\n                # ProgressBar object from it\n                progress = ProgressBar(total=n_samples_total, external_progress=rich_progress)\n            else:\n                progress = DummyProgressBar()\n        else:\n            raise TypeError(\"rich_progress must be a Progress object\")\n        with progress:\n            for trial in range(self.eng.num_trials):\n                self._run_single_trial(\n                    trial,\n                    n_samples_done,\n                    n_samples_total,\n                    progress,\n                    update_freq,\n                )\n\n    def _run_sim_single_trial(self, trial: int, *, rich_progress: Progress | None = None):\n        update_freq = self.update_frequency\n        self.db_writer.update_db_write_flags()\n        n_samples_total = self.eng.num_samples\n        n_samples_done = 0\n        self.sample_done_callback(n_samples_done, n_samples_total)\n        if rich_progress is None:\n            progress = DummyProgressBar()\n        elif isinstance(rich_progress, Progress):\n            progress = ProgressBar(total=n_samples_total, external_progress=rich_progress)\n        else:\n            raise TypeError(\"rich_progress must be a Progress object\")\n        with progress:\n            self._run_single_trial(\n                trial,\n                n_samples_done,\n                n_samples_total,\n                progress,\n                update_freq,\n            )\n\n    def run_carrier_models(self, info: Any = None, departed: bool = False, debug=False):\n        \"\"\"\n        Run carrier revenue management models in response to events.\n\n        Parameters\n        ----------\n        info : Any, optional\n            Event information including event type and associated data.\n        departed : bool, default False\n            Whether this is a departure event.\n        debug : bool, default False\n            Whether to enable debug output.\n\n        Notes\n        -----\n        This method processes various event types including callbacks,\n        DCP events, passenger arrivals, and departures. It coordinates\n        the execution of revenue management processes for all carriers.\n        \"\"\"\n        what_had_happened_was = []\n        try:\n            event_type = info[0]\n\n            if event_type.startswith(\"callback_\"):\n                # This is a callback function, not a string event type\n                # so, call it with the remaining arguments\n                callback_t = event_type[9:]\n                callback_f = info[1]\n                result = callback_f(self, *info[2:])\n                if isinstance(result, dict):\n                    self.callback_data.update_data(callback_t, self.eng.trial, self.eng.sample, *info[2:], **result)\n                return\n\n            recording_day = info[1]  # could in theory be non-integer for fractional days\n            dcp_index = info[2]\n            if dcp_index == -1:\n                dcp_index = len(self.dcp_list) - 1\n\n            if event_type.lower() in {\"dcp\", \"done\"}:\n                self.eng.last_dcp = recording_day\n                self.eng.last_dcp_index = dcp_index\n                # self.capture_dcp_data(dcp_index)\n                # self.capture_competitor_data()  # Simulates Infare / QL2\n\n            # Run the specified process(es) for the carriers\n            for carrier in self.eng.carriers:\n                if isinstance(carrier.rm_system, RmSys):\n                    continue\n                if carrier.rm_system is None:\n                    continue\n                if event_type.lower() == \"dcp\":\n                    # Regular Data Collection Points (pre-departure)\n                    what_had_happened_was.append(f\"run {carrier.name} DCP\")\n                    carrier.rm_system.run(\n                        self.eng,\n                        carrier.name,\n                        dcp_index,\n                        recording_day,\n                        event_type=\"dcp\",\n                    )\n                elif event_type.lower() == \"daily\":\n                    # Daily report, every day prior to departure EXCEPT specified DCPs\n                    what_had_happened_was.append(f\"run {carrier.name} daily\")\n                    carrier.rm_system.run(\n                        self.eng,\n                        carrier.name,\n                        dcp_index,\n                        recording_day,\n                        event_type=\"daily\",\n                    )\n                elif event_type.lower() == \"done\":\n                    # Post departure processing\n                    what_had_happened_was.append(f\"run {carrier.name} done\")\n                    carrier.rm_system.run(\n                        self.eng,\n                        carrier.name,\n                        dcp_index,\n                        recording_day,\n                        event_type=\"dcp\",\n                    )\n                    carrier.rm_system.run(\n                        self.eng,\n                        carrier.name,\n                        dcp_index,\n                        recording_day,\n                        event_type=\"departure\",\n                    )\n                    if self.eng.sample % 7 == 0:\n                        # Can be used less frequently,\n                        # such as ML steps on accumulated data\n                        carrier.rm_system.run(\n                            self.eng,\n                            carrier.name,\n                            dcp_index,\n                            recording_day,\n                            event_type=\"weekly\",\n                        )\n\n            # Internal simulation data capture that is normally done by RM systems\n            if event_type.lower() in {\"dcp\", \"done\"}:\n                self.eng.last_dcp = recording_day\n                self.eng.last_dcp_index = dcp_index\n                self.capture_dcp_data(dcp_index)\n                what_had_happened_was.append(\"capture_dcp_close_data\")\n                if self.eng.config.simulation_controls.capture_competitor_data:\n                    self.capture_competitor_data()  # Simulates Infare / QL2\n\n            # Database capture\n            if event_type.lower() == \"daily\":\n                if self.cnx.is_open and self.eng.save_timeframe_details and recording_day &gt; 0:\n                    # if self.sim.sample == 101:\n                    #     print(\"write_to_sqlite DAILY\")\n                    what_had_happened_was.append(\"write_to_sqlite daily\")\n                    _internal_log = self.db_writer.write_to_sqlite(\n                        self.cnx._connection,\n                        recording_day,\n                        store_bid_prices=self.eng.config.db.store_leg_bid_prices,\n                        intermediate_day=True,\n                        store_displacements=self.eng.config.db.store_displacements,\n                    )\n            elif event_type.lower() in {\"dcp\", \"done\"}:\n                if event_type.lower() == \"done\" and \"forecast_accuracy\" in self.config.outputs.reports:\n                    self.eng.capture_forecast_accuracy()\n                if self.cnx.is_open:\n                    self.cnx.save_details(self.db_writer, self.eng, recording_day)\n                if self.file_writer is not None:\n                    self.file_writer.save_details(self.eng, recording_day)\n\n            # simulation statistics record\n            if event_type.lower() in {\"dcp\", \"done\"}:\n                self.eng.record_dcp_statistics(recording_day)\n            self.eng.record_daily_statistics(recording_day)\n\n        except Exception:\n            # print(e)\n            # print(\"Error in run_carrier_models\")\n            # print(f\"{info=}\")\n            # print(\"what_had_happened_was=\", what_had_happened_was)\n            raise\n\n    def capture_competitor_data(self):\n        \"\"\"\n        Capture competitor pricing data for all markets.\n\n        Notes\n        -----\n        This method shops for the lowest prices in each market and\n        stores competitor pricing information that can be used by\n        revenue management systems for competitive analysis.\n        \"\"\"\n        for mkt in self.eng.markets.values():\n            lowest = self.eng.shop(mkt.orig, mkt.dest)\n            for cxr, price in lowest:\n                mkt.set_competitor_price(cxr, price)\n\n    def capture_dcp_data(self, dcp_index, closures_only=False):\n        \"\"\"\n        Capture data control point (DCP) data for revenue management.\n\n        Parameters\n        ----------\n        dcp_index : int\n            The index of the data control point.\n        closures_only : bool, default False\n            Whether to capture only closure data or all DCP data.\n\n        Notes\n        -----\n        This method captures seat availability, booking data, and other\n        metrics at specific time points (DCPs) before departure, which\n        is essential for revenue management decision making.\n        \"\"\"\n        for leg in self.eng.legs:\n            leg.capture_dcp(dcp_index)\n        for path in self.eng.paths:\n            path.capture_dcp(dcp_index, closures_only=closures_only)\n        for carrier in self.eng.carriers:\n            if dcp_index &gt; 0:\n                carrier.current_tf_index += 1\n\n    def _accum_by_tf(self, dcp_index):\n        # This is now replaced by C++ native counters ...\n        if dcp_index &gt; 0:\n            prev_dcp = self.dcp_list[dcp_index - 1]\n            for f in self.eng.fares:\n                curr_business = self.fare_sales_by_dcp.get((\"business\", prev_dcp), 0)\n                curr_leisure = self.fare_sales_by_dcp.get((\"leisure\", prev_dcp), 0)\n                inc_leisure = curr_leisure + (f.sold - f.sold_business)\n                inc_business = curr_business + f.sold_business\n                self.fare_sales_by_dcp[(\"business\", prev_dcp)] = inc_business\n                self.fare_sales_by_dcp[(\"leisure\", prev_dcp)] = inc_leisure\n\n                key2 = (f.carrier_name, prev_dcp)\n                curr_carrier = self.fare_sales_by_carrier_dcp[key2]\n                self.fare_sales_by_carrier_dcp[key2] = curr_carrier + f.sold\n\n                key3 = (f.carrier_name, f.booking_class, prev_dcp)\n                self.fare_details_sold[key3] += f.sold\n                self.fare_details_sold_business[key3] += f.sold_business\n                self.fare_details_revenue[key3] += f.price * f.sold\n\n    def generate_dcp_rm_events(self, debug=False):\n        \"\"\"Pushes an event per reading day (DCP) onto the queue.\n        Also adds events for daily reoptimzation\"\"\"\n        dcp_hour = self.eng.config.simulation_controls.dcp_hour\n        if debug:\n            tmp = datetime.fromtimestamp(self.eng.base_time, tz=UTC)\n            print(f\"Base Time is {tmp.strftime('%Y-%m-%d %H:%M:%S %Z')}\")\n        for dcp_index, dcp in enumerate(self.dcp_list):\n            if dcp == 0:\n                continue\n            event_time = int(self.eng.base_time - dcp * 86400 + 3600 * dcp_hour)\n            if debug:\n                tmp = datetime.fromtimestamp(event_time, tz=UTC)\n                print(f\"Added DCP {dcp} at {tmp.strftime('%Y-%m-%d %H:%M:%S %Z')}\")\n            info = (\"DCP\", dcp, dcp_index)\n            rm_event = Event(info, event_time)\n            self.eng.add_event(rm_event)\n\n        # Now add the events for daily reoptimization\n        max_days_prior = max(self.dcp_list)\n        dcp_idx = 0\n        for days_prior in reversed(range(max_days_prior)):\n            if days_prior not in self.dcp_list:\n                info = (\"daily\", days_prior, dcp_idx)\n                event_time = int(self.eng.base_time - days_prior * 86400 + 3600 * dcp_hour)\n                rm_event = Event(info, event_time)\n                self.eng.add_event(rm_event)\n            else:\n                dcp_idx += 1\n\n        # add events for begin and end sample callbacks\n        self.add_callback_events()\n\n    def generate_demands(self, system_rn=None, debug=False):\n        \"\"\"\n        Generate demands following the procedure used in PODS.\n\n        Parameters\n        ----------\n        system_rn : float or None, optional\n            System random number. If None, a new random number will be\n            generated using the simulation's random generator.\n        debug : bool, default False\n            Whether to enable debug output during demand generation.\n        \"\"\"\n        self.generate_dcp_rm_events()\n        total_events = 0\n        system_rn = self.random_generator.get_normal() if system_rn is None else system_rn\n\n        # We don't have an O&amp;D object, but we use this to get a market random number\n        # per market\n        mrn_ref = {}\n\n        # Need to have leisure / business split for PODS\n        trn_ref = {\n            \"business\": self.random_generator.get_normal(),\n            \"leisure\": self.random_generator.get_normal(),\n        }\n\n        # this stores a random number per segment\n        srn_ref = {}\n        segment_k_factor = self.eng.config.simulation_controls.segment_k_factor\n\n        def get_or_make_random(grouping, key):\n            if key not in grouping:\n                grouping[key] = self.random_generator.get_normal()\n            return grouping[key]\n\n        end_time = self.base_time\n\n        for dmd in self.eng.demands:\n            base = dmd.base_demand\n\n            if dmd.deterministic:\n                # Deterministic demand, no randomness\n                dmd.scenario_demand = base\n            else:\n                # Get the random numbers we're going to use to perturb demand\n                trn = get_or_make_random(trn_ref, (dmd.orig, dmd.dest, dmd.segment))\n                mrn = get_or_make_random(mrn_ref, (dmd.orig, dmd.dest))\n                if segment_k_factor:\n                    srn = get_or_make_random(srn_ref, dmd.segment)\n                else:\n                    srn = 0\n                if self.eng.config.simulation_controls.simple_cv100 &gt; 0.0:\n                    sigma = self.eng.config.simulation_controls.simple_cv100 * sqrt(base) * 10.0\n                    urn = self.random_generator.get_normal() * sigma\n                elif self.eng.config.simulation_controls.simple_k_factor:\n                    urn = self.random_generator.get_normal() * self.eng.config.simulation_controls.simple_k_factor\n                else:\n                    urn = 0\n\n                mu = base * (\n                    1.0\n                    + system_rn * self.eng.sys_k_factor\n                    + mrn * self.eng.mkt_k_factor\n                    + trn * self.eng.pax_type_k_factor\n                    + srn * segment_k_factor\n                    + urn\n                )\n                mu = max(mu, 0.0)\n                sigma = sqrt(mu * self.eng.config.simulation_controls.tot_z_factor)  # Correct?\n                n = mu + sigma * self.random_generator.get_normal()\n                dmd.scenario_demand = max(n, 0)\n\n                if debug:\n                    logger.debug(\n                        f\"DMD,{self.eng.sample},{dmd.orig},{dmd.dest},\"\n                        f\"{dmd.segment},{dmd.base_demand},\"\n                        f\"{round(mu, 2)},{round(sigma, 2)},{round(n, 2)}\"\n                    )\n\n            # Now we split it up over timeframes and add it to the simulation\n            num_pax = int(dmd.scenario_demand + 0.5)  # rounding\n            if self.eng.config.simulation_controls.timeframe_demand_allocation == \"pods\":\n                num_events_by_tf = self.eng.allocate_demand_to_tf_pods(\n                    dmd, num_pax, self.eng.tf_k_factor, int(end_time)\n                )\n            else:\n                num_events_by_tf = self.eng.allocate_demand_to_tf(dmd, num_pax, self.eng.tf_k_factor, int(end_time))\n            num_events = sum(num_events_by_tf)\n            total_events += num_events\n            if num_events != round(num_pax):\n                raise ValueError(f\"Generate demand function, num_pax={num_pax}, num_events={num_events}\")\n\n        return total_events\n\n    def generate_demands_gamma(self, system_rn=None, debug=False):\n        \"\"\"Using this as a quick test\"\"\"\n        self.generate_dcp_rm_events()\n        end_time = self.base_time\n        cv100 = 0.3\n        for dmd in self.eng.demands:\n            mu = dmd.base_demand\n            std_dev = cv100 * sqrt(mu) * 10.0\n            # std_dev = mu * 0.3\n            var = std_dev**2\n            shape_a = mu**2 / var\n            scale_b = var / mu\n            loc = 0.0\n            r = gamma.rvs(shape_a, loc, scale_b, size=1)\n            num_pax = int(r[0] + 0.5)\n            dmd.scenario_demand = num_pax\n            self.eng.allocate_demand_to_tf_pods(dmd, num_pax, self.eng.tf_k_factor, int(end_time))\n        total_events = 0\n        return total_events\n\n    def compute_reports(\n        self,\n        sim: SimulationEngine,\n        to_log=True,\n        to_db: bool | database.Database = True,\n        additional=(\n            \"fare_class_mix\",\n            \"load_factors\",\n            # \"bookings_by_timeframe\",\n            \"total_demand\",\n        ),\n    ) -&gt; SummaryTables:\n        \"\"\"\n        Compute comprehensive simulation reports.\n\n        Parameters\n        ----------\n        sim : SimulationEngine\n            The simulation engine instance to generate reports from.\n        to_log : bool, default True\n            Whether to log report summaries.\n        to_db : bool or database.Database, default True\n            Database connection or boolean indicating whether to write\n            reports to database.\n        additional : tuple, optional\n            Additional report types to include. Options include\n            'fare_class_mix', 'load_factors', 'total_demand'.\n\n        Returns\n        -------\n        SummaryTables\n            Object containing all computed reports including leg, path,\n            carrier, and other summary statistics.\n\n        Raises\n        ------\n        ValueError\n            If no samples have been completed in the simulation.\n        \"\"\"\n        num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n        if num_samples &lt;= 0:\n            raise ValueError(\n                \"insufficient number of samples outside burn period for reporting\"\n                f\"\\n- num_trials = {sim.num_trials}\"\n                f\"\\n- num_samples = {sim.num_samples}\"\n                f\"\\n- burn_samples = {sim.burn_samples}\"\n            )\n\n        if to_db is True:\n            to_db = self.cnx\n        class_dist_df = self.compute_class_dist(sim, to_log, to_db)\n        dmd_df = self.compute_demand_report(sim, to_log, to_db)\n        fare_df = self.compute_fare_report(sim, to_log, to_db)\n        leg_df = self.compute_leg_report(sim, to_log, to_db)\n        path_df = self.compute_path_report(sim, to_log, to_db)\n        path_classes_df = self.compute_path_class_report(sim, to_log, to_db)\n        carrier_df = self.compute_carrier_report(sim, to_log, to_db)\n        segmentation_df = self.compute_segmentation_by_timeframe()\n        raw_load_factor_dist_df = self.compute_raw_load_factor_distribution(sim, to_log, to_db)\n        leg_avg_load_factor_dist_df = self.compute_leg_avg_load_factor_distribution(sim, to_log, to_db)\n        fare_class_dist_df = self.compute_raw_fare_class_mix(sim, to_log, to_db)\n        bid_price_history_df = self.compute_bid_price_history(sim, to_log, to_db)\n        displacement_df = self.compute_displacement_history(sim, to_log, to_db)\n        demand_to_come_df = self.compute_demand_to_come_summary(sim, to_log, to_db)\n        local_fraction_dist_df = self.compute_leg_local_fraction_distribution(sim, to_log, to_db)\n        local_fraction_by_place = self.compute_local_fraction_by_place(sim, to_log, to_db)\n\n        summary = SummaryTables(\n            name=sim.name,\n            class_dist=class_dist_df,\n            config=sim.config,\n            demands=dmd_df,\n            fares=fare_df,\n            legs=leg_df,\n            paths=path_df,\n            path_classes=path_classes_df,\n            carriers=carrier_df,\n            bid_price_history=bid_price_history_df,\n            raw_load_factor_distribution=raw_load_factor_dist_df,\n            leg_avg_load_factor_distribution=leg_avg_load_factor_dist_df,\n            raw_fare_class_mix=fare_class_dist_df,\n            leg_local_fraction_distribution=local_fraction_dist_df,\n            local_fraction_by_place=local_fraction_by_place,\n            n_total_samples=num_samples,\n            segmentation_by_timeframe=segmentation_df,\n            displacement_history=displacement_df,\n            demand_to_come_summary=demand_to_come_df,\n        )\n        summary.load_additional_tables(self.cnx, sim.name, sim.burn_samples, additional)\n        summary.cnx = self.cnx\n        return summary\n\n    def compute_demand_report(self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None):\n        \"\"\"\n        Compute a demand report for the simulation.\n\n        Parameters\n        ----------\n        sim : SimulationEngine\n            The simulation engine instance to generate the report from.\n        to_log : bool, default True\n            Whether to log the report summary.\n        to_db : database.Database or None, optional\n            Database connection to write the report to.\n\n        Returns\n        -------\n        pd.DataFrame\n            DataFrame containing demand statistics including origin,\n            destination, segment, sold units, revenue, and other metrics.\n        \"\"\"\n        dmd_df = []\n        for m in sim.demands:\n            avg_price = m.revenue / m.sold if m.sold &gt; 0 else 0\n            dmd_df.append(\n                dict(\n                    orig=m.orig,\n                    dest=m.dest,\n                    segment=m.segment,\n                    sold=m.sold,\n                    revenue=m.revenue,\n                    avg_fare=m.revenue / m.sold if m.sold &gt; 0 else 0,\n                    gt_demand=m.gt_demand,\n                    gt_sold=m.gt_sold,\n                    gt_revenue=m.gt_revenue,\n                )\n            )\n            if to_log:\n                logger.info(\n                    f\"   Dmd: {m.orig}-{m.dest}:{m.segment}\"\n                    f\"  Sold = {m.sold},  \"\n                    f\"Rev = {m.revenue}, \"\n                    f\"AvgFare = {avg_price:.2f}\"\n                )\n        dmd_df = pd.DataFrame(dmd_df)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"demand_summary\", dmd_df)\n        return dmd_df\n\n    def compute_class_dist(self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None):\n        # Get unique segments\n        segs = set([dmd.segment for dmd in sim.demands])\n        dist = defaultdict(int)\n        for f in sim.fares:\n            for seg in segs:\n                k = (f.booking_class, seg)\n                try:\n                    dist[k] += f.get_sales_by_segment(seg)\n                except Exception:\n                    # If the segment isn't found, just ignore it.\n                    # i.e. basic economy won't book Y0\n                    pass\n\n        class_dist_df = []\n        for (cls, seg), sold in dist.items():\n            class_dist_df.append(dict(booking_class=cls, segment=seg, sold=sold))\n        class_dist_df = pd.DataFrame(class_dist_df)\n        return class_dist_df\n\n    def compute_fare_report(self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None):\n        fare_df = []\n        for f in sim.fares:\n            for dcp_index, days_prior in enumerate(self.dcp_list):\n                fare_df.append(\n                    dict(\n                        carrier=f.carrier.name,\n                        orig=f.orig,\n                        dest=f.dest,\n                        booking_class=f.booking_class,\n                        dcp_index=dcp_index,\n                        price=f.price,\n                        sold=f.get_sales_by_dcp2(days_prior),\n                        gt_sold=f.gt_sold,\n                        avg_adjusted_price=f.get_adjusted_by_dcp(dcp_index),\n                    )\n                )\n                if to_log:\n                    logger.info(\n                        f\"   Fare: {f.carrier} {f.orig}-{f.dest}:{f.booking_class}\"\n                        # f\"AvgAdjFare = {avg_adj_price:.2f},\"\n                        f\"  Sold = {f.sold},  \"\n                        f\"Price = {f.price}\"\n                    )\n        fare_df = pd.DataFrame(fare_df)\n        #        if to_db and to_db.is_open:\n        #            to_db.save_dataframe(\"fare_summary\", fare_df)\n        return fare_df\n\n    def compute_leg_report(self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None):\n        num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n        leg_df = []\n        for leg in sim.legs:\n            # Checking consistency while I debug the cabin code\n            sum_b1, sum_b2 = 0, 0\n            for b in leg.buckets:\n                sum_b1 += b.sold\n            for c in leg.cabins:\n                for b in c.buckets:\n                    sum_b2 += b.sold\n            if sum_b1 != sum_b2:\n                print(\"Oh, crap!\")\n            avg_sold = leg.gt_sold / num_samples\n            avg_rev = leg.gt_revenue / num_samples\n            lf = 100.0 * leg.gt_sold / (leg.capacity * num_samples)\n            if to_log:\n                logger.info(\n                    f\"    Leg: {leg.carrier}:{leg.flt_no} {leg.orig}-{leg.dest}: \"\n                    f\" AvgSold = {avg_sold:6.2f},  AvgRev = ${avg_rev:,.2f}, \"\n                    f\"LF = {lf:,.2f}%\"\n                )\n            leg_df.append(\n                dict(\n                    leg_id=leg.leg_id,\n                    carrier=leg.carrier_name,\n                    flt_no=leg.flt_no,\n                    orig=leg.orig,\n                    dest=leg.dest,\n                    avg_sold=avg_sold,\n                    avg_rev=avg_rev,\n                    lf=lf,\n                )\n            )\n        leg_df = pd.DataFrame(leg_df)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"leg_summary\", leg_df)\n        return leg_df\n\n    def compute_path_report(self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None):\n        num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n        avg_lf, n = 0.0, 0\n        for leg in sim.legs:\n            lf = 100.0 * leg.gt_sold / (leg.capacity * num_samples)\n            avg_lf += lf\n            n += 1\n\n        tot_rev = 0.0\n        for m in sim.demands:\n            tot_rev += m.revenue\n\n        avg_lf = avg_lf / n if n &gt; 0 else 0\n        if to_log:\n            logger.info(f\"    LF:  {avg_lf:6.2f}%, Total revenue = ${tot_rev:,.2f}\")\n\n        path_df = []\n        for path in sim.paths:\n            avg_sold = path.gt_sold / num_samples\n            avg_sold_priceable = path.gt_sold_priceable / num_samples\n            avg_rev = path.gt_revenue / num_samples\n            if to_log:\n                logger.info(f\"{path}, avg_sold={avg_sold:6.2f}, avg_rev=${avg_rev:10,.2f}\")\n            data = dict(\n                orig=path.orig,\n                dest=path.dest,\n                carrier1=path.get_leg_carrier(0),\n                leg_id1=path.get_leg_id(0),\n                carrier2=None,\n                leg_id2=None,\n                carrier3=None,\n                leg_id3=None,\n                avg_sold=avg_sold,\n                avg_sold_priceable=avg_sold_priceable,\n                avg_rev=avg_rev,\n            )\n            if path.num_legs() == 1:\n                path_df.append(data)\n            elif path.num_legs() == 2:\n                data[\"carrier2\"] = path.get_leg_carrier(1)\n                data[\"leg_id2\"] = path.get_leg_id(1)\n                path_df.append(data)\n            elif path.num_legs() == 3:\n                data[\"carrier2\"] = path.get_leg_carrier(1)\n                data[\"leg_id2\"] = path.get_leg_id(1)\n                data[\"carrier3\"] = path.get_leg_carrier(2)\n                data[\"leg_id3\"] = path.get_leg_id(2)\n                path_df.append(data)\n            else:\n                raise NotImplementedError(\"path with more than 3 legs\")\n        path_df = pd.DataFrame(path_df)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"path_summary\", path_df)\n        return path_df\n\n    def compute_path_class_report(self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None):\n        num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n\n        path_class_df = []\n        for path in sim.paths:\n            for pc in path.pathclasses:\n                avg_sold = pc.gt_sold / num_samples\n                avg_sold_priceable = pc.gt_sold_priceable / num_samples\n                avg_rev = pc.gt_revenue / num_samples\n                if to_log:\n                    logger.info(f\"{pc}, avg_sold={avg_sold:6.2f}, avg_rev=${avg_rev:10,.2f}\")\n                data = dict(\n                    orig=path.orig,\n                    dest=path.dest,\n                    carrier1=path.get_leg_carrier(0),\n                    leg_id1=path.get_leg_id(0),\n                    carrier2=None,\n                    leg_id2=None,\n                    carrier3=None,\n                    leg_id3=None,\n                    booking_class=pc.booking_class,\n                    avg_sold=avg_sold,\n                    avg_sold_priceable=avg_sold_priceable,\n                    avg_rev=avg_rev,\n                )\n                if path.num_legs() == 1:\n                    path_class_df.append(data)\n                elif path.num_legs() == 2:\n                    data[\"carrier2\"] = path.get_leg_carrier(1)\n                    data[\"leg_id2\"] = path.get_leg_id(1)\n                    path_class_df.append(data)\n                elif path.num_legs() == 3:\n                    data[\"carrier2\"] = path.get_leg_carrier(1)\n                    data[\"leg_id2\"] = path.get_leg_id(1)\n                    data[\"carrier3\"] = path.get_leg_carrier(2)\n                    data[\"leg_id3\"] = path.get_leg_id(2)\n                    path_class_df.append(data)\n                else:\n                    raise NotImplementedError(\"path with more than 3 legs\")\n        path_class_df = pd.DataFrame(path_class_df)\n        if not path_class_df.empty:\n            path_class_df.sort_values(by=[\"orig\", \"dest\", \"carrier1\", \"leg_id1\", \"booking_class\"])\n            #        if to_db and to_db.is_open:\n            #            to_db.save_dataframe(\"path_class_summary\", path_class_df)\n        return path_class_df\n\n    def compute_carrier_report(\n        self,\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Compute a carrier summary table.\n\n        The resulting table has one row per simulated carrier, and the following\n        columns:\n\n        - name\n        - avg_sold\n        - load_factor\n        - avg_rev\n        - asm (available seat miles)\n        - rpm (revenue passenger miles)\n        \"\"\"\n        num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n        carrier_df = []\n\n        carrier_asm = defaultdict(float)\n        carrier_rpm = defaultdict(float)\n        carrier_leg_lf = defaultdict(float)\n        carrier_leg_count = defaultdict(float)\n        for leg in sim.legs:\n            carrier_name = leg.carrier_name if hasattr(leg, \"carrier_name\") else leg.carrier  # TODO: remove hasattr\n            carrier_asm[carrier_name] += leg.distance * leg.capacity * num_samples\n            carrier_rpm[carrier_name] += leg.distance * leg.gt_sold\n            carrier_leg_lf[carrier_name] += leg.gt_sold / (leg.capacity * num_samples)\n            carrier_leg_count[carrier_name] += 1\n\n        for cxr in sim.carriers:\n            avg_sold = cxr.gt_sold / num_samples\n            avg_rev = cxr.gt_revenue / num_samples\n            asm = carrier_asm[cxr.name] / num_samples\n            rpm = carrier_rpm[cxr.name] / num_samples\n            # sys_lf = 100.0 * cxr.gt_revenue_passenger_miles / asm if asm &gt; 0 else 0.0\n            denom = carrier_asm[cxr.name]\n            sys_lf = (100.0 * carrier_rpm[cxr.name] / denom) if denom &gt; 0 else 0\n            if to_log:\n                logger.info(\n                    f\"Carrier: {cxr.name}, AvgSold: {round(avg_sold, 2)}, LF {sys_lf:.2f}%,  AvgRev ${avg_rev:10,.2f}\"\n                )\n\n            # Add up total ancillaries\n            tot_anc_rev = 0.0\n            for anc in cxr.ancillaries:\n                print(str(anc))\n                tot_anc_rev += anc.price * anc.sold\n\n            carrier_df.append(\n                {\n                    \"carrier\": cxr.name,\n                    \"sold\": avg_sold,\n                    \"sys_lf\": sys_lf,\n                    \"avg_leg_lf\": 100 * carrier_leg_lf[cxr.name] / max(carrier_leg_count[cxr.name], 1),\n                    \"avg_rev\": avg_rev,\n                    \"avg_price\": avg_rev / avg_sold if avg_sold &gt; 0 else 0,\n                    \"asm\": asm,\n                    \"rpm\": rpm,\n                    \"yield\": np.nan if rpm == 0 else avg_rev / rpm,\n                    \"ancillary_rev\": tot_anc_rev,\n                }\n            )\n        carrier_df = pd.DataFrame(carrier_df)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"carrier_summary\", carrier_df)\n        return carrier_df\n\n    def compute_segmentation_by_timeframe(self) -&gt; pd.DataFrame | None:\n        if self.segmentation_data_by_timeframe:\n            df = (\n                pd.concat(self.segmentation_data_by_timeframe, axis=0, names=[\"trial\"])\n                .reorder_levels([\"trial\", \"carrier\", \"booking_class\", \"days_prior\"])\n                .sort_index()\n            )\n            # df[\"Total\"] = df.sum(axis=1)\n            return df\n\n    @staticmethod\n    def compute_raw_load_factor_distribution(\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Compute a load factor distribution report.\n\n        This report is a dataframe, with integer index values from 0 to 100,\n        and column for each carrier in the simulation. The values are the\n        frequency of each leg load factor observed during the simulation\n        (excluding any burn period).  The values for leg load factors are\n        rounded down, so that a leg load factor of 99.9% is counted as 99,\n        and only actually sold-out flights are in the 100% bin.\n        \"\"\"\n        result = {}\n        for carrier in sim.carriers:\n            lf = pd.Series(\n                carrier.raw_load_factor_distribution(),\n                index=pd.RangeIndex(101, name=\"leg_load_factor\"),\n                name=\"frequency\",\n            )\n            result[carrier.name] = lf\n        if result:\n            df = pd.concat(result, axis=1, names=[\"carrier\"])\n        else:\n            df = pd.DataFrame(index=pd.RangeIndex(101, name=\"leg_load_factor\"), columns=[])\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"raw_load_factor_distribution\", df)\n        return df\n\n    @staticmethod\n    def compute_leg_avg_load_factor_distribution(\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Compute a leg average load factor distribution report.\n\n        This report is a dataframe, with integer index values from 0 to 100,\n        and column for each carrier in the simulation. The values are the\n        frequency of each leg average load factor observed over the simulation\n        (excluding any burn period).  The values for leg average load factors\n        are rounded down, so that a leg average load factor of 99.9% is counted\n        as 99, and only always sold-out flights are in the 100% bin.\n\n        This is different from the raw load factor distribution, which is the\n        distribution of load factors across sample days.  The number of\n        observations in the leg average load factor (this distribution) is\n        equal to the number of legs, while the raw load factor distribution\n        has one observation per leg per sample day.  The variance of this\n        distribution is much lower than the raw load factor distribution.\n        \"\"\"\n        idx = pd.RangeIndex(101, name=\"leg_load_factor\")\n        result = {carrier.name: pd.Series(np.zeros(101, dtype=np.int32), index=idx) for carrier in sim.carriers}\n        for leg in sim.legs:\n            try:\n                lf = int(np.floor(leg.avg_load_factor()))\n            except TypeError:\n                # TODO: remove this\n                lf = int(np.floor(leg.avg_load_factor))\n            if lf &gt; 100:\n                lf = 100\n            if lf &lt; 0:\n                lf = 0\n            # TODO remove hasattr\n            result[leg.carrier_name if hasattr(leg, \"carrier_name\") else leg.carrier].iloc[lf] += 1\n        if result:\n            df = pd.concat(result, axis=1, names=[\"carrier\"])\n        else:\n            df = pd.DataFrame(index=pd.RangeIndex(101, name=\"leg_load_factor\"), columns=[])\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"leg_avg_load_factor_distribution\", df)\n        return df\n\n    def compute_raw_fare_class_mix(\n        self,\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Compute a fare class distribution report.\n\n        This report is a dataframe, with index values giving the fare class,\n        and column for each carrier in the simulation. The values are the\n        number of passengers for each fare class observed during the simulation\n        (excluding any burn period). This is a count of passengers not legs, so\n        a passenger on a connecting itinerary only counts once.\n        \"\"\"\n        result = {}\n        for carrier in sim.carriers:\n            fc = carrier.raw_fare_class_distribution()\n            fc_sold = pd.Series(\n                {k: v[\"sold\"] for k, v in fc.items()},\n                name=\"frequency\",\n            )\n            fc_rev = pd.Series(\n                {k: v[\"revenue\"] for k, v in fc.items()},\n                name=\"frequency\",\n            )\n            result[carrier.name] = pd.concat([fc_sold, fc_rev], axis=1, keys=[\"sold\", \"revenue\"]).rename_axis(\n                index=\"booking_class\"\n            )\n        if result:\n            df = pd.concat(result, axis=0, names=[\"carrier\"])\n        else:\n            df = pd.DataFrame(\n                columns=[\"sold\", \"revenue\"],\n                index=pd.MultiIndex([[], []], [[], []], names=[\"carrier\", \"booking_class\"]),\n            )\n        df = df.fillna(0)\n        df[\"sold\"] = df[\"sold\"].astype(int)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"fare_class_distribution\", df)\n        return df\n\n    @staticmethod\n    def compute_bid_price_history(\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Compute the average bid price history for each carrier.\"\"\"\n        result = {}\n        for carrier in sim.carriers:\n            bp = carrier.raw_bid_price_trace()\n            result[carrier.name] = (\n                pd.DataFrame.from_dict(bp, orient=\"index\").sort_index(ascending=False).rename_axis(index=\"days_prior\")\n            )\n        if result:\n            df = pd.concat(result, axis=0, names=[\"carrier\"])\n        else:\n            df = pd.DataFrame(\n                columns=[\n                    \"bid_price_mean\",\n                    \"bid_price_stdev\",\n                    \"some_cap_bid_price_mean\",\n                    \"some_cap_bid_price_stdev\",\n                    \"fraction_some_cap\",\n                    \"fraction_zero_cap\",\n                ],\n                index=pd.MultiIndex([[], []], [[], []], names=[\"carrier\", \"days_prior\"]),\n            )\n        df = df.fillna(0)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"bid_price_history\", df)\n        return df\n\n    @staticmethod\n    def compute_displacement_history(\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Compute the average displacement cost history for each carrier.\"\"\"\n        result = {}\n        for carrier in sim.carriers:\n            bp = carrier.raw_displacement_cost_trace()\n            result[carrier.name] = (\n                pd.DataFrame.from_dict(bp, orient=\"index\").sort_index(ascending=False).rename_axis(index=\"days_prior\")\n            )\n        if result:\n            df = pd.concat(result, axis=0, names=[\"carrier\"])\n        else:\n            df = pd.DataFrame(\n                columns=[\n                    \"displacement_mean\",\n                    \"displacement_stdev\",\n                ],\n                index=pd.MultiIndex([[], []], [[], []], names=[\"carrier\", \"days_prior\"]),\n            )\n        df = df.fillna(0)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"displacement_history\", df)\n        return df\n\n    @staticmethod\n    def compute_demand_to_come_summary(\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        raw = sim.summary_demand_to_come()\n        df = (\n            from_nested_dict(raw, [\"segment\", \"days_prior\", \"metric\"])\n            .sort_index(ascending=[True, False])\n            .rename(columns={\"mean\": \"mean_future_demand\", \"stdev\": \"stdev_future_demand\"})\n        )\n        return df\n\n    def compute_leg_local_fraction_distribution(\n        self,\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Compute a report on the fraction of leg passengers who are local.\n\n        This report is a dataframe, with integer index values from 0 to 100,\n        and column for each carrier in the simulation. The values are the\n        frequency of the local leg-passenger fraction on each leg observed\n        over the simulation (excluding any burn period).  The values are\n        rounded down, so that a leg local fraction of 99.9% is counted\n        as 99, and only always-local flights are in the 100% bin.\n        \"\"\"\n        result = {}\n        for carrier in sim.carriers:\n            lf = pd.Series(\n                sim.distribution_local_leg_passengers(carrier),\n                index=pd.RangeIndex(101, name=\"local_fraction\"),\n                name=\"frequency\",\n            )\n            result[carrier.name] = lf\n        if result:\n            df = pd.concat(result, axis=1, names=[\"carrier\"])\n        else:\n            df = pd.DataFrame(index=pd.RangeIndex(101, name=\"local_fraction\"), columns=[])\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"leg_local_fraction_distribution\", df)\n        return df\n\n    def compute_local_fraction_by_place(\n        self,\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Compute a report on the fraction of leg passengers who are local.\n\n        Parameters\n        ----------\n        sim\n        to_log\n        to_db\n\n        Returns\n        -------\n        pd.DataFrame\n        \"\"\"\n        result = {}\n        for carrier in sim.carriers:\n            df = pd.Series(\n                sim.fraction_local_by_carrier_and_place(carrier.name),\n                name=carrier.name,\n            )\n            result[carrier.name] = df\n        if result:\n            df = pd.concat(result, axis=1, names=[\"carrier\"])\n        else:\n            df = pd.DataFrame(index=[], columns=[])\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"local_fraction_by_place\", df)\n        return df\n\n    def reseed(self, seed: int | list[int] | None = 42):\n        \"\"\"\n        Reseed the simulation's random number generator.\n\n        Parameters\n        ----------\n        seed : int, list[int], or None, default 42\n            Seed value(s) for the random number generator. Can be a single\n            integer, a list of integers, or None.\n\n        Notes\n        -----\n        This method updates the random seed for the simulation's internal\n        random number generator, affecting all subsequent random operations.\n        \"\"\"\n        logger.debug(\"reseeding random_generator: %s\", seed)\n        self.eng.random_generator.seed(seed)\n\n    def _user_certificate(self, certificate_filename=None):\n        if certificate_filename:\n            from cryptography.x509 import load_pem_x509_certificate\n\n            certificate_filename = pathlib.Path(certificate_filename)\n            with certificate_filename.open(\"rb\") as f:\n                user_cert = load_pem_x509_certificate(f.read())\n        else:\n            user_cert = self.eng.config.license_certificate\n        return user_cert\n\n    def validate_license(self, certificate_filename=None, future: int = 0):\n        user_cert = self._user_certificate(certificate_filename)\n        return self.eng.validate_license(user_cert, future=future)\n\n    def license_info(self, certificate_filename=None):\n        user_cert = self._user_certificate(certificate_filename)\n        return self.eng.license_info(user_cert)\n\n    @property\n    def config(self) -&gt; Config:\n        \"\"\"The configuration used for this Simulation.\"\"\"\n        return self.eng.config\n\n    def run(\n        self,\n        log_reports: bool = False,\n        *,\n        single_trial: int | None = None,\n        summarizer: type[SimulationTablesT] | SimulationTablesT | None = SimulationTables,\n        rich_progress: Progress | None = None,\n    ) -&gt; SummaryTables | SimulationTablesT:\n        \"\"\"\n        Run the simulation and compute reports.\n\n        Parameters\n        ----------\n        log_reports : bool\n        single_trial : int, optional\n            Run only a single trial, with the given trial number (to get\n            the correct fixed random seed, for example).\n        summarizer : type[SimulationTables] | SimulationTables | None\n            Use this summarizer to compute the reports.  If None, the\n            reports are computed in the SummaryTables object; this option\n            is deprecated and will eventually be removed.\n        rich_progress : Progress, optional\n            A rich Progress object to use for displaying progress.  If not\n            provided, a new Progress object will be created unless the\n            simulation configuration specifies not to show progress.\n\n        Returns\n        -------\n        SimulationTables or SummaryTables\n        \"\"\"\n        if summarizer is None:\n            warnings.warn(\n                \"Using SummaryTables to compute reports is deprecated, prefer SimulationTables in new code.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n\n        start_time = time.time()\n        self.setup_scenario()\n        if single_trial is not None:\n            self._run_sim_single_trial(single_trial, rich_progress=rich_progress)\n        else:\n            self._run_sim(rich_progress=rich_progress)\n        if self.choice_set_file is not None:\n            self.choice_set_file.close()\n        logger.info(\"Computing reports\")\n        if summarizer is None:\n            summary = self.compute_reports(\n                self.eng,\n                to_log=log_reports or self.eng.config.outputs.log_reports,\n                additional=self.eng.config.outputs.reports,\n            )\n            logger.info(\"Saving reports\")\n            if self.eng.config.outputs.excel:\n                summary.to_xlsx(self.eng.config.outputs.excel)\n        else:\n            if isinstance(summarizer, GenericSimulationTables):\n                summary = summarizer._extract(self)\n            elif issubclass(summarizer, GenericSimulationTables):\n                summary = summarizer.extract(self)\n            else:\n                raise TypeError(\"summarizer must be an instance or subclass of GenericSimulationTables\")\n\n        # check all callbacks for tracers, and if any are found, write their\n        # finalized data to callback_data\n        for cb_group in [\n            \"daily_callbacks\",\n            \"begin_sample_callbacks\",\n            \"end_sample_callbacks\",\n        ]:\n            for cb in getattr(self, cb_group, []):\n                if isinstance(cb, GenericTracer):\n                    summary.callback_data[cb.name] = cb.finalize()\n\n        # write output files if designated\n        if isinstance(summary, GenericSimulationTables):\n            if self.config.outputs.html and (\n                self.config.outputs.disk is True or self.config.outputs.html.filename == self.config.outputs.disk\n            ):\n                # this will ensure the html and disk files have the same timestamp\n                filenames = summary.save(self.config.outputs.html.filename)\n                summary._metadata[\"outputs.html_filename\"] = filenames[\".html\"]\n                summary._metadata[\"outputs.disk_filename\"] = filenames[\".pxsim\"]\n            else:\n                if self.config.outputs.html:\n                    out_filename = summary.to_html(self.config.outputs.html.filename)\n                    summary._metadata[\"outputs.html_filename\"] = out_filename\n                if isinstance(self.config.outputs.disk, str | pathlib.Path):\n                    out_filename = summary.to_file(self.config.outputs.disk)\n                    summary._metadata[\"outputs.disk_filename\"] = out_filename\n            if self.config.outputs.pickle:\n                pkl_filename = summary.to_pickle(self.config.outputs.pickle)\n                summary._metadata[\"outputs.pickle_filename\"] = pkl_filename\n            if self.config.outputs.excel:\n                summary.to_xlsx(self.config.outputs.excel)\n\n        logger.info(f\"Th' th' that's all folks !!!    (Elapsed time = {round(time.time() - start_time, 2)})\")\n        return summary\n\n    def run_trial(self, trial: int, log_reports: bool = False) -&gt; SummaryTables:\n        self.setup_scenario()\n        self.eng.trial = trial\n\n        update_freq = self.update_frequency\n        logger.debug(f\"run_sim, num_trials = {self.eng.num_trials}, num_samples = {self.eng.num_samples}\")\n        self.db_writer.update_db_write_flags()\n        n_samples_total = self.eng.num_samples\n        n_samples_done = 0\n        self.sample_done_callback(n_samples_done, n_samples_total)\n        if self.eng.config.simulation_controls.show_progress_bar:\n            progress = ProgressBar(total=n_samples_total)\n        else:\n            progress = DummyProgressBar()\n        with progress:\n            self._run_single_trial(\n                trial,\n                n_samples_done,\n                n_samples_total,\n                progress,\n                update_freq,\n            )\n        summary = self.compute_reports(\n            self.eng,\n            to_log=log_reports or self.eng.config.outputs.log_reports,\n            additional=self.eng.config.outputs.reports,\n        )\n        return summary\n\n    def backup_db(self, dst: pathlib.Path | str | sqlite3.Connection):\n        \"\"\"Back up this database to another copy.\n\n        Parameters\n        ----------\n        dst : Path-like or sqlite3.Connection\n        \"\"\"\n        return self.cnx.backup(dst)\n\n    def get_choice_parameters(self, choicemodel: str | ChoiceModel):\n        \"\"\"\n        Get the parameters for a choice model.\n\n        Parameters\n        ----------\n        choicemodel : str or ChoiceModel\n            The choice model name (string) or ChoiceModel object to get\n            parameters from.\n\n        Returns\n        -------\n        dict\n            Dictionary containing the choice model parameters, including\n            restrictions and their associated sigma values.\n        \"\"\"\n        if isinstance(choicemodel, str):\n            choicemodel = self.choice_models[choicemodel]\n        raw = choicemodel.get_parameters()\n        r = raw.pop(\"restrictions\", ())\n        rsigma = raw.pop(\"restriction_sigmas\", ())\n        for rname, rval, rsig in zip(self._fare_restriction_list, r, rsigma):\n            raw[f\"restrictions_{rname}\"] = rval\n            raw[f\"restrictions_{rname}_sigma\"] = rsig\n        return raw\n\n    def set_choice_parameters(self, choicemodel: str | ChoiceModel, values: dict[str, float]):\n        \"\"\"\n        Set the parameters for a choice model.\n\n        Parameters\n        ----------\n        choicemodel : str or ChoiceModel\n            The choice model name (string) or ChoiceModel object to update.\n        values : dict[str, float]\n            Dictionary of parameter names and their new values. Can include\n            restriction parameters using the format 'restrictions_{name}'.\n        \"\"\"\n        if isinstance(choicemodel, str):\n            choicemodel = self.choice_models[choicemodel]\n        raw = choicemodel.get_parameters()\n        for k, v in values.items():\n            if k.startswith(\"restrictions_\"):\n                if k.endswith(\"_sigma\"):\n                    kr = k[13:-6]\n                else:\n                    kr = k[13:]\n                position = self._fare_restriction_mapping[kr] - 1\n                if k.endswith(\"_sigma\"):\n                    raw[\"restriction_sigmas\"][position] = v\n                else:\n                    raw[\"restrictions\"][position] = v\n            else:\n                raw[k] = v\n        choicemodel.set_parameters(raw)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.airports", "title": "airports  <code>instance-attribute</code>", "text": "<pre><code>airports = {}\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.base_time", "title": "base_time  <code>property</code>", "text": "<pre><code>base_time: int\n</code></pre> <p>The base time for the simulation.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The base time in seconds since the epoch.</p> </li> </ul>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.bid_price_traces", "title": "bid_price_traces  <code>instance-attribute</code>", "text": "<pre><code>bid_price_traces: dict[int, Any] = {}\n</code></pre> <p>Bid price traces for each carrier.</p> <p>The key is the trial number, and the value is a dictionary with carrier names as keys and bid price traces as values.</p>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.callback_data", "title": "callback_data  <code>instance-attribute</code>", "text": "<pre><code>callback_data = CallbackData()\n</code></pre> <p>Data stored from callbacks.</p> <p>This allows a user to store arbitrary data during a simulation using callbacks, and access it later.</p>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.capacity_multiplier", "title": "capacity_multiplier  <code>instance-attribute</code>", "text": "<pre><code>capacity_multiplier = 1.0\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.choice_models", "title": "choice_models  <code>instance-attribute</code>", "text": "<pre><code>choice_models = {}\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.choice_set_file", "title": "choice_set_file  <code>instance-attribute</code>", "text": "<pre><code>choice_set_file = None\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.choice_set_mkts", "title": "choice_set_mkts  <code>instance-attribute</code>", "text": "<pre><code>choice_set_mkts = []\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.choice_set_obs", "title": "choice_set_obs  <code>instance-attribute</code>", "text": "<pre><code>choice_set_obs = 0\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.classes", "title": "classes  <code>instance-attribute</code>", "text": "<pre><code>classes = []\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.cnx", "title": "cnx  <code>instance-attribute</code>", "text": "<pre><code>cnx = Database()\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.config", "title": "config  <code>property</code>", "text": "<pre><code>config: Config\n</code></pre> <p>The configuration used for this Simulation.</p>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.db_writer", "title": "db_writer  <code>instance-attribute</code>", "text": "<pre><code>db_writer = None\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.dcp_list", "title": "dcp_list  <code>instance-attribute</code>", "text": "<pre><code>dcp_list = [\n    63,\n    56,\n    49,\n    42,\n    35,\n    31,\n    28,\n    24,\n    21,\n    17,\n    14,\n    10,\n    7,\n    5,\n    3,\n    1,\n    0,\n]\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.debug", "title": "debug  <code>instance-attribute</code>", "text": "<pre><code>debug = False\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.demand_multiplier", "title": "demand_multiplier  <code>instance-attribute</code>", "text": "<pre><code>demand_multiplier = 1.0\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.displacement_traces", "title": "displacement_traces  <code>instance-attribute</code>", "text": "<pre><code>displacement_traces: dict[int, Any] = {}\n</code></pre> <p>Displacement cost traces for each carrier.</p> <p>The key is the trial number, and the value is a dictionary with carrier names as keys and displacement cost traces as values.</p>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_details_revenue", "title": "fare_details_revenue  <code>instance-attribute</code>", "text": "<pre><code>fare_details_revenue = defaultdict(float)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_details_sold", "title": "fare_details_sold  <code>instance-attribute</code>", "text": "<pre><code>fare_details_sold = defaultdict(int)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_details_sold_business", "title": "fare_details_sold_business  <code>instance-attribute</code>", "text": "<pre><code>fare_details_sold_business = defaultdict(int)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_sales_by_carrier_dcp", "title": "fare_sales_by_carrier_dcp  <code>instance-attribute</code>", "text": "<pre><code>fare_sales_by_carrier_dcp = defaultdict(int)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_sales_by_dcp", "title": "fare_sales_by_dcp  <code>instance-attribute</code>", "text": "<pre><code>fare_sales_by_dcp = defaultdict(int)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.file_writer", "title": "file_writer  <code>instance-attribute</code>", "text": "<pre><code>file_writer = FileWriter(output_dir)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.frat5curves", "title": "frat5curves  <code>instance-attribute</code>", "text": "<pre><code>frat5curves = {}\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.load_factor_curves", "title": "load_factor_curves  <code>instance-attribute</code>", "text": "<pre><code>load_factor_curves = {}\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator = Generator(42)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.sample_done_callback", "title": "sample_done_callback  <code>instance-attribute</code>", "text": "<pre><code>sample_done_callback = lambda n, n_total: None\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.segmentation_data_by_timeframe", "title": "segmentation_data_by_timeframe  <code>instance-attribute</code>", "text": "<pre><code>segmentation_data_by_timeframe: dict[int, DataFrame] = {}\n</code></pre> <p>Bookings and revenue segmentation by timeframe.</p> <p>The key is the trial number, and the value is a DataFrame with a breakdown of bookings and revenue by timeframe, customer segment, carrier, and booking class.</p>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.snapshot_filters", "title": "snapshot_filters  <code>property</code> <code>writable</code>", "text": "<pre><code>snapshot_filters: list[SnapshotFilter] | None\n</code></pre> <p>Get the snapshot filters for the simulation.</p> <p>Returns:</p> <ul> <li> <code>list[SnapshotFilter] or None</code>           \u2013            <p>List of snapshot filter objects, or None if simulation is not initialized.</p> </li> </ul>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.todd_curves", "title": "todd_curves  <code>instance-attribute</code>", "text": "<pre><code>todd_curves = {}\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.update_frequency", "title": "update_frequency  <code>instance-attribute</code>", "text": "<pre><code>update_frequency = None\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.__init__", "title": "__init__", "text": "<pre><code>__init__(config: Config, output_dir: Path | None = None)\n</code></pre> <p>Initialize a Simulation instance.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>Config</code>)           \u2013            <p>The simulation configuration object. Will be revalidated during initialization.</p> </li> <li> <code>output_dir</code>               (<code>Path or None</code>, default:                   <code>None</code> )           \u2013            <p>Directory for output files. If None, a temporary directory will be created automatically.</p> </li> </ul> Notes <p>This initializes the simulation with default parameters including DCP lists, choice models, and various data structures for tracking simulation results.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def __init__(\n    self,\n    config: Config,\n    output_dir: pathlib.Path | None = None,\n):\n    \"\"\"\n    Initialize a Simulation instance.\n\n    Parameters\n    ----------\n    config : Config\n        The simulation configuration object. Will be revalidated during\n        initialization.\n    output_dir : pathlib.Path or None, optional\n        Directory for output files. If None, a temporary directory\n        will be created automatically.\n\n    Notes\n    -----\n    This initializes the simulation with default parameters including\n    DCP lists, choice models, and various data structures for tracking\n    simulation results.\n    \"\"\"\n    revalidate(config)\n    super().__init__(config, output_dir)\n    if config.simulation_controls.write_raw_files:\n        try:\n            from passengersim_core.utils import FileWriter\n        except ImportError:\n            self.file_writer = None\n        else:\n            self.file_writer = FileWriter.FileWriter(output_dir)\n    else:\n        self.file_writer = None\n    self.db_writer = None\n    self.dcp_list = [63, 56, 49, 42, 35, 31, 28, 24, 21, 17, 14, 10, 7, 5, 3, 1, 0]\n    self.classes = []\n    self.fare_sales_by_dcp = defaultdict(int)\n    self.fare_sales_by_carrier_dcp = defaultdict(int)\n    self.fare_details_sold = defaultdict(int)\n    self.fare_details_sold_business = defaultdict(int)\n    self.fare_details_revenue = defaultdict(float)\n    self.demand_multiplier = 1.0\n    self.capacity_multiplier = 1.0\n    self.airports = {}\n    self.choice_models = {}\n    self.frat5curves = {}\n    self.load_factor_curves = {}\n    self.todd_curves = {}\n    self.debug = False\n    self.update_frequency = None\n    self.random_generator = passengersim.core.Generator(42)\n    self.sample_done_callback = lambda n, n_total: None\n    self.choice_set_file = None\n    self.choice_set_obs = 0\n    self.choice_set_mkts = []\n    self.segmentation_data_by_timeframe: dict[int, pd.DataFrame] = {}\n    \"\"\"Bookings and revenue segmentation by timeframe.\n\n    The key is the trial number, and the value is a DataFrame with a\n    breakdown of bookings and revenue by timeframe, customer segment,\n    carrier, and booking class.\n    \"\"\"\n\n    self.bid_price_traces: dict[int, Any] = {}\n    \"\"\"Bid price traces for each carrier.\n\n    The key is the trial number, and the value is a dictionary with\n    carrier names as keys and bid price traces as values.\"\"\"\n\n    self.displacement_traces: dict[int, Any] = {}\n    \"\"\"Displacement cost traces for each carrier.\n\n    The key is the trial number, and the value is a dictionary with\n    carrier names as keys and displacement cost traces as values.\"\"\"\n\n    self._fare_restriction_mapping = {}\n    \"\"\"Mapping of fare restriction names to restriction numbers.\"\"\"\n\n    self._fare_restriction_list = []\n    \"\"\"List of fare restriction names in the order they were added.\"\"\"\n\n    self._initialize(config)\n    if not config.db:\n        self.cnx = database.Database()\n    else:\n        self.cnx = database.Database(\n            engine=config.db.engine,\n            filename=config.db.filename,\n            pragmas=config.db.pragmas,\n            commit_count_delay=config.db.commit_count_delay,\n        )\n    if self.cnx.is_open:\n        database.tables.create_table_leg_defs(self.cnx._connection, self.eng.legs)\n        database.tables.create_table_fare_defs(self.cnx._connection, self.eng.fares)\n        database.tables.create_table_fare_restriction_defs(self.cnx._connection, self._fare_restriction_list)\n        database.tables.create_table_path_defs(self.cnx._connection, self.eng.paths)\n        if config.db != \":memory:\":\n            self.cnx.save_configs(config)\n\n    self.callback_data = CallbackData()\n    \"\"\"Data stored from callbacks.\n\n    This allows a user to store arbitrary data during a simulation using callbacks,\n    and access it later.\n    \"\"\"\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.backup_db", "title": "backup_db", "text": "<pre><code>backup_db(dst: Path | str | Connection)\n</code></pre> <p>Back up this database to another copy.</p> <p>Parameters:</p> <ul> <li> <code>dst</code>               (<code>Path - like or Connection</code>)           \u2013            </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def backup_db(self, dst: pathlib.Path | str | sqlite3.Connection):\n    \"\"\"Back up this database to another copy.\n\n    Parameters\n    ----------\n    dst : Path-like or sqlite3.Connection\n    \"\"\"\n    return self.cnx.backup(dst)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.begin_sample", "title": "begin_sample", "text": "<pre><code>begin_sample(sample: int | None = None)\n</code></pre> <p>Begin processing a new sample in the simulation.</p> <p>Parameters:</p> <ul> <li> <code>sample</code>               (<code>int or None</code>, default:                   <code>None</code> )           \u2013            <p>The sample number to set. If None, the current sample number will be incremented by 1.</p> </li> </ul> Notes <p>This method handles sample initialization including setting the random seed (if configured) and preparing the simulation state for the new sample.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def begin_sample(self, sample: int | None = None):\n    \"\"\"\n    Begin processing a new sample in the simulation.\n\n    Parameters\n    ----------\n    sample : int or None, optional\n        The sample number to set. If None, the current sample number\n        will be incremented by 1.\n\n    Notes\n    -----\n    This method handles sample initialization including setting the\n    random seed (if configured) and preparing the simulation state\n    for the new sample.\n    \"\"\"\n    if sample is None:\n        # when sample is None, we simply increment the current sample number\n        self.eng.sample += 1\n    else:\n        # otherwise, we set the sample number to the given value\n        self.eng.sample = sample\n    if self.eng.config.simulation_controls.random_seed is not None:\n        self.reseed(\n            [\n                self.eng.config.simulation_controls.random_seed,\n                self.eng.trial,\n                self.eng.sample,\n            ]\n        )\n    self.eng.reset_counters()\n    self.generate_demands()\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.begin_trial", "title": "begin_trial", "text": "<pre><code>begin_trial(trial: int)\n</code></pre> <p>Beginning of trial processing.</p> <p>Parameters:</p> <ul> <li> <code>trial</code>               (<code>int</code>)           \u2013            <p>The trial number.</p> </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def begin_trial(self, trial: int):\n    \"\"\"Beginning of trial processing.\n\n    Parameters\n    ----------\n    trial : int\n        The trial number.\n    \"\"\"\n    self.eng.trial = trial\n    logger.info(\"beginning trial %d\", trial)\n    self.eng.reset_trial_counters()\n\n    for carrier in self.eng.carriers:\n        # Initialize the histories all the various things that need them.\n        # This is by-carrier, as the carriers may eventually have different\n        # data requirements (sizes) for their history arrays.\n        self.eng.initialize_histories(\n            carrier,\n            num_departures=26,  # TODO make this a parameter\n            num_timeframes=len(self.dcp_list) - 1,\n            truncation_rule=carrier.truncation_rule,\n            store_priceable=bool(carrier.frat5),\n            floating_closures=False,\n            wipe_existing=True,\n        )\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.capture_competitor_data", "title": "capture_competitor_data", "text": "<pre><code>capture_competitor_data()\n</code></pre> <p>Capture competitor pricing data for all markets.</p> Notes <p>This method shops for the lowest prices in each market and stores competitor pricing information that can be used by revenue management systems for competitive analysis.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def capture_competitor_data(self):\n    \"\"\"\n    Capture competitor pricing data for all markets.\n\n    Notes\n    -----\n    This method shops for the lowest prices in each market and\n    stores competitor pricing information that can be used by\n    revenue management systems for competitive analysis.\n    \"\"\"\n    for mkt in self.eng.markets.values():\n        lowest = self.eng.shop(mkt.orig, mkt.dest)\n        for cxr, price in lowest:\n            mkt.set_competitor_price(cxr, price)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.capture_dcp_data", "title": "capture_dcp_data", "text": "<pre><code>capture_dcp_data(dcp_index, closures_only=False)\n</code></pre> <p>Capture data control point (DCP) data for revenue management.</p> <p>Parameters:</p> <ul> <li> <code>dcp_index</code>               (<code>int</code>)           \u2013            <p>The index of the data control point.</p> </li> <li> <code>closures_only</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to capture only closure data or all DCP data.</p> </li> </ul> Notes <p>This method captures seat availability, booking data, and other metrics at specific time points (DCPs) before departure, which is essential for revenue management decision making.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def capture_dcp_data(self, dcp_index, closures_only=False):\n    \"\"\"\n    Capture data control point (DCP) data for revenue management.\n\n    Parameters\n    ----------\n    dcp_index : int\n        The index of the data control point.\n    closures_only : bool, default False\n        Whether to capture only closure data or all DCP data.\n\n    Notes\n    -----\n    This method captures seat availability, booking data, and other\n    metrics at specific time points (DCPs) before departure, which\n    is essential for revenue management decision making.\n    \"\"\"\n    for leg in self.eng.legs:\n        leg.capture_dcp(dcp_index)\n    for path in self.eng.paths:\n        path.capture_dcp(dcp_index, closures_only=closures_only)\n    for carrier in self.eng.carriers:\n        if dcp_index &gt; 0:\n            carrier.current_tf_index += 1\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_bid_price_history", "title": "compute_bid_price_history  <code>staticmethod</code>", "text": "<pre><code>compute_bid_price_history(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute the average bid price history for each carrier.</p> Source code in <code>passengersim/driver.py</code> <pre><code>@staticmethod\ndef compute_bid_price_history(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Compute the average bid price history for each carrier.\"\"\"\n    result = {}\n    for carrier in sim.carriers:\n        bp = carrier.raw_bid_price_trace()\n        result[carrier.name] = (\n            pd.DataFrame.from_dict(bp, orient=\"index\").sort_index(ascending=False).rename_axis(index=\"days_prior\")\n        )\n    if result:\n        df = pd.concat(result, axis=0, names=[\"carrier\"])\n    else:\n        df = pd.DataFrame(\n            columns=[\n                \"bid_price_mean\",\n                \"bid_price_stdev\",\n                \"some_cap_bid_price_mean\",\n                \"some_cap_bid_price_stdev\",\n                \"fraction_some_cap\",\n                \"fraction_zero_cap\",\n            ],\n            index=pd.MultiIndex([[], []], [[], []], names=[\"carrier\", \"days_prior\"]),\n        )\n    df = df.fillna(0)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"bid_price_history\", df)\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_carrier_report", "title": "compute_carrier_report", "text": "<pre><code>compute_carrier_report(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute a carrier summary table.</p> <p>The resulting table has one row per simulated carrier, and the following columns:</p> <ul> <li>name</li> <li>avg_sold</li> <li>load_factor</li> <li>avg_rev</li> <li>asm (available seat miles)</li> <li>rpm (revenue passenger miles)</li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_carrier_report(\n    self,\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute a carrier summary table.\n\n    The resulting table has one row per simulated carrier, and the following\n    columns:\n\n    - name\n    - avg_sold\n    - load_factor\n    - avg_rev\n    - asm (available seat miles)\n    - rpm (revenue passenger miles)\n    \"\"\"\n    num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n    carrier_df = []\n\n    carrier_asm = defaultdict(float)\n    carrier_rpm = defaultdict(float)\n    carrier_leg_lf = defaultdict(float)\n    carrier_leg_count = defaultdict(float)\n    for leg in sim.legs:\n        carrier_name = leg.carrier_name if hasattr(leg, \"carrier_name\") else leg.carrier  # TODO: remove hasattr\n        carrier_asm[carrier_name] += leg.distance * leg.capacity * num_samples\n        carrier_rpm[carrier_name] += leg.distance * leg.gt_sold\n        carrier_leg_lf[carrier_name] += leg.gt_sold / (leg.capacity * num_samples)\n        carrier_leg_count[carrier_name] += 1\n\n    for cxr in sim.carriers:\n        avg_sold = cxr.gt_sold / num_samples\n        avg_rev = cxr.gt_revenue / num_samples\n        asm = carrier_asm[cxr.name] / num_samples\n        rpm = carrier_rpm[cxr.name] / num_samples\n        # sys_lf = 100.0 * cxr.gt_revenue_passenger_miles / asm if asm &gt; 0 else 0.0\n        denom = carrier_asm[cxr.name]\n        sys_lf = (100.0 * carrier_rpm[cxr.name] / denom) if denom &gt; 0 else 0\n        if to_log:\n            logger.info(\n                f\"Carrier: {cxr.name}, AvgSold: {round(avg_sold, 2)}, LF {sys_lf:.2f}%,  AvgRev ${avg_rev:10,.2f}\"\n            )\n\n        # Add up total ancillaries\n        tot_anc_rev = 0.0\n        for anc in cxr.ancillaries:\n            print(str(anc))\n            tot_anc_rev += anc.price * anc.sold\n\n        carrier_df.append(\n            {\n                \"carrier\": cxr.name,\n                \"sold\": avg_sold,\n                \"sys_lf\": sys_lf,\n                \"avg_leg_lf\": 100 * carrier_leg_lf[cxr.name] / max(carrier_leg_count[cxr.name], 1),\n                \"avg_rev\": avg_rev,\n                \"avg_price\": avg_rev / avg_sold if avg_sold &gt; 0 else 0,\n                \"asm\": asm,\n                \"rpm\": rpm,\n                \"yield\": np.nan if rpm == 0 else avg_rev / rpm,\n                \"ancillary_rev\": tot_anc_rev,\n            }\n        )\n    carrier_df = pd.DataFrame(carrier_df)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"carrier_summary\", carrier_df)\n    return carrier_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_class_dist", "title": "compute_class_dist", "text": "<pre><code>compute_class_dist(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_class_dist(self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None):\n    # Get unique segments\n    segs = set([dmd.segment for dmd in sim.demands])\n    dist = defaultdict(int)\n    for f in sim.fares:\n        for seg in segs:\n            k = (f.booking_class, seg)\n            try:\n                dist[k] += f.get_sales_by_segment(seg)\n            except Exception:\n                # If the segment isn't found, just ignore it.\n                # i.e. basic economy won't book Y0\n                pass\n\n    class_dist_df = []\n    for (cls, seg), sold in dist.items():\n        class_dist_df.append(dict(booking_class=cls, segment=seg, sold=sold))\n    class_dist_df = pd.DataFrame(class_dist_df)\n    return class_dist_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_demand_report", "title": "compute_demand_report", "text": "<pre><code>compute_demand_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: Database | None = None,\n)\n</code></pre> <p>Compute a demand report for the simulation.</p> <p>Parameters:</p> <ul> <li> <code>sim</code>               (<code>SimulationEngine</code>)           \u2013            <p>The simulation engine instance to generate the report from.</p> </li> <li> <code>to_log</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to log the report summary.</p> </li> <li> <code>to_db</code>               (<code>Database or None</code>, default:                   <code>None</code> )           \u2013            <p>Database connection to write the report to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>DataFrame containing demand statistics including origin, destination, segment, sold units, revenue, and other metrics.</p> </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_demand_report(self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None):\n    \"\"\"\n    Compute a demand report for the simulation.\n\n    Parameters\n    ----------\n    sim : SimulationEngine\n        The simulation engine instance to generate the report from.\n    to_log : bool, default True\n        Whether to log the report summary.\n    to_db : database.Database or None, optional\n        Database connection to write the report to.\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame containing demand statistics including origin,\n        destination, segment, sold units, revenue, and other metrics.\n    \"\"\"\n    dmd_df = []\n    for m in sim.demands:\n        avg_price = m.revenue / m.sold if m.sold &gt; 0 else 0\n        dmd_df.append(\n            dict(\n                orig=m.orig,\n                dest=m.dest,\n                segment=m.segment,\n                sold=m.sold,\n                revenue=m.revenue,\n                avg_fare=m.revenue / m.sold if m.sold &gt; 0 else 0,\n                gt_demand=m.gt_demand,\n                gt_sold=m.gt_sold,\n                gt_revenue=m.gt_revenue,\n            )\n        )\n        if to_log:\n            logger.info(\n                f\"   Dmd: {m.orig}-{m.dest}:{m.segment}\"\n                f\"  Sold = {m.sold},  \"\n                f\"Rev = {m.revenue}, \"\n                f\"AvgFare = {avg_price:.2f}\"\n            )\n    dmd_df = pd.DataFrame(dmd_df)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"demand_summary\", dmd_df)\n    return dmd_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_demand_to_come_summary", "title": "compute_demand_to_come_summary  <code>staticmethod</code>", "text": "<pre><code>compute_demand_to_come_summary(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>@staticmethod\ndef compute_demand_to_come_summary(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    raw = sim.summary_demand_to_come()\n    df = (\n        from_nested_dict(raw, [\"segment\", \"days_prior\", \"metric\"])\n        .sort_index(ascending=[True, False])\n        .rename(columns={\"mean\": \"mean_future_demand\", \"stdev\": \"stdev_future_demand\"})\n    )\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_displacement_history", "title": "compute_displacement_history  <code>staticmethod</code>", "text": "<pre><code>compute_displacement_history(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute the average displacement cost history for each carrier.</p> Source code in <code>passengersim/driver.py</code> <pre><code>@staticmethod\ndef compute_displacement_history(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Compute the average displacement cost history for each carrier.\"\"\"\n    result = {}\n    for carrier in sim.carriers:\n        bp = carrier.raw_displacement_cost_trace()\n        result[carrier.name] = (\n            pd.DataFrame.from_dict(bp, orient=\"index\").sort_index(ascending=False).rename_axis(index=\"days_prior\")\n        )\n    if result:\n        df = pd.concat(result, axis=0, names=[\"carrier\"])\n    else:\n        df = pd.DataFrame(\n            columns=[\n                \"displacement_mean\",\n                \"displacement_stdev\",\n            ],\n            index=pd.MultiIndex([[], []], [[], []], names=[\"carrier\", \"days_prior\"]),\n        )\n    df = df.fillna(0)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"displacement_history\", df)\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_fare_report", "title": "compute_fare_report", "text": "<pre><code>compute_fare_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_fare_report(self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None):\n    fare_df = []\n    for f in sim.fares:\n        for dcp_index, days_prior in enumerate(self.dcp_list):\n            fare_df.append(\n                dict(\n                    carrier=f.carrier.name,\n                    orig=f.orig,\n                    dest=f.dest,\n                    booking_class=f.booking_class,\n                    dcp_index=dcp_index,\n                    price=f.price,\n                    sold=f.get_sales_by_dcp2(days_prior),\n                    gt_sold=f.gt_sold,\n                    avg_adjusted_price=f.get_adjusted_by_dcp(dcp_index),\n                )\n            )\n            if to_log:\n                logger.info(\n                    f\"   Fare: {f.carrier} {f.orig}-{f.dest}:{f.booking_class}\"\n                    # f\"AvgAdjFare = {avg_adj_price:.2f},\"\n                    f\"  Sold = {f.sold},  \"\n                    f\"Price = {f.price}\"\n                )\n    fare_df = pd.DataFrame(fare_df)\n    #        if to_db and to_db.is_open:\n    #            to_db.save_dataframe(\"fare_summary\", fare_df)\n    return fare_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_leg_avg_load_factor_distribution", "title": "compute_leg_avg_load_factor_distribution  <code>staticmethod</code>", "text": "<pre><code>compute_leg_avg_load_factor_distribution(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute a leg average load factor distribution report.</p> <p>This report is a dataframe, with integer index values from 0 to 100, and column for each carrier in the simulation. The values are the frequency of each leg average load factor observed over the simulation (excluding any burn period).  The values for leg average load factors are rounded down, so that a leg average load factor of 99.9% is counted as 99, and only always sold-out flights are in the 100% bin.</p> <p>This is different from the raw load factor distribution, which is the distribution of load factors across sample days.  The number of observations in the leg average load factor (this distribution) is equal to the number of legs, while the raw load factor distribution has one observation per leg per sample day.  The variance of this distribution is much lower than the raw load factor distribution.</p> Source code in <code>passengersim/driver.py</code> <pre><code>@staticmethod\ndef compute_leg_avg_load_factor_distribution(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute a leg average load factor distribution report.\n\n    This report is a dataframe, with integer index values from 0 to 100,\n    and column for each carrier in the simulation. The values are the\n    frequency of each leg average load factor observed over the simulation\n    (excluding any burn period).  The values for leg average load factors\n    are rounded down, so that a leg average load factor of 99.9% is counted\n    as 99, and only always sold-out flights are in the 100% bin.\n\n    This is different from the raw load factor distribution, which is the\n    distribution of load factors across sample days.  The number of\n    observations in the leg average load factor (this distribution) is\n    equal to the number of legs, while the raw load factor distribution\n    has one observation per leg per sample day.  The variance of this\n    distribution is much lower than the raw load factor distribution.\n    \"\"\"\n    idx = pd.RangeIndex(101, name=\"leg_load_factor\")\n    result = {carrier.name: pd.Series(np.zeros(101, dtype=np.int32), index=idx) for carrier in sim.carriers}\n    for leg in sim.legs:\n        try:\n            lf = int(np.floor(leg.avg_load_factor()))\n        except TypeError:\n            # TODO: remove this\n            lf = int(np.floor(leg.avg_load_factor))\n        if lf &gt; 100:\n            lf = 100\n        if lf &lt; 0:\n            lf = 0\n        # TODO remove hasattr\n        result[leg.carrier_name if hasattr(leg, \"carrier_name\") else leg.carrier].iloc[lf] += 1\n    if result:\n        df = pd.concat(result, axis=1, names=[\"carrier\"])\n    else:\n        df = pd.DataFrame(index=pd.RangeIndex(101, name=\"leg_load_factor\"), columns=[])\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"leg_avg_load_factor_distribution\", df)\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_leg_local_fraction_distribution", "title": "compute_leg_local_fraction_distribution", "text": "<pre><code>compute_leg_local_fraction_distribution(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute a report on the fraction of leg passengers who are local.</p> <p>This report is a dataframe, with integer index values from 0 to 100, and column for each carrier in the simulation. The values are the frequency of the local leg-passenger fraction on each leg observed over the simulation (excluding any burn period).  The values are rounded down, so that a leg local fraction of 99.9% is counted as 99, and only always-local flights are in the 100% bin.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_leg_local_fraction_distribution(\n    self,\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute a report on the fraction of leg passengers who are local.\n\n    This report is a dataframe, with integer index values from 0 to 100,\n    and column for each carrier in the simulation. The values are the\n    frequency of the local leg-passenger fraction on each leg observed\n    over the simulation (excluding any burn period).  The values are\n    rounded down, so that a leg local fraction of 99.9% is counted\n    as 99, and only always-local flights are in the 100% bin.\n    \"\"\"\n    result = {}\n    for carrier in sim.carriers:\n        lf = pd.Series(\n            sim.distribution_local_leg_passengers(carrier),\n            index=pd.RangeIndex(101, name=\"local_fraction\"),\n            name=\"frequency\",\n        )\n        result[carrier.name] = lf\n    if result:\n        df = pd.concat(result, axis=1, names=[\"carrier\"])\n    else:\n        df = pd.DataFrame(index=pd.RangeIndex(101, name=\"local_fraction\"), columns=[])\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"leg_local_fraction_distribution\", df)\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_leg_report", "title": "compute_leg_report", "text": "<pre><code>compute_leg_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_leg_report(self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None):\n    num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n    leg_df = []\n    for leg in sim.legs:\n        # Checking consistency while I debug the cabin code\n        sum_b1, sum_b2 = 0, 0\n        for b in leg.buckets:\n            sum_b1 += b.sold\n        for c in leg.cabins:\n            for b in c.buckets:\n                sum_b2 += b.sold\n        if sum_b1 != sum_b2:\n            print(\"Oh, crap!\")\n        avg_sold = leg.gt_sold / num_samples\n        avg_rev = leg.gt_revenue / num_samples\n        lf = 100.0 * leg.gt_sold / (leg.capacity * num_samples)\n        if to_log:\n            logger.info(\n                f\"    Leg: {leg.carrier}:{leg.flt_no} {leg.orig}-{leg.dest}: \"\n                f\" AvgSold = {avg_sold:6.2f},  AvgRev = ${avg_rev:,.2f}, \"\n                f\"LF = {lf:,.2f}%\"\n            )\n        leg_df.append(\n            dict(\n                leg_id=leg.leg_id,\n                carrier=leg.carrier_name,\n                flt_no=leg.flt_no,\n                orig=leg.orig,\n                dest=leg.dest,\n                avg_sold=avg_sold,\n                avg_rev=avg_rev,\n                lf=lf,\n            )\n        )\n    leg_df = pd.DataFrame(leg_df)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"leg_summary\", leg_df)\n    return leg_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_local_fraction_by_place", "title": "compute_local_fraction_by_place", "text": "<pre><code>compute_local_fraction_by_place(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute a report on the fraction of leg passengers who are local.</p> <p>Parameters:</p> <ul> <li> <code>sim</code>               (<code>SimulationEngine</code>)           \u2013            </li> <li> <code>to_log</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>to_db</code>               (<code>Database | None</code>, default:                   <code>None</code> )           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_local_fraction_by_place(\n    self,\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute a report on the fraction of leg passengers who are local.\n\n    Parameters\n    ----------\n    sim\n    to_log\n    to_db\n\n    Returns\n    -------\n    pd.DataFrame\n    \"\"\"\n    result = {}\n    for carrier in sim.carriers:\n        df = pd.Series(\n            sim.fraction_local_by_carrier_and_place(carrier.name),\n            name=carrier.name,\n        )\n        result[carrier.name] = df\n    if result:\n        df = pd.concat(result, axis=1, names=[\"carrier\"])\n    else:\n        df = pd.DataFrame(index=[], columns=[])\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"local_fraction_by_place\", df)\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_path_class_report", "title": "compute_path_class_report", "text": "<pre><code>compute_path_class_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_path_class_report(self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None):\n    num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n\n    path_class_df = []\n    for path in sim.paths:\n        for pc in path.pathclasses:\n            avg_sold = pc.gt_sold / num_samples\n            avg_sold_priceable = pc.gt_sold_priceable / num_samples\n            avg_rev = pc.gt_revenue / num_samples\n            if to_log:\n                logger.info(f\"{pc}, avg_sold={avg_sold:6.2f}, avg_rev=${avg_rev:10,.2f}\")\n            data = dict(\n                orig=path.orig,\n                dest=path.dest,\n                carrier1=path.get_leg_carrier(0),\n                leg_id1=path.get_leg_id(0),\n                carrier2=None,\n                leg_id2=None,\n                carrier3=None,\n                leg_id3=None,\n                booking_class=pc.booking_class,\n                avg_sold=avg_sold,\n                avg_sold_priceable=avg_sold_priceable,\n                avg_rev=avg_rev,\n            )\n            if path.num_legs() == 1:\n                path_class_df.append(data)\n            elif path.num_legs() == 2:\n                data[\"carrier2\"] = path.get_leg_carrier(1)\n                data[\"leg_id2\"] = path.get_leg_id(1)\n                path_class_df.append(data)\n            elif path.num_legs() == 3:\n                data[\"carrier2\"] = path.get_leg_carrier(1)\n                data[\"leg_id2\"] = path.get_leg_id(1)\n                data[\"carrier3\"] = path.get_leg_carrier(2)\n                data[\"leg_id3\"] = path.get_leg_id(2)\n                path_class_df.append(data)\n            else:\n                raise NotImplementedError(\"path with more than 3 legs\")\n    path_class_df = pd.DataFrame(path_class_df)\n    if not path_class_df.empty:\n        path_class_df.sort_values(by=[\"orig\", \"dest\", \"carrier1\", \"leg_id1\", \"booking_class\"])\n        #        if to_db and to_db.is_open:\n        #            to_db.save_dataframe(\"path_class_summary\", path_class_df)\n    return path_class_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_path_report", "title": "compute_path_report", "text": "<pre><code>compute_path_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_path_report(self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None):\n    num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n    avg_lf, n = 0.0, 0\n    for leg in sim.legs:\n        lf = 100.0 * leg.gt_sold / (leg.capacity * num_samples)\n        avg_lf += lf\n        n += 1\n\n    tot_rev = 0.0\n    for m in sim.demands:\n        tot_rev += m.revenue\n\n    avg_lf = avg_lf / n if n &gt; 0 else 0\n    if to_log:\n        logger.info(f\"    LF:  {avg_lf:6.2f}%, Total revenue = ${tot_rev:,.2f}\")\n\n    path_df = []\n    for path in sim.paths:\n        avg_sold = path.gt_sold / num_samples\n        avg_sold_priceable = path.gt_sold_priceable / num_samples\n        avg_rev = path.gt_revenue / num_samples\n        if to_log:\n            logger.info(f\"{path}, avg_sold={avg_sold:6.2f}, avg_rev=${avg_rev:10,.2f}\")\n        data = dict(\n            orig=path.orig,\n            dest=path.dest,\n            carrier1=path.get_leg_carrier(0),\n            leg_id1=path.get_leg_id(0),\n            carrier2=None,\n            leg_id2=None,\n            carrier3=None,\n            leg_id3=None,\n            avg_sold=avg_sold,\n            avg_sold_priceable=avg_sold_priceable,\n            avg_rev=avg_rev,\n        )\n        if path.num_legs() == 1:\n            path_df.append(data)\n        elif path.num_legs() == 2:\n            data[\"carrier2\"] = path.get_leg_carrier(1)\n            data[\"leg_id2\"] = path.get_leg_id(1)\n            path_df.append(data)\n        elif path.num_legs() == 3:\n            data[\"carrier2\"] = path.get_leg_carrier(1)\n            data[\"leg_id2\"] = path.get_leg_id(1)\n            data[\"carrier3\"] = path.get_leg_carrier(2)\n            data[\"leg_id3\"] = path.get_leg_id(2)\n            path_df.append(data)\n        else:\n            raise NotImplementedError(\"path with more than 3 legs\")\n    path_df = pd.DataFrame(path_df)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"path_summary\", path_df)\n    return path_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_raw_fare_class_mix", "title": "compute_raw_fare_class_mix", "text": "<pre><code>compute_raw_fare_class_mix(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute a fare class distribution report.</p> <p>This report is a dataframe, with index values giving the fare class, and column for each carrier in the simulation. The values are the number of passengers for each fare class observed during the simulation (excluding any burn period). This is a count of passengers not legs, so a passenger on a connecting itinerary only counts once.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_raw_fare_class_mix(\n    self,\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute a fare class distribution report.\n\n    This report is a dataframe, with index values giving the fare class,\n    and column for each carrier in the simulation. The values are the\n    number of passengers for each fare class observed during the simulation\n    (excluding any burn period). This is a count of passengers not legs, so\n    a passenger on a connecting itinerary only counts once.\n    \"\"\"\n    result = {}\n    for carrier in sim.carriers:\n        fc = carrier.raw_fare_class_distribution()\n        fc_sold = pd.Series(\n            {k: v[\"sold\"] for k, v in fc.items()},\n            name=\"frequency\",\n        )\n        fc_rev = pd.Series(\n            {k: v[\"revenue\"] for k, v in fc.items()},\n            name=\"frequency\",\n        )\n        result[carrier.name] = pd.concat([fc_sold, fc_rev], axis=1, keys=[\"sold\", \"revenue\"]).rename_axis(\n            index=\"booking_class\"\n        )\n    if result:\n        df = pd.concat(result, axis=0, names=[\"carrier\"])\n    else:\n        df = pd.DataFrame(\n            columns=[\"sold\", \"revenue\"],\n            index=pd.MultiIndex([[], []], [[], []], names=[\"carrier\", \"booking_class\"]),\n        )\n    df = df.fillna(0)\n    df[\"sold\"] = df[\"sold\"].astype(int)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"fare_class_distribution\", df)\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_raw_load_factor_distribution", "title": "compute_raw_load_factor_distribution  <code>staticmethod</code>", "text": "<pre><code>compute_raw_load_factor_distribution(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: Database | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute a load factor distribution report.</p> <p>This report is a dataframe, with integer index values from 0 to 100, and column for each carrier in the simulation. The values are the frequency of each leg load factor observed during the simulation (excluding any burn period).  The values for leg load factors are rounded down, so that a leg load factor of 99.9% is counted as 99, and only actually sold-out flights are in the 100% bin.</p> Source code in <code>passengersim/driver.py</code> <pre><code>@staticmethod\ndef compute_raw_load_factor_distribution(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute a load factor distribution report.\n\n    This report is a dataframe, with integer index values from 0 to 100,\n    and column for each carrier in the simulation. The values are the\n    frequency of each leg load factor observed during the simulation\n    (excluding any burn period).  The values for leg load factors are\n    rounded down, so that a leg load factor of 99.9% is counted as 99,\n    and only actually sold-out flights are in the 100% bin.\n    \"\"\"\n    result = {}\n    for carrier in sim.carriers:\n        lf = pd.Series(\n            carrier.raw_load_factor_distribution(),\n            index=pd.RangeIndex(101, name=\"leg_load_factor\"),\n            name=\"frequency\",\n        )\n        result[carrier.name] = lf\n    if result:\n        df = pd.concat(result, axis=1, names=[\"carrier\"])\n    else:\n        df = pd.DataFrame(index=pd.RangeIndex(101, name=\"leg_load_factor\"), columns=[])\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"raw_load_factor_distribution\", df)\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_reports", "title": "compute_reports", "text": "<pre><code>compute_reports(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: bool | Database = True,\n    additional=(\n        \"fare_class_mix\",\n        \"load_factors\",\n        \"total_demand\",\n    ),\n) -&gt; SummaryTables\n</code></pre> <p>Compute comprehensive simulation reports.</p> <p>Parameters:</p> <ul> <li> <code>sim</code>               (<code>SimulationEngine</code>)           \u2013            <p>The simulation engine instance to generate reports from.</p> </li> <li> <code>to_log</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to log report summaries.</p> </li> <li> <code>to_db</code>               (<code>bool or Database</code>, default:                   <code>True</code> )           \u2013            <p>Database connection or boolean indicating whether to write reports to database.</p> </li> <li> <code>additional</code>               (<code>tuple</code>, default:                   <code>('fare_class_mix', 'load_factors', 'total_demand')</code> )           \u2013            <p>Additional report types to include. Options include 'fare_class_mix', 'load_factors', 'total_demand'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SummaryTables</code>           \u2013            <p>Object containing all computed reports including leg, path, carrier, and other summary statistics.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no samples have been completed in the simulation.</p> </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_reports(\n    self,\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: bool | database.Database = True,\n    additional=(\n        \"fare_class_mix\",\n        \"load_factors\",\n        # \"bookings_by_timeframe\",\n        \"total_demand\",\n    ),\n) -&gt; SummaryTables:\n    \"\"\"\n    Compute comprehensive simulation reports.\n\n    Parameters\n    ----------\n    sim : SimulationEngine\n        The simulation engine instance to generate reports from.\n    to_log : bool, default True\n        Whether to log report summaries.\n    to_db : bool or database.Database, default True\n        Database connection or boolean indicating whether to write\n        reports to database.\n    additional : tuple, optional\n        Additional report types to include. Options include\n        'fare_class_mix', 'load_factors', 'total_demand'.\n\n    Returns\n    -------\n    SummaryTables\n        Object containing all computed reports including leg, path,\n        carrier, and other summary statistics.\n\n    Raises\n    ------\n    ValueError\n        If no samples have been completed in the simulation.\n    \"\"\"\n    num_samples = sim.num_trials_completed * (sim.num_samples - sim.burn_samples)\n    if num_samples &lt;= 0:\n        raise ValueError(\n            \"insufficient number of samples outside burn period for reporting\"\n            f\"\\n- num_trials = {sim.num_trials}\"\n            f\"\\n- num_samples = {sim.num_samples}\"\n            f\"\\n- burn_samples = {sim.burn_samples}\"\n        )\n\n    if to_db is True:\n        to_db = self.cnx\n    class_dist_df = self.compute_class_dist(sim, to_log, to_db)\n    dmd_df = self.compute_demand_report(sim, to_log, to_db)\n    fare_df = self.compute_fare_report(sim, to_log, to_db)\n    leg_df = self.compute_leg_report(sim, to_log, to_db)\n    path_df = self.compute_path_report(sim, to_log, to_db)\n    path_classes_df = self.compute_path_class_report(sim, to_log, to_db)\n    carrier_df = self.compute_carrier_report(sim, to_log, to_db)\n    segmentation_df = self.compute_segmentation_by_timeframe()\n    raw_load_factor_dist_df = self.compute_raw_load_factor_distribution(sim, to_log, to_db)\n    leg_avg_load_factor_dist_df = self.compute_leg_avg_load_factor_distribution(sim, to_log, to_db)\n    fare_class_dist_df = self.compute_raw_fare_class_mix(sim, to_log, to_db)\n    bid_price_history_df = self.compute_bid_price_history(sim, to_log, to_db)\n    displacement_df = self.compute_displacement_history(sim, to_log, to_db)\n    demand_to_come_df = self.compute_demand_to_come_summary(sim, to_log, to_db)\n    local_fraction_dist_df = self.compute_leg_local_fraction_distribution(sim, to_log, to_db)\n    local_fraction_by_place = self.compute_local_fraction_by_place(sim, to_log, to_db)\n\n    summary = SummaryTables(\n        name=sim.name,\n        class_dist=class_dist_df,\n        config=sim.config,\n        demands=dmd_df,\n        fares=fare_df,\n        legs=leg_df,\n        paths=path_df,\n        path_classes=path_classes_df,\n        carriers=carrier_df,\n        bid_price_history=bid_price_history_df,\n        raw_load_factor_distribution=raw_load_factor_dist_df,\n        leg_avg_load_factor_distribution=leg_avg_load_factor_dist_df,\n        raw_fare_class_mix=fare_class_dist_df,\n        leg_local_fraction_distribution=local_fraction_dist_df,\n        local_fraction_by_place=local_fraction_by_place,\n        n_total_samples=num_samples,\n        segmentation_by_timeframe=segmentation_df,\n        displacement_history=displacement_df,\n        demand_to_come_summary=demand_to_come_df,\n    )\n    summary.load_additional_tables(self.cnx, sim.name, sim.burn_samples, additional)\n    summary.cnx = self.cnx\n    return summary\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_segmentation_by_timeframe", "title": "compute_segmentation_by_timeframe", "text": "<pre><code>compute_segmentation_by_timeframe() -&gt; DataFrame | None\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_segmentation_by_timeframe(self) -&gt; pd.DataFrame | None:\n    if self.segmentation_data_by_timeframe:\n        df = (\n            pd.concat(self.segmentation_data_by_timeframe, axis=0, names=[\"trial\"])\n            .reorder_levels([\"trial\", \"carrier\", \"booking_class\", \"days_prior\"])\n            .sort_index()\n        )\n        # df[\"Total\"] = df.sum(axis=1)\n        return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.end_sample", "title": "end_sample", "text": "<pre><code>end_sample()\n</code></pre> <p>End processing of the current sample.</p> Notes <p>This method records departure statistics to carrier-level counters, handles choice set and competitor data capture if configured, and performs other end-of-sample cleanup and data collection tasks.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def end_sample(self):\n    \"\"\"\n    End processing of the current sample.\n\n    Notes\n    -----\n    This method records departure statistics to carrier-level counters,\n    handles choice set and competitor data capture if configured,\n    and performs other end-of-sample cleanup and data collection tasks.\n    \"\"\"\n\n    # Record the departure statistics to carrier-level counters in the simulation\n    self.eng.record_departure_statistics()\n\n    # Roll histories to next sample\n    self.eng.next_departure()\n\n    # Commit data to the database\n    if self.cnx:\n        try:\n            self.cnx.commit()\n        except AttributeError:\n            pass\n\n    # Are we capturing choice-set data?\n    if self.choice_set_file is not None:\n        if self.eng.sample &gt; self.eng.burn_samples:\n            cs = self.eng.get_choice_set()\n            for line in cs:\n                tmp = [str(z) for z in line]\n                tmp2 = \",\".join(tmp)\n                print(tmp2, file=self.choice_set_file)\n        self.eng.clear_choice_set()\n\n    # Market share computation (MIDT-lite), might move to C++ in a future version\n    alpha = 0.15\n    for m in self.eng.markets.values():\n        sold = float(m.sold)\n        for a in self.eng.carriers:\n            carrier_sold = m.get_carrier_sold(a.name)\n            share = carrier_sold / sold if sold &gt; 0 else 0\n            if self.eng.sample &gt; 1:\n                try:\n                    old_share = m.get_carrier_share(a.name)\n                except KeyError:\n                    old_share = 0.0\n                new_share = alpha * share + (1.0 - alpha) * old_share\n                m.set_carrier_share(a.name, new_share)\n            else:\n                m.set_carrier_share(a.name, share)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.end_trial", "title": "end_trial", "text": "<pre><code>end_trial()\n</code></pre> <p>End of trial processing.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def end_trial(self):\n    \"\"\"End of trial processing.\"\"\"\n    self.extract_segmentation_by_timeframe()\n    self.extract_and_reset_bid_price_traces()\n    if self.cnx.is_open:\n        self.db_writer.final_write_to_sqlite(self.cnx._connection)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.extract_and_reset_bid_price_traces", "title": "extract_and_reset_bid_price_traces", "text": "<pre><code>extract_and_reset_bid_price_traces()\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def extract_and_reset_bid_price_traces(self):\n    self.bid_price_traces[self.eng.trial] = {\n        carrier.name: carrier.raw_bid_price_trace() for carrier in self.eng.carriers\n    }\n    self.displacement_traces[self.eng.trial] = {\n        carrier.name: carrier.raw_displacement_cost_trace() for carrier in self.eng.carriers\n    }\n    for carrier in self.eng.carriers:\n        carrier.reset_bid_price_trace()\n        carrier.reset_displacement_cost_trace()\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.extract_segmentation_by_timeframe", "title": "extract_segmentation_by_timeframe", "text": "<pre><code>extract_segmentation_by_timeframe()\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def extract_segmentation_by_timeframe(\n    self,\n):\n    # this should be run, if desired, at the end of each trial\n    num_samples = self.eng.num_samples - self.eng.burn_samples\n    top_level = {}\n    for k in (\"bookings\", \"revenue\"):\n        data = {}\n        for carrier in self.eng.carriers:\n            carrier_data = {}\n            for segment, values in getattr(carrier, f\"raw_{k}_by_segment_fare_dcp\")().items():\n                carrier_data[segment] = (\n                    pd.DataFrame.from_dict(values, \"columns\")\n                    .rename_axis(index=\"days_prior\", columns=\"booking_class\")\n                    .stack()\n                )\n            if carrier_data:\n                data[carrier.name] = pd.concat(carrier_data, axis=1, names=[\"segment\"]).fillna(0) / num_samples\n        # add non-bookings to the data dict\n        if k == \"bookings\":\n            non_bookings = pd.DataFrame.from_dict(self.eng.nonbookings_by_segment_dcp(), \"columns\").rename_axis(\n                index=\"days_prior\", columns=\"segment\"\n            )\n            non_bookings[\"booking_class\"] = \"XX\"\n            data[\"NONE\"] = non_bookings.reset_index().set_index([\"days_prior\", \"booking_class\"]) / num_samples\n        if len(data) == 0:\n            return None\n        top_level[k] = pd.concat(data, axis=0, names=[\"carrier\"])\n    df = pd.concat(top_level, axis=1, names=[\"metric\"])\n    self.segmentation_data_by_timeframe[self.eng.trial] = df\n    return df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.generate_dcp_rm_events", "title": "generate_dcp_rm_events", "text": "<pre><code>generate_dcp_rm_events(debug=False)\n</code></pre> <p>Pushes an event per reading day (DCP) onto the queue. Also adds events for daily reoptimzation</p> Source code in <code>passengersim/driver.py</code> <pre><code>def generate_dcp_rm_events(self, debug=False):\n    \"\"\"Pushes an event per reading day (DCP) onto the queue.\n    Also adds events for daily reoptimzation\"\"\"\n    dcp_hour = self.eng.config.simulation_controls.dcp_hour\n    if debug:\n        tmp = datetime.fromtimestamp(self.eng.base_time, tz=UTC)\n        print(f\"Base Time is {tmp.strftime('%Y-%m-%d %H:%M:%S %Z')}\")\n    for dcp_index, dcp in enumerate(self.dcp_list):\n        if dcp == 0:\n            continue\n        event_time = int(self.eng.base_time - dcp * 86400 + 3600 * dcp_hour)\n        if debug:\n            tmp = datetime.fromtimestamp(event_time, tz=UTC)\n            print(f\"Added DCP {dcp} at {tmp.strftime('%Y-%m-%d %H:%M:%S %Z')}\")\n        info = (\"DCP\", dcp, dcp_index)\n        rm_event = Event(info, event_time)\n        self.eng.add_event(rm_event)\n\n    # Now add the events for daily reoptimization\n    max_days_prior = max(self.dcp_list)\n    dcp_idx = 0\n    for days_prior in reversed(range(max_days_prior)):\n        if days_prior not in self.dcp_list:\n            info = (\"daily\", days_prior, dcp_idx)\n            event_time = int(self.eng.base_time - days_prior * 86400 + 3600 * dcp_hour)\n            rm_event = Event(info, event_time)\n            self.eng.add_event(rm_event)\n        else:\n            dcp_idx += 1\n\n    # add events for begin and end sample callbacks\n    self.add_callback_events()\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.generate_demands", "title": "generate_demands", "text": "<pre><code>generate_demands(system_rn=None, debug=False)\n</code></pre> <p>Generate demands following the procedure used in PODS.</p> <p>Parameters:</p> <ul> <li> <code>system_rn</code>               (<code>float or None</code>, default:                   <code>None</code> )           \u2013            <p>System random number. If None, a new random number will be generated using the simulation's random generator.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to enable debug output during demand generation.</p> </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def generate_demands(self, system_rn=None, debug=False):\n    \"\"\"\n    Generate demands following the procedure used in PODS.\n\n    Parameters\n    ----------\n    system_rn : float or None, optional\n        System random number. If None, a new random number will be\n        generated using the simulation's random generator.\n    debug : bool, default False\n        Whether to enable debug output during demand generation.\n    \"\"\"\n    self.generate_dcp_rm_events()\n    total_events = 0\n    system_rn = self.random_generator.get_normal() if system_rn is None else system_rn\n\n    # We don't have an O&amp;D object, but we use this to get a market random number\n    # per market\n    mrn_ref = {}\n\n    # Need to have leisure / business split for PODS\n    trn_ref = {\n        \"business\": self.random_generator.get_normal(),\n        \"leisure\": self.random_generator.get_normal(),\n    }\n\n    # this stores a random number per segment\n    srn_ref = {}\n    segment_k_factor = self.eng.config.simulation_controls.segment_k_factor\n\n    def get_or_make_random(grouping, key):\n        if key not in grouping:\n            grouping[key] = self.random_generator.get_normal()\n        return grouping[key]\n\n    end_time = self.base_time\n\n    for dmd in self.eng.demands:\n        base = dmd.base_demand\n\n        if dmd.deterministic:\n            # Deterministic demand, no randomness\n            dmd.scenario_demand = base\n        else:\n            # Get the random numbers we're going to use to perturb demand\n            trn = get_or_make_random(trn_ref, (dmd.orig, dmd.dest, dmd.segment))\n            mrn = get_or_make_random(mrn_ref, (dmd.orig, dmd.dest))\n            if segment_k_factor:\n                srn = get_or_make_random(srn_ref, dmd.segment)\n            else:\n                srn = 0\n            if self.eng.config.simulation_controls.simple_cv100 &gt; 0.0:\n                sigma = self.eng.config.simulation_controls.simple_cv100 * sqrt(base) * 10.0\n                urn = self.random_generator.get_normal() * sigma\n            elif self.eng.config.simulation_controls.simple_k_factor:\n                urn = self.random_generator.get_normal() * self.eng.config.simulation_controls.simple_k_factor\n            else:\n                urn = 0\n\n            mu = base * (\n                1.0\n                + system_rn * self.eng.sys_k_factor\n                + mrn * self.eng.mkt_k_factor\n                + trn * self.eng.pax_type_k_factor\n                + srn * segment_k_factor\n                + urn\n            )\n            mu = max(mu, 0.0)\n            sigma = sqrt(mu * self.eng.config.simulation_controls.tot_z_factor)  # Correct?\n            n = mu + sigma * self.random_generator.get_normal()\n            dmd.scenario_demand = max(n, 0)\n\n            if debug:\n                logger.debug(\n                    f\"DMD,{self.eng.sample},{dmd.orig},{dmd.dest},\"\n                    f\"{dmd.segment},{dmd.base_demand},\"\n                    f\"{round(mu, 2)},{round(sigma, 2)},{round(n, 2)}\"\n                )\n\n        # Now we split it up over timeframes and add it to the simulation\n        num_pax = int(dmd.scenario_demand + 0.5)  # rounding\n        if self.eng.config.simulation_controls.timeframe_demand_allocation == \"pods\":\n            num_events_by_tf = self.eng.allocate_demand_to_tf_pods(\n                dmd, num_pax, self.eng.tf_k_factor, int(end_time)\n            )\n        else:\n            num_events_by_tf = self.eng.allocate_demand_to_tf(dmd, num_pax, self.eng.tf_k_factor, int(end_time))\n        num_events = sum(num_events_by_tf)\n        total_events += num_events\n        if num_events != round(num_pax):\n            raise ValueError(f\"Generate demand function, num_pax={num_pax}, num_events={num_events}\")\n\n    return total_events\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.generate_demands_gamma", "title": "generate_demands_gamma", "text": "<pre><code>generate_demands_gamma(system_rn=None, debug=False)\n</code></pre> <p>Using this as a quick test</p> Source code in <code>passengersim/driver.py</code> <pre><code>def generate_demands_gamma(self, system_rn=None, debug=False):\n    \"\"\"Using this as a quick test\"\"\"\n    self.generate_dcp_rm_events()\n    end_time = self.base_time\n    cv100 = 0.3\n    for dmd in self.eng.demands:\n        mu = dmd.base_demand\n        std_dev = cv100 * sqrt(mu) * 10.0\n        # std_dev = mu * 0.3\n        var = std_dev**2\n        shape_a = mu**2 / var\n        scale_b = var / mu\n        loc = 0.0\n        r = gamma.rvs(shape_a, loc, scale_b, size=1)\n        num_pax = int(r[0] + 0.5)\n        dmd.scenario_demand = num_pax\n        self.eng.allocate_demand_to_tf_pods(dmd, num_pax, self.eng.tf_k_factor, int(end_time))\n    total_events = 0\n    return total_events\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.get_choice_parameters", "title": "get_choice_parameters", "text": "<pre><code>get_choice_parameters(choicemodel: str | ChoiceModel)\n</code></pre> <p>Get the parameters for a choice model.</p> <p>Parameters:</p> <ul> <li> <code>choicemodel</code>               (<code>str or ChoiceModel</code>)           \u2013            <p>The choice model name (string) or ChoiceModel object to get parameters from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary containing the choice model parameters, including restrictions and their associated sigma values.</p> </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def get_choice_parameters(self, choicemodel: str | ChoiceModel):\n    \"\"\"\n    Get the parameters for a choice model.\n\n    Parameters\n    ----------\n    choicemodel : str or ChoiceModel\n        The choice model name (string) or ChoiceModel object to get\n        parameters from.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the choice model parameters, including\n        restrictions and their associated sigma values.\n    \"\"\"\n    if isinstance(choicemodel, str):\n        choicemodel = self.choice_models[choicemodel]\n    raw = choicemodel.get_parameters()\n    r = raw.pop(\"restrictions\", ())\n    rsigma = raw.pop(\"restriction_sigmas\", ())\n    for rname, rval, rsig in zip(self._fare_restriction_list, r, rsigma):\n        raw[f\"restrictions_{rname}\"] = rval\n        raw[f\"restrictions_{rname}_sigma\"] = rsig\n    return raw\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.get_restriction_name", "title": "get_restriction_name", "text": "<pre><code>get_restriction_name(restriction_num: int) -&gt; str\n</code></pre> <p>Convert restriction number to a restriction name.</p> <p>Parameters:</p> <ul> <li> <code>restriction_num</code>               (<code>int</code>)           \u2013            <p>The numeric identifier for the restriction (must be &gt;= 1).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The name of the restriction.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>IndexError</code>             \u2013            <p>If restriction_num is less than 1 or exceeds the number of defined restrictions.</p> </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def get_restriction_name(self, restriction_num: int) -&gt; str:\n    \"\"\"\n    Convert restriction number to a restriction name.\n\n    Parameters\n    ----------\n    restriction_num : int\n        The numeric identifier for the restriction (must be &gt;= 1).\n\n    Returns\n    -------\n    str\n        The name of the restriction.\n\n    Raises\n    ------\n    IndexError\n        If restriction_num is less than 1 or exceeds the number\n        of defined restrictions.\n    \"\"\"\n    if restriction_num &lt; 1:\n        raise IndexError(restriction_num)\n    return self._fare_restriction_list[restriction_num - 1]\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.license_info", "title": "license_info", "text": "<pre><code>license_info(certificate_filename=None)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def license_info(self, certificate_filename=None):\n    user_cert = self._user_certificate(certificate_filename)\n    return self.eng.license_info(user_cert)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.parse_restriction_flags", "title": "parse_restriction_flags", "text": "<pre><code>parse_restriction_flags(\n    restriction_flags: int,\n) -&gt; list[str]\n</code></pre> <p>Convert restriction flags to a list of restriction names.</p> <p>Parameters:</p> <ul> <li> <code>restriction_flags</code>               (<code>int</code>)           \u2013            <p>Integer bit flags representing which restrictions are active.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of restriction names corresponding to the set flags.</p> </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def parse_restriction_flags(self, restriction_flags: int) -&gt; list[str]:\n    \"\"\"\n    Convert restriction flags to a list of restriction names.\n\n    Parameters\n    ----------\n    restriction_flags : int\n        Integer bit flags representing which restrictions are active.\n\n    Returns\n    -------\n    list[str]\n        List of restriction names corresponding to the set flags.\n    \"\"\"\n    result = []\n    rest_num = 1\n    rest_names = self._fare_restriction_list\n    while restriction_flags:\n        if restriction_flags &amp; 1:\n            result.append(rest_names[rest_num - 1])\n        rest_num += 1\n        restriction_flags &gt;&gt;= 1\n    return result\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.reseed", "title": "reseed", "text": "<pre><code>reseed(seed: int | list[int] | None = 42)\n</code></pre> <p>Reseed the simulation's random number generator.</p> <p>Parameters:</p> <ul> <li> <code>seed</code>               (<code>int, list[int], or None</code>, default:                   <code>42</code> )           \u2013            <p>Seed value(s) for the random number generator. Can be a single integer, a list of integers, or None.</p> </li> </ul> Notes <p>This method updates the random seed for the simulation's internal random number generator, affecting all subsequent random operations.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def reseed(self, seed: int | list[int] | None = 42):\n    \"\"\"\n    Reseed the simulation's random number generator.\n\n    Parameters\n    ----------\n    seed : int, list[int], or None, default 42\n        Seed value(s) for the random number generator. Can be a single\n        integer, a list of integers, or None.\n\n    Notes\n    -----\n    This method updates the random seed for the simulation's internal\n    random number generator, affecting all subsequent random operations.\n    \"\"\"\n    logger.debug(\"reseeding random_generator: %s\", seed)\n    self.eng.random_generator.seed(seed)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.run", "title": "run", "text": "<pre><code>run(\n    log_reports: bool = False,\n    *,\n    single_trial: int | None = None,\n    summarizer: type[SimulationTablesT]\n    | SimulationTablesT\n    | None = SimulationTables,\n    rich_progress: Progress | None = None,\n) -&gt; SummaryTables | SimulationTablesT\n</code></pre> <p>Run the simulation and compute reports.</p> <p>Parameters:</p> <ul> <li> <code>log_reports</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>single_trial</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Run only a single trial, with the given trial number (to get the correct fixed random seed, for example).</p> </li> <li> <code>summarizer</code>               (<code>type[SimulationTables] | SimulationTables | None</code>, default:                   <code>SimulationTables</code> )           \u2013            <p>Use this summarizer to compute the reports.  If None, the reports are computed in the SummaryTables object; this option is deprecated and will eventually be removed.</p> </li> <li> <code>rich_progress</code>               (<code>Progress</code>, default:                   <code>None</code> )           \u2013            <p>A rich Progress object to use for displaying progress.  If not provided, a new Progress object will be created unless the simulation configuration specifies not to show progress.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SimulationTables or SummaryTables</code>           \u2013            </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def run(\n    self,\n    log_reports: bool = False,\n    *,\n    single_trial: int | None = None,\n    summarizer: type[SimulationTablesT] | SimulationTablesT | None = SimulationTables,\n    rich_progress: Progress | None = None,\n) -&gt; SummaryTables | SimulationTablesT:\n    \"\"\"\n    Run the simulation and compute reports.\n\n    Parameters\n    ----------\n    log_reports : bool\n    single_trial : int, optional\n        Run only a single trial, with the given trial number (to get\n        the correct fixed random seed, for example).\n    summarizer : type[SimulationTables] | SimulationTables | None\n        Use this summarizer to compute the reports.  If None, the\n        reports are computed in the SummaryTables object; this option\n        is deprecated and will eventually be removed.\n    rich_progress : Progress, optional\n        A rich Progress object to use for displaying progress.  If not\n        provided, a new Progress object will be created unless the\n        simulation configuration specifies not to show progress.\n\n    Returns\n    -------\n    SimulationTables or SummaryTables\n    \"\"\"\n    if summarizer is None:\n        warnings.warn(\n            \"Using SummaryTables to compute reports is deprecated, prefer SimulationTables in new code.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    start_time = time.time()\n    self.setup_scenario()\n    if single_trial is not None:\n        self._run_sim_single_trial(single_trial, rich_progress=rich_progress)\n    else:\n        self._run_sim(rich_progress=rich_progress)\n    if self.choice_set_file is not None:\n        self.choice_set_file.close()\n    logger.info(\"Computing reports\")\n    if summarizer is None:\n        summary = self.compute_reports(\n            self.eng,\n            to_log=log_reports or self.eng.config.outputs.log_reports,\n            additional=self.eng.config.outputs.reports,\n        )\n        logger.info(\"Saving reports\")\n        if self.eng.config.outputs.excel:\n            summary.to_xlsx(self.eng.config.outputs.excel)\n    else:\n        if isinstance(summarizer, GenericSimulationTables):\n            summary = summarizer._extract(self)\n        elif issubclass(summarizer, GenericSimulationTables):\n            summary = summarizer.extract(self)\n        else:\n            raise TypeError(\"summarizer must be an instance or subclass of GenericSimulationTables\")\n\n    # check all callbacks for tracers, and if any are found, write their\n    # finalized data to callback_data\n    for cb_group in [\n        \"daily_callbacks\",\n        \"begin_sample_callbacks\",\n        \"end_sample_callbacks\",\n    ]:\n        for cb in getattr(self, cb_group, []):\n            if isinstance(cb, GenericTracer):\n                summary.callback_data[cb.name] = cb.finalize()\n\n    # write output files if designated\n    if isinstance(summary, GenericSimulationTables):\n        if self.config.outputs.html and (\n            self.config.outputs.disk is True or self.config.outputs.html.filename == self.config.outputs.disk\n        ):\n            # this will ensure the html and disk files have the same timestamp\n            filenames = summary.save(self.config.outputs.html.filename)\n            summary._metadata[\"outputs.html_filename\"] = filenames[\".html\"]\n            summary._metadata[\"outputs.disk_filename\"] = filenames[\".pxsim\"]\n        else:\n            if self.config.outputs.html:\n                out_filename = summary.to_html(self.config.outputs.html.filename)\n                summary._metadata[\"outputs.html_filename\"] = out_filename\n            if isinstance(self.config.outputs.disk, str | pathlib.Path):\n                out_filename = summary.to_file(self.config.outputs.disk)\n                summary._metadata[\"outputs.disk_filename\"] = out_filename\n        if self.config.outputs.pickle:\n            pkl_filename = summary.to_pickle(self.config.outputs.pickle)\n            summary._metadata[\"outputs.pickle_filename\"] = pkl_filename\n        if self.config.outputs.excel:\n            summary.to_xlsx(self.config.outputs.excel)\n\n    logger.info(f\"Th' th' that's all folks !!!    (Elapsed time = {round(time.time() - start_time, 2)})\")\n    return summary\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.run_carrier_models", "title": "run_carrier_models", "text": "<pre><code>run_carrier_models(\n    info: Any = None, departed: bool = False, debug=False\n)\n</code></pre> <p>Run carrier revenue management models in response to events.</p> <p>Parameters:</p> <ul> <li> <code>info</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>Event information including event type and associated data.</p> </li> <li> <code>departed</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether this is a departure event.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to enable debug output.</p> </li> </ul> Notes <p>This method processes various event types including callbacks, DCP events, passenger arrivals, and departures. It coordinates the execution of revenue management processes for all carriers.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def run_carrier_models(self, info: Any = None, departed: bool = False, debug=False):\n    \"\"\"\n    Run carrier revenue management models in response to events.\n\n    Parameters\n    ----------\n    info : Any, optional\n        Event information including event type and associated data.\n    departed : bool, default False\n        Whether this is a departure event.\n    debug : bool, default False\n        Whether to enable debug output.\n\n    Notes\n    -----\n    This method processes various event types including callbacks,\n    DCP events, passenger arrivals, and departures. It coordinates\n    the execution of revenue management processes for all carriers.\n    \"\"\"\n    what_had_happened_was = []\n    try:\n        event_type = info[0]\n\n        if event_type.startswith(\"callback_\"):\n            # This is a callback function, not a string event type\n            # so, call it with the remaining arguments\n            callback_t = event_type[9:]\n            callback_f = info[1]\n            result = callback_f(self, *info[2:])\n            if isinstance(result, dict):\n                self.callback_data.update_data(callback_t, self.eng.trial, self.eng.sample, *info[2:], **result)\n            return\n\n        recording_day = info[1]  # could in theory be non-integer for fractional days\n        dcp_index = info[2]\n        if dcp_index == -1:\n            dcp_index = len(self.dcp_list) - 1\n\n        if event_type.lower() in {\"dcp\", \"done\"}:\n            self.eng.last_dcp = recording_day\n            self.eng.last_dcp_index = dcp_index\n            # self.capture_dcp_data(dcp_index)\n            # self.capture_competitor_data()  # Simulates Infare / QL2\n\n        # Run the specified process(es) for the carriers\n        for carrier in self.eng.carriers:\n            if isinstance(carrier.rm_system, RmSys):\n                continue\n            if carrier.rm_system is None:\n                continue\n            if event_type.lower() == \"dcp\":\n                # Regular Data Collection Points (pre-departure)\n                what_had_happened_was.append(f\"run {carrier.name} DCP\")\n                carrier.rm_system.run(\n                    self.eng,\n                    carrier.name,\n                    dcp_index,\n                    recording_day,\n                    event_type=\"dcp\",\n                )\n            elif event_type.lower() == \"daily\":\n                # Daily report, every day prior to departure EXCEPT specified DCPs\n                what_had_happened_was.append(f\"run {carrier.name} daily\")\n                carrier.rm_system.run(\n                    self.eng,\n                    carrier.name,\n                    dcp_index,\n                    recording_day,\n                    event_type=\"daily\",\n                )\n            elif event_type.lower() == \"done\":\n                # Post departure processing\n                what_had_happened_was.append(f\"run {carrier.name} done\")\n                carrier.rm_system.run(\n                    self.eng,\n                    carrier.name,\n                    dcp_index,\n                    recording_day,\n                    event_type=\"dcp\",\n                )\n                carrier.rm_system.run(\n                    self.eng,\n                    carrier.name,\n                    dcp_index,\n                    recording_day,\n                    event_type=\"departure\",\n                )\n                if self.eng.sample % 7 == 0:\n                    # Can be used less frequently,\n                    # such as ML steps on accumulated data\n                    carrier.rm_system.run(\n                        self.eng,\n                        carrier.name,\n                        dcp_index,\n                        recording_day,\n                        event_type=\"weekly\",\n                    )\n\n        # Internal simulation data capture that is normally done by RM systems\n        if event_type.lower() in {\"dcp\", \"done\"}:\n            self.eng.last_dcp = recording_day\n            self.eng.last_dcp_index = dcp_index\n            self.capture_dcp_data(dcp_index)\n            what_had_happened_was.append(\"capture_dcp_close_data\")\n            if self.eng.config.simulation_controls.capture_competitor_data:\n                self.capture_competitor_data()  # Simulates Infare / QL2\n\n        # Database capture\n        if event_type.lower() == \"daily\":\n            if self.cnx.is_open and self.eng.save_timeframe_details and recording_day &gt; 0:\n                # if self.sim.sample == 101:\n                #     print(\"write_to_sqlite DAILY\")\n                what_had_happened_was.append(\"write_to_sqlite daily\")\n                _internal_log = self.db_writer.write_to_sqlite(\n                    self.cnx._connection,\n                    recording_day,\n                    store_bid_prices=self.eng.config.db.store_leg_bid_prices,\n                    intermediate_day=True,\n                    store_displacements=self.eng.config.db.store_displacements,\n                )\n        elif event_type.lower() in {\"dcp\", \"done\"}:\n            if event_type.lower() == \"done\" and \"forecast_accuracy\" in self.config.outputs.reports:\n                self.eng.capture_forecast_accuracy()\n            if self.cnx.is_open:\n                self.cnx.save_details(self.db_writer, self.eng, recording_day)\n            if self.file_writer is not None:\n                self.file_writer.save_details(self.eng, recording_day)\n\n        # simulation statistics record\n        if event_type.lower() in {\"dcp\", \"done\"}:\n            self.eng.record_dcp_statistics(recording_day)\n        self.eng.record_daily_statistics(recording_day)\n\n    except Exception:\n        # print(e)\n        # print(\"Error in run_carrier_models\")\n        # print(f\"{info=}\")\n        # print(\"what_had_happened_was=\", what_had_happened_was)\n        raise\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.run_single_sample", "title": "run_single_sample", "text": "<pre><code>run_single_sample() -&gt; int\n</code></pre> <p>Context manager to run the next sample in the current trial.</p> <p>On entry, the sample number is run through to departure, so all sales have happened, but per-sample wrap up (e.g. rolling history forward, resetting counters) is deferred until exit.  This is useful for running a single sample in a testing framework.</p> <p>Yields:</p> <ul> <li> <code>int</code>           \u2013            <p>The sample number just completed.</p> </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>@contextlib.contextmanager\ndef run_single_sample(self) -&gt; int:\n    \"\"\"Context manager to run the next sample in the current trial.\n\n    On entry, the sample number is run through to departure, so all\n    sales have happened, but per-sample wrap up (e.g. rolling history\n    forward, resetting counters) is deferred until exit.  This is useful\n    for running a single sample in a testing framework.\n\n    Yields\n    ------\n    int\n        The sample number just completed.\n    \"\"\"\n    if self.eng.trial &lt; 0:\n        warnings.warn(\n            \"Trial must be started before running a sample, implicitly starting Trial 0\",\n            skip_file_prefixes=_warn_skips,\n            stacklevel=1,\n        )\n        self.begin_trial(0)\n    self.begin_sample()\n    while True:\n        event = self.eng.go()\n        self.run_carrier_models(event)\n        if event is None or str(event) == \"Done\" or (event[0] == \"Done\"):\n            assert self.eng.num_events() == 0, f\"Event queue still has {self.eng.num_events()} events\"\n            break\n    yield self.eng.sample\n    self.end_sample()\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.run_trial", "title": "run_trial", "text": "<pre><code>run_trial(\n    trial: int, log_reports: bool = False\n) -&gt; SummaryTables\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def run_trial(self, trial: int, log_reports: bool = False) -&gt; SummaryTables:\n    self.setup_scenario()\n    self.eng.trial = trial\n\n    update_freq = self.update_frequency\n    logger.debug(f\"run_sim, num_trials = {self.eng.num_trials}, num_samples = {self.eng.num_samples}\")\n    self.db_writer.update_db_write_flags()\n    n_samples_total = self.eng.num_samples\n    n_samples_done = 0\n    self.sample_done_callback(n_samples_done, n_samples_total)\n    if self.eng.config.simulation_controls.show_progress_bar:\n        progress = ProgressBar(total=n_samples_total)\n    else:\n        progress = DummyProgressBar()\n    with progress:\n        self._run_single_trial(\n            trial,\n            n_samples_done,\n            n_samples_total,\n            progress,\n            update_freq,\n        )\n    summary = self.compute_reports(\n        self.eng,\n        to_log=log_reports or self.eng.config.outputs.log_reports,\n        additional=self.eng.config.outputs.reports,\n    )\n    return summary\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.set_choice_parameters", "title": "set_choice_parameters", "text": "<pre><code>set_choice_parameters(\n    choicemodel: str | ChoiceModel, values: dict[str, float]\n)\n</code></pre> <p>Set the parameters for a choice model.</p> <p>Parameters:</p> <ul> <li> <code>choicemodel</code>               (<code>str or ChoiceModel</code>)           \u2013            <p>The choice model name (string) or ChoiceModel object to update.</p> </li> <li> <code>values</code>               (<code>dict[str, float]</code>)           \u2013            <p>Dictionary of parameter names and their new values. Can include restriction parameters using the format 'restrictions_{name}'.</p> </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def set_choice_parameters(self, choicemodel: str | ChoiceModel, values: dict[str, float]):\n    \"\"\"\n    Set the parameters for a choice model.\n\n    Parameters\n    ----------\n    choicemodel : str or ChoiceModel\n        The choice model name (string) or ChoiceModel object to update.\n    values : dict[str, float]\n        Dictionary of parameter names and their new values. Can include\n        restriction parameters using the format 'restrictions_{name}'.\n    \"\"\"\n    if isinstance(choicemodel, str):\n        choicemodel = self.choice_models[choicemodel]\n    raw = choicemodel.get_parameters()\n    for k, v in values.items():\n        if k.startswith(\"restrictions_\"):\n            if k.endswith(\"_sigma\"):\n                kr = k[13:-6]\n            else:\n                kr = k[13:]\n            position = self._fare_restriction_mapping[kr] - 1\n            if k.endswith(\"_sigma\"):\n                raw[\"restriction_sigmas\"][position] = v\n            else:\n                raw[\"restrictions\"][position] = v\n        else:\n            raw[k] = v\n    choicemodel.set_parameters(raw)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.set_classes", "title": "set_classes", "text": "<pre><code>set_classes(leg: Leg, _cabin, debug=False)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def set_classes(self, leg: passengersim.core.Leg, _cabin, debug=False):\n    leg_classes = self.config.carriers[leg.carrier.name].classes\n    cabin_code_list = [c.name for c in leg.cabins]\n    if len(leg_classes) == 0:\n        return\n    cap = float(leg.capacity)\n    if debug:\n        print(leg, \"Capacity = \", cap)\n    history_def = leg.carrier.get_history_def()\n    for bkg_class in leg_classes:\n        # Input as a percentage\n        auth = int(cap * self.init_rm.get(bkg_class, 100.0) / 100.0)\n        if isinstance(bkg_class, tuple):\n            # We are likely using multi-cabin, so unpack it\n            (bkg_class, cabin_code) = bkg_class\n        else:\n            cabin_code = bkg_class[0]\n        if cabin_code not in cabin_code_list:\n            continue\n        b = passengersim.core.Bucket(bkg_class, alloc=auth, history=history_def)\n        b.cabin = cabin_code\n        leg.add_bucket(b)\n        if debug:\n            print(\"    Added Bucket\", leg, bkg_class, auth)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.setup_scenario", "title": "setup_scenario", "text": "<pre><code>setup_scenario() -&gt; None\n</code></pre> <p>Set up the scenario for the simulation.</p> <p>This will delete any existing data in the database under the same simulation name, build the connections if needed, and then call the vn_initial_mapping method to set up the initial mapping for the carriers using virtual nesting.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def setup_scenario(self) -&gt; None:\n    \"\"\"\n    Set up the scenario for the simulation.\n\n    This will delete any existing data in the database under the same simulation\n    name, build the connections if needed, and then call the vn_initial_mapping\n    method to set up the initial mapping for the carriers using virtual nesting.\n    \"\"\"\n    self.cnx.delete_experiment(self.eng.name)\n    logger.debug(\"building connections\")\n    num_paths = self.eng.build_connections()\n    self.eng.compute_hhi()\n    if num_paths and self.cnx.is_open:\n        database.tables.create_table_path_defs(self.cnx._connection, self.eng.paths)\n    logger.debug(f\"Connections done, num_paths = {num_paths}\")\n    self.eng.initialize_bucket_ap_rules()\n\n    # start with default number of timeframes\n    num_timeframes_default = len(self.config.dcps)\n    if len(self.config.dcps) and self.config.dcps[-1] == 0:\n        num_timeframes_default -= 1\n\n    # initialize pathclasses for each carrier, using settings from the carrier\n    # to size the history buffers\n    # Also, Q-demand can be forecasted by pathclass even in the absence of bookings\n    for carrier in self.eng.carriers:\n        self.eng.initialize_pathclasses(carrier.get_history_def(), carrier.name)\n        try:\n            self.vn_initial_mapping(carrier.name)\n        except Exception as e:\n            print(e)\n\n    # TODO: only initialize nonstop linkage when needed?\n    self.eng.initialize_nonstop_path_linkage()\n\n    # Compute a sampling probability to get approximately the number of\n    # choice sets requested\n    if self.choice_set_file is not None and self.choice_set_obs &gt; 0:\n        tot_dmd = 0\n        for d in self.config.demands:\n            if len(self.choice_set_mkts) == 0 or (d.orig, d.dest) in self.choice_set_mkts:\n                tot_dmd += d.base_demand\n        usable_samples = self.eng.num_trials * (self.eng.num_samples - self.eng.burn_samples)\n        total_choice_sets = tot_dmd * usable_samples\n        prob = self.choice_set_obs / total_choice_sets if total_choice_sets &gt; 0 else 0\n        self.eng.choice_set_sampling_probability = prob\n        self.eng.choice_set_mkts = self.choice_set_mkts\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.validate_license", "title": "validate_license", "text": "<pre><code>validate_license(\n    certificate_filename=None, future: int = 0\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def validate_license(self, certificate_filename=None, future: int = 0):\n    user_cert = self._user_certificate(certificate_filename)\n    return self.eng.validate_license(user_cert, future=future)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.vn_initial_mapping", "title": "vn_initial_mapping", "text": "<pre><code>vn_initial_mapping(carrier_code)\n</code></pre> <p>Set up initial virtual nesting mapping for a carrier.</p> <p>Parameters:</p> <ul> <li> <code>carrier_code</code>               (<code>str</code>)           \u2013            <p>The carrier code to set up virtual nesting mapping for.</p> </li> </ul> Notes <p>This method assigns index values to path classes for carriers using virtual nesting, which allows revenue management systems to map between physical and virtual booking classes.</p> Source code in <code>passengersim/driver.py</code> <pre><code>def vn_initial_mapping(self, carrier_code):\n    \"\"\"\n    Set up initial virtual nesting mapping for a carrier.\n\n    Parameters\n    ----------\n    carrier_code : str\n        The carrier code to set up virtual nesting mapping for.\n\n    Notes\n    -----\n    This method assigns index values to path classes for carriers\n    using virtual nesting, which allows revenue management systems\n    to map between physical and virtual booking classes.\n    \"\"\"\n    for path in self.eng.paths:\n        if path.get_leg_carrier(0) == carrier_code:\n            for i, pc in enumerate(path.pathclasses):\n                pc.set_index(0, i)\n</code></pre>"}, {"location": "API/summary.html", "title": "Summary Results", "text": ""}, {"location": "API/summary.html#passengersim.summary.logger", "title": "logger  <code>module-attribute</code>", "text": "<pre><code>logger = getLogger('passengersim.summary')\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables", "title": "SummaryTables", "text": "Source code in <code>passengersim/summary.py</code> <pre><code>class SummaryTables:\n    @classmethod\n    def from_sqlite(\n        cls,\n        filename: str | pathlib.Path,\n        make_indexes: bool | dict = False,\n        additional: Collection[str | tuple] | str | None = None,\n    ):\n        summarytables_is_deprecated()\n        if not os.path.isfile(filename):\n            raise FileNotFoundError(filename)\n        db = database.Database(\n            engine=\"sqlite\",\n            filename=filename,\n        )\n\n        demands = cls.load_basic_table(db, \"demand_summary\")\n        legs = cls.load_basic_table(db, \"leg_summary\")\n        paths = cls.load_basic_table(db, \"path_summary\")\n        carriers = cls.load_basic_table(db, \"carrier_summary\")\n\n        summary = cls(\n            demands=demands,\n            legs=legs,\n            paths=paths,\n            carriers=carriers,\n        )\n\n        if make_indexes:\n            if isinstance(make_indexes, dict):\n                db.add_indexes(**make_indexes)\n            else:\n                db.add_indexes()\n\n        logger.info(\"loading configs\")\n        config = db.load_configs(on_validation_error=\"ignore\")\n        try:\n            scenario = config.scenario\n            burn_samples = config.simulation_controls.burn_samples\n        except AttributeError:\n            scenario = config.get(\"scenario\", \"unknown\")\n            burn_samples = config.get(\"simulation_controls\", {}).get(\"burn_samples\", 100)\n\n        summary.load_additional_tables(\n            db,\n            scenario=scenario,\n            burn_samples=burn_samples,\n            additional=additional,\n        )\n        summary.cnx = db\n        return summary\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        if \"cnx\" in state:\n            del state[\"cnx\"]\n        if \"config\" in state:\n            # state[\"_config_yaml\"] = state[\"config\"].to_yaml()\n            del state[\"config\"]\n        if \"meta_trials\" in state and not state.get(\"_preserve_meta_trials\", True):\n            del state[\"meta_trials\"]\n        if \"_preserve_meta_trials\" in state:\n            del state[\"_preserve_meta_trials\"]\n        return state\n\n    def __setstate__(self, state):\n        # if \"_config_yaml\" in state:\n        #     state[\"config\"] = Config.from_raw_yaml(state.pop(\"_config_yaml\"))\n        self.__dict__.update(state)\n\n    def to_pickle(\n        self,\n        filename: str | pathlib.Path,\n        add_timestamp_ext: bool = True,\n        preserve_meta_trials: bool = False,\n    ):\n        \"\"\"Save the object to a pickle file.\n\n        Parameters\n        ----------\n        filename : str or Path-like\n            The filename to save the object to.\n        add_timestamp_ext : bool, default True\n            Add a timestamp extension to the filename.\n        \"\"\"\n        import dill as pickle\n\n        if add_timestamp_ext:\n            filename = filename_with_timestamp(filename, suffix=\".pkl\")\n\n        with open(filename, \"wb\") as f:\n            self._preserve_meta_trials = preserve_meta_trials\n            pickle.dump(self, f)\n            del self._preserve_meta_trials\n\n    @classmethod\n    def from_pickle(cls, filename: str | pathlib.Path, read_latest: bool = True):\n        \"\"\"Load the object from a pickle file.\n\n        Parameters\n        ----------\n        filename : str or Path-like\n            The filename to load the object from.\n        read_latest : bool, default True\n            If True, read the latest file matching the pattern.\n        \"\"\"\n        summarytables_is_deprecated()\n\n        import glob\n        import dill as pickle\n\n        if read_latest:\n            filename_glob = pathlib.Path(filename).with_suffix(\".*.pkl\")\n            files = sorted(glob.glob(str(filename_glob)))\n            if not files:\n                if not os.path.exists(filename):\n                    raise FileNotFoundError(filename)\n            else:\n                filename = files[-1]\n\n        with open(filename, \"rb\") as f:\n            result = pickle.load(f)\n            if result.__class__.__name__ != cls.__name__:\n                raise TypeError(f\"Expected {cls}, got {type(result)}\")\n            return result\n\n    @classmethod\n    def aggregate(cls, summaries: Collection[SummaryTables]):\n        \"\"\"Aggregate multiple summary tables.\"\"\"\n        summarytables_is_deprecated()\n\n        if not summaries:\n            return None\n\n        # dataframes where trial is in the index, just concatenate\n        def concat(name):\n            frames = []\n            for s in summaries:\n                frame = getattr(s, name)\n                if frame is not None:\n                    frames.append(frame)\n            if frames:\n                return pd.concat(frames)\n            return None\n\n        carrier_history = concat(\"carrier_history\")\n        bookings_by_timeframe = concat(\"bookings_by_timeframe\")\n        segmentation_by_timeframe = concat(\"segmentation_by_timeframe\")\n        demand_to_come = concat(\"demand_to_come\")\n\n        # demands has some columns that are averages and some that are sums\n        demands_avg = sum(\n            s.demands.set_index([\"orig\", \"dest\", \"segment\"])[[\"sold\", \"revenue\", \"avg_fare\"]] for s in summaries\n        ) / len(summaries)\n        demands_sum = sum(\n            s.demands.set_index([\"orig\", \"dest\", \"segment\"])[[\"gt_demand\", \"gt_sold\", \"gt_revenue\"]] for s in summaries\n        )\n        demands = pd.concat([demands_avg, demands_sum], axis=1).reset_index()\n\n        # TODO: aggregate fares\n        # fares has some columns that are (weighted) averages and some that are sums\n        # fares_gt_adj_price = sum(\n        #     s.fares.set_index(\n        #     [\"carrier\", \"orig\", \"dest\", \"booking_class\", \"dcp_index\"]\n        #     ).eval(\"gt_sold * avg_adjusted_price\")\n        #     for s in summaries\n        # )\n        # fares_avg = sum(\n        #     s.fares.set_index(\n        #     [\"carrier\", \"orig\", \"dest\", \"booking_class\", \"dcp_index\"]\n        #     )[\n        #         [\"price\", \"gt_sold\"]\n        #     ]\n        #     for s in summaries\n        # ) / len(summaries)\n        # fares_sum = sum(\n        #     s.fares.set_index(\n        #     [\"carrier\", \"orig\", \"dest\", \"booking_class\", \"dcp_index\"]\n        #     )[\n        #         [\"gt_sold\"]\n        #     ]\n        #     for s in summaries\n        # )\n\n        # TODO: aggregate path_classes\n\n        # these are averages, but need to have the index values excluded\n        # TODO: the index values should be set properly on the original dataframes\n        carriers = sum(s.carriers.set_index(\"carrier\") for s in summaries) / len(summaries)\n        legs = sum(s.legs.set_index([\"carrier\", \"leg_id\", \"flt_no\", \"orig\", \"dest\"]) for s in summaries) / len(\n            summaries\n        )\n        legs = legs.reset_index()\n        paths = sum(s.paths.set_index([\"orig\", \"dest\", \"carrier1\", \"leg_id1\", \"carrier2\"]) for s in summaries) / len(\n            summaries\n        )\n\n        def average(name):\n            frames = []\n            for s in summaries:\n                frame = getattr(s, name)\n                if frame is not None:\n                    frames.append(frame)\n            if frames:\n                return sum(frames) / len(frames)\n            return None\n\n        fare_class_mix = average(\"fare_class_mix\")\n        leg_forecasts = average(\"leg_forecasts\")\n        path_forecasts = average(\"path_forecasts\")\n        bid_price_history = average(\"bid_price_history\")\n        displacement_history = average(\"displacement_history\")\n        demand_to_come_summary = average(\"demand_to_come_summary\")\n\n        # dataframes with count data that need to be summed\n        def sum_count(name):\n            frames = []\n            for s in summaries:\n                frame = getattr(s, name)\n                if frame is not None:\n                    frames.append(frame)\n            if frames:\n                return sum(frames)\n            return None\n\n        raw_load_factor_distribution = sum_count(\"raw_load_factor_distribution\")\n        leg_avg_load_factor_distribution = sum_count(\"leg_avg_load_factor_distribution\")\n        raw_fare_class_mix = sum_count(\"raw_fare_class_mix\")\n        leg_local_fraction_distribution = sum_count(\"leg_local_fraction_distribution\")\n\n        result = cls(\n            demands=demands,\n            legs=legs,\n            paths=paths,\n            carriers=carriers,\n            fare_class_mix=fare_class_mix,\n            leg_forecasts=leg_forecasts,\n            path_forecasts=path_forecasts,\n            carrier_history=carrier_history,\n            bookings_by_timeframe=bookings_by_timeframe,\n            segmentation_by_timeframe=segmentation_by_timeframe,\n            bid_price_history=bid_price_history,\n            displacement_history=displacement_history,\n            demand_to_come=demand_to_come,\n            demand_to_come_summary=demand_to_come_summary,\n            leg_avg_load_factor_distribution=leg_avg_load_factor_distribution,\n            leg_local_fraction_distribution=leg_local_fraction_distribution,\n            raw_load_factor_distribution=raw_load_factor_distribution,\n            raw_fare_class_mix=raw_fare_class_mix,\n            n_total_samples=sum(s.n_total_samples for s in summaries),\n        )\n        result.meta_trials = summaries\n        return result\n\n    @classmethod\n    def from_sqlite_glob(\n        cls,\n        pattern: str,\n        make_indexes: bool | dict = False,\n        additional: Collection[str | tuple] | str | None = None,\n        *,\n        load_config: bool = True,\n        max_num_files: int = 9999,\n    ):\n        \"\"\"\n        Load and aggregate multiple summary tables from a glob pattern.\n\n        Parameters\n        ----------\n        pattern : str\n            A glob pattern to match the files to load.\n        make_indexes\n        additional\n        load_config\n\n        Returns\n        -------\n        SummaryTables\n        \"\"\"\n        summarytables_is_deprecated()\n\n        import glob\n\n        cfg = None\n        raw = []\n        n = 0\n        for filename in glob.glob(pattern):\n            n += 1\n            if n &gt; max_num_files:\n                continue\n            raw.append(\n                cls.from_sqlite(\n                    filename,\n                    make_indexes=make_indexes,\n                    additional=additional,\n                )\n            )\n            if cfg is None and load_config:\n                cfg = raw[-1].cnx.load_configs(on_validation_error=\"ignore\")\n        if n &gt; max_num_files:\n            warnings.warn(\n                f\"Only loaded {max_num_files} of {n} files matching pattern\",\n                stacklevel=2,\n            )\n        try:\n            result = cls.aggregate(raw)\n        except Exception as e:\n            logger.error(\"Error aggregating summary tables: %s\", e)\n            logger.exception(e)\n            return raw\n        if cfg is not None:\n            result.config = cfg\n        return result\n\n    @classmethod\n    def load_basic_table(self, db: database.Database, tablename: str):\n        \"\"\"Load a basic table\"\"\"\n        logger.info(\"loading %s\", tablename)\n        return db.dataframe(f\"SELECT * FROM {tablename}\")\n\n    def load_additional_tables(\n        self,\n        db: database.Database,\n        scenario: str,\n        burn_samples: int,\n        additional: Collection[str | tuple] | str | None = (\n            \"fare_class_mix\",\n            \"bookings_by_timeframe\",\n            \"total_demand\",\n            \"load_factor_distribution\",\n        ),\n    ) -&gt; None:\n        \"\"\"\n        Load additional summary tables based on common queries.\n\n        Parameters\n        ----------\n        db : Database\n        scenario : str\n        burn_samples : int\n            The number of samples in the burn period.  The data from these samples\n            is ignored in most common queries.\n        additional : Collection[str | tuple] | str\n            One or more additional tables to load.  If \"*\", then this will load\n            all common queries supported by the configuration used during the\n            simulation.\n        \"\"\"\n        print(\"XXXXXXXXXXXXX\")\n        if isinstance(additional, str):\n            if additional == \"*\":\n                additional = set()\n                cfg = db.load_configs(scenario)\n                if \"fare\" in cfg.db.write_items:\n                    additional.add(\"fare_class_mix\")\n                if \"fare_final\" in cfg.db.write_items:\n                    additional.add(\"fare_class_mix\")\n                if \"bookings\" in cfg.db.write_items:\n                    additional.add(\"bookings_by_timeframe\")\n                if \"demand\" in cfg.db.write_items:\n                    additional.add(\"total_demand\")\n                    additional.add(\"demand_to_come\")\n                if \"demand_final\" in cfg.db.write_items:\n                    additional.add(\"total_demand\")\n                if \"bucket\" in cfg.db.write_items:\n                    additional.add(\"leg_forecasts\")\n                    additional.add(\"carrier_history\")\n                if \"pathclass\" in cfg.db.write_items:\n                    additional.add(\"path_forecasts\")\n                    additional.add(\"local_and_flow_yields\")\n                if \"pathclass_final\" in cfg.db.write_items:\n                    additional.add(\"local_and_flow_yields\")\n                if \"leg\" in cfg.db.write_items and cfg.db.store_leg_bid_prices:\n                    additional.add(\"bid_price_history\")\n                if \"leg\" in cfg.db.write_items and cfg.db.store_displacements:\n                    additional.add(\"displacement_history\")\n                if \"leg\" in cfg.db.write_items or \"leg_final\" in cfg.db.write_items:\n                    additional.add(\"load_factor_distribution\")\n            else:\n                additional = [additional]\n        elif additional is None:\n            additional = []\n\n        if \"fare_class_mix\" in additional and db.is_open:\n            logger.info(\"loading fare_class_mix\")\n            self.fare_class_mix = database.common_queries.fare_class_mix(db, scenario, burn_samples=burn_samples)\n            if self.od_fare_class_mix:\n                for orig, dest in list(self.od_fare_class_mix):\n                    self.od_fare_class_mix[(orig, dest)] = database.common_queries.od_fare_class_mix(\n                        db, orig, dest, scenario, burn_samples=burn_samples\n                    )\n        # load additional fare class mix tables\n        for i in additional:\n            if isinstance(i, tuple) and i[0] == \"od_fare_class_mix\" and db.is_open:\n                orig, dest = i[1], i[2]\n                if self.od_fare_class_mix is None:\n                    self.od_fare_class_mix = {}\n                logger.info(f\"loading od_fare_class_mix({orig},{dest})\")\n                self.od_fare_class_mix[(orig, dest)] = database.common_queries.od_fare_class_mix(\n                    db, orig, dest, scenario, burn_samples=burn_samples\n                )\n\n        for i in additional:\n            cutoffs = None\n            if i == \"load_factor_distribution\" and db.is_open:\n                cutoffs = (0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95)  # default cutoffs\n            elif isinstance(i, tuple) and i[0] == \"load_factor_distribution\" and db.is_open:\n                cutoffs = ast.literal_eval(i[1])\n            if cutoffs is not None:\n                logger.info(\"loading load_factor_distribution\")\n                self.load_factor_distribution = database.common_queries.load_factor_distribution(\n                    db,\n                    scenario=scenario,\n                    burn_samples=burn_samples,\n                    cutoffs=cutoffs,\n                )\n\n        if \"bookings_by_timeframe\" in additional and db.is_open:\n            logger.info(\"loading bookings_by_timeframe\")\n            self.bookings_by_timeframe = database.common_queries.bookings_by_timeframe(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"total_demand\" in additional and db.is_open:\n            logger.info(\"loading total_demand\")\n            self.total_demand = database.common_queries.total_demand(db, scenario=scenario, burn_samples=burn_samples)\n\n        if \"leg_forecasts\" in additional and db.is_open:\n            logger.info(\"loading leg_forecasts\")\n            self.leg_forecasts = database.common_queries.leg_forecasts(db, scenario=scenario, burn_samples=burn_samples)\n\n        if \"path_forecasts\" in additional and db.is_open:\n            logger.info(\"loading path_forecasts\")\n            self.path_forecasts = database.common_queries.path_forecasts(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"demand_to_come\" in additional and db.is_open:\n            logger.info(\"loading demand_to_come\")\n            self.demand_to_come = database.common_queries.demand_to_come(db, scenario=scenario)\n\n        if \"demand_to_come_summary\" in additional and db.is_open:\n            logger.info(\"loading demand_to_come_summary\")\n            self.demand_to_come_summary = database.common_queries.demand_to_come_summary(db, scenario=scenario)\n\n        if \"carrier_history\" in additional and db.is_open:\n            logger.info(\"loading carrier_history\")\n            self.carrier_history = database.common_queries.carrier_history(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"bid_price_history\" in additional and db.is_open:\n            logger.info(\"loading bid_price_history\")\n            self.bid_price_history = database.common_queries.bid_price_history(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"displacement_history\" in additional and db.is_open:\n            logger.info(\"loading displacement_history\")\n            self.displacement_history = database.common_queries.displacement_history(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"local_and_flow_yields\" in additional and db.is_open:\n            logger.info(\"loading local_and_flow_yields\")\n            self.local_and_flow_yields = database.common_queries.local_and_flow_yields(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"leg_local_and_flow_by_class\" in additional and db.is_open:\n            logger.info(\"loading leg_local_and_flow_by_class\")\n            self.leg_carried = database.common_queries.leg_local_and_flow_by_class(\n                db, scenario=scenario, burn_samples=burn_samples\n            )\n\n        if \"edgar\" in additional and db.is_open:\n            logger.info(\"loading edgar\")\n            self.edgar = database.common_queries.edgar(db, scenario=scenario, burn_samples=burn_samples)\n\n    def __init__(\n        self,\n        *,\n        name: str | None = \"name?\",\n        config: Config | None = None,\n        cnx: database.Database | None = None,\n        sim: Simulation | None = None,\n        cabins: pd.DataFrame | None = None,\n        class_dist: pd.DataFrame | None = None,\n        demands: pd.DataFrame | None = None,\n        fares: pd.DataFrame | None = None,\n        legs: pd.DataFrame | None = None,\n        paths: pd.DataFrame | None = None,\n        path_classes: pd.DataFrame | None = None,\n        carriers: pd.DataFrame | None = None,\n        fare_class_mix: pd.DataFrame | None = None,\n        load_factors: pd.DataFrame | None = None,\n        bookings_by_timeframe: pd.DataFrame | None = None,\n        segmentation_by_timeframe: pd.DataFrame | None = None,\n        total_demand: float | None = None,\n        od_fare_class_mix: dict[tuple[str, str], pd.DataFrame] | None = None,\n        leg_forecasts: pd.DataFrame | None = None,\n        path_forecasts: pd.DataFrame | None = None,\n        carrier_history: pd.DataFrame | None = None,\n        demand_to_come: pd.DataFrame | None = None,\n        demand_to_come_summary: pd.DataFrame | None = None,\n        bid_price_history: pd.DataFrame | None = None,\n        displacement_history: pd.DataFrame | None = None,\n        local_and_flow_yields: pd.DataFrame | None = None,\n        leg_carried: pd.DataFrame | None = None,\n        load_factor_distribution: pd.DataFrame | None = None,\n        leg_avg_load_factor_distribution: pd.DataFrame | None = None,\n        raw_load_factor_distribution: pd.DataFrame | None = None,\n        raw_fare_class_mix: pd.DataFrame | None = None,\n        leg_local_fraction_distribution: pd.DataFrame | None = None,\n        local_fraction_by_place: pd.DataFrame | None = None,\n        n_total_samples: int = 0,\n    ):\n        summarytables_is_deprecated()\n\n        self.config = config\n        \"\"\"Configuration used in the simulation that generated the summary tables.\"\"\"\n\n        self.cnx = cnx\n        \"\"\"The database connection used to load the summary tables.\"\"\"\n\n        self.sim = sim\n        \"\"\"The simulation object that generated the summary tables.\"\"\"\n\n        self.cabins = cabins\n        self.class_dist = class_dist\n        self.demands = demands\n        self.fares = fares\n        self.legs = legs\n        self.paths = paths\n        self.path_classes = path_classes\n        self.carriers = carriers\n        self.fare_class_mix = fare_class_mix\n        self.od_fare_class_mix = od_fare_class_mix\n        self.load_factors = load_factors\n        self.bookings_by_timeframe = bookings_by_timeframe\n        self.segmentation_by_timeframe = segmentation_by_timeframe\n        self.total_demand = total_demand\n        self.leg_forecasts = leg_forecasts\n        self.path_forecasts = path_forecasts\n        self.carrier_history = carrier_history\n        self.demand_to_come = demand_to_come\n        self.demand_to_come_summary = demand_to_come_summary\n        self.bid_price_history = bid_price_history\n        self.displacement_history = displacement_history\n        self.local_and_flow_yields = local_and_flow_yields\n        self.leg_carried = leg_carried\n        self.load_factor_distribution = load_factor_distribution\n\n        self.leg_avg_load_factor_distribution = leg_avg_load_factor_distribution\n        \"\"\"Leg average load factor distribution (integers 0-100).\"\"\"\n\n        self.raw_load_factor_distribution = raw_load_factor_distribution\n        \"\"\"Total number of departures by carrier by load factor (integers 0-100).\"\"\"\n\n        self.raw_fare_class_mix = raw_fare_class_mix\n        \"\"\"Total number of passengers by carrier by fare class.\"\"\"\n\n        self.leg_local_fraction_distribution = leg_local_fraction_distribution\n        \"\"\"Fraction of local passengers on each leg.\"\"\"\n\n        self.local_fraction_by_place = local_fraction_by_place\n        \"\"\"Fraction of local passengers by place.\"\"\"\n\n        self.n_total_samples = n_total_samples\n        \"\"\"Total number of sample departures simulated to create these summaries.\n\n        This excludes any burn samples.\n        \"\"\"\n\n    def to_records(self) -&gt; dict[str, list[dict]]:\n        \"\"\"Convert all summary tables to a dictionary of records.\"\"\"\n        return {k: v.to_dict(orient=\"records\") for (k, v) in self.__dict__.items()}\n\n    def to_xlsx(self, filename: str | pathlib.Path) -&gt; None:\n        \"\"\"Write summary tables to excel.\n\n        Parameters\n        ----------\n        filename : Path-like\n            The excel file to write.\n        \"\"\"\n        if isinstance(filename, str):\n            filename = pathlib.Path(filename)\n        filename.parent.mkdir(exist_ok=True, parents=True)\n        with pd.ExcelWriter(filename) as writer:\n            for k, v in self.__dict__.items():\n                if isinstance(v, pd.DataFrame):\n                    v.to_excel(writer, sheet_name=k)\n\n    def to_dataframe(self, table) -&gt; pd.DataFrame:\n        \"\"\"Convert the summary tables to a individual dataframes.\"\"\"\n        sheet_count = 0\n        for k, v in self.__dict__.items():\n            if isinstance(v, pd.DataFrame):\n                sheet_count += 1\n                if sheet_count == table:\n                    return v.assign(table=k)\n\n        raise IndexError(\"There are fewer than\", table, \" DataFrames in the object\")\n\n    def aggregate_demand_history(self, by_segment: bool = True) -&gt; pd.Series:\n        \"\"\"\n        Total demand by sample, aggregated over all markets.\n\n        Parameters\n        ----------\n        by_segment : bool, default True\n            Aggregate by segment.  If false, segments are also aggregated.\n\n        Returns\n        -------\n        pandas.Series\n            Total demand, indexed by trial, sample, and segment\n            (business/leisure).\n        \"\"\"\n        groupbys = [\"trial\", \"sample\"]\n        if by_segment:\n            groupbys.append(\"segment\")\n        return self.demand_to_come.iloc[:, 0].groupby(groupbys, observed=False).sum()\n\n    def demand_in_tf(self) -&gt; pd.DataFrame | None:\n        \"\"\"History of demand arriving in each timeframe.\n\n        This dataframe is derived from the `demand_to_come` dataframe\n        by taking the sequential differences.\n        \"\"\"\n        if self.demand_to_come is None:\n            return None\n        return self.demand_to_come.diff(-1, axis=1).iloc[:, :-1]\n\n    def fig_carrier_mileage(self, raw_df: bool = False, report=None):\n        \"\"\"\n        Figure showing ASM, RPM by carrier.\n\n        ASM is available seat miles.  RPM is revenue passenger miles.\n\n        Parameters\n        ----------\n        raw_df : bool, default False\n            Return the raw data for this figure as a pandas DataFrame, instead\n            of generating the figure itself.\n        report : xmle.Reporter, optional\n            Also append this figure to the given report.\n        \"\"\"\n        df = (\n            self.carriers.reset_index()[[\"carrier\", \"asm\", \"rpm\"]]\n            .set_index(\"carrier\")\n            .rename_axis(columns=\"measure\")\n            .unstack()\n            .to_frame(\"value\")\n            .reset_index()\n        )\n        if raw_df:\n            return df\n        import altair as alt\n\n        chart = alt.Chart(df, title=\"Carrier Loads\")\n        bars = chart.mark_bar().encode(\n            x=alt.X(\"carrier:N\", title=\"Carrier\"),\n            y=alt.Y(\"value\", stack=None, title=\"miles\"),\n            color=\"measure\",\n            tooltip=[\"carrier\", \"measure\", alt.Tooltip(\"value\", format=\".4s\")],\n        )\n        text = chart.mark_text(\n            dx=0,\n            dy=5,\n            color=\"white\",\n            baseline=\"top\",\n        ).encode(\n            x=alt.X(\"carrier:N\"),\n            y=alt.Y(\"value\").stack(None),\n            text=alt.Text(\"value:Q\", format=\".4s\"),\n        )\n        fig = (\n            (bars + text)\n            .properties(\n                width=400,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n        if report:\n            report.add_figure(fig)\n        return fig\n\n    def _fig_fare_class_mix(self, df: pd.DataFrame, label_threshold: float = 0.06, title=None):\n        import altair as alt\n\n        label_threshold_value = df.groupby(\"carrier\", observed=False).avg_sold.sum().max() * label_threshold\n        chart = alt.Chart(df, **({\"title\": title} if title else {})).transform_calculate(\n            halfsold=\"datum.avg_sold / 2.0\",\n        )\n        bars = chart.mark_bar().encode(\n            x=alt.X(\"carrier:N\", title=\"Carrier\"),\n            y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n            color=\"booking_class\",\n            tooltip=[\n                \"carrier\",\n                \"booking_class\",\n                alt.Tooltip(\"avg_sold\", format=\".2f\"),\n            ],\n        )\n        text = chart.mark_text(dx=0, dy=3, color=\"white\", baseline=\"top\").encode(\n            x=alt.X(\"carrier:N\", title=\"Carrier\"),\n            y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n            text=alt.Text(\"avg_sold:Q\", format=\".2f\"),\n            opacity=alt.condition(\n                f\"datum.avg_sold &lt; {label_threshold_value:.3f}\",\n                alt.value(0),\n                alt.value(1),\n            ),\n            order=alt.Order(\"booking_class:N\", sort=\"descending\"),\n        )\n        return (\n            (bars + text)\n            .properties(\n                width=400,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n\n    @report_figure\n    def fig_fare_class_mix(self, raw_df=False, label_threshold=0.06):\n        if self.fare_class_mix is not None:\n            df = self.fare_class_mix.reset_index()[[\"carrier\", \"booking_class\", \"avg_sold\"]]\n        elif self.raw_fare_class_mix is not None and self.n_total_samples &gt; 0:\n            df = self.raw_fare_class_mix / self.n_total_samples\n            df = df.rename(columns={\"sold\": \"avg_sold\"})\n            df = df.reset_index()[[\"carrier\", \"booking_class\", \"avg_sold\"]]\n        else:\n            return None\n\n        if raw_df:\n            return df\n        return self._fig_fare_class_mix(\n            df,\n            label_threshold=label_threshold,\n            title=\"Fare Class Mix\",\n        )\n\n    @report_figure\n    def fig_od_fare_class_mix(self, orig: str, dest: str, raw_df=False, label_threshold=0.06):\n        df = self.od_fare_class_mix[orig, dest].reset_index()[[\"carrier\", \"booking_class\", \"avg_sold\"]]\n        if raw_df:\n            return df\n        return self._fig_fare_class_mix(df, label_threshold=label_threshold, title=f\"Fare Class Mix ({orig}-{dest})\")\n\n    @report_figure\n    def fig_load_factor_distribution(\n        self,\n        by_carrier: bool | str = True,\n        breakpoints: Collection[int] = (\n            50,\n            55,\n            60,\n            65,\n            70,\n            75,\n            80,\n            85,\n            90,\n            95,\n            100,\n        ),\n        source: Literal[\"leg_avg\", \"raw\", \"db\"] = \"leg_avg\",\n        raw_df=False,\n    ):\n        \"\"\"\n        Figure showing the distribution of leg load factors.\n\n        Parameters\n        ----------\n        by_carrier : bool or str, default True\n            If True, show the distribution by carrier.  If a string, show the\n            distribution for that carrier. If False, show the distribution\n            aggregated over all carriers.\n        breakpoints : Collection[int, ...], default (50, 55, 60, 65, ..., 90, 95, 100)\n            The breakpoints for the load factor ranges, which represent the lowest\n            load factor value in each bin. The first and last breakpoints are always\n            bounded to 0 and 101, respectively; these bounds can be included explicitly\n            or omitted to be included implicitly. Setting the top value to 101 ensures\n            that the highest load factor value (100) is included in the last bin.\n        source : {\"raw\", \"db\"}, default \"raw\"\n            The source of the data.  \"raw\" uses the raw load factor distribution\n            output from the simulation, which is faster and preferred if available.\n            \"db\" uses the older load factor distribution table, which is extracted\n            as a query from the database.  This requires leg level departure (final)\n            details to have been recorded in the database, but potentially allows\n            arbitrary custom filters or transformations to be applied.\n        raw_df : bool, default False\n            Return the raw data for this figure as a pandas DataFrame, instead\n            of generating the figure itself.\n\n        Returns\n        -------\n        altair.Chart or pd.DataFrame\n        \"\"\"\n        title = \"Load Factor Frequency\"  # default title\n        if source == \"raw\" or source == \"leg_avg\":\n            # Load using faster raw load factor data generated by the simulation\n            # This is faster than loading from the database and now preferred\n            if source == \"raw\":\n                if self.raw_load_factor_distribution is None:\n                    raise AttributeError(\n                        \"raw_load_factor_distribution not found, \" \"it is required for using raw source data.\"\n                    )\n                df_for_chart = (\n                    self.raw_load_factor_distribution.rename_axis(columns=\"carrier\")\n                    .stack(future_stack=True)\n                    .rename(\"Count\")\n                    .reset_index()\n                )\n                title = \"Raw Load Factor Frequency\"\n            elif source == \"leg_avg\":\n                if self.leg_avg_load_factor_distribution is None:\n                    raise AttributeError(\n                        \"leg_avg_load_factor_distribution not found, \" \"it is required for using leg_avg source data.\"\n                    )\n                df_for_chart = (\n                    self.leg_avg_load_factor_distribution.rename_axis(columns=\"carrier\")\n                    .stack(future_stack=True)\n                    .rename(\"Count\")\n                    .reset_index()\n                )\n                title = \"Leg Average Load Factor Frequency\"\n            if not isinstance(breakpoints, tuple):\n                breakpoints = tuple(breakpoints)\n            if breakpoints[0] &lt;= 0:\n                breakpoints = (-1,) + breakpoints[1:]\n            else:\n                breakpoints = (-1,) + breakpoints\n            if breakpoints[-1] &gt;= 101:\n                breakpoints = breakpoints[:-1] + (101,)\n            else:\n                breakpoints = breakpoints + (101,)\n\n            # Create labels for categories\n            def make_label(i, j):\n                if i == j - 1:\n                    return f\"{i}\"\n                else:\n                    return f\"{i}-{j-1}\"\n\n            labels = [make_label(0, breakpoints[1])]\n            for i in range(1, len(breakpoints) - 2):\n                labels += [make_label(breakpoints[i], breakpoints[i + 1])]\n            if breakpoints[-2] &lt; 100:\n                labels += [make_label(breakpoints[-2], 101)]\n            else:\n                labels += [\"100\"]\n            breaker = pd.cut(\n                df_for_chart.leg_load_factor,\n                bins=breakpoints,\n                right=False,\n                labels=labels,\n            ).rename(\"Load Factor Range\")\n            df_for_chart = df_for_chart.groupby([\"carrier\", breaker], observed=False).Count.sum().reset_index()\n\n        elif source == \"db\":\n            # Older load factor distribution table, taken from database\n            if not hasattr(self, \"load_factor_distribution\"):\n                raise AttributeError(\"load_factor_distribution data not found. Please load it first.\")\n\n            df_for_chart = self.load_factor_distribution\n            df_for_chart.columns.names = [\"Load Factor Range\"]\n            df_for_chart = df_for_chart.set_index(\"carrier\")\n            df_for_chart = df_for_chart.stack(future_stack=True).rename(\"Count\").reset_index()\n\n        else:\n            raise ValueError(f\"Unknown source {source}, should be 'raw' or 'db'\")\n\n        if not by_carrier:\n            df_for_chart = df_for_chart.groupby([\"Load Factor Range\"], observed=False).Count.sum().reset_index()\n        elif isinstance(by_carrier, str):\n            df_for_chart = df_for_chart[df_for_chart[\"carrier\"] == by_carrier]\n            df_for_chart = df_for_chart.drop(columns=[\"carrier\"])\n\n        if raw_df:\n            return df_for_chart\n\n        import altair as alt\n\n        if by_carrier is True:\n            chart = (\n                alt.Chart(df_for_chart)\n                .mark_bar()\n                .encode(\n                    x=alt.X(\"Load Factor Range\", title=\"Load Factor Range\"),\n                    y=alt.Y(\"Count:Q\", title=\"Count\"),\n                    facet=alt.Facet(\"carrier:N\", columns=2, title=\"Carrier\"),\n                    tooltip=[\n                        alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                        alt.Tooltip(\"Count\", title=\"Count\"),\n                    ],\n                )\n                .properties(width=300, height=250, title=f\"{title} by Carrier\")\n            )\n        else:\n            chart = (\n                alt.Chart(df_for_chart)\n                .mark_bar()\n                .encode(\n                    x=alt.X(\"Load Factor Range\", title=\"Load Factor Range\"),\n                    y=alt.Y(\"Count:Q\", title=\"Count\"),\n                )\n                .properties(\n                    width=600,\n                    height=400,\n                    title=title if not by_carrier else f\"{title} ({by_carrier})\",\n                )\n            )\n\n        return chart\n\n    def fig_leg_local_fraction_distribution(\n        self,\n        by_carrier: bool | str = True,\n        breakpoints: Collection[int] = (\n            50,\n            55,\n            60,\n            65,\n            70,\n            75,\n            80,\n            85,\n            90,\n            95,\n            100,\n        ),\n        raw_df=False,\n    ):\n        \"\"\"\n        Figure showing the distribution of fraction of leg passengers who are local.\n\n        Parameters\n        ----------\n        by_carrier : bool or str, default True\n            If True, show the distribution by carrier.  If a string, show the\n            distribution for that carrier. If False, show the distribution\n            aggregated over all carriers.\n        breakpoints : Collection[int, ...], default (50, 55, 60, 65, ..., 90, 95, 100)\n            The breakpoints for the local fraction ranges, which represent the lowest\n            local fraction value in each bin. The first and last breakpoints are always\n            bounded to 0 and 101, respectively; these bounds can be included explicitly\n            or omitted to be included implicitly. Setting the top value to 101 ensures\n            that the highest local fraction value (100) is included in the last bin.\n        raw_df : bool, default False\n            Return the raw data for this figure as a pandas DataFrame, instead\n            of generating the figure itself.\n\n        Returns\n        -------\n        altair.Chart or pd.DataFrame\n        \"\"\"\n        title = \"Local Fraction Frequency\"  # default title\n        if self.leg_local_fraction_distribution is None:\n            raise AttributeError(\n                \"leg_local_fraction_distribution not found, \" \"it is required for using raw source data.\"\n            )\n        df_for_chart = (\n            self.leg_local_fraction_distribution.rename_axis(columns=\"carrier\")\n            .stack(future_stack=True)\n            .rename(\"Count\")\n            .reset_index()\n        )\n        if not isinstance(breakpoints, tuple):\n            breakpoints = tuple(breakpoints)\n        if breakpoints[0] &lt;= 0:\n            breakpoints = (-1,) + breakpoints[1:]\n        else:\n            breakpoints = (-1,) + breakpoints\n        if breakpoints[-1] &gt;= 101:\n            breakpoints = breakpoints[:-1] + (101,)\n        else:\n            breakpoints = breakpoints + (101,)\n\n        # Create labels for categories\n        def make_label(i, j):\n            if i == j - 1:\n                return f\"{i}\"\n            else:\n                return f\"{i}-{j-1}\"\n\n        labels = [make_label(0, breakpoints[1])]\n        for i in range(1, len(breakpoints) - 2):\n            labels += [make_label(breakpoints[i], breakpoints[i + 1])]\n        if breakpoints[-2] &lt; 100:\n            labels += [make_label(breakpoints[-2], 101)]\n        else:\n            labels += [\"100\"]\n\n        breaker = pd.cut(\n            df_for_chart.local_fraction,\n            bins=breakpoints,\n            right=False,\n            labels=labels,\n        ).rename(\"Leg Local Fraction Range\")\n        df_for_chart = df_for_chart.groupby([\"carrier\", breaker], observed=False).Count.sum().reset_index()\n\n        if not by_carrier:\n            df_for_chart = df_for_chart.groupby([\"Leg Local Fraction Range\"], observed=False).Count.sum().reset_index()\n        elif isinstance(by_carrier, str):\n            df_for_chart = df_for_chart[df_for_chart[\"carrier\"] == by_carrier]\n            df_for_chart = df_for_chart.drop(columns=[\"carrier\"])\n\n        if raw_df:\n            return df_for_chart\n\n        import altair as alt\n\n        if by_carrier is True:\n            chart = (\n                alt.Chart(df_for_chart)\n                .mark_bar()\n                .encode(\n                    x=alt.X(\"Leg Local Fraction Range\", title=\"Leg Local Fraction Range\"),\n                    y=alt.Y(\"Count:Q\", title=\"Count\"),\n                    facet=alt.Facet(\"carrier:N\", columns=2, title=\"Carrier\"),\n                    tooltip=[\n                        alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                        alt.Tooltip(\"Count\", title=\"Count\"),\n                    ],\n                )\n                .properties(width=300, height=250, title=f\"{title} by Carrier\")\n            )\n        else:\n            chart = (\n                alt.Chart(df_for_chart)\n                .mark_bar()\n                .encode(\n                    x=alt.X(\"Leg Local Fraction Range\", title=\"Leg Local Fraction Range\"),\n                    y=alt.Y(\"Count:Q\", title=\"Count\"),\n                )\n                .properties(\n                    width=600,\n                    height=400,\n                    title=title if not by_carrier else f\"{title} ({by_carrier})\",\n                )\n            )\n        return chart\n\n    @report_figure\n    def fig_bookings_by_timeframe(\n        self,\n        by_carrier: bool | str = True,\n        by_class: bool | str = False,\n        raw_df: bool = False,\n        errorbands: bool = False,\n        exclude_nogo: bool = True,\n    ):\n        if errorbands:\n            if by_carrier is True:\n                raise NotImplementedError(\"error bands for all carriers is messy\")\n            return self._fig_bookings_by_timeframe_errorband(by_carrier=by_carrier, raw_df=raw_df)\n\n        def differs(x):\n            return x.shift(-1, fill_value=0) - x\n\n        def _summarize(x: pd.DataFrame, c: str):\n            if \"trial\" not in x.columns:\n                x = x.assign(trial=0)\n            if by_class:\n                y = (\n                    x.groupby(\n                        [\"trial\", \"carrier\", \"booking_class\", \"days_prior\"],\n                        observed=False,\n                    )[f\"avg_{c}\"]\n                    .sum()\n                    .unstack([\"trial\", \"carrier\", \"booking_class\"])\n                    .sort_index(ascending=False)\n                    .apply(differs)\n                    .stack([\"carrier\", \"booking_class\"], future_stack=True)\n                    .aggregate([\"mean\", \"sem\"], axis=1)\n                    .assign(\n                        ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                        ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                    )\n                )\n            else:\n                y = (\n                    x.groupby([\"trial\", \"carrier\", \"days_prior\"], observed=False)[f\"avg_{c}\"]\n                    .sum()\n                    .unstack([\"trial\", \"carrier\"])\n                    .sort_index(ascending=False)\n                    .apply(differs)\n                    .stack(\"carrier\", future_stack=True)\n                    .aggregate([\"mean\", \"sem\"], axis=1)\n                    .assign(\n                        ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                        ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                    )\n                )\n            return pd.concat({c: y}, names=[\"paxtype\"])\n\n        if self.bookings_by_timeframe is None:\n            raise ValueError(\"bookings_by_timeframe not found\")\n        bookings_by_timeframe = self.bookings_by_timeframe.reset_index()\n        df0 = _summarize(bookings_by_timeframe, \"business\")\n        df1 = _summarize(bookings_by_timeframe, \"leisure\")\n        df = (\n            pd.concat([df0, df1], axis=0)\n            .rename(columns={\"mean\": \"sold\"})\n            .reset_index()\n            .query(\"(days_prior&gt;0) &amp; (sold&gt;0)\")\n        )\n        title = \"Bookings by Timeframe\"\n        if by_class is True:\n            title = \"Bookings by Timeframe and Booking Class\"\n        title_annot = []\n        if not by_carrier:\n            g = [\"days_prior\", \"paxtype\"]\n            if by_class:\n                g += [\"booking_class\"]\n            df = df.groupby(g, observed=False)[[\"sold\", \"ci0\", \"ci1\"]].sum().reset_index()\n        if isinstance(by_carrier, str):\n            df = df[df[\"carrier\"] == by_carrier]\n            df = df.drop(columns=[\"carrier\"])\n            title_annot.append(by_carrier)\n            by_carrier = False\n        if isinstance(by_class, str):\n            df = df[df[\"booking_class\"] == by_class]\n            df = df.drop(columns=[\"booking_class\"])\n            title_annot.append(f\"Class {by_class}\")\n            by_class = False\n        if title_annot:\n            title = f\"{title} ({', '.join(title_annot)})\"\n        if exclude_nogo and \"carrier\" in df.columns:\n            df = df[df[\"carrier\"] != \"NONE\"]\n        if raw_df:\n            return df\n\n        import altair as alt\n\n        if by_carrier:\n            color = \"carrier:N\"\n            color_title = \"Carrier\"\n        elif by_class:\n            color = \"booking_class:N\"\n            color_title = \"Booking Class\"\n        else:\n            color = \"paxtype:N\"\n            color_title = \"Passenger Type\"\n\n        if by_class:\n            chart = (\n                alt.Chart(df)\n                .mark_bar()\n                .encode(\n                    color=alt.Color(color).title(color_title),\n                    x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n                    y=alt.Y(\"sold\"),\n                    tooltip=([alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else [])\n                    + [\n                        alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                        alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                        alt.Tooltip(\"sold\", format=\".2f\"),\n                    ],\n                )\n                .properties(\n                    width=500,\n                    height=200,\n                )\n                .facet(\n                    row=alt.Row(\"paxtype:N\", title=\"Passenger Type\"),\n                    title=title,\n                )\n            )\n        else:\n            chart = (\n                alt.Chart(df, title=title)\n                .mark_line()\n                .encode(\n                    color=alt.Color(color).title(color_title),\n                    x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n                    y=alt.Y(\"sold\") if by_class else \"sold\",\n                    strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n                    tooltip=([alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else [])\n                    + [\n                        alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                        alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                        alt.Tooltip(\"sold\", format=\".2f\"),\n                    ],\n                )\n                .properties(\n                    width=500,\n                    height=300,\n                )\n                .configure_axis(\n                    labelFontSize=12,\n                    titleFontSize=12,\n                )\n                .configure_legend(\n                    titleFontSize=12,\n                    labelFontSize=15,\n                )\n            )\n        return chart\n\n    def _fig_bookings_by_timeframe_errorband(self, by_carrier: bool | str = True, raw_df=False):\n        def differs(x):\n            return x.shift(-1, fill_value=0) - x\n\n        b = self.bookings_by_timeframe.reset_index()\n\n        def _summarize(x, c):\n            y = (\n                x.groupby([\"trial\", \"carrier\", \"days_prior\"], observed=False)[f\"avg_{c}\"]\n                .sum()\n                .unstack([\"trial\", \"carrier\"])\n                .sort_index(ascending=False)\n                .apply(differs)\n                .stack(\"carrier\", future_stack=True)\n                .aggregate([\"mean\", \"sem\"], axis=1)\n                .assign(\n                    ci0=lambda x: x[\"mean\"] - 1.96 * x[\"sem\"],\n                    ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                )\n            )\n            return pd.concat({c: y}, names=[\"paxtype\"])\n\n        df0 = _summarize(b, \"business\")\n        df1 = _summarize(b, \"leisure\")\n        df = pd.concat([df0, df1], axis=0).rename(columns={\"mean\": \"sold\"}).reset_index().query(\"days_prior&gt;0\")\n        if not by_carrier:\n            df = df.groupby([\"days_prior\", \"paxtype\"], observed=False)[[\"sold\", \"ci0\", \"ci1\"]].sum().reset_index()\n        if isinstance(by_carrier, str):\n            df = df[df[\"carrier\"] == by_carrier]\n            df = df.drop(columns=[\"carrier\"])\n            by_carrier = False\n        if raw_df:\n            return df\n        import altair as alt\n\n        chart = alt.Chart(df)\n        lines = chart.mark_line().encode(\n            color=alt.Color(\"carrier:N\" if by_carrier else \"paxtype\").title(\n                \"Carrier\" if by_carrier else \"Passenger Type\"\n            ),\n            x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            y=\"sold\",\n            strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n            tooltip=([alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else [])\n            + [\n                alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                alt.Tooltip(\"sold\", format=\".2f\"),\n            ],\n        )\n        bands = chart.mark_errorband().encode(\n            color=alt.Color(\n                \"carrier:N\" if by_carrier else \"paxtype\",\n                title=\"Carrier\" if by_carrier else \"Passenger Type\",\n            ),\n            x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            y=\"ci0\",\n            y2=\"ci1\",\n            strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n        )\n\n        return (\n            (lines + bands)\n            .properties(\n                width=500,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n\n    @report_figure\n    def fig_segmentation_by_timeframe(\n        self,\n        metric: Literal[\"bookings\", \"revenue\"],\n        by_carrier: bool | str = True,\n        by_class: bool | str = False,\n        raw_df: bool = False,\n        exclude_nogo: bool = True,\n    ):\n        if self.segmentation_by_timeframe is None:\n            raise ValueError(\"segmentation_by_timeframe not found\")\n        df = self.segmentation_by_timeframe\n        idxs = list(df.index.names)\n        if \"trial\" in idxs:\n            idxs.remove(\"trial\")\n            df = df.groupby(idxs).mean()\n        df = df[metric].stack().rename(metric).reset_index()\n\n        title = f\"{metric.title()} by Timeframe\"\n        if by_class is True:\n            title = f\"{metric.title()} by Timeframe and Booking Class\"\n        title_annot = []\n        if not by_carrier:\n            g = [\"days_prior\", \"segment\"]\n            if by_class:\n                g += [\"booking_class\"]\n            df = df.groupby(g, observed=False)[[metric]].sum().reset_index()\n        if by_carrier and not by_class:\n            df = df.groupby([\"carrier\", \"days_prior\", \"segment\"], observed=False)[[metric]].sum().reset_index()\n        if isinstance(by_carrier, str):\n            df = df[df[\"carrier\"] == by_carrier]\n            df = df.drop(columns=[\"carrier\"])\n            title_annot.append(by_carrier)\n            by_carrier = False\n        if isinstance(by_class, str):\n            df = df[df[\"booking_class\"] == by_class]\n            df = df.drop(columns=[\"booking_class\"])\n            title_annot.append(f\"Class {by_class}\")\n            by_class = False\n        if title_annot:\n            title = f\"{title} ({', '.join(title_annot)})\"\n        if exclude_nogo and \"carrier\" in df.columns:\n            df = df[df[\"carrier\"] != \"NONE\"]\n        if raw_df:\n            return df\n\n        import altair as alt\n\n        if by_carrier:\n            color = \"carrier:N\"\n            color_title = \"Carrier\"\n        elif by_class:\n            color = \"booking_class:N\"\n            color_title = \"Booking Class\"\n        else:\n            color = \"segment:N\"\n            color_title = \"Passenger Type\"\n\n        if metric == \"revenue\":\n            metric_fmt = \"$,.0f\"\n        else:\n            metric_fmt = \",.2f\"\n\n        chart = (\n            alt.Chart(df)\n            .mark_bar()\n            .encode(\n                color=alt.Color(color).title(color_title),\n                x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n                y=alt.Y(metric),\n                tooltip=([alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else [])\n                + ([alt.Tooltip(\"booking_class\").title(\"Booking Class\")] if by_class else [])\n                + [\n                    alt.Tooltip(\"segment\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"days_prior\", title=\"Days Prior\"),\n                    alt.Tooltip(metric, format=metric_fmt, title=metric.title()),\n                ],\n            )\n            .properties(\n                width=500,\n                height=200,\n            )\n        )\n        if by_carrier or by_class:\n            chart = chart.facet(\n                row=alt.Row(\"segment:N\", title=\"Passenger Type\"),\n                title=title,\n            )\n        return chart\n\n    def _fig_carrier_load_factors(\n        self,\n        raw_df: bool,\n        load_measure: str,\n        measure_name: str,\n        measure_format: str = \".2f\",\n        orient: Literal[\"h\", \"v\"] = \"h\",\n        title: str | None = None,\n        also_df: bool = False,\n    ):\n        df = self.carriers.reset_index()[[\"carrier\", load_measure]]\n        if raw_df:\n            return df\n        import altair as alt\n\n        chart = alt.Chart(df)\n        if orient == \"v\":\n            bars = chart.mark_bar().encode(\n                x=alt.X(\"carrier:N\", title=\"Carrier\"),\n                y=alt.Y(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                tooltip=[\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(f\"{load_measure}:Q\", title=measure_name, format=measure_format),\n                ],\n            )\n            text = chart.mark_text(dx=0, dy=3, color=\"white\", baseline=\"top\").encode(\n                x=alt.X(\"carrier:N\", title=\"Carrier\"),\n                y=alt.Y(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                text=alt.Text(f\"{load_measure}:Q\", format=measure_format),\n            )\n        else:\n            bars = chart.mark_bar().encode(\n                y=alt.Y(\"carrier:N\", title=\"Carrier\"),\n                x=alt.X(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                tooltip=[\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(f\"{load_measure}:Q\", title=measure_name, format=measure_format),\n                ],\n            )\n            text = chart.mark_text(dx=-5, dy=0, color=\"white\", baseline=\"middle\", align=\"right\").encode(\n                y=alt.Y(\"carrier:N\", title=\"Carrier\"),\n                x=alt.X(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                text=alt.Text(f\"{load_measure}:Q\", format=measure_format),\n            )\n        fig = (\n            (bars + text)\n            .properties(\n                width=500,\n                height=10 + 20 * len(df),\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n        if title:\n            fig.title = title\n        if also_df:\n            return fig, df\n        return fig\n\n    @report_figure\n    def fig_carrier_load_factors(\n        self, raw_df=False, load_measure: Literal[\"sys_lf\", \"avg_leg_lf\"] = \"sys_lf\", also_df: bool = False\n    ):\n        measure_name = \"System Load Factor\" if load_measure == \"sys_lf\" else \"Leg Load Factor\"\n        return self._fig_carrier_load_factors(\n            raw_df,\n            load_measure,\n            measure_name,\n            title=f\"Carrier {measure_name}s\",\n            also_df=also_df,\n        )\n\n    @report_figure\n    def fig_carrier_revenues(self, raw_df=False, also_df: bool = False):\n        return self._fig_carrier_load_factors(\n            raw_df, \"avg_rev\", \"Average Revenue\", \"$.4s\", title=\"Carrier Revenues\", also_df=also_df\n        )\n\n    @report_figure\n    def fig_carrier_yields(self, raw_df=False, also_df: bool = False):\n        return self._fig_carrier_load_factors(\n            raw_df, \"yield\", \"Average Yield\", \"$.4f\", title=\"Carrier Yields\", also_df=also_df\n        )\n\n    @report_figure\n    def fig_carrier_total_bookings(self, raw_df=False, also_df: bool = False):\n        return self._fig_carrier_load_factors(\n            raw_df, \"sold\", \"Total Bookings\", \".4s\", title=\"Carrier Total Bookings\", also_df=also_df\n        )\n\n    def _fig_forecasts(\n        self,\n        df,\n        facet_on=None,\n        y=\"forecast_mean\",\n        color=\"booking_class:N\",\n        y_title=\"Avg Demand Forecast\",\n    ):\n        import altair as alt\n\n        encoding = dict(\n            x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            y=alt.Y(f\"{y}:Q\", title=y_title),\n        )\n        if color:\n            encoding[\"color\"] = color\n        if not facet_on:\n            return alt.Chart(df).mark_line().encode(**encoding)\n        else:\n            return (\n                alt.Chart(df)\n                .mark_line()\n                .encode(**encoding)\n                .facet(\n                    facet=f\"{facet_on}:N\",\n                    columns=3,\n                )\n            )\n\n    @report_figure\n    def fig_leg_forecasts(\n        self,\n        by_leg_id: bool | int = True,\n        by_class: bool | str = True,\n        of: Literal[\"mu\", \"sigma\"] | list[Literal[\"mu\", \"sigma\"]] = \"mu\",\n        raw_df=False,\n    ):\n        if isinstance(of, list):\n            if raw_df:\n                raise NotImplementedError\n            fig = self.fig_leg_forecasts(\n                by_leg_id=by_leg_id,\n                by_class=by_class,\n                of=of[0],\n            )\n            for of_ in of[1:]:\n                fig |= self.fig_leg_forecasts(\n                    by_leg_id=by_leg_id,\n                    by_class=by_class,\n                    of=of_,\n                )\n            return fig\n        y = \"forecast_mean\" if of == \"mu\" else \"forecast_stdev\"\n        columns = [\n            \"carrier\",\n            \"leg_id\",\n            \"booking_class\",\n            \"days_prior\",\n            y,\n        ]\n        if self.leg_forecasts is None:\n            raise ValueError(\"the leg_forecasts summary table is not available\")\n        df = self.leg_forecasts.reset_index()[columns]\n        color = \"booking_class:N\"\n        if isinstance(by_leg_id, int) and by_leg_id is not True:\n            df = df[df.leg_id == by_leg_id]\n        if isinstance(by_class, str):\n            df = df[df.booking_class == by_class]\n            color = None\n        if raw_df:\n            return df\n        return self._fig_forecasts(\n            df,\n            facet_on=None,\n            y=y,\n            color=color,\n            y_title=\"Mean Demand Forecast\" if of == \"mu\" else \"Std Dev Demand Forecast\",\n        )\n\n    @report_figure\n    def fig_path_forecasts(\n        self,\n        by_path_id: bool | int = True,\n        by_class: bool | str = True,\n        of: Literal[\"mu\", \"sigma\", \"closed\", \"adj_price\"] = \"mu\",\n        raw_df=False,\n    ):\n        if self.path_forecasts is None:\n            raise ValueError(\"the path_forecasts summary table is not available\")\n        of_columns = {\n            \"mu\": \"forecast_mean\",\n            \"sigma\": \"forecast_stdev\",\n            \"closed\": \"forecast_closed_in_tf\",\n            \"adj_price\": \"adjusted_price\",\n        }\n        y = of_columns.get(of)\n        columns = [\n            \"path_id\",\n            \"booking_class\",\n            \"days_prior\",\n            y,\n        ]\n        df = self.path_forecasts.reset_index()[columns]\n        color = \"booking_class:N\"\n        if isinstance(by_path_id, int) and by_path_id is not True:\n            df = df[df.path_id == by_path_id]\n        if isinstance(by_class, str):\n            df = df[df.booking_class == by_class]\n            color = None\n        if raw_df:\n            return df\n        facet_on = None\n        if by_path_id is True:\n            facet_on = \"path_id\"\n        return self._fig_forecasts(df, facet_on=facet_on, y=y, color=color)\n\n    @report_figure\n    def fig_bid_price_history(\n        self,\n        by_carrier: bool | str = True,\n        show_stdev: float | bool | None = None,\n        cap: Literal[\"some\", \"zero\", None] = None,\n        raw_df=False,\n        also_df: bool = False,\n    ):\n        if cap is None:\n            bp_mean = \"bid_price_mean\"\n        elif cap == \"some\":\n            bp_mean = \"some_cap_bid_price_mean\"\n        elif cap == \"zero\":\n            bp_mean = \"zero_cap_bid_price_mean\"\n        else:\n            raise ValueError(f\"cap={cap!r} not in ['some', 'zero', None]\")\n        df = self.bid_price_history.reset_index()\n        color = None\n        if isinstance(by_carrier, str):\n            df = df[df.carrier == by_carrier]\n        elif by_carrier:\n            color = \"carrier:N\"\n            if show_stdev is None:\n                show_stdev = False\n        if show_stdev:\n            if show_stdev is True:\n                show_stdev = 2\n            df[\"bid_price_upper\"] = df[bp_mean] + show_stdev * df[\"bid_price_stdev\"]\n            df[\"bid_price_lower\"] = (df[bp_mean] - show_stdev * df[\"bid_price_stdev\"]).clip(0, None)\n        if raw_df:\n            return df\n\n        import altair as alt\n\n        line_encoding = dict(\n            x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            y=alt.Y(bp_mean, title=\"Bid Price\"),\n        )\n        if color:\n            line_encoding[\"color\"] = color\n        chart = alt.Chart(df)\n        fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n        if show_stdev:\n            area_encoding = dict(\n                x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n                y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"),\n                y2=alt.Y2(\"bid_price_upper:Q\", title=\"Bid Price\"),\n            )\n            bound = chart.mark_area(\n                opacity=0.1,\n                interpolate=\"step-before\",\n            ).encode(**area_encoding)\n            bound_line = chart.mark_line(opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\").encode(\n                x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\")\n            )\n            top_line = bound_line.encode(y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"))\n            bottom_line = bound_line.encode(y=alt.Y(\"bid_price_upper:Q\", title=\"Bid Price\"))\n            fig = fig + bound + top_line + bottom_line\n        if also_df:\n            return fig, df\n        return fig\n\n    @report_figure\n    def fig_displacement_history(\n        self, by_carrier: bool | str = True, show_stdev: float | bool | None = None, raw_df=False, also_df: bool = False\n    ):\n        df = self.displacement_history.reset_index()\n        color = None\n        if isinstance(by_carrier, str):\n            df = df[df.carrier == by_carrier]\n        elif by_carrier:\n            color = \"carrier:N\"\n            if show_stdev is None:\n                show_stdev = False\n        if show_stdev:\n            if show_stdev is True:\n                show_stdev = 2\n            df[\"displacement_upper\"] = df[\"displacement_mean\"] + show_stdev * df[\"displacement_stdev\"]\n            df[\"displacement_lower\"] = (df[\"displacement_mean\"] - show_stdev * df[\"displacement_stdev\"]).clip(0, None)\n        if raw_df:\n            return df\n\n        import altair as alt\n\n        line_encoding = dict(\n            x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            y=alt.Y(\"displacement_mean\", title=\"Displacement Cost\"),\n        )\n        if color:\n            line_encoding[\"color\"] = color\n        chart = alt.Chart(df)\n        fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n        if show_stdev:\n            area_encoding = dict(\n                x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n                y=alt.Y(\"displacement_lower:Q\", title=\"Displacement Cost\"),\n                y2=alt.Y2(\"displacement_upper:Q\", title=\"Displacement Cost\"),\n            )\n            bound = chart.mark_area(\n                opacity=0.1,\n                interpolate=\"step-before\",\n            ).encode(**area_encoding)\n            bound_line = chart.mark_line(opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\").encode(\n                x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\")\n            )\n            top_line = bound_line.encode(y=alt.Y(\"displacement_lower:Q\", title=\"Displacement Cost\"))\n            bottom_line = bound_line.encode(y=alt.Y(\"displacement_upper:Q\", title=\"Displacement Cost\"))\n            fig = fig + bound + top_line + bottom_line\n        if also_df:\n            return fig, df\n        return fig\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.bid_price_history", "title": "bid_price_history  <code>instance-attribute</code>", "text": "<pre><code>bid_price_history = bid_price_history\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.bookings_by_timeframe", "title": "bookings_by_timeframe  <code>instance-attribute</code>", "text": "<pre><code>bookings_by_timeframe = bookings_by_timeframe\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.cabins", "title": "cabins  <code>instance-attribute</code>", "text": "<pre><code>cabins = cabins\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.carrier_history", "title": "carrier_history  <code>instance-attribute</code>", "text": "<pre><code>carrier_history = carrier_history\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.carriers", "title": "carriers  <code>instance-attribute</code>", "text": "<pre><code>carriers = carriers\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.class_dist", "title": "class_dist  <code>instance-attribute</code>", "text": "<pre><code>class_dist = class_dist\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.cnx", "title": "cnx  <code>instance-attribute</code>", "text": "<pre><code>cnx = cnx\n</code></pre> <p>The database connection used to load the summary tables.</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.config", "title": "config  <code>instance-attribute</code>", "text": "<pre><code>config = config\n</code></pre> <p>Configuration used in the simulation that generated the summary tables.</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.demand_to_come", "title": "demand_to_come  <code>instance-attribute</code>", "text": "<pre><code>demand_to_come = demand_to_come\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.demand_to_come_summary", "title": "demand_to_come_summary  <code>instance-attribute</code>", "text": "<pre><code>demand_to_come_summary = demand_to_come_summary\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.demands", "title": "demands  <code>instance-attribute</code>", "text": "<pre><code>demands = demands\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.displacement_history", "title": "displacement_history  <code>instance-attribute</code>", "text": "<pre><code>displacement_history = displacement_history\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fare_class_mix", "title": "fare_class_mix  <code>instance-attribute</code>", "text": "<pre><code>fare_class_mix = fare_class_mix\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fares", "title": "fares  <code>instance-attribute</code>", "text": "<pre><code>fares = fares\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.leg_avg_load_factor_distribution", "title": "leg_avg_load_factor_distribution  <code>instance-attribute</code>", "text": "<pre><code>leg_avg_load_factor_distribution = (\n    leg_avg_load_factor_distribution\n)\n</code></pre> <p>Leg average load factor distribution (integers 0-100).</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.leg_carried", "title": "leg_carried  <code>instance-attribute</code>", "text": "<pre><code>leg_carried = leg_carried\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.leg_forecasts", "title": "leg_forecasts  <code>instance-attribute</code>", "text": "<pre><code>leg_forecasts = leg_forecasts\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.leg_local_fraction_distribution", "title": "leg_local_fraction_distribution  <code>instance-attribute</code>", "text": "<pre><code>leg_local_fraction_distribution = (\n    leg_local_fraction_distribution\n)\n</code></pre> <p>Fraction of local passengers on each leg.</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.legs", "title": "legs  <code>instance-attribute</code>", "text": "<pre><code>legs = legs\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.load_factor_distribution", "title": "load_factor_distribution  <code>instance-attribute</code>", "text": "<pre><code>load_factor_distribution = load_factor_distribution\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.load_factors", "title": "load_factors  <code>instance-attribute</code>", "text": "<pre><code>load_factors = load_factors\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.local_and_flow_yields", "title": "local_and_flow_yields  <code>instance-attribute</code>", "text": "<pre><code>local_and_flow_yields = local_and_flow_yields\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.local_fraction_by_place", "title": "local_fraction_by_place  <code>instance-attribute</code>", "text": "<pre><code>local_fraction_by_place = local_fraction_by_place\n</code></pre> <p>Fraction of local passengers by place.</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.n_total_samples", "title": "n_total_samples  <code>instance-attribute</code>", "text": "<pre><code>n_total_samples = n_total_samples\n</code></pre> <p>Total number of sample departures simulated to create these summaries.</p> <p>This excludes any burn samples.</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.od_fare_class_mix", "title": "od_fare_class_mix  <code>instance-attribute</code>", "text": "<pre><code>od_fare_class_mix = od_fare_class_mix\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.path_classes", "title": "path_classes  <code>instance-attribute</code>", "text": "<pre><code>path_classes = path_classes\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.path_forecasts", "title": "path_forecasts  <code>instance-attribute</code>", "text": "<pre><code>path_forecasts = path_forecasts\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.paths", "title": "paths  <code>instance-attribute</code>", "text": "<pre><code>paths = paths\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.raw_fare_class_mix", "title": "raw_fare_class_mix  <code>instance-attribute</code>", "text": "<pre><code>raw_fare_class_mix = raw_fare_class_mix\n</code></pre> <p>Total number of passengers by carrier by fare class.</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.raw_load_factor_distribution", "title": "raw_load_factor_distribution  <code>instance-attribute</code>", "text": "<pre><code>raw_load_factor_distribution = raw_load_factor_distribution\n</code></pre> <p>Total number of departures by carrier by load factor (integers 0-100).</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.segmentation_by_timeframe", "title": "segmentation_by_timeframe  <code>instance-attribute</code>", "text": "<pre><code>segmentation_by_timeframe = segmentation_by_timeframe\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.sim", "title": "sim  <code>instance-attribute</code>", "text": "<pre><code>sim = sim\n</code></pre> <p>The simulation object that generated the summary tables.</p>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.total_demand", "title": "total_demand  <code>instance-attribute</code>", "text": "<pre><code>total_demand = total_demand\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.__getstate__", "title": "__getstate__", "text": "<pre><code>__getstate__()\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>def __getstate__(self):\n    state = self.__dict__.copy()\n    if \"cnx\" in state:\n        del state[\"cnx\"]\n    if \"config\" in state:\n        # state[\"_config_yaml\"] = state[\"config\"].to_yaml()\n        del state[\"config\"]\n    if \"meta_trials\" in state and not state.get(\"_preserve_meta_trials\", True):\n        del state[\"meta_trials\"]\n    if \"_preserve_meta_trials\" in state:\n        del state[\"_preserve_meta_trials\"]\n    return state\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    *,\n    name: str | None = \"name?\",\n    config: Config | None = None,\n    cnx: Database | None = None,\n    sim: Simulation | None = None,\n    cabins: DataFrame | None = None,\n    class_dist: DataFrame | None = None,\n    demands: DataFrame | None = None,\n    fares: DataFrame | None = None,\n    legs: DataFrame | None = None,\n    paths: DataFrame | None = None,\n    path_classes: DataFrame | None = None,\n    carriers: DataFrame | None = None,\n    fare_class_mix: DataFrame | None = None,\n    load_factors: DataFrame | None = None,\n    bookings_by_timeframe: DataFrame | None = None,\n    segmentation_by_timeframe: DataFrame | None = None,\n    total_demand: float | None = None,\n    od_fare_class_mix: dict[tuple[str, str], DataFrame]\n    | None = None,\n    leg_forecasts: DataFrame | None = None,\n    path_forecasts: DataFrame | None = None,\n    carrier_history: DataFrame | None = None,\n    demand_to_come: DataFrame | None = None,\n    demand_to_come_summary: DataFrame | None = None,\n    bid_price_history: DataFrame | None = None,\n    displacement_history: DataFrame | None = None,\n    local_and_flow_yields: DataFrame | None = None,\n    leg_carried: DataFrame | None = None,\n    load_factor_distribution: DataFrame | None = None,\n    leg_avg_load_factor_distribution: DataFrame\n    | None = None,\n    raw_load_factor_distribution: DataFrame | None = None,\n    raw_fare_class_mix: DataFrame | None = None,\n    leg_local_fraction_distribution: DataFrame\n    | None = None,\n    local_fraction_by_place: DataFrame | None = None,\n    n_total_samples: int = 0,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>def __init__(\n    self,\n    *,\n    name: str | None = \"name?\",\n    config: Config | None = None,\n    cnx: database.Database | None = None,\n    sim: Simulation | None = None,\n    cabins: pd.DataFrame | None = None,\n    class_dist: pd.DataFrame | None = None,\n    demands: pd.DataFrame | None = None,\n    fares: pd.DataFrame | None = None,\n    legs: pd.DataFrame | None = None,\n    paths: pd.DataFrame | None = None,\n    path_classes: pd.DataFrame | None = None,\n    carriers: pd.DataFrame | None = None,\n    fare_class_mix: pd.DataFrame | None = None,\n    load_factors: pd.DataFrame | None = None,\n    bookings_by_timeframe: pd.DataFrame | None = None,\n    segmentation_by_timeframe: pd.DataFrame | None = None,\n    total_demand: float | None = None,\n    od_fare_class_mix: dict[tuple[str, str], pd.DataFrame] | None = None,\n    leg_forecasts: pd.DataFrame | None = None,\n    path_forecasts: pd.DataFrame | None = None,\n    carrier_history: pd.DataFrame | None = None,\n    demand_to_come: pd.DataFrame | None = None,\n    demand_to_come_summary: pd.DataFrame | None = None,\n    bid_price_history: pd.DataFrame | None = None,\n    displacement_history: pd.DataFrame | None = None,\n    local_and_flow_yields: pd.DataFrame | None = None,\n    leg_carried: pd.DataFrame | None = None,\n    load_factor_distribution: pd.DataFrame | None = None,\n    leg_avg_load_factor_distribution: pd.DataFrame | None = None,\n    raw_load_factor_distribution: pd.DataFrame | None = None,\n    raw_fare_class_mix: pd.DataFrame | None = None,\n    leg_local_fraction_distribution: pd.DataFrame | None = None,\n    local_fraction_by_place: pd.DataFrame | None = None,\n    n_total_samples: int = 0,\n):\n    summarytables_is_deprecated()\n\n    self.config = config\n    \"\"\"Configuration used in the simulation that generated the summary tables.\"\"\"\n\n    self.cnx = cnx\n    \"\"\"The database connection used to load the summary tables.\"\"\"\n\n    self.sim = sim\n    \"\"\"The simulation object that generated the summary tables.\"\"\"\n\n    self.cabins = cabins\n    self.class_dist = class_dist\n    self.demands = demands\n    self.fares = fares\n    self.legs = legs\n    self.paths = paths\n    self.path_classes = path_classes\n    self.carriers = carriers\n    self.fare_class_mix = fare_class_mix\n    self.od_fare_class_mix = od_fare_class_mix\n    self.load_factors = load_factors\n    self.bookings_by_timeframe = bookings_by_timeframe\n    self.segmentation_by_timeframe = segmentation_by_timeframe\n    self.total_demand = total_demand\n    self.leg_forecasts = leg_forecasts\n    self.path_forecasts = path_forecasts\n    self.carrier_history = carrier_history\n    self.demand_to_come = demand_to_come\n    self.demand_to_come_summary = demand_to_come_summary\n    self.bid_price_history = bid_price_history\n    self.displacement_history = displacement_history\n    self.local_and_flow_yields = local_and_flow_yields\n    self.leg_carried = leg_carried\n    self.load_factor_distribution = load_factor_distribution\n\n    self.leg_avg_load_factor_distribution = leg_avg_load_factor_distribution\n    \"\"\"Leg average load factor distribution (integers 0-100).\"\"\"\n\n    self.raw_load_factor_distribution = raw_load_factor_distribution\n    \"\"\"Total number of departures by carrier by load factor (integers 0-100).\"\"\"\n\n    self.raw_fare_class_mix = raw_fare_class_mix\n    \"\"\"Total number of passengers by carrier by fare class.\"\"\"\n\n    self.leg_local_fraction_distribution = leg_local_fraction_distribution\n    \"\"\"Fraction of local passengers on each leg.\"\"\"\n\n    self.local_fraction_by_place = local_fraction_by_place\n    \"\"\"Fraction of local passengers by place.\"\"\"\n\n    self.n_total_samples = n_total_samples\n    \"\"\"Total number of sample departures simulated to create these summaries.\n\n    This excludes any burn samples.\n    \"\"\"\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.__setstate__", "title": "__setstate__", "text": "<pre><code>__setstate__(state)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>def __setstate__(self, state):\n    # if \"_config_yaml\" in state:\n    #     state[\"config\"] = Config.from_raw_yaml(state.pop(\"_config_yaml\"))\n    self.__dict__.update(state)\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.aggregate", "title": "aggregate  <code>classmethod</code>", "text": "<pre><code>aggregate(summaries: Collection[SummaryTables])\n</code></pre> <p>Aggregate multiple summary tables.</p> Source code in <code>passengersim/summary.py</code> <pre><code>@classmethod\ndef aggregate(cls, summaries: Collection[SummaryTables]):\n    \"\"\"Aggregate multiple summary tables.\"\"\"\n    summarytables_is_deprecated()\n\n    if not summaries:\n        return None\n\n    # dataframes where trial is in the index, just concatenate\n    def concat(name):\n        frames = []\n        for s in summaries:\n            frame = getattr(s, name)\n            if frame is not None:\n                frames.append(frame)\n        if frames:\n            return pd.concat(frames)\n        return None\n\n    carrier_history = concat(\"carrier_history\")\n    bookings_by_timeframe = concat(\"bookings_by_timeframe\")\n    segmentation_by_timeframe = concat(\"segmentation_by_timeframe\")\n    demand_to_come = concat(\"demand_to_come\")\n\n    # demands has some columns that are averages and some that are sums\n    demands_avg = sum(\n        s.demands.set_index([\"orig\", \"dest\", \"segment\"])[[\"sold\", \"revenue\", \"avg_fare\"]] for s in summaries\n    ) / len(summaries)\n    demands_sum = sum(\n        s.demands.set_index([\"orig\", \"dest\", \"segment\"])[[\"gt_demand\", \"gt_sold\", \"gt_revenue\"]] for s in summaries\n    )\n    demands = pd.concat([demands_avg, demands_sum], axis=1).reset_index()\n\n    # TODO: aggregate fares\n    # fares has some columns that are (weighted) averages and some that are sums\n    # fares_gt_adj_price = sum(\n    #     s.fares.set_index(\n    #     [\"carrier\", \"orig\", \"dest\", \"booking_class\", \"dcp_index\"]\n    #     ).eval(\"gt_sold * avg_adjusted_price\")\n    #     for s in summaries\n    # )\n    # fares_avg = sum(\n    #     s.fares.set_index(\n    #     [\"carrier\", \"orig\", \"dest\", \"booking_class\", \"dcp_index\"]\n    #     )[\n    #         [\"price\", \"gt_sold\"]\n    #     ]\n    #     for s in summaries\n    # ) / len(summaries)\n    # fares_sum = sum(\n    #     s.fares.set_index(\n    #     [\"carrier\", \"orig\", \"dest\", \"booking_class\", \"dcp_index\"]\n    #     )[\n    #         [\"gt_sold\"]\n    #     ]\n    #     for s in summaries\n    # )\n\n    # TODO: aggregate path_classes\n\n    # these are averages, but need to have the index values excluded\n    # TODO: the index values should be set properly on the original dataframes\n    carriers = sum(s.carriers.set_index(\"carrier\") for s in summaries) / len(summaries)\n    legs = sum(s.legs.set_index([\"carrier\", \"leg_id\", \"flt_no\", \"orig\", \"dest\"]) for s in summaries) / len(\n        summaries\n    )\n    legs = legs.reset_index()\n    paths = sum(s.paths.set_index([\"orig\", \"dest\", \"carrier1\", \"leg_id1\", \"carrier2\"]) for s in summaries) / len(\n        summaries\n    )\n\n    def average(name):\n        frames = []\n        for s in summaries:\n            frame = getattr(s, name)\n            if frame is not None:\n                frames.append(frame)\n        if frames:\n            return sum(frames) / len(frames)\n        return None\n\n    fare_class_mix = average(\"fare_class_mix\")\n    leg_forecasts = average(\"leg_forecasts\")\n    path_forecasts = average(\"path_forecasts\")\n    bid_price_history = average(\"bid_price_history\")\n    displacement_history = average(\"displacement_history\")\n    demand_to_come_summary = average(\"demand_to_come_summary\")\n\n    # dataframes with count data that need to be summed\n    def sum_count(name):\n        frames = []\n        for s in summaries:\n            frame = getattr(s, name)\n            if frame is not None:\n                frames.append(frame)\n        if frames:\n            return sum(frames)\n        return None\n\n    raw_load_factor_distribution = sum_count(\"raw_load_factor_distribution\")\n    leg_avg_load_factor_distribution = sum_count(\"leg_avg_load_factor_distribution\")\n    raw_fare_class_mix = sum_count(\"raw_fare_class_mix\")\n    leg_local_fraction_distribution = sum_count(\"leg_local_fraction_distribution\")\n\n    result = cls(\n        demands=demands,\n        legs=legs,\n        paths=paths,\n        carriers=carriers,\n        fare_class_mix=fare_class_mix,\n        leg_forecasts=leg_forecasts,\n        path_forecasts=path_forecasts,\n        carrier_history=carrier_history,\n        bookings_by_timeframe=bookings_by_timeframe,\n        segmentation_by_timeframe=segmentation_by_timeframe,\n        bid_price_history=bid_price_history,\n        displacement_history=displacement_history,\n        demand_to_come=demand_to_come,\n        demand_to_come_summary=demand_to_come_summary,\n        leg_avg_load_factor_distribution=leg_avg_load_factor_distribution,\n        leg_local_fraction_distribution=leg_local_fraction_distribution,\n        raw_load_factor_distribution=raw_load_factor_distribution,\n        raw_fare_class_mix=raw_fare_class_mix,\n        n_total_samples=sum(s.n_total_samples for s in summaries),\n    )\n    result.meta_trials = summaries\n    return result\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.aggregate_demand_history", "title": "aggregate_demand_history", "text": "<pre><code>aggregate_demand_history(by_segment: bool = True) -&gt; Series\n</code></pre> <p>Total demand by sample, aggregated over all markets.</p> <p>Parameters:</p> <ul> <li> <code>by_segment</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Aggregate by segment.  If false, segments are also aggregated.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>Total demand, indexed by trial, sample, and segment (business/leisure).</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def aggregate_demand_history(self, by_segment: bool = True) -&gt; pd.Series:\n    \"\"\"\n    Total demand by sample, aggregated over all markets.\n\n    Parameters\n    ----------\n    by_segment : bool, default True\n        Aggregate by segment.  If false, segments are also aggregated.\n\n    Returns\n    -------\n    pandas.Series\n        Total demand, indexed by trial, sample, and segment\n        (business/leisure).\n    \"\"\"\n    groupbys = [\"trial\", \"sample\"]\n    if by_segment:\n        groupbys.append(\"segment\")\n    return self.demand_to_come.iloc[:, 0].groupby(groupbys, observed=False).sum()\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.demand_in_tf", "title": "demand_in_tf", "text": "<pre><code>demand_in_tf() -&gt; DataFrame | None\n</code></pre> <p>History of demand arriving in each timeframe.</p> <p>This dataframe is derived from the <code>demand_to_come</code> dataframe by taking the sequential differences.</p> Source code in <code>passengersim/summary.py</code> <pre><code>def demand_in_tf(self) -&gt; pd.DataFrame | None:\n    \"\"\"History of demand arriving in each timeframe.\n\n    This dataframe is derived from the `demand_to_come` dataframe\n    by taking the sequential differences.\n    \"\"\"\n    if self.demand_to_come is None:\n        return None\n    return self.demand_to_come.diff(-1, axis=1).iloc[:, :-1]\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_bid_price_history", "title": "fig_bid_price_history", "text": "<pre><code>fig_bid_price_history(\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df=False,\n    also_df: bool = False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_bid_price_history(\n    self,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df=False,\n    also_df: bool = False,\n):\n    if cap is None:\n        bp_mean = \"bid_price_mean\"\n    elif cap == \"some\":\n        bp_mean = \"some_cap_bid_price_mean\"\n    elif cap == \"zero\":\n        bp_mean = \"zero_cap_bid_price_mean\"\n    else:\n        raise ValueError(f\"cap={cap!r} not in ['some', 'zero', None]\")\n    df = self.bid_price_history.reset_index()\n    color = None\n    if isinstance(by_carrier, str):\n        df = df[df.carrier == by_carrier]\n    elif by_carrier:\n        color = \"carrier:N\"\n        if show_stdev is None:\n            show_stdev = False\n    if show_stdev:\n        if show_stdev is True:\n            show_stdev = 2\n        df[\"bid_price_upper\"] = df[bp_mean] + show_stdev * df[\"bid_price_stdev\"]\n        df[\"bid_price_lower\"] = (df[bp_mean] - show_stdev * df[\"bid_price_stdev\"]).clip(0, None)\n    if raw_df:\n        return df\n\n    import altair as alt\n\n    line_encoding = dict(\n        x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n        y=alt.Y(bp_mean, title=\"Bid Price\"),\n    )\n    if color:\n        line_encoding[\"color\"] = color\n    chart = alt.Chart(df)\n    fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n    if show_stdev:\n        area_encoding = dict(\n            x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"),\n            y2=alt.Y2(\"bid_price_upper:Q\", title=\"Bid Price\"),\n        )\n        bound = chart.mark_area(\n            opacity=0.1,\n            interpolate=\"step-before\",\n        ).encode(**area_encoding)\n        bound_line = chart.mark_line(opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\").encode(\n            x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\")\n        )\n        top_line = bound_line.encode(y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"))\n        bottom_line = bound_line.encode(y=alt.Y(\"bid_price_upper:Q\", title=\"Bid Price\"))\n        fig = fig + bound + top_line + bottom_line\n    if also_df:\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_bookings_by_timeframe", "title": "fig_bookings_by_timeframe", "text": "<pre><code>fig_bookings_by_timeframe(\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df: bool = False,\n    errorbands: bool = False,\n    exclude_nogo: bool = True,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_bookings_by_timeframe(\n    self,\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df: bool = False,\n    errorbands: bool = False,\n    exclude_nogo: bool = True,\n):\n    if errorbands:\n        if by_carrier is True:\n            raise NotImplementedError(\"error bands for all carriers is messy\")\n        return self._fig_bookings_by_timeframe_errorband(by_carrier=by_carrier, raw_df=raw_df)\n\n    def differs(x):\n        return x.shift(-1, fill_value=0) - x\n\n    def _summarize(x: pd.DataFrame, c: str):\n        if \"trial\" not in x.columns:\n            x = x.assign(trial=0)\n        if by_class:\n            y = (\n                x.groupby(\n                    [\"trial\", \"carrier\", \"booking_class\", \"days_prior\"],\n                    observed=False,\n                )[f\"avg_{c}\"]\n                .sum()\n                .unstack([\"trial\", \"carrier\", \"booking_class\"])\n                .sort_index(ascending=False)\n                .apply(differs)\n                .stack([\"carrier\", \"booking_class\"], future_stack=True)\n                .aggregate([\"mean\", \"sem\"], axis=1)\n                .assign(\n                    ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                    ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                )\n            )\n        else:\n            y = (\n                x.groupby([\"trial\", \"carrier\", \"days_prior\"], observed=False)[f\"avg_{c}\"]\n                .sum()\n                .unstack([\"trial\", \"carrier\"])\n                .sort_index(ascending=False)\n                .apply(differs)\n                .stack(\"carrier\", future_stack=True)\n                .aggregate([\"mean\", \"sem\"], axis=1)\n                .assign(\n                    ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                    ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                )\n            )\n        return pd.concat({c: y}, names=[\"paxtype\"])\n\n    if self.bookings_by_timeframe is None:\n        raise ValueError(\"bookings_by_timeframe not found\")\n    bookings_by_timeframe = self.bookings_by_timeframe.reset_index()\n    df0 = _summarize(bookings_by_timeframe, \"business\")\n    df1 = _summarize(bookings_by_timeframe, \"leisure\")\n    df = (\n        pd.concat([df0, df1], axis=0)\n        .rename(columns={\"mean\": \"sold\"})\n        .reset_index()\n        .query(\"(days_prior&gt;0) &amp; (sold&gt;0)\")\n    )\n    title = \"Bookings by Timeframe\"\n    if by_class is True:\n        title = \"Bookings by Timeframe and Booking Class\"\n    title_annot = []\n    if not by_carrier:\n        g = [\"days_prior\", \"paxtype\"]\n        if by_class:\n            g += [\"booking_class\"]\n        df = df.groupby(g, observed=False)[[\"sold\", \"ci0\", \"ci1\"]].sum().reset_index()\n    if isinstance(by_carrier, str):\n        df = df[df[\"carrier\"] == by_carrier]\n        df = df.drop(columns=[\"carrier\"])\n        title_annot.append(by_carrier)\n        by_carrier = False\n    if isinstance(by_class, str):\n        df = df[df[\"booking_class\"] == by_class]\n        df = df.drop(columns=[\"booking_class\"])\n        title_annot.append(f\"Class {by_class}\")\n        by_class = False\n    if title_annot:\n        title = f\"{title} ({', '.join(title_annot)})\"\n    if exclude_nogo and \"carrier\" in df.columns:\n        df = df[df[\"carrier\"] != \"NONE\"]\n    if raw_df:\n        return df\n\n    import altair as alt\n\n    if by_carrier:\n        color = \"carrier:N\"\n        color_title = \"Carrier\"\n    elif by_class:\n        color = \"booking_class:N\"\n        color_title = \"Booking Class\"\n    else:\n        color = \"paxtype:N\"\n        color_title = \"Passenger Type\"\n\n    if by_class:\n        chart = (\n            alt.Chart(df)\n            .mark_bar()\n            .encode(\n                color=alt.Color(color).title(color_title),\n                x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n                y=alt.Y(\"sold\"),\n                tooltip=([alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else [])\n                + [\n                    alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                    alt.Tooltip(\"sold\", format=\".2f\"),\n                ],\n            )\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"paxtype:N\", title=\"Passenger Type\"),\n                title=title,\n            )\n        )\n    else:\n        chart = (\n            alt.Chart(df, title=title)\n            .mark_line()\n            .encode(\n                color=alt.Color(color).title(color_title),\n                x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n                y=alt.Y(\"sold\") if by_class else \"sold\",\n                strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n                tooltip=([alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else [])\n                + [\n                    alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"days_prior\", title=\"DfD\"),\n                    alt.Tooltip(\"sold\", format=\".2f\"),\n                ],\n            )\n            .properties(\n                width=500,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n    return chart\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_load_factors", "title": "fig_carrier_load_factors", "text": "<pre><code>fig_carrier_load_factors(\n    raw_df=False,\n    load_measure: Literal[\n        \"sys_lf\", \"avg_leg_lf\"\n    ] = \"sys_lf\",\n    also_df: bool = False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_carrier_load_factors(\n    self, raw_df=False, load_measure: Literal[\"sys_lf\", \"avg_leg_lf\"] = \"sys_lf\", also_df: bool = False\n):\n    measure_name = \"System Load Factor\" if load_measure == \"sys_lf\" else \"Leg Load Factor\"\n    return self._fig_carrier_load_factors(\n        raw_df,\n        load_measure,\n        measure_name,\n        title=f\"Carrier {measure_name}s\",\n        also_df=also_df,\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_mileage", "title": "fig_carrier_mileage", "text": "<pre><code>fig_carrier_mileage(raw_df: bool = False, report=None)\n</code></pre> <p>Figure showing ASM, RPM by carrier.</p> <p>ASM is available seat miles.  RPM is revenue passenger miles.</p> <p>Parameters:</p> <ul> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return the raw data for this figure as a pandas DataFrame, instead of generating the figure itself.</p> </li> <li> <code>report</code>               (<code>Reporter</code>, default:                   <code>None</code> )           \u2013            <p>Also append this figure to the given report.</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def fig_carrier_mileage(self, raw_df: bool = False, report=None):\n    \"\"\"\n    Figure showing ASM, RPM by carrier.\n\n    ASM is available seat miles.  RPM is revenue passenger miles.\n\n    Parameters\n    ----------\n    raw_df : bool, default False\n        Return the raw data for this figure as a pandas DataFrame, instead\n        of generating the figure itself.\n    report : xmle.Reporter, optional\n        Also append this figure to the given report.\n    \"\"\"\n    df = (\n        self.carriers.reset_index()[[\"carrier\", \"asm\", \"rpm\"]]\n        .set_index(\"carrier\")\n        .rename_axis(columns=\"measure\")\n        .unstack()\n        .to_frame(\"value\")\n        .reset_index()\n    )\n    if raw_df:\n        return df\n    import altair as alt\n\n    chart = alt.Chart(df, title=\"Carrier Loads\")\n    bars = chart.mark_bar().encode(\n        x=alt.X(\"carrier:N\", title=\"Carrier\"),\n        y=alt.Y(\"value\", stack=None, title=\"miles\"),\n        color=\"measure\",\n        tooltip=[\"carrier\", \"measure\", alt.Tooltip(\"value\", format=\".4s\")],\n    )\n    text = chart.mark_text(\n        dx=0,\n        dy=5,\n        color=\"white\",\n        baseline=\"top\",\n    ).encode(\n        x=alt.X(\"carrier:N\"),\n        y=alt.Y(\"value\").stack(None),\n        text=alt.Text(\"value:Q\", format=\".4s\"),\n    )\n    fig = (\n        (bars + text)\n        .properties(\n            width=400,\n            height=300,\n        )\n        .configure_axis(\n            labelFontSize=12,\n            titleFontSize=12,\n        )\n        .configure_legend(\n            titleFontSize=12,\n            labelFontSize=15,\n        )\n    )\n    if report:\n        report.add_figure(fig)\n    return fig\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_revenues", "title": "fig_carrier_revenues", "text": "<pre><code>fig_carrier_revenues(raw_df=False, also_df: bool = False)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_carrier_revenues(self, raw_df=False, also_df: bool = False):\n    return self._fig_carrier_load_factors(\n        raw_df, \"avg_rev\", \"Average Revenue\", \"$.4s\", title=\"Carrier Revenues\", also_df=also_df\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_total_bookings", "title": "fig_carrier_total_bookings", "text": "<pre><code>fig_carrier_total_bookings(\n    raw_df=False, also_df: bool = False\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_carrier_total_bookings(self, raw_df=False, also_df: bool = False):\n    return self._fig_carrier_load_factors(\n        raw_df, \"sold\", \"Total Bookings\", \".4s\", title=\"Carrier Total Bookings\", also_df=also_df\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_yields", "title": "fig_carrier_yields", "text": "<pre><code>fig_carrier_yields(raw_df=False, also_df: bool = False)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_carrier_yields(self, raw_df=False, also_df: bool = False):\n    return self._fig_carrier_load_factors(\n        raw_df, \"yield\", \"Average Yield\", \"$.4f\", title=\"Carrier Yields\", also_df=also_df\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_displacement_history", "title": "fig_displacement_history", "text": "<pre><code>fig_displacement_history(\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    raw_df=False,\n    also_df: bool = False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_displacement_history(\n    self, by_carrier: bool | str = True, show_stdev: float | bool | None = None, raw_df=False, also_df: bool = False\n):\n    df = self.displacement_history.reset_index()\n    color = None\n    if isinstance(by_carrier, str):\n        df = df[df.carrier == by_carrier]\n    elif by_carrier:\n        color = \"carrier:N\"\n        if show_stdev is None:\n            show_stdev = False\n    if show_stdev:\n        if show_stdev is True:\n            show_stdev = 2\n        df[\"displacement_upper\"] = df[\"displacement_mean\"] + show_stdev * df[\"displacement_stdev\"]\n        df[\"displacement_lower\"] = (df[\"displacement_mean\"] - show_stdev * df[\"displacement_stdev\"]).clip(0, None)\n    if raw_df:\n        return df\n\n    import altair as alt\n\n    line_encoding = dict(\n        x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n        y=alt.Y(\"displacement_mean\", title=\"Displacement Cost\"),\n    )\n    if color:\n        line_encoding[\"color\"] = color\n    chart = alt.Chart(df)\n    fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n    if show_stdev:\n        area_encoding = dict(\n            x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            y=alt.Y(\"displacement_lower:Q\", title=\"Displacement Cost\"),\n            y2=alt.Y2(\"displacement_upper:Q\", title=\"Displacement Cost\"),\n        )\n        bound = chart.mark_area(\n            opacity=0.1,\n            interpolate=\"step-before\",\n        ).encode(**area_encoding)\n        bound_line = chart.mark_line(opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\").encode(\n            x=alt.X(\"days_prior:Q\").scale(reverse=True).title(\"Days Prior to Departure\")\n        )\n        top_line = bound_line.encode(y=alt.Y(\"displacement_lower:Q\", title=\"Displacement Cost\"))\n        bottom_line = bound_line.encode(y=alt.Y(\"displacement_upper:Q\", title=\"Displacement Cost\"))\n        fig = fig + bound + top_line + bottom_line\n    if also_df:\n        return fig, df\n    return fig\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_fare_class_mix", "title": "fig_fare_class_mix", "text": "<pre><code>fig_fare_class_mix(raw_df=False, label_threshold=0.06)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_fare_class_mix(self, raw_df=False, label_threshold=0.06):\n    if self.fare_class_mix is not None:\n        df = self.fare_class_mix.reset_index()[[\"carrier\", \"booking_class\", \"avg_sold\"]]\n    elif self.raw_fare_class_mix is not None and self.n_total_samples &gt; 0:\n        df = self.raw_fare_class_mix / self.n_total_samples\n        df = df.rename(columns={\"sold\": \"avg_sold\"})\n        df = df.reset_index()[[\"carrier\", \"booking_class\", \"avg_sold\"]]\n    else:\n        return None\n\n    if raw_df:\n        return df\n    return self._fig_fare_class_mix(\n        df,\n        label_threshold=label_threshold,\n        title=\"Fare Class Mix\",\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_leg_forecasts", "title": "fig_leg_forecasts", "text": "<pre><code>fig_leg_forecasts(\n    by_leg_id: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"]\n    | list[Literal[\"mu\", \"sigma\"]] = \"mu\",\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_leg_forecasts(\n    self,\n    by_leg_id: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"] | list[Literal[\"mu\", \"sigma\"]] = \"mu\",\n    raw_df=False,\n):\n    if isinstance(of, list):\n        if raw_df:\n            raise NotImplementedError\n        fig = self.fig_leg_forecasts(\n            by_leg_id=by_leg_id,\n            by_class=by_class,\n            of=of[0],\n        )\n        for of_ in of[1:]:\n            fig |= self.fig_leg_forecasts(\n                by_leg_id=by_leg_id,\n                by_class=by_class,\n                of=of_,\n            )\n        return fig\n    y = \"forecast_mean\" if of == \"mu\" else \"forecast_stdev\"\n    columns = [\n        \"carrier\",\n        \"leg_id\",\n        \"booking_class\",\n        \"days_prior\",\n        y,\n    ]\n    if self.leg_forecasts is None:\n        raise ValueError(\"the leg_forecasts summary table is not available\")\n    df = self.leg_forecasts.reset_index()[columns]\n    color = \"booking_class:N\"\n    if isinstance(by_leg_id, int) and by_leg_id is not True:\n        df = df[df.leg_id == by_leg_id]\n    if isinstance(by_class, str):\n        df = df[df.booking_class == by_class]\n        color = None\n    if raw_df:\n        return df\n    return self._fig_forecasts(\n        df,\n        facet_on=None,\n        y=y,\n        color=color,\n        y_title=\"Mean Demand Forecast\" if of == \"mu\" else \"Std Dev Demand Forecast\",\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_leg_local_fraction_distribution", "title": "fig_leg_local_fraction_distribution", "text": "<pre><code>fig_leg_local_fraction_distribution(\n    by_carrier: bool | str = True,\n    breakpoints: Collection[int] = (\n        50,\n        55,\n        60,\n        65,\n        70,\n        75,\n        80,\n        85,\n        90,\n        95,\n        100,\n    ),\n    raw_df=False,\n)\n</code></pre> <p>Figure showing the distribution of fraction of leg passengers who are local.</p> <p>Parameters:</p> <ul> <li> <code>by_carrier</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>If True, show the distribution by carrier.  If a string, show the distribution for that carrier. If False, show the distribution aggregated over all carriers.</p> </li> <li> <code>breakpoints</code>               (<code>Collection[int, ...]</code>, default:                   <code>(50, 55, 60, 65, ..., 90, 95, 100)</code> )           \u2013            <p>The breakpoints for the local fraction ranges, which represent the lowest local fraction value in each bin. The first and last breakpoints are always bounded to 0 and 101, respectively; these bounds can be included explicitly or omitted to be included implicitly. Setting the top value to 101 ensures that the highest local fraction value (100) is included in the last bin.</p> </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return the raw data for this figure as a pandas DataFrame, instead of generating the figure itself.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def fig_leg_local_fraction_distribution(\n    self,\n    by_carrier: bool | str = True,\n    breakpoints: Collection[int] = (\n        50,\n        55,\n        60,\n        65,\n        70,\n        75,\n        80,\n        85,\n        90,\n        95,\n        100,\n    ),\n    raw_df=False,\n):\n    \"\"\"\n    Figure showing the distribution of fraction of leg passengers who are local.\n\n    Parameters\n    ----------\n    by_carrier : bool or str, default True\n        If True, show the distribution by carrier.  If a string, show the\n        distribution for that carrier. If False, show the distribution\n        aggregated over all carriers.\n    breakpoints : Collection[int, ...], default (50, 55, 60, 65, ..., 90, 95, 100)\n        The breakpoints for the local fraction ranges, which represent the lowest\n        local fraction value in each bin. The first and last breakpoints are always\n        bounded to 0 and 101, respectively; these bounds can be included explicitly\n        or omitted to be included implicitly. Setting the top value to 101 ensures\n        that the highest local fraction value (100) is included in the last bin.\n    raw_df : bool, default False\n        Return the raw data for this figure as a pandas DataFrame, instead\n        of generating the figure itself.\n\n    Returns\n    -------\n    altair.Chart or pd.DataFrame\n    \"\"\"\n    title = \"Local Fraction Frequency\"  # default title\n    if self.leg_local_fraction_distribution is None:\n        raise AttributeError(\n            \"leg_local_fraction_distribution not found, \" \"it is required for using raw source data.\"\n        )\n    df_for_chart = (\n        self.leg_local_fraction_distribution.rename_axis(columns=\"carrier\")\n        .stack(future_stack=True)\n        .rename(\"Count\")\n        .reset_index()\n    )\n    if not isinstance(breakpoints, tuple):\n        breakpoints = tuple(breakpoints)\n    if breakpoints[0] &lt;= 0:\n        breakpoints = (-1,) + breakpoints[1:]\n    else:\n        breakpoints = (-1,) + breakpoints\n    if breakpoints[-1] &gt;= 101:\n        breakpoints = breakpoints[:-1] + (101,)\n    else:\n        breakpoints = breakpoints + (101,)\n\n    # Create labels for categories\n    def make_label(i, j):\n        if i == j - 1:\n            return f\"{i}\"\n        else:\n            return f\"{i}-{j-1}\"\n\n    labels = [make_label(0, breakpoints[1])]\n    for i in range(1, len(breakpoints) - 2):\n        labels += [make_label(breakpoints[i], breakpoints[i + 1])]\n    if breakpoints[-2] &lt; 100:\n        labels += [make_label(breakpoints[-2], 101)]\n    else:\n        labels += [\"100\"]\n\n    breaker = pd.cut(\n        df_for_chart.local_fraction,\n        bins=breakpoints,\n        right=False,\n        labels=labels,\n    ).rename(\"Leg Local Fraction Range\")\n    df_for_chart = df_for_chart.groupby([\"carrier\", breaker], observed=False).Count.sum().reset_index()\n\n    if not by_carrier:\n        df_for_chart = df_for_chart.groupby([\"Leg Local Fraction Range\"], observed=False).Count.sum().reset_index()\n    elif isinstance(by_carrier, str):\n        df_for_chart = df_for_chart[df_for_chart[\"carrier\"] == by_carrier]\n        df_for_chart = df_for_chart.drop(columns=[\"carrier\"])\n\n    if raw_df:\n        return df_for_chart\n\n    import altair as alt\n\n    if by_carrier is True:\n        chart = (\n            alt.Chart(df_for_chart)\n            .mark_bar()\n            .encode(\n                x=alt.X(\"Leg Local Fraction Range\", title=\"Leg Local Fraction Range\"),\n                y=alt.Y(\"Count:Q\", title=\"Count\"),\n                facet=alt.Facet(\"carrier:N\", columns=2, title=\"Carrier\"),\n                tooltip=[\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\"Count\", title=\"Count\"),\n                ],\n            )\n            .properties(width=300, height=250, title=f\"{title} by Carrier\")\n        )\n    else:\n        chart = (\n            alt.Chart(df_for_chart)\n            .mark_bar()\n            .encode(\n                x=alt.X(\"Leg Local Fraction Range\", title=\"Leg Local Fraction Range\"),\n                y=alt.Y(\"Count:Q\", title=\"Count\"),\n            )\n            .properties(\n                width=600,\n                height=400,\n                title=title if not by_carrier else f\"{title} ({by_carrier})\",\n            )\n        )\n    return chart\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_load_factor_distribution", "title": "fig_load_factor_distribution", "text": "<pre><code>fig_load_factor_distribution(\n    by_carrier: bool | str = True,\n    breakpoints: Collection[int] = (\n        50,\n        55,\n        60,\n        65,\n        70,\n        75,\n        80,\n        85,\n        90,\n        95,\n        100,\n    ),\n    source: Literal[\"leg_avg\", \"raw\", \"db\"] = \"leg_avg\",\n    raw_df=False,\n)\n</code></pre> <p>Figure showing the distribution of leg load factors.</p> <p>Parameters:</p> <ul> <li> <code>by_carrier</code>               (<code>bool or str</code>, default:                   <code>True</code> )           \u2013            <p>If True, show the distribution by carrier.  If a string, show the distribution for that carrier. If False, show the distribution aggregated over all carriers.</p> </li> <li> <code>breakpoints</code>               (<code>Collection[int, ...]</code>, default:                   <code>(50, 55, 60, 65, ..., 90, 95, 100)</code> )           \u2013            <p>The breakpoints for the load factor ranges, which represent the lowest load factor value in each bin. The first and last breakpoints are always bounded to 0 and 101, respectively; these bounds can be included explicitly or omitted to be included implicitly. Setting the top value to 101 ensures that the highest load factor value (100) is included in the last bin.</p> </li> <li> <code>source</code>               (<code>('raw', 'db')</code>, default:                   <code>\"raw\"</code> )           \u2013            <p>The source of the data.  \"raw\" uses the raw load factor distribution output from the simulation, which is faster and preferred if available. \"db\" uses the older load factor distribution table, which is extracted as a query from the database.  This requires leg level departure (final) details to have been recorded in the database, but potentially allows arbitrary custom filters or transformations to be applied.</p> </li> <li> <code>raw_df</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return the raw data for this figure as a pandas DataFrame, instead of generating the figure itself.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chart or DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_load_factor_distribution(\n    self,\n    by_carrier: bool | str = True,\n    breakpoints: Collection[int] = (\n        50,\n        55,\n        60,\n        65,\n        70,\n        75,\n        80,\n        85,\n        90,\n        95,\n        100,\n    ),\n    source: Literal[\"leg_avg\", \"raw\", \"db\"] = \"leg_avg\",\n    raw_df=False,\n):\n    \"\"\"\n    Figure showing the distribution of leg load factors.\n\n    Parameters\n    ----------\n    by_carrier : bool or str, default True\n        If True, show the distribution by carrier.  If a string, show the\n        distribution for that carrier. If False, show the distribution\n        aggregated over all carriers.\n    breakpoints : Collection[int, ...], default (50, 55, 60, 65, ..., 90, 95, 100)\n        The breakpoints for the load factor ranges, which represent the lowest\n        load factor value in each bin. The first and last breakpoints are always\n        bounded to 0 and 101, respectively; these bounds can be included explicitly\n        or omitted to be included implicitly. Setting the top value to 101 ensures\n        that the highest load factor value (100) is included in the last bin.\n    source : {\"raw\", \"db\"}, default \"raw\"\n        The source of the data.  \"raw\" uses the raw load factor distribution\n        output from the simulation, which is faster and preferred if available.\n        \"db\" uses the older load factor distribution table, which is extracted\n        as a query from the database.  This requires leg level departure (final)\n        details to have been recorded in the database, but potentially allows\n        arbitrary custom filters or transformations to be applied.\n    raw_df : bool, default False\n        Return the raw data for this figure as a pandas DataFrame, instead\n        of generating the figure itself.\n\n    Returns\n    -------\n    altair.Chart or pd.DataFrame\n    \"\"\"\n    title = \"Load Factor Frequency\"  # default title\n    if source == \"raw\" or source == \"leg_avg\":\n        # Load using faster raw load factor data generated by the simulation\n        # This is faster than loading from the database and now preferred\n        if source == \"raw\":\n            if self.raw_load_factor_distribution is None:\n                raise AttributeError(\n                    \"raw_load_factor_distribution not found, \" \"it is required for using raw source data.\"\n                )\n            df_for_chart = (\n                self.raw_load_factor_distribution.rename_axis(columns=\"carrier\")\n                .stack(future_stack=True)\n                .rename(\"Count\")\n                .reset_index()\n            )\n            title = \"Raw Load Factor Frequency\"\n        elif source == \"leg_avg\":\n            if self.leg_avg_load_factor_distribution is None:\n                raise AttributeError(\n                    \"leg_avg_load_factor_distribution not found, \" \"it is required for using leg_avg source data.\"\n                )\n            df_for_chart = (\n                self.leg_avg_load_factor_distribution.rename_axis(columns=\"carrier\")\n                .stack(future_stack=True)\n                .rename(\"Count\")\n                .reset_index()\n            )\n            title = \"Leg Average Load Factor Frequency\"\n        if not isinstance(breakpoints, tuple):\n            breakpoints = tuple(breakpoints)\n        if breakpoints[0] &lt;= 0:\n            breakpoints = (-1,) + breakpoints[1:]\n        else:\n            breakpoints = (-1,) + breakpoints\n        if breakpoints[-1] &gt;= 101:\n            breakpoints = breakpoints[:-1] + (101,)\n        else:\n            breakpoints = breakpoints + (101,)\n\n        # Create labels for categories\n        def make_label(i, j):\n            if i == j - 1:\n                return f\"{i}\"\n            else:\n                return f\"{i}-{j-1}\"\n\n        labels = [make_label(0, breakpoints[1])]\n        for i in range(1, len(breakpoints) - 2):\n            labels += [make_label(breakpoints[i], breakpoints[i + 1])]\n        if breakpoints[-2] &lt; 100:\n            labels += [make_label(breakpoints[-2], 101)]\n        else:\n            labels += [\"100\"]\n        breaker = pd.cut(\n            df_for_chart.leg_load_factor,\n            bins=breakpoints,\n            right=False,\n            labels=labels,\n        ).rename(\"Load Factor Range\")\n        df_for_chart = df_for_chart.groupby([\"carrier\", breaker], observed=False).Count.sum().reset_index()\n\n    elif source == \"db\":\n        # Older load factor distribution table, taken from database\n        if not hasattr(self, \"load_factor_distribution\"):\n            raise AttributeError(\"load_factor_distribution data not found. Please load it first.\")\n\n        df_for_chart = self.load_factor_distribution\n        df_for_chart.columns.names = [\"Load Factor Range\"]\n        df_for_chart = df_for_chart.set_index(\"carrier\")\n        df_for_chart = df_for_chart.stack(future_stack=True).rename(\"Count\").reset_index()\n\n    else:\n        raise ValueError(f\"Unknown source {source}, should be 'raw' or 'db'\")\n\n    if not by_carrier:\n        df_for_chart = df_for_chart.groupby([\"Load Factor Range\"], observed=False).Count.sum().reset_index()\n    elif isinstance(by_carrier, str):\n        df_for_chart = df_for_chart[df_for_chart[\"carrier\"] == by_carrier]\n        df_for_chart = df_for_chart.drop(columns=[\"carrier\"])\n\n    if raw_df:\n        return df_for_chart\n\n    import altair as alt\n\n    if by_carrier is True:\n        chart = (\n            alt.Chart(df_for_chart)\n            .mark_bar()\n            .encode(\n                x=alt.X(\"Load Factor Range\", title=\"Load Factor Range\"),\n                y=alt.Y(\"Count:Q\", title=\"Count\"),\n                facet=alt.Facet(\"carrier:N\", columns=2, title=\"Carrier\"),\n                tooltip=[\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\"Count\", title=\"Count\"),\n                ],\n            )\n            .properties(width=300, height=250, title=f\"{title} by Carrier\")\n        )\n    else:\n        chart = (\n            alt.Chart(df_for_chart)\n            .mark_bar()\n            .encode(\n                x=alt.X(\"Load Factor Range\", title=\"Load Factor Range\"),\n                y=alt.Y(\"Count:Q\", title=\"Count\"),\n            )\n            .properties(\n                width=600,\n                height=400,\n                title=title if not by_carrier else f\"{title} ({by_carrier})\",\n            )\n        )\n\n    return chart\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_od_fare_class_mix", "title": "fig_od_fare_class_mix", "text": "<pre><code>fig_od_fare_class_mix(\n    orig: str, dest: str, raw_df=False, label_threshold=0.06\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_od_fare_class_mix(self, orig: str, dest: str, raw_df=False, label_threshold=0.06):\n    df = self.od_fare_class_mix[orig, dest].reset_index()[[\"carrier\", \"booking_class\", \"avg_sold\"]]\n    if raw_df:\n        return df\n    return self._fig_fare_class_mix(df, label_threshold=label_threshold, title=f\"Fare Class Mix ({orig}-{dest})\")\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_path_forecasts", "title": "fig_path_forecasts", "text": "<pre><code>fig_path_forecasts(\n    by_path_id: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\n        \"mu\", \"sigma\", \"closed\", \"adj_price\"\n    ] = \"mu\",\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_path_forecasts(\n    self,\n    by_path_id: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\", \"closed\", \"adj_price\"] = \"mu\",\n    raw_df=False,\n):\n    if self.path_forecasts is None:\n        raise ValueError(\"the path_forecasts summary table is not available\")\n    of_columns = {\n        \"mu\": \"forecast_mean\",\n        \"sigma\": \"forecast_stdev\",\n        \"closed\": \"forecast_closed_in_tf\",\n        \"adj_price\": \"adjusted_price\",\n    }\n    y = of_columns.get(of)\n    columns = [\n        \"path_id\",\n        \"booking_class\",\n        \"days_prior\",\n        y,\n    ]\n    df = self.path_forecasts.reset_index()[columns]\n    color = \"booking_class:N\"\n    if isinstance(by_path_id, int) and by_path_id is not True:\n        df = df[df.path_id == by_path_id]\n    if isinstance(by_class, str):\n        df = df[df.booking_class == by_class]\n        color = None\n    if raw_df:\n        return df\n    facet_on = None\n    if by_path_id is True:\n        facet_on = \"path_id\"\n    return self._fig_forecasts(df, facet_on=facet_on, y=y, color=color)\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_segmentation_by_timeframe", "title": "fig_segmentation_by_timeframe", "text": "<pre><code>fig_segmentation_by_timeframe(\n    metric: Literal[\"bookings\", \"revenue\"],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df: bool = False,\n    exclude_nogo: bool = True,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_segmentation_by_timeframe(\n    self,\n    metric: Literal[\"bookings\", \"revenue\"],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df: bool = False,\n    exclude_nogo: bool = True,\n):\n    if self.segmentation_by_timeframe is None:\n        raise ValueError(\"segmentation_by_timeframe not found\")\n    df = self.segmentation_by_timeframe\n    idxs = list(df.index.names)\n    if \"trial\" in idxs:\n        idxs.remove(\"trial\")\n        df = df.groupby(idxs).mean()\n    df = df[metric].stack().rename(metric).reset_index()\n\n    title = f\"{metric.title()} by Timeframe\"\n    if by_class is True:\n        title = f\"{metric.title()} by Timeframe and Booking Class\"\n    title_annot = []\n    if not by_carrier:\n        g = [\"days_prior\", \"segment\"]\n        if by_class:\n            g += [\"booking_class\"]\n        df = df.groupby(g, observed=False)[[metric]].sum().reset_index()\n    if by_carrier and not by_class:\n        df = df.groupby([\"carrier\", \"days_prior\", \"segment\"], observed=False)[[metric]].sum().reset_index()\n    if isinstance(by_carrier, str):\n        df = df[df[\"carrier\"] == by_carrier]\n        df = df.drop(columns=[\"carrier\"])\n        title_annot.append(by_carrier)\n        by_carrier = False\n    if isinstance(by_class, str):\n        df = df[df[\"booking_class\"] == by_class]\n        df = df.drop(columns=[\"booking_class\"])\n        title_annot.append(f\"Class {by_class}\")\n        by_class = False\n    if title_annot:\n        title = f\"{title} ({', '.join(title_annot)})\"\n    if exclude_nogo and \"carrier\" in df.columns:\n        df = df[df[\"carrier\"] != \"NONE\"]\n    if raw_df:\n        return df\n\n    import altair as alt\n\n    if by_carrier:\n        color = \"carrier:N\"\n        color_title = \"Carrier\"\n    elif by_class:\n        color = \"booking_class:N\"\n        color_title = \"Booking Class\"\n    else:\n        color = \"segment:N\"\n        color_title = \"Passenger Type\"\n\n    if metric == \"revenue\":\n        metric_fmt = \"$,.0f\"\n    else:\n        metric_fmt = \",.2f\"\n\n    chart = (\n        alt.Chart(df)\n        .mark_bar()\n        .encode(\n            color=alt.Color(color).title(color_title),\n            x=alt.X(\"days_prior:O\").scale(reverse=True).title(\"Days Prior to Departure\"),\n            y=alt.Y(metric),\n            tooltip=([alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else [])\n            + ([alt.Tooltip(\"booking_class\").title(\"Booking Class\")] if by_class else [])\n            + [\n                alt.Tooltip(\"segment\", title=\"Passenger Type\"),\n                alt.Tooltip(\"days_prior\", title=\"Days Prior\"),\n                alt.Tooltip(metric, format=metric_fmt, title=metric.title()),\n            ],\n        )\n        .properties(\n            width=500,\n            height=200,\n        )\n    )\n    if by_carrier or by_class:\n        chart = chart.facet(\n            row=alt.Row(\"segment:N\", title=\"Passenger Type\"),\n            title=title,\n        )\n    return chart\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.from_pickle", "title": "from_pickle  <code>classmethod</code>", "text": "<pre><code>from_pickle(filename: str | Path, read_latest: bool = True)\n</code></pre> <p>Load the object from a pickle file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str or Path - like</code>)           \u2013            <p>The filename to load the object from.</p> </li> <li> <code>read_latest</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, read the latest file matching the pattern.</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>@classmethod\ndef from_pickle(cls, filename: str | pathlib.Path, read_latest: bool = True):\n    \"\"\"Load the object from a pickle file.\n\n    Parameters\n    ----------\n    filename : str or Path-like\n        The filename to load the object from.\n    read_latest : bool, default True\n        If True, read the latest file matching the pattern.\n    \"\"\"\n    summarytables_is_deprecated()\n\n    import glob\n    import dill as pickle\n\n    if read_latest:\n        filename_glob = pathlib.Path(filename).with_suffix(\".*.pkl\")\n        files = sorted(glob.glob(str(filename_glob)))\n        if not files:\n            if not os.path.exists(filename):\n                raise FileNotFoundError(filename)\n        else:\n            filename = files[-1]\n\n    with open(filename, \"rb\") as f:\n        result = pickle.load(f)\n        if result.__class__.__name__ != cls.__name__:\n            raise TypeError(f\"Expected {cls}, got {type(result)}\")\n        return result\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.from_sqlite", "title": "from_sqlite  <code>classmethod</code>", "text": "<pre><code>from_sqlite(\n    filename: str | Path,\n    make_indexes: bool | dict = False,\n    additional: Collection[str | tuple] | str | None = None,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@classmethod\ndef from_sqlite(\n    cls,\n    filename: str | pathlib.Path,\n    make_indexes: bool | dict = False,\n    additional: Collection[str | tuple] | str | None = None,\n):\n    summarytables_is_deprecated()\n    if not os.path.isfile(filename):\n        raise FileNotFoundError(filename)\n    db = database.Database(\n        engine=\"sqlite\",\n        filename=filename,\n    )\n\n    demands = cls.load_basic_table(db, \"demand_summary\")\n    legs = cls.load_basic_table(db, \"leg_summary\")\n    paths = cls.load_basic_table(db, \"path_summary\")\n    carriers = cls.load_basic_table(db, \"carrier_summary\")\n\n    summary = cls(\n        demands=demands,\n        legs=legs,\n        paths=paths,\n        carriers=carriers,\n    )\n\n    if make_indexes:\n        if isinstance(make_indexes, dict):\n            db.add_indexes(**make_indexes)\n        else:\n            db.add_indexes()\n\n    logger.info(\"loading configs\")\n    config = db.load_configs(on_validation_error=\"ignore\")\n    try:\n        scenario = config.scenario\n        burn_samples = config.simulation_controls.burn_samples\n    except AttributeError:\n        scenario = config.get(\"scenario\", \"unknown\")\n        burn_samples = config.get(\"simulation_controls\", {}).get(\"burn_samples\", 100)\n\n    summary.load_additional_tables(\n        db,\n        scenario=scenario,\n        burn_samples=burn_samples,\n        additional=additional,\n    )\n    summary.cnx = db\n    return summary\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.from_sqlite_glob", "title": "from_sqlite_glob  <code>classmethod</code>", "text": "<pre><code>from_sqlite_glob(\n    pattern: str,\n    make_indexes: bool | dict = False,\n    additional: Collection[str | tuple] | str | None = None,\n    *,\n    load_config: bool = True,\n    max_num_files: int = 9999,\n)\n</code></pre> <p>Load and aggregate multiple summary tables from a glob pattern.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>A glob pattern to match the files to load.</p> </li> <li> <code>make_indexes</code>               (<code>bool | dict</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>additional</code>               (<code>Collection[str | tuple] | str | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>load_config</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>SummaryTables</code>           \u2013            </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>@classmethod\ndef from_sqlite_glob(\n    cls,\n    pattern: str,\n    make_indexes: bool | dict = False,\n    additional: Collection[str | tuple] | str | None = None,\n    *,\n    load_config: bool = True,\n    max_num_files: int = 9999,\n):\n    \"\"\"\n    Load and aggregate multiple summary tables from a glob pattern.\n\n    Parameters\n    ----------\n    pattern : str\n        A glob pattern to match the files to load.\n    make_indexes\n    additional\n    load_config\n\n    Returns\n    -------\n    SummaryTables\n    \"\"\"\n    summarytables_is_deprecated()\n\n    import glob\n\n    cfg = None\n    raw = []\n    n = 0\n    for filename in glob.glob(pattern):\n        n += 1\n        if n &gt; max_num_files:\n            continue\n        raw.append(\n            cls.from_sqlite(\n                filename,\n                make_indexes=make_indexes,\n                additional=additional,\n            )\n        )\n        if cfg is None and load_config:\n            cfg = raw[-1].cnx.load_configs(on_validation_error=\"ignore\")\n    if n &gt; max_num_files:\n        warnings.warn(\n            f\"Only loaded {max_num_files} of {n} files matching pattern\",\n            stacklevel=2,\n        )\n    try:\n        result = cls.aggregate(raw)\n    except Exception as e:\n        logger.error(\"Error aggregating summary tables: %s\", e)\n        logger.exception(e)\n        return raw\n    if cfg is not None:\n        result.config = cfg\n    return result\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.load_additional_tables", "title": "load_additional_tables", "text": "<pre><code>load_additional_tables(\n    db: Database,\n    scenario: str,\n    burn_samples: int,\n    additional: Collection[str | tuple] | str | None = (\n        \"fare_class_mix\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n        \"load_factor_distribution\",\n    ),\n) -&gt; None\n</code></pre> <p>Load additional summary tables based on common queries.</p> <p>Parameters:</p> <ul> <li> <code>db</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>)           \u2013            <p>The number of samples in the burn period.  The data from these samples is ignored in most common queries.</p> </li> <li> <code>additional</code>               (<code>Collection[str | tuple] | str</code>, default:                   <code>('fare_class_mix', 'bookings_by_timeframe', 'total_demand', 'load_factor_distribution')</code> )           \u2013            <p>One or more additional tables to load.  If \"*\", then this will load all common queries supported by the configuration used during the simulation.</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def load_additional_tables(\n    self,\n    db: database.Database,\n    scenario: str,\n    burn_samples: int,\n    additional: Collection[str | tuple] | str | None = (\n        \"fare_class_mix\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n        \"load_factor_distribution\",\n    ),\n) -&gt; None:\n    \"\"\"\n    Load additional summary tables based on common queries.\n\n    Parameters\n    ----------\n    db : Database\n    scenario : str\n    burn_samples : int\n        The number of samples in the burn period.  The data from these samples\n        is ignored in most common queries.\n    additional : Collection[str | tuple] | str\n        One or more additional tables to load.  If \"*\", then this will load\n        all common queries supported by the configuration used during the\n        simulation.\n    \"\"\"\n    print(\"XXXXXXXXXXXXX\")\n    if isinstance(additional, str):\n        if additional == \"*\":\n            additional = set()\n            cfg = db.load_configs(scenario)\n            if \"fare\" in cfg.db.write_items:\n                additional.add(\"fare_class_mix\")\n            if \"fare_final\" in cfg.db.write_items:\n                additional.add(\"fare_class_mix\")\n            if \"bookings\" in cfg.db.write_items:\n                additional.add(\"bookings_by_timeframe\")\n            if \"demand\" in cfg.db.write_items:\n                additional.add(\"total_demand\")\n                additional.add(\"demand_to_come\")\n            if \"demand_final\" in cfg.db.write_items:\n                additional.add(\"total_demand\")\n            if \"bucket\" in cfg.db.write_items:\n                additional.add(\"leg_forecasts\")\n                additional.add(\"carrier_history\")\n            if \"pathclass\" in cfg.db.write_items:\n                additional.add(\"path_forecasts\")\n                additional.add(\"local_and_flow_yields\")\n            if \"pathclass_final\" in cfg.db.write_items:\n                additional.add(\"local_and_flow_yields\")\n            if \"leg\" in cfg.db.write_items and cfg.db.store_leg_bid_prices:\n                additional.add(\"bid_price_history\")\n            if \"leg\" in cfg.db.write_items and cfg.db.store_displacements:\n                additional.add(\"displacement_history\")\n            if \"leg\" in cfg.db.write_items or \"leg_final\" in cfg.db.write_items:\n                additional.add(\"load_factor_distribution\")\n        else:\n            additional = [additional]\n    elif additional is None:\n        additional = []\n\n    if \"fare_class_mix\" in additional and db.is_open:\n        logger.info(\"loading fare_class_mix\")\n        self.fare_class_mix = database.common_queries.fare_class_mix(db, scenario, burn_samples=burn_samples)\n        if self.od_fare_class_mix:\n            for orig, dest in list(self.od_fare_class_mix):\n                self.od_fare_class_mix[(orig, dest)] = database.common_queries.od_fare_class_mix(\n                    db, orig, dest, scenario, burn_samples=burn_samples\n                )\n    # load additional fare class mix tables\n    for i in additional:\n        if isinstance(i, tuple) and i[0] == \"od_fare_class_mix\" and db.is_open:\n            orig, dest = i[1], i[2]\n            if self.od_fare_class_mix is None:\n                self.od_fare_class_mix = {}\n            logger.info(f\"loading od_fare_class_mix({orig},{dest})\")\n            self.od_fare_class_mix[(orig, dest)] = database.common_queries.od_fare_class_mix(\n                db, orig, dest, scenario, burn_samples=burn_samples\n            )\n\n    for i in additional:\n        cutoffs = None\n        if i == \"load_factor_distribution\" and db.is_open:\n            cutoffs = (0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95)  # default cutoffs\n        elif isinstance(i, tuple) and i[0] == \"load_factor_distribution\" and db.is_open:\n            cutoffs = ast.literal_eval(i[1])\n        if cutoffs is not None:\n            logger.info(\"loading load_factor_distribution\")\n            self.load_factor_distribution = database.common_queries.load_factor_distribution(\n                db,\n                scenario=scenario,\n                burn_samples=burn_samples,\n                cutoffs=cutoffs,\n            )\n\n    if \"bookings_by_timeframe\" in additional and db.is_open:\n        logger.info(\"loading bookings_by_timeframe\")\n        self.bookings_by_timeframe = database.common_queries.bookings_by_timeframe(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"total_demand\" in additional and db.is_open:\n        logger.info(\"loading total_demand\")\n        self.total_demand = database.common_queries.total_demand(db, scenario=scenario, burn_samples=burn_samples)\n\n    if \"leg_forecasts\" in additional and db.is_open:\n        logger.info(\"loading leg_forecasts\")\n        self.leg_forecasts = database.common_queries.leg_forecasts(db, scenario=scenario, burn_samples=burn_samples)\n\n    if \"path_forecasts\" in additional and db.is_open:\n        logger.info(\"loading path_forecasts\")\n        self.path_forecasts = database.common_queries.path_forecasts(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"demand_to_come\" in additional and db.is_open:\n        logger.info(\"loading demand_to_come\")\n        self.demand_to_come = database.common_queries.demand_to_come(db, scenario=scenario)\n\n    if \"demand_to_come_summary\" in additional and db.is_open:\n        logger.info(\"loading demand_to_come_summary\")\n        self.demand_to_come_summary = database.common_queries.demand_to_come_summary(db, scenario=scenario)\n\n    if \"carrier_history\" in additional and db.is_open:\n        logger.info(\"loading carrier_history\")\n        self.carrier_history = database.common_queries.carrier_history(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"bid_price_history\" in additional and db.is_open:\n        logger.info(\"loading bid_price_history\")\n        self.bid_price_history = database.common_queries.bid_price_history(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"displacement_history\" in additional and db.is_open:\n        logger.info(\"loading displacement_history\")\n        self.displacement_history = database.common_queries.displacement_history(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"local_and_flow_yields\" in additional and db.is_open:\n        logger.info(\"loading local_and_flow_yields\")\n        self.local_and_flow_yields = database.common_queries.local_and_flow_yields(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"leg_local_and_flow_by_class\" in additional and db.is_open:\n        logger.info(\"loading leg_local_and_flow_by_class\")\n        self.leg_carried = database.common_queries.leg_local_and_flow_by_class(\n            db, scenario=scenario, burn_samples=burn_samples\n        )\n\n    if \"edgar\" in additional and db.is_open:\n        logger.info(\"loading edgar\")\n        self.edgar = database.common_queries.edgar(db, scenario=scenario, burn_samples=burn_samples)\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.load_basic_table", "title": "load_basic_table  <code>classmethod</code>", "text": "<pre><code>load_basic_table(db: Database, tablename: str)\n</code></pre> <p>Load a basic table</p> Source code in <code>passengersim/summary.py</code> <pre><code>@classmethod\ndef load_basic_table(self, db: database.Database, tablename: str):\n    \"\"\"Load a basic table\"\"\"\n    logger.info(\"loading %s\", tablename)\n    return db.dataframe(f\"SELECT * FROM {tablename}\")\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.to_dataframe", "title": "to_dataframe", "text": "<pre><code>to_dataframe(table) -&gt; DataFrame\n</code></pre> <p>Convert the summary tables to a individual dataframes.</p> Source code in <code>passengersim/summary.py</code> <pre><code>def to_dataframe(self, table) -&gt; pd.DataFrame:\n    \"\"\"Convert the summary tables to a individual dataframes.\"\"\"\n    sheet_count = 0\n    for k, v in self.__dict__.items():\n        if isinstance(v, pd.DataFrame):\n            sheet_count += 1\n            if sheet_count == table:\n                return v.assign(table=k)\n\n    raise IndexError(\"There are fewer than\", table, \" DataFrames in the object\")\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.to_pickle", "title": "to_pickle", "text": "<pre><code>to_pickle(\n    filename: str | Path,\n    add_timestamp_ext: bool = True,\n    preserve_meta_trials: bool = False,\n)\n</code></pre> <p>Save the object to a pickle file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str or Path - like</code>)           \u2013            <p>The filename to save the object to.</p> </li> <li> <code>add_timestamp_ext</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Add a timestamp extension to the filename.</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def to_pickle(\n    self,\n    filename: str | pathlib.Path,\n    add_timestamp_ext: bool = True,\n    preserve_meta_trials: bool = False,\n):\n    \"\"\"Save the object to a pickle file.\n\n    Parameters\n    ----------\n    filename : str or Path-like\n        The filename to save the object to.\n    add_timestamp_ext : bool, default True\n        Add a timestamp extension to the filename.\n    \"\"\"\n    import dill as pickle\n\n    if add_timestamp_ext:\n        filename = filename_with_timestamp(filename, suffix=\".pkl\")\n\n    with open(filename, \"wb\") as f:\n        self._preserve_meta_trials = preserve_meta_trials\n        pickle.dump(self, f)\n        del self._preserve_meta_trials\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.to_records", "title": "to_records", "text": "<pre><code>to_records() -&gt; dict[str, list[dict]]\n</code></pre> <p>Convert all summary tables to a dictionary of records.</p> Source code in <code>passengersim/summary.py</code> <pre><code>def to_records(self) -&gt; dict[str, list[dict]]:\n    \"\"\"Convert all summary tables to a dictionary of records.\"\"\"\n    return {k: v.to_dict(orient=\"records\") for (k, v) in self.__dict__.items()}\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.to_xlsx", "title": "to_xlsx", "text": "<pre><code>to_xlsx(filename: str | Path) -&gt; None\n</code></pre> <p>Write summary tables to excel.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>Path - like</code>)           \u2013            <p>The excel file to write.</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def to_xlsx(self, filename: str | pathlib.Path) -&gt; None:\n    \"\"\"Write summary tables to excel.\n\n    Parameters\n    ----------\n    filename : Path-like\n        The excel file to write.\n    \"\"\"\n    if isinstance(filename, str):\n        filename = pathlib.Path(filename)\n    filename.parent.mkdir(exist_ok=True, parents=True)\n    with pd.ExcelWriter(filename) as writer:\n        for k, v in self.__dict__.items():\n            if isinstance(v, pd.DataFrame):\n                v.to_excel(writer, sheet_name=k)\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.summarytables_is_deprecated", "title": "summarytables_is_deprecated", "text": "<pre><code>summarytables_is_deprecated()\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>def summarytables_is_deprecated():\n    warnings.warn(\n        \"SummaryTables is deprecated and will be removed in a future version.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n</code></pre>"}, {"location": "API/Core/index.html", "title": "PassengerSim.Core API", "text": "<p>While the main <code>passengersim</code> package available as a freely downloadable open source package, the functionality in the <code>passengersim.core</code> sub-package is only available to authorized users.  The documentation of the API for this sub-package is provided here.</p>"}, {"location": "API/Core/00-SimulationEngine.html", "title": "Simulation Engine", "text": ""}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine-attributes", "title": "Attributes", "text": ""}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.base_time", "title": "base_time  <code>instance-attribute</code>", "text": "<pre><code>base_time: int\n</code></pre> <p>The base time of the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.bucketnames", "title": "bucketnames  <code>instance-attribute</code>", "text": "<pre><code>bucketnames: Sequence[str]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.buckets", "title": "buckets  <code>instance-attribute</code>", "text": "<pre><code>buckets: Sequence[Bucket]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.burn_samples", "title": "burn_samples  <code>instance-attribute</code>", "text": "<pre><code>burn_samples: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.carriers", "title": "carriers  <code>instance-attribute</code>", "text": "<pre><code>carriers: Sequence[Carrier]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.choice_set_sampling_probability", "title": "choice_set_sampling_probability  <code>instance-attribute</code>", "text": "<pre><code>choice_set_sampling_probability: float\n</code></pre> <p>Used to randomly sample the choice set, especially useful for large networks</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.config", "title": "config  <code>instance-attribute</code>", "text": "<pre><code>config: Config | None\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.demands", "title": "demands  <code>instance-attribute</code>", "text": "<pre><code>demands: Sequence[Demand]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.disable_ap", "title": "disable_ap  <code>instance-attribute</code>", "text": "<pre><code>disable_ap: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.dwm_lite", "title": "dwm_lite  <code>instance-attribute</code>", "text": "<pre><code>dwm_lite: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.fares", "title": "fares  <code>instance-attribute</code>", "text": "<pre><code>fares: Sequence[Fare]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.iteration", "title": "iteration  <code>instance-attribute</code>", "text": "<pre><code>iteration: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.last_dcp", "title": "last_dcp  <code>instance-attribute</code>", "text": "<pre><code>last_dcp: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.last_dcp_index", "title": "last_dcp_index  <code>instance-attribute</code>", "text": "<pre><code>last_dcp_index: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.last_event_time", "title": "last_event_time  <code>instance-attribute</code>", "text": "<pre><code>last_event_time: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.legs", "title": "legs  <code>instance-attribute</code>", "text": "<pre><code>legs: LegIterator\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.manual_paths", "title": "manual_paths  <code>instance-attribute</code>", "text": "<pre><code>manual_paths: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.markets", "title": "markets  <code>instance-attribute</code>", "text": "<pre><code>markets: Mapping[str, Market]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.max_connect_time", "title": "max_connect_time  <code>instance-attribute</code>", "text": "<pre><code>max_connect_time: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.mkt_k_factor", "title": "mkt_k_factor  <code>instance-attribute</code>", "text": "<pre><code>mkt_k_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_dcps", "title": "num_dcps  <code>instance-attribute</code>", "text": "<pre><code>num_dcps: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_samples", "title": "num_samples  <code>instance-attribute</code>", "text": "<pre><code>num_samples: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_trials", "title": "num_trials  <code>instance-attribute</code>", "text": "<pre><code>num_trials: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_trials_completed", "title": "num_trials_completed  <code>instance-attribute</code>", "text": "<pre><code>num_trials_completed: int\n</code></pre> <p>Number of trials actually completed with this simulation.</p> <p>When multiprocessing, this typically will be just 1, as each process will complete only one trial.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.pathclasses", "title": "pathclasses  <code>instance-attribute</code>", "text": "<pre><code>pathclasses: Sequence[PathClass]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.paths", "title": "paths  <code>instance-attribute</code>", "text": "<pre><code>paths: PathIterator\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.pax_type_k_factor", "title": "pax_type_k_factor  <code>instance-attribute</code>", "text": "<pre><code>pax_type_k_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.prorate_revenue", "title": "prorate_revenue  <code>instance-attribute</code>", "text": "<pre><code>prorate_revenue: bool\n</code></pre> <p>When set to True, O&amp;D revenue is prorated by mileage to the leg level</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator: Generator\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.rm_start_sample", "title": "rm_start_sample  <code>instance-attribute</code>", "text": "<pre><code>rm_start_sample: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.sample", "title": "sample  <code>instance-attribute</code>", "text": "<pre><code>sample: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.save_timeframe_details", "title": "save_timeframe_details  <code>instance-attribute</code>", "text": "<pre><code>save_timeframe_details: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.snapshot_filters", "title": "snapshot_filters  <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[SnapshotFilter] | None\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.sys_k_factor", "title": "sys_k_factor  <code>instance-attribute</code>", "text": "<pre><code>sys_k_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.tf_k_factor", "title": "tf_k_factor  <code>instance-attribute</code>", "text": "<pre><code>tf_k_factor: float\n</code></pre> <p>Timeframe k-factor, controls variance in the passenger arrival curves</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.tf_z_factor", "title": "tf_z_factor  <code>instance-attribute</code>", "text": "<pre><code>tf_z_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.trial", "title": "trial  <code>instance-attribute</code>", "text": "<pre><code>trial: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine-functions", "title": "Functions", "text": ""}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.__init__", "title": "__init__", "text": "<pre><code>__init__(name: str = 'Incognito', random_generator=None)\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine._book_offer", "title": "_book_offer", "text": "<pre><code>_book_offer(\n    dmd: Demand, offer: Offer, num_pax: int = 1\n) -&gt; None\n</code></pre> <p>Exercise the bookOffer method in CoreSim, this is ONLY for unit testing !!!</p> <p>Trying to do anything else with this method may result in pain, mental anguish and gnashing of teeth</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine._get_event", "title": "_get_event", "text": "<pre><code>_get_event() -&gt; float\n</code></pre> <p>Pop the next event from the queue and return the timestamp.</p> <p>Only used for unit testing.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_airport", "title": "add_airport", "text": "<pre><code>add_airport(airport: Airport) -&gt; None\n</code></pre> <p>Add an Airport to the simulation</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_carrier", "title": "add_carrier", "text": "<pre><code>add_carrier(carrier: Carrier) -&gt; None\n</code></pre> <p>Add a Carrier to the simulation</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_dcp", "title": "add_dcp", "text": "<pre><code>add_dcp(dcp_index: int, days_prior: int) -&gt; None\n</code></pre> <p>Add dcp_index and days_prior.  Must be added in ascending order of dcp_index</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_demand", "title": "add_demand", "text": "<pre><code>add_demand(dmd: Demand) -&gt; None\n</code></pre> <p>Add a Market Segment demand to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_event", "title": "add_event", "text": "<pre><code>add_event(e: Event) -&gt; None\n</code></pre> <p>Add a user Event to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_fare", "title": "add_fare", "text": "<pre><code>add_fare(fare: Fare) -&gt; None\n</code></pre> <p>Add a Fare to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_frat5", "title": "add_frat5", "text": "<pre><code>add_frat5(frat5: Frat5) -&gt; None\n</code></pre> <p>Add a Frat5 curve to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_leg", "title": "add_leg", "text": "<pre><code>add_leg(leg: Leg) -&gt; None\n</code></pre> <p>Add a Leg to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_path", "title": "add_path", "text": "<pre><code>add_path(path: Path) -&gt; None\n</code></pre> <p>Add a Path to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.additional_settings", "title": "additional_settings", "text": "<pre><code>additional_settings(**kwargs) -&gt; None\n</code></pre> <p>Set additional settings for the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.allocate_demand_to_tf", "title": "allocate_demand_to_tf", "text": "<pre><code>allocate_demand_to_tf(\n    dmd: Demand,\n    num_pax: int,\n    tf_k_factor: float,\n    endTS: int,\n    debug: bool = False,\n) -&gt; tuple[int]\n</code></pre> <p>Generate events for a single demand</p> <p>Parameters:</p> <ul> <li> <code>dmd</code>               (<code>Demand</code>)           \u2013            </li> <li> <code>num_pax</code>               (<code>int</code>)           \u2013            </li> <li> <code>tf_k_factor</code>               (<code>float</code>)           \u2013            </li> <li> <code>endTS</code>               (<code>int</code>)           \u2013            </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of events allocated.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.allocate_demand_to_tf_pods", "title": "allocate_demand_to_tf_pods", "text": "<pre><code>allocate_demand_to_tf_pods(\n    dmd: Demand,\n    num_pax: int,\n    tf_k_factor: float,\n    endTS: int,\n) -&gt; tuple[int]\n</code></pre> <p>Generate events for a single demand (used to simulate PODS processing)</p> <p>Parameters:</p> <ul> <li> <code>dmd</code>               (<code>Demand</code>)           \u2013            </li> <li> <code>num_pax</code>               (<code>int</code>)           \u2013            </li> <li> <code>tf_k_factor</code>               (<code>float</code>)           \u2013            </li> <li> <code>endTS</code>               (<code>int</code>)           \u2013            </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int]</code>           \u2013            <p>Number of events allocated by DCP.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.build_connections", "title": "build_connections", "text": "<pre><code>build_connections(\n    dmd: Demand, debug: bool | None = False\n) -&gt; None\n</code></pre> <p>Build connections for the demands.</p> <p>This will create <code>Path</code> objects for each demand, if the network is given only by the <code>Leg</code> objects.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.build_expiration", "title": "build_expiration", "text": "<pre><code>build_expiration() -&gt; datetime\n</code></pre> <p>Get the expiration time for this build.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.capture_forecast_accuracy", "title": "capture_forecast_accuracy", "text": "<pre><code>capture_forecast_accuracy() -&gt; None\n</code></pre> <p>Capture EDGAR-like forecast accuracy data</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.choice_set_columns", "title": "choice_set_columns", "text": "<pre><code>choice_set_columns() -&gt; list\n</code></pre> <p>Return a list of column names for the choice set</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.clear_choice_set", "title": "clear_choice_set", "text": "<pre><code>clear_choice_set() -&gt; None\n</code></pre> <p>Delete the choice set data that is stored in memory</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.compute_hhi", "title": "compute_hhi", "text": "<pre><code>compute_hhi(debug: bool | None = False)\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.distribution_local_leg_passengers", "title": "distribution_local_leg_passengers", "text": "<pre><code>distribution_local_leg_passengers(carrier: str) -&gt; ndarray\n</code></pre> <p>Return the distribution of percent local passengers by leg for this carrier.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.final_write_to_sqlite", "title": "final_write_to_sqlite", "text": "<pre><code>final_write_to_sqlite(cnx: Connection)\n</code></pre> <p>Write final summary details to sqlite</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.fraction_local_by_carrier_and_place", "title": "fraction_local_by_carrier_and_place", "text": "<pre><code>fraction_local_by_carrier_and_place(\n    carrier: str,\n) -&gt; dict[str, float]\n</code></pre> <p>Return the fraction of local passengers by place for this carrier.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.get_airport_carrier_share", "title": "get_airport_carrier_share", "text": "<pre><code>get_airport_carrier_share(\n    selfself, airport: str, carrier: str\n) -&gt; float\n</code></pre> <p>Get the seat share for this carrier at the specified airport</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.get_choice_set", "title": "get_choice_set", "text": "<pre><code>get_choice_set(carrier: str | None) -&gt; list\n</code></pre> <p>Get the choice set for the all, or subset for the specified carrier</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.get_days_prior", "title": "get_days_prior", "text": "<pre><code>get_days_prior(dcp_index: int) -&gt; int\n</code></pre> <p>Get days_prior for this dcp_index</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.get_preferred_carrier", "title": "get_preferred_carrier", "text": "<pre><code>get_preferred_carrier(\n    dmd: Demand, z_val: float, debug: bool\n)\n</code></pre> <p>Calls the code to set preferred carrier. This is for unit tests</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.go", "title": "go", "text": "<pre><code>go() -&gt; Any\n</code></pre> <p>Run the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.license_info", "title": "license_info", "text": "<pre><code>license_info(user_cert=None) -&gt; str\n</code></pre> <p>Access license info as a human-readable string.</p> <p>Parameters:</p> <ul> <li> <code>user_cert</code>               (<code>Certificate</code>, default:                   <code>None</code> )           \u2013            <p>The license.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_events", "title": "num_events", "text": "<pre><code>num_events() -&gt; int\n</code></pre> <p>Return the number of events currently on the event queue.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.path_2_leg", "title": "path_2_leg", "text": "<pre><code>path_2_leg(carrier: str, dcp_index: int) -&gt; None\n</code></pre> <p>Aggregate PathClass forecasts to Leg/Bucket</p> <p>The dcp_index is used to adjust forecast revenues when fare adjustment is used.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.record_daily_statistics", "title": "record_daily_statistics", "text": "<pre><code>record_daily_statistics(days_prior: int) -&gt; int\n</code></pre> <p>Record daily statistics.</p> <p>Parameters:</p> <ul> <li> <code>days_prior</code>               (<code>int</code>)           \u2013            <p>The current number of days prior to departure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>1 if statistics were recorded (i.e. the sample is after the burn period), or 0 otherwise.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.record_dcp_statistics", "title": "record_dcp_statistics", "text": "<pre><code>record_dcp_statistics(days_prior: int) -&gt; int\n</code></pre> <p>Record DCP statistics.</p> <p>Parameters:</p> <ul> <li> <code>days_prior</code>               (<code>int</code>)           \u2013            <p>The current number of days prior to departure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>1 if statistics were recorded (i.e. the sample is after the burn period), or 0 otherwise.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.record_departure_statistics", "title": "record_departure_statistics", "text": "<pre><code>record_departure_statistics() -&gt; int\n</code></pre> <p>Record departure statistics.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>1 if statistics were recorded (i.e. the sample is after the burn period), or 0 otherwise.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.reset_counters", "title": "reset_counters", "text": "<pre><code>reset_counters() -&gt; None\n</code></pre> <p>Reset counters for sold &amp; revenue, for demands and legs.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.set_parm", "title": "set_parm", "text": "<pre><code>set_parm(name: str, value: float) -&gt; None\n</code></pre> <p>Set a simulation parameter by name and value</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.shop", "title": "shop", "text": "<pre><code>shop(orig: str, dest: str) -&gt; list[tuple]\n</code></pre> <p>Shop all carriers for this O-D pair, return a list of (carrier, price)</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.update_db_write_flags", "title": "update_db_write_flags", "text": "<pre><code>update_db_write_flags()\n</code></pre> <p>Update database writing flags based on config.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.validate_license", "title": "validate_license", "text": "<pre><code>validate_license(user_cert=None, future: int = 0) -&gt; None\n</code></pre> <p>Validate a user's license certificate.</p> <p>Parameters:</p> <ul> <li> <code>user_cert</code>               (<code>Certificate</code>, default:                   <code>None</code> )           \u2013            <p>The license.</p> </li> <li> <code>future</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Validate as if it is this many days in the future.  This is primarily used for debugging and testing. This is treated as an unsigned integer internally, so negative values will not go back in time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the license certificate is not valid.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.write_to_sqlite", "title": "write_to_sqlite", "text": "<pre><code>write_to_sqlite(\n    cnx: Connection,\n    dcp: int,\n    store_bid_prices: bool = True,\n    intermediate_day: bool = False,\n    store_displacements: bool = True,\n)\n</code></pre> <p>Write details to sqlite</p>"}, {"location": "API/Core/BookingCurves.html", "title": "Booking Curves", "text": ""}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator: Generator\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.__init__", "title": "__init__", "text": "<pre><code>__init__(name: str)\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.add_dcp", "title": "add_dcp", "text": "<pre><code>add_dcp(dcp: int, pct: float)\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.get_curve", "title": "get_curve", "text": "<pre><code>get_curve() -&gt; dict[int, float]\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.verify_curve", "title": "verify_curve", "text": "<pre><code>verify_curve() -&gt; bool\n</code></pre>"}, {"location": "API/Core/Bucket.html", "title": "Bucket", "text": ""}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.alloc", "title": "alloc  <code>instance-attribute</code>", "text": "<pre><code>alloc: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.fcst_revenue", "title": "fcst_revenue  <code>instance-attribute</code>", "text": "<pre><code>fcst_revenue: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.force_closed", "title": "force_closed  <code>instance-attribute</code>", "text": "<pre><code>force_closed: bool\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.forecast", "title": "forecast  <code>instance-attribute</code>", "text": "<pre><code>forecast: Forecast\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.protection", "title": "protection  <code>instance-attribute</code>", "text": "<pre><code>protection: int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.untruncated_demand", "title": "untruncated_demand  <code>instance-attribute</code>", "text": "<pre><code>untruncated_demand: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    name: str,\n    alloc: float = 0,\n    price: float = 0,\n    sold: float = 0,\n    revenue: float = 0,\n    fcst_mean: float = 0,\n    fcst_std_dev: float = 0,\n    *,\n    history: History | dict | None = None,\n)\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.capture_history", "title": "capture_history", "text": "<pre><code>capture_history(dcp_index: int)\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.get_history_closed", "title": "get_history_closed", "text": "<pre><code>get_history_closed(period: int, dcp_index: int) -&gt; float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.get_history_demand", "title": "get_history_demand", "text": "<pre><code>get_history_demand(period: int, dcp_index: int) -&gt; float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.get_history_num_dcp", "title": "get_history_num_dcp", "text": "<pre><code>get_history_num_dcp() -&gt; int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.get_history_num_dep", "title": "get_history_num_dep", "text": "<pre><code>get_history_num_dep() -&gt; int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.get_history_sold", "title": "get_history_sold", "text": "<pre><code>get_history_sold(period: int, dcp_index: int) -&gt; float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.push_history", "title": "push_history", "text": "<pre><code>push_history()\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.set_history_demand", "title": "set_history_demand", "text": "<pre><code>set_history_demand(dcp_index: int, demand: float)\n</code></pre>"}, {"location": "API/Core/Carrier.html", "title": "Carrier", "text": "<p>Carrier objects, mostly has counters and link to RM pipeline.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.ancillaries", "title": "ancillaries  <code>instance-attribute</code>", "text": "<pre><code>ancillaries: Iterator[Ancillary]\n</code></pre> <p>List of ancillaries that this airline will offer.</p> <p>This attribute is read-only.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.brand_preference", "title": "brand_preference  <code>instance-attribute</code>", "text": "<pre><code>brand_preference: float\n</code></pre> <p>An array of Brand Preference information.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.control", "title": "control  <code>instance-attribute</code>", "text": "<pre><code>control: Literal[\n    \"leg\", \"cabin\", \"theft\", \"bp\", \"bp_loose\", \"vn\", \"none\"\n]\n</code></pre> <p>RM control technique, such as 'leg', 'bp', 'bp_loose', 'vn', 'cabin', 'theft', or 'none'.</p> <p>This attribute is read-only.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.cp_algorithm", "title": "cp_algorithm  <code>instance-attribute</code>", "text": "<pre><code>cp_algorithm: Literal[\n    \"None\", \"BP\", \"CBC\", \"OPT\", \"CLASSLESS\"\n]\n</code></pre> <p>Algorithm to use for Continuous Pricing, defaults to 'None'.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.cp_elasticity", "title": "cp_elasticity  <code>instance-attribute</code>", "text": "<pre><code>cp_elasticity: dict[str, float]\n</code></pre> <p>For Continuous Pricing, estimate customer price elasticity.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.cp_quantize", "title": "cp_quantize  <code>instance-attribute</code>", "text": "<pre><code>cp_quantize: int\n</code></pre> <p>For Continuous Pricing, round the value to this.</p> <p>i.e. 10 will result in all prices being a multiple of 10.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.cp_record", "title": "cp_record  <code>instance-attribute</code>", "text": "<pre><code>cp_record: Literal['lowest_open', 'highest_closed']\n</code></pre> <p>For Continuous Pricing, do we record in the highest_closed class or the lowest_open?</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.cp_record_highest_closed_as_open", "title": "cp_record_highest_closed_as_open  <code>instance-attribute</code>", "text": "<pre><code>cp_record_highest_closed_as_open: bool\n</code></pre> <p>For Continuous Pricing, do we record the highest closed class as open in the pathclass history?</p> <p>Has no effect unless cp_record is set to highest_closed.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.cp_scale", "title": "cp_scale  <code>instance-attribute</code>", "text": "<pre><code>cp_scale: float\n</code></pre> <p>Scale the Continuous Pricing modifier.</p> <p>Example, 0.5 will add 50% of the modifier to the bid price.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.current_tf_index", "title": "current_tf_index  <code>instance-attribute</code>", "text": "<pre><code>current_tf_index: int\n</code></pre> <p>Current timeframe index.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.dcp_days_prior", "title": "dcp_days_prior  <code>instance-attribute</code>", "text": "<pre><code>dcp_days_prior: tuple[int, ...]\n</code></pre> <p>Days prior for DCPs (i.e. the start time of each timeframe).</p> <p>This attribute is read-only.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.frat5", "title": "frat5  <code>instance-attribute</code>", "text": "<pre><code>frat5: Frat5 | None\n</code></pre> <p>Default Frat5 curve to use for this Carrier.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.gt_available_seat_miles", "title": "gt_available_seat_miles  <code>instance-attribute</code>", "text": "<pre><code>gt_available_seat_miles: float\n</code></pre> <p>Grand total ASM.</p> <p>This value is updated outside the burn period and is not reset by the reset methods.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.gt_cp_revenue", "title": "gt_cp_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_cp_revenue: float\n</code></pre> <p>Grand total Continuous Pricing revenue.</p> <p>This value is updated outside the burn period and is not reset by the reset methods.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.gt_cp_sold", "title": "gt_cp_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_cp_sold: int\n</code></pre> <p>Grand total Continuous Pricing sales.</p> <p>This value is updated outside the burn period and is not reset by the reset methods.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.gt_demand", "title": "gt_demand  <code>instance-attribute</code>", "text": "<pre><code>gt_demand: float\n</code></pre> <p>Grand total generated demand.</p> <p>This value is updated outside the burn period and is not reset by the reset methods.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre> <p>Grand total revenue.</p> <p>This value is updated outside the burn period and is not reset by the reset methods.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.gt_revenue_passenger_miles", "title": "gt_revenue_passenger_miles  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue_passenger_miles: float\n</code></pre> <p>Grand total RPM.</p> <p>This value is updated outside the burn period and is not reset by the reset methods.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre> <p>Grand total sold.</p> <p>This value is updated outside the burn period and is not reset by the reset methods.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.history_length", "title": "history_length  <code>instance-attribute</code>", "text": "<pre><code>history_length: int\n</code></pre> <p>History length.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.load_factor_curve", "title": "load_factor_curve  <code>instance-attribute</code>", "text": "<pre><code>load_factor_curve: Any | None\n</code></pre> <p>Load Factor curve, was an experiment in used this type of RM control.  (deprecated)</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre> <p>Name is usually the code, such as 'AL1' or 'DL'.</p> <p>This attribute is read-only.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.num_objects", "title": "num_objects  <code>instance-attribute</code>", "text": "<pre><code>num_objects: int\n</code></pre> <p>Number of Carrier objects allocated, was used for memory leak detection.</p> <p>This attribute is read-only.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.proration_rule", "title": "proration_rule  <code>instance-attribute</code>", "text": "<pre><code>proration_rule: Literal[\n    \"distance\", \"sqrt_distance\", \"disabled\", \"off\"\n]\n</code></pre> <p>How do we prorate revenue between legs on connecting paths?</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre> <p>Revenue total, reset after each sample.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.rm_system", "title": "rm_system  <code>instance-attribute</code>", "text": "<pre><code>rm_system: Any\n</code></pre> <p>An instance of RmSystem, called at each DCP to do detruncation forecasting / optimization.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre> <p>Number sold, reset after each sample.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.sold_priceable", "title": "sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>sold_priceable: int\n</code></pre> <p>Number sold priceable, reset after each sample.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.truncation_rule", "title": "truncation_rule  <code>instance-attribute</code>", "text": "<pre><code>truncation_rule: int\n</code></pre> <p>Do we mark a TimeFrame as closed if it's closed at the start, end, or both.</p> <p>Values: 1=beginning, 2=end, 3=beginning_or_end</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    name: str,\n    control: Literal[\n        \"leg\",\n        \"cabin\",\n        \"theft\",\n        \"bp\",\n        \"bp_loose\",\n        \"vn\",\n        \"none\",\n    ] = \"leg\",\n) -&gt; None\n</code></pre> <p>Initialize a new Carrier.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the carrier, usually the code such as 'AL1' or 'DL'.</p> </li> <li> <code>control</code>               (<code>('leg', 'cabin', 'theft', 'bp', 'bp_loose', 'vn', 'none')</code>, default:                   <code>\"leg\"</code> )           \u2013            <p>RM control technique to use.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.add_ancillary", "title": "add_ancillary", "text": "<pre><code>add_ancillary(anc: Ancillary) -&gt; int\n</code></pre> <p>Add an ancillary (code &amp; price).</p> <p>Parameters:</p> <ul> <li> <code>anc</code>               (<code>Ancillary</code>)           \u2013            <p>The ancillary item to add.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Returns 0 on success.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.add_carrier_history", "title": "add_carrier_history", "text": "<pre><code>add_carrier_history(\n    trial: int,\n    sample: int,\n    sold: int,\n    sold_priceable: int,\n    revenue: float,\n) -&gt; int\n</code></pre> <p>Add an item to the carrier history.</p> <p>ONLY USED FOR UNIT TESTING.</p> <p>Parameters:</p> <ul> <li> <code>trial</code>               (<code>int</code>)           \u2013            <p>Trial number.</p> </li> <li> <code>sample</code>               (<code>int</code>)           \u2013            <p>Sample number.</p> </li> <li> <code>sold</code>               (<code>int</code>)           \u2013            <p>Number of items sold.</p> </li> <li> <code>sold_priceable</code>               (<code>int</code>)           \u2013            <p>Number of priceable items sold.</p> </li> <li> <code>revenue</code>               (<code>float</code>)           \u2013            <p>Revenue amount.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Returns 0 on success.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.add_frat5_mkt", "title": "add_frat5_mkt", "text": "<pre><code>add_frat5_mkt(orig: str, dest: str, frat5: Frat5) -&gt; None\n</code></pre> <p>Specify Frat5 for an O&amp;D market.</p> <p>Parameters:</p> <ul> <li> <code>orig</code>               (<code>str</code>)           \u2013            <p>Origin airport code.</p> </li> <li> <code>dest</code>               (<code>str</code>)           \u2013            <p>Destination airport code.</p> </li> <li> <code>frat5</code>               (<code>Frat5</code>)           \u2013            <p>The Frat5 curve to use for this market.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.get_ancillary_by_index", "title": "get_ancillary_by_index", "text": "<pre><code>get_ancillary_by_index(index: int) -&gt; Ancillary\n</code></pre> <p>Get ancillary by index.</p> <p>ONLY USED FOR DEBUGGING.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>int</code>)           \u2013            <p>The index of the ancillary to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Ancillary</code>           \u2013            <p>The ancillary at the specified index.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.get_ancillary_price", "title": "get_ancillary_price", "text": "<pre><code>get_ancillary_price(name: str) -&gt; float\n</code></pre> <p>Get the price for an ancillary, by code.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The ancillary code to look up.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The price of the ancillary.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.get_ancillary_sold", "title": "get_ancillary_sold", "text": "<pre><code>get_ancillary_sold(name: str) -&gt; int\n</code></pre> <p>Get the sold for an ancillary, by code.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The ancillary code to look up.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number sold of the ancillary.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.get_carrier_history", "title": "get_carrier_history", "text": "<pre><code>get_carrier_history() -&gt; list[dict[str, int | float | str]]\n</code></pre> <p>Return carrier history, has an item for each sample.</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>List of dictionaries, each containing carrier history data for a sample.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.get_forecast_accuracy", "title": "get_forecast_accuracy", "text": "<pre><code>get_forecast_accuracy() -&gt; (\n    list[dict[str, int | float | str]]\n)\n</code></pre> <p>Return forecast accuracy, as a dictionary.</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>List of dictionaries containing forecast accuracy data.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.get_frat5_mkt", "title": "get_frat5_mkt", "text": "<pre><code>get_frat5_mkt(orig: str, dest: str) -&gt; Frat5 | None\n</code></pre> <p>Get Frat5 for an O&amp;D market.</p> <p>Parameters:</p> <ul> <li> <code>orig</code>               (<code>str</code>)           \u2013            <p>Origin airport code.</p> </li> <li> <code>dest</code>               (<code>str</code>)           \u2013            <p>Destination airport code.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Frat5 or None</code>           \u2013            <p>The Frat5 curve for the specified market, or None if not found.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.get_history_def", "title": "get_history_def", "text": "<pre><code>get_history_def() -&gt; dict[str, int | bool]\n</code></pre> <p>Get the history definition, used to initialize the history for this carrier's buckets and pathclasses.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary with history definition data including 'num_departures', 'num_timeframes', and 'store_priceable'.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.raw_bid_price_trace", "title": "raw_bid_price_trace", "text": "<pre><code>raw_bid_price_trace() -&gt; dict[int, dict[str, float]]\n</code></pre> <p>Raw bid price trace.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary with DCP keys and values containing bid price statistics.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.raw_bookings_by_day", "title": "raw_bookings_by_day", "text": "<pre><code>raw_bookings_by_day() -&gt; dict[str, dict[int, int]]\n</code></pre> <p>Raw bookings by fare class by days prior.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary with fare class keys and values containing day-prior bookings.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.raw_bookings_by_segment_fare_dcp", "title": "raw_bookings_by_segment_fare_dcp", "text": "<pre><code>raw_bookings_by_segment_fare_dcp() -&gt; dict[str, Any]\n</code></pre> <p>Raw bookings by segment, fare class, and dcp.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary containing booking data by segment, fare class and DCP.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.raw_displacement_cost_trace", "title": "raw_displacement_cost_trace", "text": "<pre><code>raw_displacement_cost_trace() -&gt; (\n    dict[int, dict[str, float]]\n)\n</code></pre> <p>Raw displacement cost trace.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary with DCP keys and values containing displacement cost statistics.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.raw_fare_class_distribution", "title": "raw_fare_class_distribution", "text": "<pre><code>raw_fare_class_distribution() -&gt; (\n    dict[str, dict[str, int | float]]\n)\n</code></pre> <p>Raw fare class distribution.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary with fare class keys and values containing 'sold' and 'revenue' keys.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.raw_load_factor_distribution", "title": "raw_load_factor_distribution", "text": "<pre><code>raw_load_factor_distribution() -&gt; (\n    ndarray[Any, dtype[int32]]\n)\n</code></pre> <p>Raw load factor distribution.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of load factor distribution data.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.raw_revenue_by_segment_fare_dcp", "title": "raw_revenue_by_segment_fare_dcp", "text": "<pre><code>raw_revenue_by_segment_fare_dcp() -&gt; dict[str, Any]\n</code></pre> <p>Raw revenue by segment, fare class, and dcp.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary containing revenue data by segment, fare class and DCP.</p> </li> </ul>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.reset_bid_price_trace", "title": "reset_bid_price_trace", "text": "<pre><code>reset_bid_price_trace() -&gt; None\n</code></pre> <p>Reset bid price trace.</p>"}, {"location": "API/Core/Carrier.html#passengersim_core.Carrier.reset_displacement_cost_trace", "title": "reset_displacement_cost_trace", "text": "<pre><code>reset_displacement_cost_trace() -&gt; None\n</code></pre> <p>Reset displacement cost trace.</p>"}, {"location": "API/Core/ChoiceModel.html", "title": "Choice Model", "text": ""}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.buffer_threshold", "title": "buffer_threshold  <code>instance-attribute</code>", "text": "<pre><code>buffer_threshold: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.buffer_time_alpha", "title": "buffer_time_alpha  <code>instance-attribute</code>", "text": "<pre><code>buffer_time_alpha: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.buffer_time_beta", "title": "buffer_time_beta  <code>instance-attribute</code>", "text": "<pre><code>buffer_time_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.dwm_eliminate_outside_window", "title": "dwm_eliminate_outside_window  <code>instance-attribute</code>", "text": "<pre><code>dwm_eliminate_outside_window: bool\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.dwm_tod", "title": "dwm_tod  <code>instance-attribute</code>", "text": "<pre><code>dwm_tod: list[float]\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.early_dep_beta", "title": "early_dep_beta  <code>instance-attribute</code>", "text": "<pre><code>early_dep_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.early_dep_offset", "title": "early_dep_offset  <code>instance-attribute</code>", "text": "<pre><code>early_dep_offset: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.early_dep_slope", "title": "early_dep_slope  <code>instance-attribute</code>", "text": "<pre><code>early_dep_slope: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.elapsed_time_alpha", "title": "elapsed_time_alpha  <code>instance-attribute</code>", "text": "<pre><code>elapsed_time_alpha: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.elapsed_time_beta", "title": "elapsed_time_beta  <code>instance-attribute</code>", "text": "<pre><code>elapsed_time_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.k_factor", "title": "k_factor  <code>instance-attribute</code>", "text": "<pre><code>k_factor: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.late_arr_beta", "title": "late_arr_beta  <code>instance-attribute</code>", "text": "<pre><code>late_arr_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.late_arr_offset", "title": "late_arr_offset  <code>instance-attribute</code>", "text": "<pre><code>late_arr_offset: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.late_arr_slope", "title": "late_arr_slope  <code>instance-attribute</code>", "text": "<pre><code>late_arr_slope: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.path_quality_alpha", "title": "path_quality_alpha  <code>instance-attribute</code>", "text": "<pre><code>path_quality_alpha: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.path_quality_beta", "title": "path_quality_beta  <code>instance-attribute</code>", "text": "<pre><code>path_quality_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.preferred_carrier_alpha", "title": "preferred_carrier_alpha  <code>instance-attribute</code>", "text": "<pre><code>preferred_carrier_alpha: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.preferred_carrier_beta", "title": "preferred_carrier_beta  <code>instance-attribute</code>", "text": "<pre><code>preferred_carrier_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator: Generator\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.replanning_alpha", "title": "replanning_alpha  <code>instance-attribute</code>", "text": "<pre><code>replanning_alpha: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.replanning_beta", "title": "replanning_beta  <code>instance-attribute</code>", "text": "<pre><code>replanning_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.segment", "title": "segment  <code>instance-attribute</code>", "text": "<pre><code>segment: str\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    name: str,\n    type: Literal[\"logit\", \"pods\"],\n    random_generator: Generator | None = None,\n)\n</code></pre> <p>Create a choice model object.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the choice model.</p> </li> <li> <code>type</code>               (<code>Literal['logit', 'pods']</code>)           \u2013            <p>Type of the choice model.</p> </li> <li> <code>random_generator</code>               (<code>Generator</code>, default:                   <code>None</code> )           \u2013            <p>Random number generator.  If not provided, a default generator is used.</p> </li> </ul>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.add_parm", "title": "add_parm", "text": "<pre><code>add_parm(\n    name: str, value: float, value2: float = 0\n) -&gt; None\n</code></pre> <p>Add a parameter value to the choice model</p>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.get_dwm_penalty", "title": "get_dwm_penalty", "text": "<pre><code>get_dwm_penalty(\n    choice_model: ChoiceModel,\n    distance: int,\n    startTime: int,\n    endTime: int,\n    path: Path,\n    reference_fare: float,\n    debug: bool,\n) -&gt; float\n</code></pre> <p>Get DWM penalty - used for Unit Tests</p>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.get_midpoint", "title": "get_midpoint", "text": "<pre><code>get_midpoint(z_val: float) -&gt; float\n</code></pre> <p>Get decision window midpoint - used for Unit Tests</p>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.get_time_disutility", "title": "get_time_disutility", "text": "<pre><code>get_time_disutility(\n    dmd: Demand, path: Path, debug: bool\n) -&gt; float\n</code></pre> <p>Get time (short connection and/or long elapsed) penalty - used for Unit Tests</p>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.get_window", "title": "get_window", "text": "<pre><code>get_window(\n    dmd: Demand, midpoint: int, distance: int, z_val: float\n) -&gt; tuple[int, int]\n</code></pre> <p>Get decision window start &amp; end - used for Unit Tests</p>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.serialize", "title": "serialize", "text": "<pre><code>serialize() -&gt; dict\n</code></pre> <p>Get all parameter values from the choice model.</p>"}, {"location": "API/Core/Demand.html", "title": "Demand", "text": "<p>Demand objects represent travel demand for a specific origin-destination-segment combination.</p> <p>A Demand object encapsulates all aspects of passenger demand including booking patterns, choice models, group sizes, and various demand metrics used in airline revenue management and network planning simulations.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.base_demand", "title": "base_demand  <code>instance-attribute</code>", "text": "<pre><code>base_demand: float\n</code></pre> <p>Average demand for this origin/destination/segment combination.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.business", "title": "business  <code>instance-attribute</code>", "text": "<pre><code>business: bool\n</code></pre> <p>Indicator for 'business' demand segment.</p> <p>This is a deprecated attribute.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.curve_number", "title": "curve_number  <code>instance-attribute</code>", "text": "<pre><code>curve_number: int\n</code></pre> <p>Curve number used for converting PODS input files.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre> <p>Destination airport code.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.deterministic", "title": "deterministic  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>deterministic: bool = False\n</code></pre> <p>Indicates if demand is deterministic for this object.</p> <p>When demand is deterministic, the generated total demand will be exactly  the base demand for every simulation day. All demand generation K factors  are rendered moot in this case. There can still be some randomness in the  timeframe distribution of this demand, but the total amount will be deterministic.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.distance", "title": "distance  <code>instance-attribute</code>", "text": "<pre><code>distance: float\n</code></pre> <p>Market distance in nautical miles.</p> <p>This is a pass-through attribute of the market object.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.dwm_tolerance", "title": "dwm_tolerance  <code>instance-attribute</code>", "text": "<pre><code>dwm_tolerance: float\n</code></pre> <p>Decision Window Model tolerance.</p> <p>How far outside the decision window will these passengers tolerate  with replanning disutility.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.fares", "title": "fares  <code>instance-attribute</code>", "text": "<pre><code>fares: Iterator[Fare]\n</code></pre> <p>Iterator for the fares corresponding to this demand.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.generated_demand", "title": "generated_demand  <code>instance-attribute</code>", "text": "<pre><code>generated_demand: float\n</code></pre> <p>The amount of demand generated for this segment.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_demand", "title": "gt_demand  <code>instance-attribute</code>", "text": "<pre><code>gt_demand: int\n</code></pre> <p>Grand Total demand, excluding burn samples.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_eliminated_chose_nothing", "title": "gt_eliminated_chose_nothing  <code>instance-attribute</code>", "text": "<pre><code>gt_eliminated_chose_nothing: int\n</code></pre> <p>Grand Total eliminated demand that chose nothing, excluding burn samples.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_eliminated_no_offers", "title": "gt_eliminated_no_offers  <code>instance-attribute</code>", "text": "<pre><code>gt_eliminated_no_offers: int\n</code></pre> <p>Grand total NO-GO due to no offers available, excluding burn samples.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_eliminated_wtp", "title": "gt_eliminated_wtp  <code>instance-attribute</code>", "text": "<pre><code>gt_eliminated_wtp: int\n</code></pre> <p>Grand total NO-GO due to Willingness To Pay (WTP), excluding burn samples.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre> <p>Grand Total revenue, excluding burn samples.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre> <p>Grand Total sold, excluding burn samples.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.identifier", "title": "identifier  <code>instance-attribute</code>", "text": "<pre><code>identifier: str\n</code></pre> <p>The unique identifier of this demand, in the form \"origin~destination@segment\".</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.market", "title": "market  <code>instance-attribute</code>", "text": "<pre><code>market: Market\n</code></pre> <p>The market this demand is part of.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre> <p>Origin airport code.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre> <p>Default price for this demand.</p> <p>This was used for initial scheduling experiments and is now deprecated.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.prob_favored_carrier", "title": "prob_favored_carrier  <code>instance-attribute</code>", "text": "<pre><code>prob_favored_carrier: dict[str, float]\n</code></pre> <p>Weights to compute favored carrier preferences.</p> <p>Based on the PODS approach for carrier preference modeling.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.prob_num_days", "title": "prob_num_days  <code>instance-attribute</code>", "text": "<pre><code>prob_num_days: list[float]\n</code></pre> <p>List of probabilities for length of trip.</p> <p>Used for ML experiments, not used internally.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.prob_saturday_night", "title": "prob_saturday_night  <code>instance-attribute</code>", "text": "<pre><code>prob_saturday_night: float\n</code></pre> <p>Probability of Saturday night stay.</p> <p>Sets a flag in the Offer, used for ML experiments. Not used internally.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.reference_fare", "title": "reference_fare  <code>instance-attribute</code>", "text": "<pre><code>reference_fare: float\n</code></pre> <p>Reference fare used when computing Willingness To Pay (WTP).</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre> <p>Total revenue generated from this demand.</p> <p>This value is reset after every simulation sample.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.scenario_demand", "title": "scenario_demand  <code>instance-attribute</code>", "text": "<pre><code>scenario_demand: float\n</code></pre> <p>Demand for this origin/destination/segment in this sample.</p> <p>Usually generated as a random draw based on base_demand.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.segment", "title": "segment  <code>instance-attribute</code>", "text": "<pre><code>segment: str\n</code></pre> <p>Customer segment name such as 'business' or 'leisure'.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre> <p>Number of tickets sold for this demand.</p> <p>This value is reset after every simulation sample.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.unsold", "title": "unsold  <code>instance-attribute</code>", "text": "<pre><code>unsold: int\n</code></pre> <p>NO-GO count for demand that chose nothing.</p> <p>Count of demand that could not be satisfied due to capacity or  Willingness To Pay (WTP) constraints.</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    orig: str | None = None,\n    dest: str | None = None,\n    segment: str = \"\",\n    base_demand: float = 0,\n    scenario_demand: float = 0,\n    *,\n    market: Market | None = None,\n    deterministic: bool = False,\n)\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_booking_curve", "title": "add_booking_curve", "text": "<pre><code>add_booking_curve(curve: BookingCurve) -&gt; str\n</code></pre> <p>Add a booking curve to this market segment.</p> <p>Parameters:</p> <ul> <li> <code>curve</code>               (<code>BookingCurve</code>)           \u2013            <p>The booking curve object to add to this market segment.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A confirmation message indicating the curve was added.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the parameter is not a BookingCurve object.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_choice_model", "title": "add_choice_model", "text": "<pre><code>add_choice_model(choice_model: ChoiceModel) -&gt; str\n</code></pre> <p>Add a choice model to this market segment.</p> <p>Parameters:</p> <ul> <li> <code>choice_model</code>               (<code>ChoiceModel</code>)           \u2013            <p>The choice model object to add to this market segment.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A confirmation message indicating the choice model was added.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the parameter is not a ChoiceModel object.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_curve", "title": "add_curve", "text": "<pre><code>add_curve(curve: BookingCurve) -&gt; str\n</code></pre> <p>Add a booking curve to this market segment.</p> <p>Parameters:</p> <ul> <li> <code>curve</code>               (<code>BookingCurve</code>)           \u2013            <p>The booking curve object to add to this market segment.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A confirmation message indicating the curve was added.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the parameter is not a BookingCurve object.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_dwm", "title": "add_dwm", "text": "<pre><code>add_dwm(decision_window: DecisionWindow) -&gt; int\n</code></pre> <p>Add a Decision Window Model to this market segment.</p> <p>Parameters:</p> <ul> <li> <code>decision_window</code>               (<code>DecisionWindow</code>)           \u2013            <p>The Decision Window Model object to add to this market segment.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Returns 0 to indicate successful addition.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the parameter is not a DecisionWindow object.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_fare", "title": "add_fare", "text": "<pre><code>add_fare(fare: Fare) -&gt; None\n</code></pre> <p>Add a fare to this market segment.</p> <p>Parameters:</p> <ul> <li> <code>fare</code>               (<code>Fare</code>)           \u2013            <p>The fare object to add to this market segment.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the parameter is not a Fare object.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_group_sizes", "title": "add_group_sizes", "text": "<pre><code>add_group_sizes(group_sizes: list[float]) -&gt; str\n</code></pre> <p>Add a list of group sizes to this market segment.</p> <p>Group sizes is an array of proportions that define the distribution of group sizes for bookings. For example, [0.5, 0.4, 0.1] indicates 50% single passengers, 40% groups of 2, and 10% groups of 3.</p> <p>Parameters:</p> <ul> <li> <code>group_sizes</code>               (<code>list of float</code>)           \u2013            <p>A list of proportions for different group sizes. Must sum to 1.0 (\u00b10.001).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A confirmation message indicating the group sizes were added.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the parameter is not a list.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the group sizes do not sum to 1.0 (within tolerance of 0.001).</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_override", "title": "add_override", "text": "<pre><code>add_override(\n    carrier: str, discount_pct: float, pref_adj: float\n) -&gt; int\n</code></pre> <p>Add demand override information to this market segment.</p> <p>Overrides allow for carrier-specific adjustments to demand modeling, including discount percentages and preference adjustments.</p> <p>Parameters:</p> <ul> <li> <code>carrier</code>               (<code>str</code>)           \u2013            <p>The carrier code to apply the override to.</p> </li> <li> <code>discount_pct</code>               (<code>float</code>)           \u2013            <p>The discount percentage to apply for this carrier.</p> </li> <li> <code>pref_adj</code>               (<code>float</code>)           \u2013            <p>The preference adjustment factor for this carrier.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Returns 0 to indicate successful addition.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the carrier parameter is not a string.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_path", "title": "add_path", "text": "<pre><code>add_path(path: Path) -&gt; str\n</code></pre> <p>Add an itinerary path to this market segment.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The itinerary path object to add to this market segment.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A confirmation message indicating the path was added.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the parameter is not a Path object.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the market is not set for this Demand object.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_carrier_revenue", "title": "get_carrier_revenue", "text": "<pre><code>get_carrier_revenue(carrier: str) -&gt; float\n</code></pre> <p>Get the revenue generated for the specified carrier.</p> <p>Parameters:</p> <ul> <li> <code>carrier</code>               (<code>str</code>)           \u2013            <p>The carrier code to query.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The revenue generated for the specified carrier, or 0.0 if no revenue recorded.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the carrier parameter is not a string.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_carrier_sold", "title": "get_carrier_sold", "text": "<pre><code>get_carrier_sold(carrier: str) -&gt; int\n</code></pre> <p>Get the number of tickets sold for the specified carrier.</p> <p>Parameters:</p> <ul> <li> <code>carrier</code>               (<code>str</code>)           \u2013            <p>The carrier code to query.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of tickets sold for the specified carrier, or 0 if no sales recorded.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the carrier parameter is not a string.</p> </li> <li> <code>Exception</code>             \u2013            <p>If an error occurs during the lookup.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_choice_model", "title": "get_choice_model", "text": "<pre><code>get_choice_model() -&gt; ChoiceModel | None\n</code></pre> <p>Get the choice model attached to this market segment.</p> <p>Returns:</p> <ul> <li> <code>ChoiceModel or None</code>           \u2013            <p>The choice model object if one is attached, None otherwise.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_choice_model_name", "title": "get_choice_model_name", "text": "<pre><code>get_choice_model_name() -&gt; str | None\n</code></pre> <p>Get the name of the choice model attached to this market segment.</p> <p>Returns:</p> <ul> <li> <code>str or None</code>           \u2013            <p>The name of the choice model if one is attached, None otherwise.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_demand_dcp", "title": "get_demand_dcp", "text": "<pre><code>get_demand_dcp(dcp: int) -&gt; float\n</code></pre> <p>Get generated demand for the specified Days before Close of Passage (DCP).</p> <p>Used for debugging and unit tests to examine demand generation at specific timeframes.</p> <p>Parameters:</p> <ul> <li> <code>dcp</code>               (<code>int</code>)           \u2013            <p>The Days before Close of Passage (DCP) to query.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The generated demand for the specified DCP.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>IndexError</code>             \u2013            <p>If the specified DCP is not found in the demand timeframe data.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_min_delta_t", "title": "get_min_delta_t", "text": "<pre><code>get_min_delta_t() -&gt; int\n</code></pre> <p>Get the minimum delta_t across all paths for this demand.</p> <p>Used for unit testing of Decision Window Model (DWM). Finds the shortest delta_t value among all paths that can handle requests from this demand.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The minimum delta_t value.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If an error occurs during the calculation.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_min_elapsed_time", "title": "get_min_elapsed_time", "text": "<pre><code>get_min_elapsed_time() -&gt; int\n</code></pre> <p>Get the minimum elapsed time across all paths for this demand.</p> <p>Finds the shortest elapsed time (total travel time) among all paths that can handle requests from this demand.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The minimum elapsed time in minutes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If an error occurs during the calculation.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_overrides", "title": "get_overrides", "text": "<pre><code>get_overrides() -&gt; list[dict[str, str | float]]\n</code></pre> <p>Get the demand overrides for this market segment.</p> <p>Returns a list of dictionaries containing override information for different carriers. Each dictionary contains 'carrier', 'discount_pct', and 'pref_adj' keys.</p> <p>Returns:</p> <ul> <li> <code>list of dict</code>           \u2013            <p>A list of dictionaries, each containing: - 'carrier' (str): The carrier code - 'discount_pct' (float): The discount percentage - 'pref_adj' (float): The preference adjustment factor</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If an error occurs while processing the overrides.</p> </li> </ul>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_paths", "title": "get_paths", "text": "<pre><code>get_paths() -&gt; tuple[Path, ...]\n</code></pre> <p>Get the paths that can handle requests from this demand.</p> <p>Returns a tuple of Path objects representing all itinerary paths available for this market segment.</p> <p>Returns:</p> <ul> <li> <code>tuple of Path</code>           \u2013            <p>A tuple containing all Path objects that can handle requests from this demand. Returns an empty tuple if no paths are available.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the market is not set for this Demand object.</p> </li> <li> <code>Exception</code>             \u2013            <p>If an error occurs while creating path objects.</p> </li> </ul>"}, {"location": "API/Core/Fare.html", "title": "Fare", "text": ""}, {"location": "API/Core/Fare.html#passengersim_core.Fare.adjusted_price", "title": "adjusted_price  <code>instance-attribute</code>", "text": "<pre><code>adjusted_price: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.adv_purch", "title": "adv_purch  <code>instance-attribute</code>", "text": "<pre><code>adv_purch: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.booking_class", "title": "booking_class  <code>instance-attribute</code>", "text": "<pre><code>booking_class: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.cabin", "title": "cabin  <code>instance-attribute</code>", "text": "<pre><code>cabin: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: Carrier | None\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.category", "title": "category  <code>instance-attribute</code>", "text": "<pre><code>category: Any\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.cp_revenue", "title": "cp_revenue  <code>instance-attribute</code>", "text": "<pre><code>cp_revenue: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.cp_sold", "title": "cp_sold  <code>instance-attribute</code>", "text": "<pre><code>cp_sold: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.fare_id", "title": "fare_id  <code>instance-attribute</code>", "text": "<pre><code>fare_id: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.gt_cp_revenue", "title": "gt_cp_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_cp_revenue: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.gt_cp_sold", "title": "gt_cp_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_cp_sold: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.min_stay", "title": "min_stay  <code>instance-attribute</code>", "text": "<pre><code>min_stay: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.price_lower_bound", "title": "price_lower_bound  <code>instance-attribute</code>", "text": "<pre><code>price_lower_bound: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.price_upper_bound", "title": "price_upper_bound  <code>instance-attribute</code>", "text": "<pre><code>price_upper_bound: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.saturday_night_required", "title": "saturday_night_required  <code>instance-attribute</code>", "text": "<pre><code>saturday_night_required: bool\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.sold_business", "title": "sold_business  <code>instance-attribute</code>", "text": "<pre><code>sold_business: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    carrier: Carrier | None,\n    orig: str,\n    dest: str,\n    booking_class: str,\n    price: float,\n)\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.add_restriction", "title": "add_restriction", "text": "<pre><code>add_restriction(restriction: int) -&gt; None\n</code></pre> <p>Add a restriction code to this Fare.</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.adjust_price", "title": "adjust_price", "text": "<pre><code>adjust_price(dcp_index: int, adjusted_price: float)\n</code></pre> <p>Set the adjusted price.  The dcp_index is only used for tracking and reporting</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_adjusted_by_dcp", "title": "get_adjusted_by_dcp", "text": "<pre><code>get_adjusted_by_dcp(dcp_index: int) -&gt; float\n</code></pre> <p>Return the average adjusted fare for this DCP index.  Will return 0.0 if the DCP index was not found</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_restriction", "title": "get_restriction", "text": "<pre><code>get_restriction(n: int) -&gt; str\n</code></pre> <p>Get the n-th restriction code on this Fare</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_sales_by_dcp", "title": "get_sales_by_dcp", "text": "<pre><code>get_sales_by_dcp(dcp: int) -&gt; int\n</code></pre> <p>Get the sales by specified DCP</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_sales_by_dcp2", "title": "get_sales_by_dcp2", "text": "<pre><code>get_sales_by_dcp2(dcp: int) -&gt; int\n</code></pre> <p>Get the sales by specified DCP</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_sales_by_segment", "title": "get_sales_by_segment", "text": "<pre><code>get_sales_by_segment(seg: str) -&gt; int\n</code></pre> <p>Get the sales by demand segment DCP</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.num_restrictions", "title": "num_restrictions", "text": "<pre><code>num_restrictions() -&gt; int\n</code></pre> <p>How many restrictions do we have on this fare?</p>"}, {"location": "API/Core/Generator.html", "title": "Generator", "text": ""}, {"location": "API/Core/Generator.html#passengersim_core.Generator.bitgenerator", "title": "bitgenerator  <code>instance-attribute</code>", "text": "<pre><code>bitgenerator: BitGenerator\n</code></pre>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.bitgenerator_class", "title": "bitgenerator_class  <code>instance-attribute</code>", "text": "<pre><code>bitgenerator_class: type[BitGenerator]\n</code></pre>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    seed: int | None = None,\n    bitgenerator_class: type[BitGenerator] | None = None,\n)\n</code></pre> <p>Initialize a random number generator.</p> <p>Parameters:</p> <ul> <li> <code>seed</code>               (<code>int or None</code>, default:                   <code>None</code> )           \u2013            <p>For reproducibility, provide a seed.  If no seed is provided, a random seed is provided by the operating system and generally the results will be different every time you reseed.</p> </li> <li> <code>bitgenerator_class</code>               (<code>type[BitGenerator]</code>, default:                   <code>None</code> )           \u2013            <p>This is the class used to create new BitGenerator objects when the seed is reset.</p> </li> </ul>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.get_normal", "title": "get_normal", "text": "<pre><code>get_normal() -&gt; float\n</code></pre> <p>Return a random draw from a standard normal distribution.</p>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.get_uniform", "title": "get_uniform", "text": "<pre><code>get_uniform() -&gt; float\n</code></pre> <p>Return a random draw standard uniform distribution.</p>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.seed", "title": "seed", "text": "<pre><code>seed(seed: int | list[int] | None) -&gt; None\n</code></pre> <p>Reseed the random bit generator.</p>"}, {"location": "API/Core/Leg.html", "title": "Leg", "text": ""}, {"location": "API/Core/Leg.html#passengersim_core.Leg.action_state", "title": "action_state  <code>instance-attribute</code>", "text": "<pre><code>action_state: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.action_timestamp", "title": "action_timestamp  <code>instance-attribute</code>", "text": "<pre><code>action_timestamp: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.arr_time", "title": "arr_time  <code>instance-attribute</code>", "text": "<pre><code>arr_time: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.arr_time_offset", "title": "arr_time_offset  <code>instance-attribute</code>", "text": "<pre><code>arr_time_offset: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.bid_price", "title": "bid_price  <code>instance-attribute</code>", "text": "<pre><code>bid_price: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.bid_price_gradient", "title": "bid_price_gradient  <code>instance-attribute</code>", "text": "<pre><code>bid_price_gradient: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.buckets", "title": "buckets  <code>instance-attribute</code>", "text": "<pre><code>buckets: Iterator[Bucket]\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.cabins", "title": "cabins  <code>instance-attribute</code>", "text": "<pre><code>cabins: Iterator[Cabin]\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.capacity", "title": "capacity  <code>instance-attribute</code>", "text": "<pre><code>capacity: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: Carrier | None\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.dep_time", "title": "dep_time  <code>instance-attribute</code>", "text": "<pre><code>dep_time: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.dep_time_offset", "title": "dep_time_offset  <code>instance-attribute</code>", "text": "<pre><code>dep_time_offset: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.displacement", "title": "displacement  <code>instance-attribute</code>", "text": "<pre><code>displacement: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.distance", "title": "distance  <code>instance-attribute</code>", "text": "<pre><code>distance: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.duration", "title": "duration  <code>instance-attribute</code>", "text": "<pre><code>duration: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.equipment", "title": "equipment  <code>instance-attribute</code>", "text": "<pre><code>equipment: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.flt_no", "title": "flt_no  <code>instance-attribute</code>", "text": "<pre><code>flt_no: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.gt_capacity", "title": "gt_capacity  <code>instance-attribute</code>", "text": "<pre><code>gt_capacity: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.info", "title": "info  <code>instance-attribute</code>", "text": "<pre><code>info: Any\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.leg_id", "title": "leg_id  <code>instance-attribute</code>", "text": "<pre><code>leg_id: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.pathclass_identifiers", "title": "pathclass_identifiers  <code>instance-attribute</code>", "text": "<pre><code>pathclass_identifiers: Iterator[str]\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.q_demand", "title": "q_demand  <code>instance-attribute</code>", "text": "<pre><code>q_demand: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    leg_id: int,\n    carrier: Carrier | None,\n    flt_no: int,\n    orig: str,\n    dest: str,\n    capacity: int = 0,\n    sold: int = 0,\n    duration: int = 0,\n    equipment: str = None,\n    info: Any = None,\n)\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.add_bucket", "title": "add_bucket", "text": "<pre><code>add_bucket(*args: Bucket)\n</code></pre> <p>Add an inventory control bucket to the Leg.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.add_cabin", "title": "add_cabin", "text": "<pre><code>add_cabin(*args: Cabin)\n</code></pre> <p>Add a Cabin to the Leg.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.bucket_number", "title": "bucket_number", "text": "<pre><code>bucket_number(i: int | str) -&gt; Bucket\n</code></pre> <p>Get the bucket from the leg.</p> <p>Parameters:</p> <ul> <li> <code>i</code>               (<code>int or str</code>)           \u2013            <p>If an integer, returns the bucket at this index position from the list of buckets attached to this Leg.  If given as a str, returns the bucket with the indicated booking class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Bucket</code>           \u2013            </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.capture_dcp", "title": "capture_dcp", "text": "<pre><code>capture_dcp(i: int) -&gt; None\n</code></pre> <p>Grab a snapshot of important variables.</p> <p>Parameters:</p> <ul> <li> <code>i</code>               (<code>int</code>)           \u2013            <p>The index of the DCP to capture.</p> </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.compute_forecasts", "title": "compute_forecasts", "text": "<pre><code>compute_forecasts(\n    dcp_index: int,\n    algorithm: str = None,\n    snapshot_instruction: SnapshotInstruction | None = None,\n    recompute: bool = True,\n    alpha: float = 0.15,\n    event_time: int = None,\n    return_vectors: bool = False,\n) -&gt; None | dict[str, ForecastVectors]\n</code></pre> <p>Compute forecasts for the leg and its buckets.</p> <p>Parameters:</p> <ul> <li> <code>dcp_index</code>               (<code>int</code>)           \u2013            <p>The index of the DCP to compute the forecasts for. This is used to limit the computation to only the relevant data; if the DCP index is greater than zero then the forecast is only computed for the DCP(s) at and after this index.</p> </li> <li> <code>algorithm</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the forecast algorithm to use.  This must be provided if recompute is True, otherwise it is ignored.</p> </li> <li> <code>snapshot_instruction</code>               (<code>SnapshotInstruction</code>, default:                   <code>None</code> )           \u2013            <p>If given, this is a snapshot instruction to use for the forecast.</p> </li> <li> <code>recompute</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, recompute the forecast, otherwise use the existing forecast and simply update cached values on the Leg and its buckets to reflect the <code>dcp_index</code>.</p> </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.15</code> )           \u2013            <p>The alpha value to use for exponential smoothing.</p> </li> <li> <code>event_time</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The time of the event that triggered the forecast computation.</p> </li> <li> <code>return_vectors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a dictionary of forecast vectors for each bucket. Primarily used for debugging and testing.</p> </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.emsrb", "title": "emsrb", "text": "<pre><code>emsrb(debug: bool | None)\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.forecast", "title": "forecast", "text": "<pre><code>forecast(\n    dcp_index: int,\n    algorithm: str,\n    snapshot_instruction: SnapshotInstruction | None = None,\n)\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bid_price_array", "title": "get_bid_price_array", "text": "<pre><code>get_bid_price_array() -&gt; ndarray\n</code></pre> <p>Get a copy of the bid price array for the leg.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_auth", "title": "get_bucket_auth", "text": "<pre><code>get_bucket_auth(i: int | str) -&gt; int\n</code></pre> <p>Get the authorization for a bucket attached to this leg.</p> <p>Parameters:</p> <ul> <li> <code>i</code>               (<code>int or str</code>)           \u2013            <p>If an integer, returns the auth of the bucket at this index position from the list of buckets attached to this Leg.  If given as a str, returns the auth of the bucket with the indicated booking class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_fcst_mean", "title": "get_bucket_fcst_mean", "text": "<pre><code>get_bucket_fcst_mean(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the forecast demand for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_fcst_revenue", "title": "get_bucket_fcst_revenue", "text": "<pre><code>get_bucket_fcst_revenue(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the forecast revenue for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_fcst_std_dev", "title": "get_bucket_fcst_std_dev", "text": "<pre><code>get_bucket_fcst_std_dev(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the forecast demand std. dev. for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_revenue", "title": "get_bucket_revenue", "text": "<pre><code>get_bucket_revenue(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the revenue for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_sold", "title": "get_bucket_sold", "text": "<pre><code>get_bucket_sold(i: int | str) -&gt; int\n</code></pre> <p>Get the number of seats sold for a bucket attached to this leg.</p> <p>Parameters:</p> <ul> <li> <code>i</code>               (<code>int or str</code>)           \u2013            <p>If an integer, returns the number of seats sold for the bucket at this index position from the list of buckets attached to this Leg.  If given as a str, returns the number of seats sold for the bucket with the indicated booking class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_cabin", "title": "get_cabin", "text": "<pre><code>get_cabin(i: int) -&gt; Cabin\n</code></pre> <p>Get Cabin by index</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_num_buckets", "title": "get_num_buckets", "text": "<pre><code>get_num_buckets() -&gt; int\n</code></pre> <p>Get the number of buckets attached to this leg.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_num_cabins", "title": "get_num_cabins", "text": "<pre><code>get_num_cabins() -&gt; int\n</code></pre> <p>Get the number of cabins attached to this leg.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.littlewood", "title": "littlewood", "text": "<pre><code>littlewood(\n    mu: float,\n    sigma: float,\n    rev_hi: float,\n    rev_lo: float,\n    cv100: float,\n) -&gt; float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.print_bucket_detail", "title": "print_bucket_detail", "text": "<pre><code>print_bucket_detail() -&gt; None\n</code></pre> <p>Print a bunch of debugging info</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.print_bucket_history", "title": "print_bucket_history", "text": "<pre><code>print_bucket_history()\n</code></pre> <p>Print a bunch of debugging info</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_auth", "title": "set_bucket_auth", "text": "<pre><code>set_bucket_auth(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the authorization for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_fcst_mean", "title": "set_bucket_fcst_mean", "text": "<pre><code>set_bucket_fcst_mean(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the forecast demand for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_fcst_revenue", "title": "set_bucket_fcst_revenue", "text": "<pre><code>set_bucket_fcst_revenue(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the revenue forecast for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_fcst_std_dev", "title": "set_bucket_fcst_std_dev", "text": "<pre><code>set_bucket_fcst_std_dev(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the forecast demand std. dev. for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_revenue", "title": "set_bucket_revenue", "text": "<pre><code>set_bucket_revenue(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the revenue for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_sold", "title": "set_bucket_sold", "text": "<pre><code>set_bucket_sold(bkt_ref: int | str, sold: int)\n</code></pre> <p>Set the seats sold for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.untruncate_demand", "title": "untruncate_demand", "text": "<pre><code>untruncate_demand(\n    dcp_index: int,\n    algorithm: str,\n    snapshot_instruction: SnapshotInstruction | None = None,\n    maxiter: int = 20,\n    tolerance: float = 0.01,\n    pods_initialization: bool = False,\n    minimum_mu: float = 0.01,\n    minimum_sigma: float = 0.1,\n)\n</code></pre> <p>Run the demand untruncation models for this leg and its buckets.</p> <p>Parameters:</p> <ul> <li> <code>dcp_index</code>               (<code>int</code>)           \u2013            <p>The index of the DCP to run the untruncation models for.</p> </li> <li> <code>algorithm</code>               (<code>str</code>)           \u2013            <p>The name of the untruncation algorithm to use.</p> </li> <li> <code>snapshot_instruction</code>               (<code>SnapshotInstruction</code>, default:                   <code>None</code> )           \u2013            <p>If given, this is a snapshot instruction to use for the untruncation</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None or str</code>           \u2013            </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.write_to_sqlite", "title": "write_to_sqlite", "text": "<pre><code>write_to_sqlite(\n    sqlite_pointer: Connection,\n    sim: SimulationEngine,\n    dcp: int,\n)\n</code></pre> <p>Write to leg_bucket_detail.</p>"}, {"location": "API/Core/Path.html", "title": "Path", "text": ""}, {"location": "API/Core/Path.html#passengersim_core.Path.adjusted_at", "title": "adjusted_at  <code>instance-attribute</code>", "text": "<pre><code>adjusted_at: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: Carrier\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.carrier_name", "title": "carrier_name  <code>instance-attribute</code>", "text": "<pre><code>carrier_name: str\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.delta_t", "title": "delta_t  <code>instance-attribute</code>", "text": "<pre><code>delta_t: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.duration", "title": "duration  <code>instance-attribute</code>", "text": "<pre><code>duration: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.first_flight", "title": "first_flight  <code>instance-attribute</code>", "text": "<pre><code>first_flight: bool\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.gt_sold_priceable", "title": "gt_sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>gt_sold_priceable: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.last_fcst_ts", "title": "last_fcst_ts  <code>instance-attribute</code>", "text": "<pre><code>last_fcst_ts: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.last_flight", "title": "last_flight  <code>instance-attribute</code>", "text": "<pre><code>last_flight: bool\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.market", "title": "market  <code>instance-attribute</code>", "text": "<pre><code>market: Market\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.minimum_conect_time", "title": "minimum_conect_time  <code>instance-attribute</code>", "text": "<pre><code>minimum_conect_time: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.path_quality_index", "title": "path_quality_index  <code>instance-attribute</code>", "text": "<pre><code>path_quality_index: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.pathclasses", "title": "pathclasses  <code>instance-attribute</code>", "text": "<pre><code>pathclasses: Iterator[PathClass]\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.q_forecast", "title": "q_forecast  <code>instance-attribute</code>", "text": "<pre><code>q_forecast: Forecast\n</code></pre> <p>The Q-Forecast object for this Path.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.sold_priceable", "title": "sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>sold_priceable: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    orig: str,\n    dest: str,\n    price: float,\n    carrier: Carrier | None = None,\n)\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.accumulate_forecasts", "title": "accumulate_forecasts", "text": "<pre><code>accumulate_forecasts(dcpIndex: int)\n</code></pre> <p>Adds the path fcst to each leg / bucket</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.accumulate_forecasts_vn", "title": "accumulate_forecasts_vn", "text": "<pre><code>accumulate_forecasts_vn()\n</code></pre> <p>Adds the path fcst to each leg / bucket, using the Virtual Nesting mapping</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_booking_class", "title": "add_booking_class", "text": "<pre><code>add_booking_class(booking_class: str)\n</code></pre> <p>Add a booking class to this Path</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_carrier", "title": "add_carrier", "text": "<pre><code>add_carrier(carrier: Carrier) -&gt; None\n</code></pre> <p>Add a Carrier to this Path.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_get_orders", "title": "add_get_orders", "text": "<pre><code>add_get_orders() -&gt; list\n</code></pre> <p>Return a list of orders</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_leg", "title": "add_leg", "text": "<pre><code>add_leg(leg: Leg) -&gt; None\n</code></pre> <p>Add a leg to this Path.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_order", "title": "add_order", "text": "<pre><code>add_order(\n    timestamp: float,\n    dcp_index: int,\n    num_pax: int,\n    price: float,\n)\n</code></pre> <p>Add an Order to the Path</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_path_class", "title": "add_path_class", "text": "<pre><code>add_path_class(path_class: PathClass)\n</code></pre> <p>Add a path class to this Path</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.adjust_forecasts", "title": "adjust_forecasts", "text": "<pre><code>adjust_forecasts(\n    current_tf_index: int,\n    current_tf_begin_time: int,\n    current_time: int,\n    current_tf_end_time: int,\n    departure_time: int = 0,\n    snapshot_instruction: SnapshotInstruction | None = None,\n) -&gt; None\n</code></pre> <p>Adjust the forecast for this path and any path-class items it has, using in daily reoptimization</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.allocate_q_demand", "title": "allocate_q_demand", "text": "<pre><code>allocate_q_demand(\n    frat5: Frat5,\n    dcp_index: int,\n    snapshot_instruction,\n    allocation_algorithm: Literal[\"tf\", \"dep\"],\n) -&gt; float\n</code></pre> <p>First step in Q-forecasting</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.capture_dcp", "title": "capture_dcp", "text": "<pre><code>capture_dcp(\n    dcp_index: int, frat5=None, snapshot_instruction=None\n)\n</code></pre> <p>Save relevant information for this DCP</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.check_avail", "title": "check_avail", "text": "<pre><code>check_avail(fare: Fare, num_pax: int, debug: bool | None)\n</code></pre> <p>Is this fare available on the Path?  Used for unit testing</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.compute_fare_adjustments", "title": "compute_fare_adjustments", "text": "<pre><code>compute_fare_adjustments(\n    dcp_index: int,\n    algorithm: Literal[\"mr\", \"ki\"],\n    frat5: Frat5,\n    scale_factor: float = 1.0,\n    snapshot_instruction: SnapshotInstruction | None = None,\n    *,\n    sort_pathclasses: bool = True,\n) -&gt; None\n</code></pre> <p>Compute the fare adjustment for this path and its path-class items.</p> <p>Parameters:</p> <ul> <li> <code>dcp_index</code>               (<code>int</code>)           \u2013            <p>Compute fare adjustments from this DCP to departure.</p> </li> <li> <code>algorithm</code>               (<code>('mr', 'ki')</code>, default:                   <code>'mr'</code> )           \u2013            <p>The algorithm to use for fare adjustment.</p> </li> <li> <code>frat5</code>               (<code>Frat5</code>)           \u2013            <p>Frat5 object to use for Q-forecasting.</p> </li> <li> <code>scale_factor</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Scale factor to apply to fare adjustments.  This overrides the scale factor set in the Frat5 object, which is deprecated.</p> </li> <li> <code>snapshot_instruction</code>               (<code>SnapshotInstruction</code>, default:                   <code>None</code> )           \u2013            <p>If not None, a snapshot of the forecast will be written based on these instructions.</p> </li> <li> <code>sort_pathclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, sort the pathclasses by fare before adjustment.  If the pathclasses are already sorted, this can be set to False to save time.</p> </li> </ul>"}, {"location": "API/Core/Path.html#passengersim_core.Path.compute_forecasts", "title": "compute_forecasts", "text": "<pre><code>compute_forecasts(\n    dcp_index: int,\n    algorithm: str = None,\n    snapshot_instruction: SnapshotInstruction | None = None,\n    recompute: bool = True,\n    *,\n    alpha: float = 0.15,\n    event_time: int | None = None,\n) -&gt; None\n</code></pre> <p>Run the standard forecast models for this Path and its PathClass items.</p> <p>Parameters:</p> <ul> <li> <code>dcp_index</code>               (<code>int</code>)           \u2013            <p>The index of the DCP to compute the forecasts for. This is used to limit the computation to only the relevant data; if the DCP index is greater than zero then the forecast is only computed for the DCP(s) at and after this index.</p> </li> <li> <code>algorithm</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the forecast algorithm to use.  This must be provided if recompute is True, otherwise it is ignored.</p> </li> <li> <code>snapshot_instruction</code>               (<code>SnapshotInstruction</code>, default:                   <code>None</code> )           \u2013            <p>If given, this is a snapshot instruction to use for the forecast.</p> </li> <li> <code>recompute</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, recompute the forecast, otherwise use the existing forecast and simply update cached values on the Leg and its buckets to reflect the <code>dcp_index</code>.</p> </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.15</code> )           \u2013            <p>The alpha value to use for exponential smoothing, this is ignored if <code>algorithm</code> is not 'exp_smoothing'.</p> </li> <li> <code>event_time</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The time of the event that triggered the forecast computation. This is used to when adjusting forecasts within a DCP.</p> </li> </ul>"}, {"location": "API/Core/Path.html#passengersim_core.Path.compute_hybrid_forecasts", "title": "compute_hybrid_forecasts", "text": "<pre><code>compute_hybrid_forecasts(\n    dcp_index: int,\n    algorithm: str,\n    frat5: Frat5,\n    snapshot_instruction: SnapshotInstruction | None = None,\n    recompute: bool = True,\n    pods_init: bool = False,\n    *,\n    alpha: float = 0.15,\n) -&gt; float\n</code></pre> <p>Run the hybrid forecast models for this path and its path-class items.</p> <p>Parameters:</p> <ul> <li> <code>dcp_index</code>               (<code>int</code>)           \u2013            <p>Only compute forecasts only from this DCP to departure.</p> </li> <li> <code>algorithm</code>               (<code>('exp_smoothing', 'additive_pickup')</code>, default:                   <code>'exp_smoothing'</code> )           \u2013            <p>Forecasting algorithm to use.</p> </li> <li> <code>frat5</code>               (<code>Frat5</code>)           \u2013            <p>Frat5 object to use for Q-forecasting.</p> </li> <li> <code>snapshot_instruction</code>               (<code>SnapshotInstruction</code>, default:                   <code>None</code> )           \u2013            <p>If not None, a snapshot of the forecast will be written based on these instructions.</p> </li> <li> <code>max_cap</code>               (<code>float</code>, default:                   <code>10.0</code> )           \u2013            <p>Maximum capacity inflation for Q-forecasting.</p> </li> <li> <code>pods_init</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>0.15</code> )           \u2013            <p>Smoothing factor for exponential smoothing. This is a keyword-only argument.</p> </li> </ul>"}, {"location": "API/Core/Path.html#passengersim_core.Path.compute_q_equivalent", "title": "compute_q_equivalent", "text": "<pre><code>compute_q_equivalent(\n    frat5: Frat5,\n    dcp_index: int,\n    max_cap: float = 10.0,\n    snapshot_instruction: SnapshotInstruction | None = None,\n) -&gt; float\n</code></pre> <p>First step in Q-forecasting</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_decision_fare", "title": "get_class_decision_fare", "text": "<pre><code>get_class_decision_fare(pc_index: int | str) -&gt; float\n</code></pre> <p>Get the decision fare amount for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_fcst_mean", "title": "get_class_fcst_mean", "text": "<pre><code>get_class_fcst_mean(pc_index: int | str) -&gt; float\n</code></pre> <p>Get the demand forecast for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_sold", "title": "get_class_sold", "text": "<pre><code>get_class_sold(pc_index: int | str) -&gt; int\n</code></pre> <p>Get the number sold for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_std_dev", "title": "get_class_std_dev", "text": "<pre><code>get_class_std_dev(pc_index: int | str) -&gt; float\n</code></pre> <p>Get the demand forecast std. dev. for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_bid_price", "title": "get_leg_bid_price", "text": "<pre><code>get_leg_bid_price(n: int) -&gt; float\n</code></pre> <p>Get the bid price on the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_carrier", "title": "get_leg_carrier", "text": "<pre><code>get_leg_carrier(n: int) -&gt; str\n</code></pre> <p>Get the carrier code for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_dep_time", "title": "get_leg_dep_time", "text": "<pre><code>get_leg_dep_time(n: int) -&gt; int\n</code></pre> <p>Get the departure timestamp code for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_dest", "title": "get_leg_dest", "text": "<pre><code>get_leg_dest(n: int) -&gt; str\n</code></pre> <p>Get the destination airport for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_equipment", "title": "get_leg_equipment", "text": "<pre><code>get_leg_equipment(n: int) -&gt; str\n</code></pre> <p>Get the equipment code for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_fltno", "title": "get_leg_fltno", "text": "<pre><code>get_leg_fltno(n: int) -&gt; int\n</code></pre> <p>Get the flight number for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_orig", "title": "get_leg_orig", "text": "<pre><code>get_leg_orig(n: int) -&gt; str\n</code></pre> <p>Get the origin airport for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_total_bid_price", "title": "get_total_bid_price", "text": "<pre><code>get_total_bid_price() -&gt; float\n</code></pre> <p>Get the total of bid prices on all legs</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_total_distance", "title": "get_total_distance", "text": "<pre><code>get_total_distance() -&gt; float\n</code></pre> <p>Get the total of distances on all legs</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.num_classes", "title": "num_classes", "text": "<pre><code>num_classes() -&gt; int\n</code></pre> <p>Return the number of booking classes that are tracked for this Path</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.num_deps", "title": "num_deps", "text": "<pre><code>num_deps() -&gt; int\n</code></pre> <p>How many historical departures are on this path?</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.num_legs", "title": "num_legs", "text": "<pre><code>num_legs() -&gt; int\n</code></pre> <p>How many legs are on this path?</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.print_class_history", "title": "print_class_history", "text": "<pre><code>print_class_history(path_class_index: int) -&gt; str\n</code></pre> <p>Print some historical data to stdout, mostly for debugging</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.reset_counters", "title": "reset_counters", "text": "<pre><code>reset_counters() -&gt; None\n</code></pre> <p>Reset the sold, revenue, and forecast counters for this path and any path-class items it has</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_decision_fare", "title": "set_class_decision_fare", "text": "<pre><code>set_class_decision_fare(pc_index: int | str, fcst: float)\n</code></pre> <p>Set the decision fare amount for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_fcst_mean", "title": "set_class_fcst_mean", "text": "<pre><code>set_class_fcst_mean(pc_index: int | str, fcst: float)\n</code></pre> <p>Set the demand forecast for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_sold", "title": "set_class_sold", "text": "<pre><code>set_class_sold(pc_index: int | str, sold: int)\n</code></pre> <p>Set the number sold for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_std_dev", "title": "set_class_std_dev", "text": "<pre><code>set_class_std_dev(pc_index: int | str, fcst: float)\n</code></pre> <p>Set the demand forecast std. dev.for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.untruncate_demand", "title": "untruncate_demand", "text": "<pre><code>untruncate_demand(\n    dcp_index: int,\n    algorithm: str,\n    debug: SnapshotInstruction | None = None,\n    maxiter: int = 20,\n    tolerance: float = 0.01,\n    pods_initialization: bool = False,\n    minimum_mu: float = 0.01,\n    minimum_sigma: float = 0.1,\n)\n</code></pre> <p>Run the demand untruncation models for this path and any path-class items it has</p>"}, {"location": "API/Core/PathClass.html", "title": "Path Class", "text": ""}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.adjusted_fare_price", "title": "adjusted_fare_price  <code>instance-attribute</code>", "text": "<pre><code>adjusted_fare_price: tuple[float]\n</code></pre> <p>Adjusted fare by DCP.</p> <p>This will be an empty tuple if fare adjustment is not being computed.</p>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.booking_class", "title": "booking_class  <code>instance-attribute</code>", "text": "<pre><code>booking_class: str\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.decision_fare", "title": "decision_fare  <code>instance-attribute</code>", "text": "<pre><code>decision_fare: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.fare", "title": "fare  <code>instance-attribute</code>", "text": "<pre><code>fare: Fare | None\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.forecast", "title": "forecast  <code>instance-attribute</code>", "text": "<pre><code>forecast: Forecast\n</code></pre> <p>Forecast of total demand.</p> <p>If hybrid forecasting is in use, this forecast includes both priceable and yieldable demand.</p>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.gt_sold_priceable", "title": "gt_sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>gt_sold_priceable: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.identifier", "title": "identifier  <code>instance-attribute</code>", "text": "<pre><code>identifier: str\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.path_id", "title": "path_id  <code>instance-attribute</code>", "text": "<pre><code>path_id: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.q_forecast", "title": "q_forecast  <code>instance-attribute</code>", "text": "<pre><code>q_forecast: Forecast\n</code></pre> <p>Forecast of the class allocation of Q-equivalent priceable demand.</p> <p>The forecasting for Q-equivalent priceable demand is handled at the Path level, and this attribute is used to store the allocated portion of that forecast for this pathclass.</p>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.sold_priceable", "title": "sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>sold_priceable: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.y_forecast", "title": "y_forecast  <code>instance-attribute</code>", "text": "<pre><code>y_forecast: Forecast\n</code></pre> <p>Forecast of yieldable demand.</p> <p>If hybrid forecasting is not in use, this will be the same as <code>forecast</code>.</p>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    path: Path, booking_class: Any, fare: Fare | None = None\n)\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.add_fare", "title": "add_fare", "text": "<pre><code>add_fare(fare: Fare)\n</code></pre> <p>Add a Fare to the PathClass</p> <p>This method is deprecated, use the <code>fare</code> attribute instead.</p>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.get_indexes", "title": "get_indexes", "text": "<pre><code>get_indexes(leg_number: int) -&gt; None\n</code></pre> <p>Get a VN index for this PathClass.</p>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.set_indexes", "title": "set_indexes", "text": "<pre><code>set_indexes(leg_number: int, index: int) -&gt; None\n</code></pre> <p>Set a VN index for this PathClass.</p>"}, {"location": "API/RM/index.html", "title": "PassengerSim.RM", "text": "<p>Revenue management (RM) systems are a key part of PassengerSim.  They are used to tailor the set of products being offered to maximize revenue.  RM systems typically involve several steps, including untruncation, forecasting, and optimization.  Each of these steps can be configured in detail to suit your needs.</p>"}, {"location": "API/RM/bases.html", "title": "RM Action Base Classes", "text": ""}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmAction", "title": "RmAction", "text": "<pre><code>RmAction(\n    *,\n    carrier: str = \"\",\n    minimum_sample: int = 10,\n    dcps: Collection[int] = (),\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>A revenue management action.</p> <p>Each RmAction is configured to run on a specific carrier, and on a set of days prior to departure.  Actions can be scheduled to run on specific days prior to departure (DCPs), or daily, or on other frequencies.</p>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmAction.requires", "title": "requires  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>requires: set[str] = set()\n</code></pre>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmAction.produces", "title": "produces  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>produces: set[str] = set()\n</code></pre>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmAction.frequency", "title": "frequency  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frequency: Literal[\n    \"dcp\",\n    \"daily\",\n    \"daily_pre_dep\",\n    \"non_dcp\",\n    \"begin_sample\",\n    \"end_sample\",\n    \"weekly\",\n] = None\n</code></pre> <p>The frequency with which to run this action.</p> <p>This can be one of the following values: - \"dcp\": run only on the specified DCPs. - \"daily\": run every day. - \"daily_pre_dep\": run every day prior to departure (i.e., days_prior &gt; 0).\" - \"non_dcp\": run on days that are not in the specified DCPs. - \"begin_sample\": run only on the first DCP (i.e., the maximum days_prior). - \"end_sample\": run only on the day of departure (i.e., days_prior == 0). - \"weekly\": run every 7 days (i.e. when days_prior is a multiple of 7).</p> <p>The <code>run</code> method of RM actions is actually called every day (as it is implemented as a daily callback), but the first thing the <code>run</code> method should do is check whether it should actually execute on that day, using the <code>should_run</code> method, which uses this frequency setting to determine whether to proceed.</p>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmAction.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier = carrier\n</code></pre> <p>The carrier upon which to apply this action.</p>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmAction.minimum_sample", "title": "minimum_sample  <code>instance-attribute</code>", "text": "<pre><code>minimum_sample = minimum_sample\n</code></pre> <p>The minimum sample number before this action will run.</p>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmAction.dcps", "title": "dcps  <code>instance-attribute</code>", "text": "<pre><code>dcps = set(dcps)\n</code></pre> <p>Set of days prior to departure on which to run this action.</p>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmAction.run", "title": "run  <code>abstractmethod</code>", "text": "<pre><code>run(sim: Simulation, days_prior: int)\n</code></pre> <p>Execute the action for the given simulation.</p> <p>Subclasses must implement this method.</p>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmAction.configure", "title": "configure  <code>classmethod</code>", "text": "<pre><code>configure(\n    fixed: dict[str, Any] | None = None, **kwargs\n) -&gt; RmActionFactory\n</code></pre> <p>Create an RmActionFactory for this action with the given configuration.</p> <p>Each keyword argument name should correspond to a parameter in the RmAction subclass's init method. The value of each keyword argument will be the keyword argument used in the <code>RmSys</code> that uses this factory.</p> <p>Fixed values can be provided via the <code>fixed</code> parameter, which is a dictionary of parameter names to fixed values. These values will always be passed to the RmAction constructor, and cannot be overridden via the RmSys.</p>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmAction.get_dcp_index", "title": "get_dcp_index", "text": "<pre><code>get_dcp_index(\n    days_prior: int, allow_between: bool = False\n) -&gt; int\n</code></pre>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmAction.should_run", "title": "should_run", "text": "<pre><code>should_run(sim: Simulation, days_prior: int) -&gt; bool\n</code></pre> <p>Determine if the action should run on the given days_prior.</p>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmSys", "title": "RmSys", "text": "<pre><code>RmSys(carrier: str, dcps: Collection[int] = (), **kwargs)\n</code></pre> <p>A revenue management (RM) system that executes a sequence of RM actions.</p> <p>Initialize the RM system.</p> <p>Parameters:</p> <ul> <li> <code>carrier</code>               (<code>str</code>)           \u2013            <p>The carrier code for which this RM system is configured.</p> </li> <li> <code>dcps</code>               (<code>Collection[int]</code>, default:                   <code>()</code> )           \u2013            <p>A collection of data collection points (DCPs) given as days prior to departure, on which to run the EMSR optimization and other actions.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments to configure the RM actions in this system.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>availability_control</code> is not defined, or if no actions are defined, or if any provided keyword argument does not match any action's configuration options.</p> </li> </ul>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmSys.priority", "title": "priority  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>priority: int = -1\n</code></pre> <p>Priority of this RM system when scheduled as an event callback.</p> <p>The default setting is -1, which means it will run just before other daily callbacks with the default priority of 0.</p>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmSys.availability_control", "title": "availability_control  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>availability_control: Literal[\n    \"leg\", \"cabin\", \"bp\", \"bp_loose\", \"classless\", None\n] = None\n</code></pre> <p>The type of availability control used in this RM system.</p> <p>The selected availability control is injected into the Carrier object at the time it is created in the simulation, as this setting is used during the passenger arrival simulation loop, and instead of during the RM system steps run from the action queue each day.</p> <p>Subclasses of <code>RmSys</code> must set this class variable to one of the allowed values (other than None) to indicate the type of availability control used by that RM system.</p>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmSys.actions", "title": "actions  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>actions: list[RmActionFactory | type[RmAction]] = []\n</code></pre> <p>List of RM actions (or action factories) to execute in this RM system.</p> <p>Each item in this list should be either an <code>RmActionFactory</code> instance, or an <code>RmAction</code> subclass.  If an <code>RmAction</code> subclass is provided, its <code>configure()</code> class method will be called to create an <code>RmActionFactory</code> with no configurable parameters.</p> <p>Subclasses of <code>RmSys</code> must set this class variable to a non-empty list of actions to be executed in order when this RM system runs.</p>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmSys.action_queue", "title": "action_queue  <code>instance-attribute</code>", "text": "<pre><code>action_queue: list[RmAction] = [\n    (make_action(carrier=carrier, dcps=dcps, **kwargs))\n    for f in factory_queue\n]\n</code></pre> <p>List of RM actions to be executed in order.</p>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmSys.run", "title": "run", "text": "<pre><code>run(sim: Simulation, days_prior: int) -&gt; None\n</code></pre> <p>Run all actions in the RM system's action queue.</p> <p>This will call all the actions in the action queue in order, passing the simulation and days prior to each action's run method. Each action should handle its own logic for whether it should execute based on the current simulation state and days prior.</p>"}, {"location": "API/RM/bases.html#passengersim.rm.systems.RmSys.get_name", "title": "get_name  <code>classmethod</code>", "text": "<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the name of this RM system class.</p>"}, {"location": "API/RM/emsr.html", "title": "Expected Marginal Seat Revenue (EMSR) Actions", "text": ""}, {"location": "API/RM/emsr.html#passengersim.rm.emsr.ExpectedMarginalSeatRevenue", "title": "ExpectedMarginalSeatRevenue", "text": "<p>               Bases: <code>RmAction</code></p> <p>EMSR (Expected Marginal Seat Revenue) is a leg-based optimization algorithm.</p>"}, {"location": "API/RM/emsr.html#passengersim.rm.emsr.ExpectedMarginalSeatRevenue.requires", "title": "requires  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>requires: set[str] = {'leg_forecast'}\n</code></pre>"}, {"location": "API/RM/emsr.html#passengersim.rm.emsr.ExpectedMarginalSeatRevenue.frequency", "title": "frequency  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frequency = 'dcp'\n</code></pre>"}, {"location": "API/RM/emsr.html#passengersim.rm.emsr.ExpectedMarginalSeatRevenue.OPT", "title": "OPT  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>OPT = EMSR()\n</code></pre>"}, {"location": "API/RM/emsr.html#passengersim.rm.emsr.ExpectedMarginalSeatRevenue.variant", "title": "variant  <code>instance-attribute</code>", "text": "<pre><code>variant = variant\n</code></pre>"}, {"location": "API/RM/emsr.html#passengersim.rm.emsr.ExpectedMarginalSeatRevenue.cabins", "title": "cabins  <code>instance-attribute</code>", "text": "<pre><code>cabins = cabins\n</code></pre> <p>Optional list of cabin codes to optimize.</p> <p>If not provided, this tool will optimize on the leg as a whole.</p>"}, {"location": "API/RM/emsr.html#passengersim.rm.emsr.ExpectedMarginalSeatRevenue.snapshots", "title": "snapshots  <code>instance-attribute</code>", "text": "<pre><code>snapshots = []\n</code></pre> <p>Optional list of snapshots to grap when running this action.</p>"}, {"location": "API/RM/emsr.html#passengersim.rm.emsr.ExpectedMarginalSeatRevenue.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    *,\n    variant: Literal[\"a\", \"b\", \"c\"] = \"b\",\n    carrier: str = \"\",\n    cabins: str | list[str] | None = None,\n    minimum_sample: int = 10,\n    dcps: Collection[int] = (),\n    snapshots: Collection[SnapshotFilter | dict] = (),\n)\n</code></pre>"}, {"location": "API/RM/emsr.html#passengersim.rm.emsr.ExpectedMarginalSeatRevenue.run", "title": "run", "text": "<pre><code>run(sim: Simulation, days_prior: int)\n</code></pre>"}, {"location": "API/RM/forecasting.html", "title": "Std Forecasting", "text": ""}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardLegForecast", "title": "StandardLegForecast", "text": "<p>               Bases: <code>RmAction</code></p> <p>Standard leg-level demand forecasting tool.</p>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardLegForecast.requires", "title": "requires  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>requires: set[str] = {'leg_demand'}\n</code></pre>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardLegForecast.produces", "title": "produces  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>produces: set[str] = {'leg_forecast'}\n</code></pre>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardLegForecast.frequency", "title": "frequency  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frequency = 'dcp'\n</code></pre>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardLegForecast.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm = algorithm\n</code></pre> <p>Forecasting algorithm.</p> <p>There are several available forecasting algorithms:</p> <p><code>additive_pickup</code>     is an additive pickup model, which generates a forecast by considering the     \"pickup\", or the number of new sales in a booking class, in each time     period (DCP).  This model is additive in that the forecast of demand yet     to come at given time is computed as the sum of forecast pickups in all     future time periods.  This forecasting model does not consider the level     of demand already accumulated, only the demand expected in the future. The     forecast is made considering the results from the prior 26 sample days.     The additive pickup model ignores the value of the alpha parameter, and it     can safely be omitted when using this algorithm.</p> <p><code>exp_smoothing</code>     is an exponential smoothing model.  This model uses the <code>alpha</code> parameter     to control the amount of smoothing applied.  It does not (currently)     incorporate trend effects or seasonality.</p> <p><code>multiplicative_pickup</code>     is a multiplicative pickup model.  This model is in development.</p>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardLegForecast.alpha", "title": "alpha  <code>instance-attribute</code>", "text": "<pre><code>alpha = alpha\n</code></pre> <p>Exponential smoothing factor.</p> <p>This setting is ignored if the forecast algorithm is not \"exp_smoothing\".</p>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardLegForecast.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    *,\n    algorithm: Literal[\n        \"additive_pickup\",\n        \"exp_smoothing\",\n        \"multiplicative_pickup\",\n    ] = \"additive_pickup\",\n    alpha: float = 0.15,\n    carrier: str = \"\",\n    minimum_sample: int = 10,\n    dcps: Collection[int] = (),\n)\n</code></pre>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardLegForecast.run", "title": "run", "text": "<pre><code>run(sim: Simulation, days_prior: int)\n</code></pre>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardPathForecast", "title": "StandardPathForecast", "text": "<p>               Bases: <code>RmAction</code></p> <p>Standard path-level demand forecasting tool.</p>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardPathForecast.requires", "title": "requires  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>requires: set[str] = {'path_demand'}\n</code></pre>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardPathForecast.produces", "title": "produces  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>produces: set[str] = {'path_forecast'}\n</code></pre>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardPathForecast.frequency", "title": "frequency  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frequency = 'dcp'\n</code></pre>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardPathForecast.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm = algorithm\n</code></pre> <p>Forecasting algorithm.</p> <p>There are several available forecasting algorithms:</p> <p><code>additive_pickup</code>     is an additive pickup model, which generates a forecast by considering the     \"pickup\", or the number of new sales in a booking class, in each time     period (DCP).  This model is additive in that the forecast of demand yet     to come at given time is computed as the sum of forecast pickups in all     future time periods.  This forecasting model does not consider the level     of demand already accumulated, only the demand expected in the future. The     forecast is made considering the results from the prior 26 sample days.     The additive pickup model ignores the value of the alpha parameter, and it     can safely be omitted when using this algorithm.</p> <p><code>exp_smoothing</code>     is an exponential smoothing model.  This model uses the <code>alpha</code> parameter     to control the amount of smoothing applied.  It does not (currently)     incorporate trend effects or seasonality.</p> <p><code>multiplicative_pickup</code>     is a multiplicative pickup model.  This model is in development.</p>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardPathForecast.alpha", "title": "alpha  <code>instance-attribute</code>", "text": "<pre><code>alpha = alpha\n</code></pre> <p>Exponential smoothing factor.</p> <p>This setting is ignored if the forecast algorithm is not \"exp_smoothing\".</p>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardPathForecast.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    *,\n    algorithm: Literal[\n        \"additive_pickup\",\n        \"exp_smoothing\",\n        \"multiplicative_pickup\",\n    ] = \"additive_pickup\",\n    alpha: float = 0.15,\n    carrier: str = \"\",\n    minimum_sample: int = 10,\n    dcps: Collection[int] = (),\n)\n</code></pre>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.StandardPathForecast.run", "title": "run", "text": "<pre><code>run(sim: Simulation, days_prior: int)\n</code></pre>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.PathForecastDailyDecay", "title": "PathForecastDailyDecay", "text": "<p>               Bases: <code>RmAction</code></p> <p>Apply daily decay to path-level demand forecasts.</p>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.PathForecastDailyDecay.frequency", "title": "frequency  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frequency = 'non_dcp'\n</code></pre>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.PathForecastDailyDecay.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    *,\n    carrier: str = \"\",\n    minimum_sample: int = 10,\n    dcps: Collection[int] = (),\n)\n</code></pre>"}, {"location": "API/RM/forecasting.html#passengersim.rm.standard_forecasting.PathForecastDailyDecay.run", "title": "run", "text": "<pre><code>run(sim: Simulation, days_prior: int)\n</code></pre>"}, {"location": "API/RM/probp.html", "title": "Probabilistic Bid Price (ProBP) Actions", "text": ""}, {"location": "API/RM/probp.html#passengersim.rm.probp.ProbabilisticBidPrice", "title": "ProbabilisticBidPrice", "text": "<p>               Bases: <code>RmAction</code></p> <p>ProBP (ProbabilisticBidPrice) is a path-based optimization algorithm.</p>"}, {"location": "API/RM/probp.html#passengersim.rm.probp.ProbabilisticBidPrice.requires", "title": "requires  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>requires: set[str] = {'path_forecast'}\n</code></pre>"}, {"location": "API/RM/probp.html#passengersim.rm.probp.ProbabilisticBidPrice.frequency", "title": "frequency  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frequency = 'daily_pre_dep'\n</code></pre>"}, {"location": "API/RM/probp.html#passengersim.rm.probp.ProbabilisticBidPrice.cabins", "title": "cabins  <code>instance-attribute</code>", "text": "<pre><code>cabins = cabins\n</code></pre> <p>Optional list of cabin codes to optimize.</p> <p>If not provided, this tool will optimize on the leg as a whole.</p>"}, {"location": "API/RM/probp.html#passengersim.rm.probp.ProbabilisticBidPrice.capacity_sharing", "title": "capacity_sharing  <code>instance-attribute</code>", "text": "<pre><code>capacity_sharing = capacity_sharing\n</code></pre> <p>Capacity sharing flag between cabins.</p> <p>When set to True, will use method 3 from Peter Belobaba's presentation. Higher cabin(s) will get max of combined cabins or itself alone. Lower cabin(s) will get min of combined cabins or itself alone.</p>"}, {"location": "API/RM/probp.html#passengersim.rm.probp.ProbabilisticBidPrice.capacity_sharing_start_dcp_index", "title": "capacity_sharing_start_dcp_index  <code>instance-attribute</code>", "text": "<pre><code>capacity_sharing_start_dcp_index = (\n    capacity_sharing_start_dcp_index\n)\n</code></pre>"}, {"location": "API/RM/probp.html#passengersim.rm.probp.ProbabilisticBidPrice.use_adjusted_fares", "title": "use_adjusted_fares  <code>instance-attribute</code>", "text": "<pre><code>use_adjusted_fares = use_adjusted_fares\n</code></pre> <p>If True, ProBP will use the adjusted fares for the optimization.</p> <p>The default is False, which means that ProBP will use the original fares.  This should be set to True if fare adjustment is being used for this carrier.</p>"}, {"location": "API/RM/probp.html#passengersim.rm.probp.ProbabilisticBidPrice.bid_price_vector", "title": "bid_price_vector  <code>instance-attribute</code>", "text": "<pre><code>bid_price_vector = bid_price_vector\n</code></pre> <p>If True, we create a bid price vector in ProBP, rather than just keep a constant bid-price untiol daily re-optimization</p>"}, {"location": "API/RM/probp.html#passengersim.rm.probp.ProbabilisticBidPrice.maxiter", "title": "maxiter  <code>instance-attribute</code>", "text": "<pre><code>maxiter = maxiter\n</code></pre> <p>The maximum number of iterations to run ProBP.</p> <p>If the algorithm has not converged by the time this number of iterations has been reached, it will stop and return the current results.</p>"}, {"location": "API/RM/probp.html#passengersim.rm.probp.ProbabilisticBidPrice.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    *,\n    carrier: str = \"\",\n    cabins: str | list[str] | None = None,\n    minimum_sample: int = 10,\n    dcps: Collection[int] = (),\n    capacity_sharing: bool | None = False,\n    capacity_sharing_start_dcp_index: int | None = 0,\n    use_adjusted_fares: bool = False,\n    bid_price_vector: bool | None = False,\n    maxiter: int = 10,\n)\n</code></pre>"}, {"location": "API/RM/probp.html#passengersim.rm.probp.ProbabilisticBidPrice.run", "title": "run", "text": "<pre><code>run(sim: Simulation, days_prior: int)\n</code></pre>"}, {"location": "API/RM/std_systems.html", "title": "Standard RM Systems", "text": ""}, {"location": "API/RM/std_systems.html#passengersim.rm.standard_systems.E", "title": "E", "text": "<p>               Bases: <code>RmSys</code></p> <p>A standard RM system of type \"E\".</p> <p>This RM system uses leg-level seat allocation controls with EMSR-B optimization, along with EM untruncation and standard leg forecasting.</p> <p>Parameters:</p> <ul> <li> <code>emsr_variant</code>               (<code>(b, a)</code>, default:                   <code>'b'</code> )           \u2013            <p>Specifies which variant of the EMSR algorithm to use, either 'b' for EMSR-B, or 'a' for EMSR-A.  At this time only 'b' is supported.</p> </li> <li> <code>forecast_algorithm</code>               (<code>(additive_pickup, multiplicative_pickup)</code>, default:                   <code>'additive_pickup'</code> )           \u2013            <p>Specifies which leg-level forecasting algorithm to use for generating leg demand forecasts.  Options are 'additive_pickup' or 'multiplicative_pickup'.  The default is 'additive_pickup'.</p> </li> </ul> Notes <p>This RM system consists of the following actions executed in order:</p> <ol> <li> <p>EM Untruncation of Leg Demands     This step applies the EM algorithm to untruncate observed leg     sales into inferred true demand levels.  It runs only once at the     beginning of each sample day, and detruncates demand for all timeframes.</p> </li> <li> <p>Standard Leg Forecasting     This step generates leg-level demand forecasts using a standard     class-based forecasting algorithm (additive pickup by default). It     runs full computations to produce leg forecasts for the entire     booking horizon in one pass at the beginning of each sample day,     and on later DCPs it simply moves a pointer forward through that     array of forecasts to provide the correct forecast values at that     time.</p> </li> <li> <p>EMSR-B Optimization     Optimizes leg-level seat availability using the Expected Marginal     Seat Revenue Version B (EMSR-B) algorithm. This step runs on each     DCP to update the seat availability controls based on the current     leg forecasts, current sales, and the EMSR optimization logic.</p> </li> </ol>"}, {"location": "API/RM/std_systems.html#passengersim.rm.standard_systems.E.availability_control", "title": "availability_control  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>availability_control = 'leg'\n</code></pre> <p>This RM system uses leg-level class allocation availability controls.</p>"}, {"location": "API/RM/std_systems.html#passengersim.rm.standard_systems.P", "title": "P", "text": "<p>               Bases: <code>RmSys</code></p> <p>A standard RM system of type \"P\".</p> <p>This RM system uses path-level bid price controls with Pro-BP optimization, along with EM untruncation and standard leg forecasting.</p> <p>Parameters:</p> <ul> <li> <code>forecast_algorithm</code>               (<code>(additive_pickup, multiplicative_pickup)</code>, default:                   <code>'additive_pickup'</code> )           \u2013            <p>Specifies which leg-level forecasting algorithm to use for generating leg demand forecasts.  Options are 'additive_pickup' or 'multiplicative_pickup'.  The default is 'additive_pickup'.</p> </li> <li> <code>bid_price_vector</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, enables bid price vector optimization in ProBP.  If False, uses scalar bid prices.</p> </li> </ul> Notes <p>This RM system consists of the following actions executed in order:</p> <ol> <li> <p>EM Untruncation of Path Demands     This step applies the EM algorithm to untruncate observed path     sales into inferred true demand levels.  It runs only once at the     beginning of each sample day, and detruncates demand for all timeframes.</p> </li> <li> <p>Standard Path Forecasting     This step generates path-level demand forecasts using a standard     class-based forecasting algorithm (additive pickup by default). It     runs full computations to produce path forecasts for the entire     booking horizon in one pass at the beginning of each sample day,     and on later DCPs it simply moves a pointer forward through that     array of forecasts to provide the correct forecast values at that     time.</p> </li> <li> <p>Path Forecast Daily Decay Adjustment     This step applies a daily decay adjustment to the path-level forecasts,     to account for the changes in expected demand to come in between DCPs.     It runs every day that isn't a DCP, to adjust the path forecasts     accordingly.</p> </li> <li> <p>ProBP Optimization     Optimizes path-level bid prices using the Probabilistic Bid Price     (ProBP) algorithm. This step runs every day, to update the bid price     controls based on the current path forecasts, current sales, and the     ProBP optimization logic.</p> </li> </ol>"}, {"location": "API/RM/std_systems.html#passengersim.rm.standard_systems.P.availability_control", "title": "availability_control  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>availability_control = 'bp'\n</code></pre> <p>This RM system uses bid price availability controls.</p>"}, {"location": "API/RM/std_systems.html#passengersim.rm.standard_systems.U", "title": "U", "text": "<p>               Bases: <code>RmSys</code></p> <p>A standard RM system of type \"U\".</p> <p>This RM system uses path-level bid price controls with UDP optimization, along with EM untruncation and standard leg forecasting.</p> <p>Parameters:</p> <ul> <li> <code>forecast_algorithm</code>               (<code>(additive_pickup, multiplicative_pickup)</code>, default:                   <code>'additive_pickup'</code> )           \u2013            <p>Specifies which leg-level forecasting algorithm to use for generating leg demand forecasts.  Options are 'additive_pickup' or 'multiplicative_pickup'.  The default is 'additive_pickup'.</p> </li> <li> <code>arrivals_per_time_slice</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Specifies the expected number of customer arrivals per time slice used in the dynamic program optimization. This value affects the granularity of the discrete time approximation of the Poisson arrivals process; smaller values lead to finer granularity and a closer match to the theoretical continuous-time model, but increased computational time. Note that achieving a closer match to the continuous-time model may not always lead to better RM performance, as the actual customer arrival process may deviate from the Poisson assumption in practice (and in PassengerSim simulations). The default value is 1.0, which provides the fastest computational speed, while still capturing all forecast demand in the dynamic program.</p> </li> </ul> Notes <p>This RM system consists of the following actions executed in order:</p> <ol> <li> <p>EM Untruncation of Path Demands     This step applies the EM algorithm to untruncate observed path     sales into inferred true demand levels.  It runs only once at the     beginning of each sample day, and detruncates demand for all timeframes.</p> </li> <li> <p>Standard Path Forecasting     This step generates path-level demand forecasts using a standard     class-based forecasting algorithm (additive pickup by default). It     runs full computations to produce path forecasts for the entire     booking horizon in one pass at the beginning of each sample day,     and on later DCPs it simply moves a pointer forward through that     array of forecasts to provide the correct forecast values at that     time.</p> </li> <li> <p>UDP Optimization     Optimizes path-level bid prices using the Unbucketed Dynamic Program     (UDP) algorithm. This step re-solves the dynamic program with updated     displacement values based on actual sales and current forecasts only on     the DCPs; however, it still updates the bid prices every day, using daily     average bid price vectors taken from the most recent DP solution..</p> </li> </ol>"}, {"location": "API/RM/std_systems.html#passengersim.rm.standard_systems.U.availability_control", "title": "availability_control  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>availability_control = 'bp'\n</code></pre> <p>This RM system uses bid price availability controls.</p>"}, {"location": "API/RM/std_systems.html#passengersim.rm.standard_systems.M", "title": "M", "text": "<p>               Bases: <code>RmSys</code></p> <p>A standard RM system of type \"M\".</p> <p>This RM system uses path-level bid price controls with Pro-BP optimization, along with EM untruncation of yieldable demand and hybrid conditional path forecasting.</p> <p>Parameters:</p> <ul> <li> <code>forecast_algorithm</code>               (<code>(additive_pickup, multiplicative_pickup)</code>, default:                   <code>'additive_pickup'</code> )           \u2013            <p>Specifies which leg-level forecasting algorithm to use for generating leg demand forecasts.  Options are 'additive_pickup' or 'multiplicative_pickup'.  The default is 'additive_pickup'.</p> </li> <li> <code>bid_price_vector</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables bid price vector optimization in ProBP.  If False, uses scalar bid prices.  Default is False.</p> </li> <li> <code>fare_adjustment</code>               (<code>(mr, ki, None)</code>, default:                   <code>'mr'</code> )           \u2013            <p>Specifies the type of fare adjustment to apply in the conditional path forecasting algorithm. Options are 'mr' for marginal revenue adjustment, 'ki' for Karl Isler's method, or None for no fare adjustment.</p> </li> <li> <code>fare_adjustment_scale</code>               (<code>float</code>, default:                   <code>0.25</code> )           \u2013            <p>Specifies the scale factor to use for fare adjustment in the conditional path forecasting algorithm. This factor determines the magnitude of the fare adjustment applied to the forecasts. A value of 1.0 applies the full adjustment, while values less than 1.0 scale down the adjustment. In practice, values between 0.1 and 0.5 are commonly used to avoid being too aggressive, given the competitive environment.</p> </li> <li> <code>regression_weight</code>               (<code>(sellup, sellup ^ 2, fare, none, None)</code>, default:                   <code>'sellup'</code> )           \u2013            <p>Specifies the type of regression weight to use in the conditional path forecasting algorithm. Options are 'sellup' to weight by sellup factor, 'sellup^2' to weight by the square of the sellup factor, 'fare' to weight by fare amount, 'none' for no weighting.</p> </li> <li> <code>variance_rollup_algorithm</code>               (<code>(tf, dep)</code>, default:                   <code>'tf'</code> )           \u2013            <p>Specifies how to roll up variance when combining priceable and yieldable forecasts. Options are 'tf' to roll up variance by time frame, or 'dep' to roll up variance to departure.</p> </li> <li> <code>variance_is_ratio_of_mean</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Assume that the variance is this ratio of the mean. When this is set to a value greater than zero, the variance of the forecast is set to this fixed ratio of the mean.  Note that many algorithms for optimization use the forecast standard deviation, which is the square root of the variance, but it is the variance that is set to this ratio times the mean. When set to zero (the default), the variance is computed from mean squared error of the linear regression model used to compute the mean, and is not a fixed ratio of the mean.</p> </li> <li> <code>max_cap</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Maximum sellup weighting factor for the conditional forecast. If set to a value greater than zero, the weighting factor used in the conditional forecast is capped at this maximum value to prevent excessively high weights from extreme sellup factors.  The max cap will be more important when the regression weight is set to 'sellup^2', as this weighting can grow very large for extreme sellup factors.</p> </li> <li> <code>q_allocation_algorithm</code>               (<code>(tf, dep)</code>, default:                   <code>'tf'</code> )           \u2013            <p>Specifies how to allocate variance from aggregate Q forecasts to class-level forecasts. Options are 'tf' to allocate variance by time frame, or 'dep' to allocate variance to departure.</p> </li> </ul> Notes <p>This RM system consists of the following actions executed in order:</p> <ol> <li> <p>EM Untruncation of Leg Demands     This step applies the EM algorithm to untruncate observed path     sales into inferred true demand levels.  It runs only once at the     beginning of each sample day, and detruncates demand for all timeframes.</p> </li> <li> <p>Hybrid-Conditional Path Forecasting     This step generates path-level demand forecasts using a hybrid conditional     class-based forecasting algorithm (additive pickup by default). It     runs full computations to produce path forecasts for the entire     booking horizon in one pass at the beginning of each sample day,     and on later DCPs it simply moves a pointer forward through that     array of forecasts to provide the correct forecast values at that     time.</p> </li> <li> <p>Path Forecast Daily Decay Adjustment     This step applies a daily decay adjustment to the path-level forecasts,     to account for the changes in expected demand to come in between DCPs.     It runs every day that isn't a DCP, to adjust the path forecasts     accordingly.</p> </li> <li> <p>ProBP Optimization     Optimizes path-level bid prices using the Probabilistic Bid Price     (ProBP) algorithm. This step runs every day, to update the bid price     controls based on the current path forecasts, current sales, and the     ProBP optimization logic.</p> </li> </ol>"}, {"location": "API/RM/std_systems.html#passengersim.rm.standard_systems.M.availability_control", "title": "availability_control  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>availability_control = 'bp'\n</code></pre>"}, {"location": "API/RM/std_systems.html#passengersim.rm.standard_systems.V", "title": "V", "text": "<p>               Bases: <code>RmSys</code></p> <p>A standard RM system of type \"V\".</p> <p>This RM system uses path-level bid price controls with UDP optimization, along with EM untruncation and standard leg forecasting.</p> <p>Parameters:</p> <ul> <li> <code>forecast_algorithm</code>               (<code>(additive_pickup, multiplicative_pickup)</code>, default:                   <code>'additive_pickup'</code> )           \u2013            <p>Specifies which leg-level forecasting algorithm to use for generating leg demand forecasts.  Options are 'additive_pickup' or 'multiplicative_pickup'.  The default is 'additive_pickup'.</p> </li> <li> <code>arrivals_per_time_slice</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Specifies the expected number of customer arrivals per time slice used in the dynamic program optimization. This value affects the granularity of the discrete time approximation of the Poisson arrivals process; smaller values lead to finer granularity and a closer match to the theoretical continuous-time model, but increased computational time. Note that achieving a closer match to the continuous-time model may not always lead to better RM performance, as the actual customer arrival process may deviate from the Poisson assumption in practice (and in PassengerSim simulations). The default value is 1.0, which provides the fastest computational speed, while still capturing all forecast demand in the dynamic program.</p> </li> <li> <code>fare_adjustment</code>               (<code>(mr, ki, None)</code>, default:                   <code>'mr'</code> )           \u2013            <p>Specifies the type of fare adjustment to apply in the conditional path forecasting algorithm. Options are 'mr' for marginal revenue adjustment, 'ki' for Karl Isler's method, or None for no fare adjustment.</p> </li> <li> <code>fare_adjustment_scale</code>               (<code>float</code>, default:                   <code>0.25</code> )           \u2013            <p>Specifies the scale factor to use for fare adjustment in the conditional path forecasting algorithm. This factor determines the magnitude of the fare adjustment applied to the forecasts. A value of 1.0 applies the full adjustment, while values less than 1.0 scale down the adjustment. In practice, values between 0.1 and 0.5 are commonly used to avoid being too aggressive, given the competitive environment.</p> </li> <li> <code>regression_weight</code>               (<code>(sellup, sellup ^ 2, fare, none, None)</code>, default:                   <code>'sellup'</code> )           \u2013            <p>Specifies the type of regression weight to use in the conditional path forecasting algorithm. Options are 'sellup' to weight by sellup factor, 'sellup^2' to weight by the square of the sellup factor, 'fare' to weight by fare amount, 'none' for no weighting.</p> </li> <li> <code>variance_rollup_algorithm</code>               (<code>(tf, dep)</code>, default:                   <code>'tf'</code> )           \u2013            <p>Specifies how to roll up variance when combining priceable and yieldable forecasts. Options are 'tf' to roll up variance by time frame, or 'dep' to roll up variance to departure.</p> </li> <li> <code>variance_is_ratio_of_mean</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Assume that the variance is this ratio of the mean. When this is set to a value greater than zero, the variance of the forecast is set to this fixed ratio of the mean.  Note that many algorithms for optimization use the forecast standard deviation, which is the square root of the variance, but it is the variance that is set to this ratio times the mean. When set to zero (the default), the variance is computed from mean squared error of the linear regression model used to compute the mean, and is not a fixed ratio of the mean.</p> </li> <li> <code>max_cap</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Maximum sellup weighting factor for the conditional forecast. If set to a value greater than zero, the weighting factor used in the conditional forecast is capped at this maximum value to prevent excessively high weights from extreme sellup factors.  The max cap will be more important when the regression weight is set to 'sellup^2', as this weighting can grow very large for extreme sellup factors.</p> </li> <li> <code>q_allocation_algorithm</code>               (<code>(tf, dep)</code>, default:                   <code>'tf'</code> )           \u2013            <p>Specifies how to allocate variance from aggregate Q forecasts to class-level forecasts. Options are 'tf' to allocate variance by time frame, or 'dep' to allocate variance to departure.</p> </li> </ul> Notes <p>This RM system consists of the following actions executed in order:</p> <ol> <li> <p>EM Untruncation of Leg Demands     This step applies the EM algorithm to untruncate observed path     sales into inferred true demand levels.  It runs only once at the     beginning of each sample day, and detruncates demand for all timeframes.</p> </li> <li> <p>Hybrid-Conditional Path Forecasting     This step generates path-level demand forecasts using a hybrid conditional     class-based forecasting algorithm (additive pickup by default). It     runs full computations to produce path forecasts for the entire     booking horizon in one pass at the beginning of each sample day,     and on later DCPs it simply moves a pointer forward through that     array of forecasts to provide the correct forecast values at that     time.</p> </li> <li> <p>UDP Optimization     Optimizes path-level bid prices using the Unbucketed Dynamic Program     (UDP) algorithm. This step re-solves the dynamic program with updated     displacement values based on actual sales and current forecasts only on     the DCPs; however, it still updates the bid prices every day, using daily     average bid price vectors taken from the most recent DP solution..</p> </li> </ol>"}, {"location": "API/RM/std_systems.html#passengersim.rm.standard_systems.V.availability_control", "title": "availability_control  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>availability_control = 'bp'\n</code></pre>"}, {"location": "API/RM/untruncation.html", "title": "Untruncation Actions", "text": ""}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.LegUntruncation", "title": "LegUntruncation", "text": "<p>               Bases: <code>RmAction</code></p> <p>Leg-level demand untruncation action.</p> <p>This action will untruncate demand on legs using the specified algorithm. It is called only once at the beginning of each sample.</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.LegUntruncation.produces", "title": "produces  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>produces: set[str] = {'leg_demand'}\n</code></pre>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.LegUntruncation.frequency", "title": "frequency  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frequency = 'begin_sample'\n</code></pre>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.LegUntruncation.which_data", "title": "which_data  <code>instance-attribute</code>", "text": "<pre><code>which_data = which_data\n</code></pre> <p>Which data to use for untruncation.</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.LegUntruncation.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: Literal[\n    \"em\",\n    \"em_py\",\n    \"none\",\n    \"naive1\",\n    \"naive2\",\n    \"naive3\",\n    \"pd\",\n    \"mfem\",\n] = algorithm\n</code></pre> <p>Untruncation algorithm.</p> <p>There are several available algorithms:</p> <p><code>none</code>     applies no untruncation, and assumes that demand was the same as sales.     Applying this algorithm is still important even if no detruncation is     desired, as PassengerSim tracks historical demand separately from sales     and without \"none\" the historical demand used in forecasting would be     zero.</p> <p><code>em</code>     is an expectation-maximization model.</p> <p><code>em_py</code>     is an expectation-maximization model implemented in Python.  It is slow     but useful for educational purposes.</p> <p><code>naive1</code>     is not recommended for use.</p> <p><code>naive2</code>     is not recommended for use.</p> <p><code>naive3</code>     is not recommended for use.</p> <p><code>pd</code>     is a projection-detruncation model, based on the method developed by     Hopperstad and described by Weatherford &amp; Polt.</p> <p><code>mfem</code>     Multi-Flight Expectation Maximization.  Takes into account spill and recapture across multiple departures</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.LegUntruncation.maxiter", "title": "maxiter  <code>instance-attribute</code>", "text": "<pre><code>maxiter = maxiter\n</code></pre> <p>Maximum number of iterations for the EM and PD algorithms.</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.LegUntruncation.tolerance", "title": "tolerance  <code>instance-attribute</code>", "text": "<pre><code>tolerance = tolerance\n</code></pre> <p>Tolerance for the EM and PD algorithms.</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.LegUntruncation.initialization_method", "title": "initialization_method  <code>instance-attribute</code>", "text": "<pre><code>initialization_method: Literal[\"default\", \"pods\"] = (\n    initialization_method\n)\n</code></pre> <p>Method for initializing the EM algorithm.</p> <p>The default method is to use all available data on the first EM iteration.  The pods method is to use only the data from unclosed observations on the first EM iteration.</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.LegUntruncation.minimum_mu", "title": "minimum_mu  <code>instance-attribute</code>", "text": "<pre><code>minimum_mu = minimum_mu\n</code></pre> <p>Minimum value for the mean of the demand distribution.</p> <p>If the computed mean is less than this value, untruncation will result in zero demand. Setting this to a very small but non-zero value can help avoid thin-path problems, where untruncation results in some non-zero demand on every path-class, even though many path-classes have zero historical sales and probably will stay that way.</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.LegUntruncation.minimum_sigma", "title": "minimum_sigma  <code>instance-attribute</code>", "text": "<pre><code>minimum_sigma = minimum_sigma\n</code></pre> <p>Minimum value for the standard deviation of the demand distribution.</p> <p>If the computed sigma is less than this value, this value is used instead.</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.LegUntruncation.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    *,\n    carrier: str = \"\",\n    minimum_sample: int = 10,\n    dcps: Collection[int] = (),\n    algorithm: Literal[\n        \"em\",\n        \"em_py\",\n        \"none\",\n        \"naive1\",\n        \"naive2\",\n        \"naive3\",\n        \"pd\",\n        \"mfem\",\n    ] = \"em\",\n    which_data: Literal[\n        \"total\", \"yieldable\", \"priceable\"\n    ] = \"total\",\n    maxiter: int = 20,\n    tolerance: float = 0.01,\n    initialization_method: Literal[\n        \"default\", \"pods\"\n    ] = \"default\",\n    minimum_mu: float = 0.01,\n    minimum_sigma: float = 0.1,\n)\n</code></pre>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.LegUntruncation.run", "title": "run", "text": "<pre><code>run(sim: Simulation, days_prior: int)\n</code></pre>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.PathUntruncation", "title": "PathUntruncation", "text": "<p>               Bases: <code>RmAction</code></p> <p>Path-level demand untruncation tool.</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.PathUntruncation.produces", "title": "produces  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>produces: set[str] = {'path_demand'}\n</code></pre>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.PathUntruncation.frequency", "title": "frequency  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frequency = 'begin_sample'\n</code></pre>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.PathUntruncation.which_data", "title": "which_data  <code>instance-attribute</code>", "text": "<pre><code>which_data = which_data\n</code></pre> <p>Which data to use for untruncation.</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.PathUntruncation.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm = algorithm\n</code></pre> <p>Untruncation algorithm.</p> <p>There are several available algorithms:</p> <p><code>none</code>     applies no untruncation, and assumes that demand was the same as sales.     Applying this algorithm is still important even if no detruncation is     desired, as PassengerSim tracks historical demand separately from sales     and without \"none\" the historical demand used in forecasting would be     zero.</p> <p><code>em</code>     is an expectation-maximization model.</p> <p><code>em_py</code>     is an expectation-maximization model implemented in Python.  It is slow     but useful for educational purposes.</p> <p><code>naive1</code>     is not recommended for use.</p> <p><code>naive2</code>     is not recommended for use.</p> <p><code>naive3</code>     is not recommended for use.</p> <p><code>pd</code>     is a projection-detruncation model, based on the method developed by     Hopperstad and described by Weatherford &amp; Polt.</p> <p><code>mfem</code>     Multi-Flight Expectation Maximization.  Takes into account spill and recapture across multiple departures</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.PathUntruncation.maxiter", "title": "maxiter  <code>instance-attribute</code>", "text": "<pre><code>maxiter = maxiter\n</code></pre> <p>Maximum number of iterations for the EM and PD algorithms.</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.PathUntruncation.tolerance", "title": "tolerance  <code>instance-attribute</code>", "text": "<pre><code>tolerance = tolerance\n</code></pre> <p>Tolerance for the EM and PD algorithms.</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.PathUntruncation.initialization_method", "title": "initialization_method  <code>instance-attribute</code>", "text": "<pre><code>initialization_method = initialization_method\n</code></pre> <p>Method for initializing the EM algorithm.</p> <p>The default method is to use all available data on the first EM iteration.  The pods method is to use only the data from unclosed observations on the first EM iteration.</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.PathUntruncation.minimum_mu", "title": "minimum_mu  <code>instance-attribute</code>", "text": "<pre><code>minimum_mu = minimum_mu\n</code></pre> <p>Minimum value for the mean of the demand distribution.</p> <p>If the computed mean is less than this value, untruncation will result in zero demand. Setting this to a very small but non-zero value can help avoid thin-path problems, where untruncation results in some non-zero demand on every path-class, even though many path-classes have zero historical sales and probably will stay that way.</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.PathUntruncation.minimum_sigma", "title": "minimum_sigma  <code>instance-attribute</code>", "text": "<pre><code>minimum_sigma = minimum_sigma\n</code></pre> <p>Minimum value for the standard deviation of the demand distribution.</p> <p>If the computed sigma is less than this value, this value is used instead.</p>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.PathUntruncation.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    *,\n    carrier: str = \"\",\n    minimum_sample: int = 10,\n    dcps: Collection[int] = (),\n    algorithm: Literal[\n        \"em\",\n        \"em_py\",\n        \"none\",\n        \"naive1\",\n        \"naive2\",\n        \"naive3\",\n        \"pd\",\n        \"mfem\",\n    ] = \"em\",\n    which_data: Literal[\n        \"total\", \"yieldable\", \"priceable\"\n    ] = \"total\",\n    maxiter: int = 20,\n    tolerance: float = 0.01,\n    initialization_method: Literal[\n        \"default\", \"pods\"\n    ] = \"default\",\n    minimum_mu: float = 0.01,\n    minimum_sigma: float = 0.1,\n)\n</code></pre>"}, {"location": "API/RM/untruncation.html#passengersim.rm.untruncation.PathUntruncation.run", "title": "run", "text": "<pre><code>run(sim: Simulation, days_prior: int)\n</code></pre>"}, {"location": "API/config/00-configs.html", "title": "Config", "text": ""}, {"location": "API/config/00-configs.html#passengersim.config.base.Config", "title": "Config", "text": "<p>               Bases: <code>YamlConfig</code></p> Source code in <code>passengersim/config/base.py</code> <pre><code>class Config(YamlConfig, extra=\"forbid\"):\n    scenario: str = Field(default_factory=random_label)\n    \"\"\"Name for this scenario.\n\n    The scenario name is helpful when writing different simulations to the same\n    database so you can uniquely identify and query results for a particular\n    scenario.\"\"\"\n\n    simulation_controls: SimulationSettings = SimulationSettings()\n    \"\"\"\n    Controls that apply broadly to the overall simulation.\n\n    See [SimulationSettings][passengersim.config.SimulationSettings] for detailed\n    documentation.\n    \"\"\"\n\n    db: DatabaseConfig = DatabaseConfig()\n    \"\"\"\n    See [passengersim.config.DatabaseConfig][] for detailed documentation.\n    \"\"\"\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _db_is_none(cls, data: Any) -&gt; Any:\n        \"\"\"Setting the database to none creates a null database.\"\"\"\n        if isinstance(data, dict):\n            db = data.get(\"db\", None)\n            if db is None:\n                db = DatabaseConfig(filename=None, write_items=set())\n            data[\"db\"] = db\n        return data\n\n    @field_serializer(\"db\", mode=\"wrap\")\n    @classmethod\n    def _db_to_none(cls, v: DatabaseConfig | None, nxt: SerializerFunctionWrapHandler) -&gt; dict | None:\n        \"\"\"Serialize the database to None if it is a null database.\"\"\"\n        if v is None:\n            return None\n        if v.filename is None and not v.write_items:\n            return None\n        return nxt(v)\n\n    outputs: OutputConfig = OutputConfig()\n    \"\"\"\n    See [passengersim.config.OutputConfig][] for detailed documentation.\n    \"\"\"\n\n    rm_systems: DictOfNamed[RmSystem] = {}\n    \"\"\"\n    The revenue management systems used by the carriers in this simulation.\n\n    See [RM Systems][rm-systems] for details.\n    \"\"\"\n\n    blf_curves: DictOfNamed[BlfCurve] = {}\n    \"\"\" Booked Load Factor curves\"\"\"\n\n    frat5_curves: DictOfNamed[Frat5Curve] = {}\n    \"\"\" FRAT5 curves are used to model sellup rates in Q-forecasting\"\"\"\n\n    load_factor_curves: DictOfNamed[LoadFactorCurve] = {}\n    \"\"\" FRAT5 curves are used to model sellup rates in Q-forecasting\"\"\"\n\n    todd_curves: DictOfNamed[ToddCurve] = {}\n    \"\"\" Time of Day curves\"\"\"\n\n    choice_models: DictOfNamed[ChoiceModel] = {}\n    \"\"\"Several choice models are programmed behind the scenes.\n\n    The choice_models option allows the user to set the parameters used in the\n    utility model for a particular choice model. There are two choice models\n    currently programmed.\n    1. PODS-like\n    2. MNL, using the Lurkin et. al. paper (needs more testing and pdating)\n\n    Need to explaining more here\"\"\"\n\n    carriers: DictOfNamed[Carrier] = {}\n    \"\"\"A list of carriers.\n\n    One convention is to use Airline1, Airline2, ... to list the carriers in the\n    network.  Another convention is to use IATA industry-standard two-letter airline\n    codes.  See the\n    [IATA code search](https://www.iata.org/en/publications/directories/code-search/)\n    for more information.\"\"\"\n\n    places: DictOfNamed[Place] = {}\n    \"\"\"A list of places (airports, vertiports, other stations).\"\"\"\n\n    circuity_rules: ListOfNamed[CircuityRule] = []\n    \"\"\"Specifies exceptions and the default rule\"\"\"\n\n    classes: list[str] = []\n    \"\"\"A list of fare classes.\n\n    One convention is to use Y0, Y1, ... to label fare classes from the highest\n    fare (Y0) to the lowest fare (Yn).  You can also use Y, B, M, H,... etc.\n    An example of classes is below.\n\n    Example\n    -------\n    ```{yaml}\n    classes:\n      - Y0\n      - Y1\n      - Y2\n      - Y3\n      - Y4\n      - Y5\n    ```\n    \"\"\"\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _classes_are_for_carriers(cls, data: Any) -&gt; Any:\n        \"\"\"Any carrier that doesn't have its own classes gets the global ones.\"\"\"\n        if isinstance(data, dict):\n            carriers = data.get(\"carriers\", {})\n            if isinstance(carriers, list):\n                for carrier in carriers:\n                    if isinstance(carrier, dict) and \"classes\" not in carrier:\n                        carrier[\"classes\"] = data.get(\"classes\", [])\n            else:\n                for carrier in carriers.values():\n                    if isinstance(carrier, dict) and \"classes\" not in carrier:\n                        carrier[\"classes\"] = data.get(\"classes\", [])\n            data[\"carriers\"] = carriers\n        return data\n\n    dcps: list[int] = []\n    \"\"\"A list of DCPs (data collection points).\n\n    The DCPs are given as integers, which represent the number of days\n    before departure.   An example of data collection points is given below.\n    Note that typically as you get closer to day of departure (DCP=0) the number\n    of days between two consecutive DCP periods decreases.  The DCP intervals are\n    shorter because as you get closer to departure, customer arrival rates tend\n    to increase, and it is advantageous to forecast changes in demand for shorter\n    intervals.\n\n    Example\n    -------\n    ```{yaml}\n    dcps: [63, 56, 49, 42, 35, 31, 28, 24, 21, 17, 14, 10, 7, 5, 3, 1]\n    ```\n    \"\"\"\n\n    booking_curves: DictOfNamed[BookingCurve] = {}\n    \"\"\"Booking curves\n\n    The booking curve points typically line up with the DCPs.\n\n    Example\n    -------\n    ```{yaml}\n    booking_curves:\n      - name: c1\n        curve:\n          63: 0.06\n          56: 0.11\n          49: 0.15\n          42: 0.2\n          35: 0.23\n          31: 0.25\n          28: 0.28\n          24: 0.31\n          21: 0.35\n          17: 0.4\n          14: 0.5\n          10: 0.62\n          7: 0.7\n          5: 0.78\n          3: 0.95\n          1: 1.0\n    \"\"\"\n\n    legs: list[Leg] = []\n    demands: list[Demand] = []\n    fares: list[Fare] = []\n    paths: list[Path] = []\n    markets: list[Market] = []\n\n    @property\n    def markets_dict(self):\n        result = {}\n        for m in self.markets:\n            if isinstance(m, dict):\n                m = Market(**m)\n            ident = f\"{m.orig}~{m.dest}\"\n            if ident in result:\n                raise ValueError(f\"Duplicate market {ident}\")\n            result[ident] = m\n        return result\n\n    @model_validator(mode=\"after\")\n    def _fare_ap_restrictions_must_match_dcps(cls, m: Config):\n        \"\"\"AP restrictions on fare can only be invoked at the DCPs.\"\"\"\n        for f in m.fares:\n            if f.advance_purchase != 0 and f.advance_purchase not in m.dcps:\n                raise ValueError(f\"Advance purchase restriction not aligned with DCP for Fare {f}\")\n        return m\n\n    @field_validator(\"markets\")\n    @classmethod\n    def _no_duplicate_markets(cls, v: list[Market]) -&gt; list[Market]:\n        \"\"\"Check for duplicate markets.\"\"\"\n        seen = set()\n        for mkt in v:\n            ident = f\"{mkt.orig}~{mkt.dest}\"\n            if ident in seen:\n                raise ValueError(f\"Duplicate market {ident}\")\n            seen.add(ident)\n        return v\n\n    snapshot_filters: list[SnapshotFilter] = []\n\n    @field_validator(\"snapshot_filters\", mode=\"before\")\n    @classmethod\n    def _handle_no_snapshot_filters(cls, v):\n        if v is None:\n            v = []\n        return v\n\n    dwm_tolerance: list[dict] = []\n    \"\"\"Each item is a dictionary of {min_distance, max_distance, business, leisure}\n       The segments are named, so you can add more in the future, and they will be\n       matched agains the Demand segment name by the loader\"\"\"\n\n    raw_license_certificate: bytes | None | bool = None\n\n    @field_validator(\"raw_license_certificate\", mode=\"before\")\n    def _handle_license_certificate(cls, v):\n        if isinstance(v, str) and v.startswith(\"-----BEGIN CERTIFICATE-----\"):\n            v = v.encode(\"utf8\")\n        return v\n\n    @property\n    def license_certificate(self):\n        from cryptography.x509 import load_pem_x509_certificate\n\n        if isinstance(self.raw_license_certificate, bytes):\n            return load_pem_x509_certificate(self.raw_license_certificate)\n        elif self.raw_license_certificate is False:\n            return False\n        elif self.raw_license_certificate is None:\n            return None\n        raise ValueError(\"invalid license certificate\")\n\n    @model_validator(mode=\"after\")\n    def _burn_samples(cls, m: Config):\n        \"\"\"burn_samples must be strictly less than samples\"\"\"\n        if m.simulation_controls.burn_samples &gt;= m.simulation_controls.num_samples:\n            raise ValueError(\n                \"burn_samples must be strictly less than samples. It will default to 100 if you haven't set a value\"\n            )\n        if m.simulation_controls.burn_samples == 0 and m.simulation_controls.num_samples &gt; 10:\n            raise ValueError(\"to ensure meaningful results, burn_samples may not be zero when num_samples &gt; 10.\")\n        return m\n\n    @model_validator(mode=\"after\")\n    def _manual_paths(cls, m: Config):\n        \"\"\"If manual_paths is true, there must be Path items\n        if it's set to false, then there shouldn't be any path items\"\"\"\n        if m.simulation_controls.manual_paths and len(m.paths) == 0:\n            raise ValueError(\"manual_paths is set to true, but no paths found in the input config\")\n        if not m.simulation_controls.manual_paths and len(m.paths) &gt; 0:\n            raise ValueError(\"manual_paths is set to false, but paths were specified in the input config\")\n        return m\n\n    def _load_std_rm_system(self, std_name: str):\n        \"\"\"Load a standard RM system from the standard RM systems file.\n\n        Parameters\n        ----------\n        std_name : str\n            The name of the standard RM system to load.\n        \"\"\"\n        from .standards import standard_rm_systems_raw\n\n        raw_rm_systems = standard_rm_systems_raw()\n        if std_name in raw_rm_systems:\n            rm_sys = Config.model_validate({\"rm_systems\": {std_name: raw_rm_systems[std_name]}})\n            self.rm_systems[std_name] = rm_sys.rm_systems[std_name]\n        else:\n            raise KeyError(f\"Unknown standard RM system {std_name}\")\n\n    @classmethod\n    def _carriers_have_rm_systems(cls, m: Config):\n        \"\"\"Check that all carriers have RM systems that have been defined.\"\"\"\n        for carrier in m.carriers.values():\n            # an RM system name must be defined somewhere for each carrier\n            if not carrier.rm_system and not isinstance(carrier.rm_system_options, dict):\n                raise ValueError(f\"Carrier {carrier.name} has no RM system name defined\")\n            # that RM system must be stored in the config at `carrier.rm_system`\n            # if it's not but it's defined in carrier.rm_system_options, that fixable\n            if not carrier.rm_system:\n                carrier.rm_system = carrier.rm_system_options.pop(\"name\", None)\n            # if the name is defined in rm_system_options, it must match carrier.rm_system\n            if carrier.rm_system_options is not None and carrier.rm_system_options is not False:\n                if carrier.rm_system_options.get(\"name\", carrier.rm_system) != carrier.rm_system:\n                    raise ValueError(f\"rm_system {carrier.rm_system} does not match name in rm_system_options\")\n            # if the named system is supposed to be a callback-style RM system, check that it's registered\n            if carrier.rm_system_options:\n                # it's definitely supposed to be a callback-style RM system\n                if not check_registered_rm_system(carrier.rm_system):\n                    raise ValueError(f\"Carrier {carrier.name} has unregistered RM system {carrier.rm_system}\")\n            elif not check_registered_rm_system(carrier.rm_system) or carrier.rm_system_options is False:\n                # the named system is not a registered callback-style system, or the user has explicitly\n                # disabled callback-style RM systems for this carrier\n                # so it must be defined in rm_systems, or be an old-style standard RM system we can load\n                if carrier.rm_system not in m.rm_systems:\n                    try:\n                        m._load_std_rm_system(carrier.rm_system)\n                    except KeyError:\n                        raise ValueError(f\"Carrier {carrier.name} has unknown RM system {carrier.rm_system}\") from None\n        return m\n\n    def _load_std_frat5(self, std_name: str):\n        \"\"\"Load a standard Frat5 curve from the standard Frat5 file.\n\n        Parameters\n        ----------\n        std_name : str\n            The name of the standard Frat5 curve to load.\n        \"\"\"\n        from passengersim import demo_network\n\n        std_cfg = Config.from_yaml(demo_network(\"standard-frat5.yaml\"))\n        if std_name in std_cfg.frat5_curves:\n            self.frat5_curves[std_name] = std_cfg.frat5_curves[std_name]\n        else:\n            raise KeyError(f\"Unknown standard Frat5 curve {std_name}\")\n\n    @model_validator(mode=\"after\")\n    def _carriers_have_frat5(cls, m: Config):\n        \"\"\"Check that all carriers have defined or null Frat5 curves.\"\"\"\n        cls._carriers_have_rm_systems(m)\n        for carrier in m.carriers.values():\n            # first, if the carrier has no Frat5 curve, see if the RM system has one\n            if not carrier.frat5 and carrier.rm_system in m.rm_systems:\n                rm_system = m.rm_systems[carrier.rm_system]\n                if rm_system.frat5:\n                    carrier.frat5 = rm_system.frat5\n            if carrier.frat5 and carrier.frat5 not in m.frat5_curves:\n                try:\n                    m._load_std_frat5(carrier.frat5)\n                except KeyError:\n                    raise ValueError(f\"Carrier {carrier.name} has unknown Frat5 curve {carrier.frat5}\") from None\n        return m\n\n    @model_validator(mode=\"after\")\n    def _legs_have_carriers(cls, m: Config):\n        \"\"\"Check that all legs have a carrier that has been defined.\"\"\"\n        for leg in m.legs:\n            if leg.carrier not in m.carriers:\n                raise ValueError(f\"Carrier for leg {leg.carrier} {leg.fltno} is not defined\")\n        return m\n\n    @model_validator(mode=\"after\")\n    def _choice_model_todd_curves_exist(cls, m: Config):\n        \"\"\"Check that any TODD curves referenced in Demand objects have been defined.\"\"\"\n        for name, cm in m.choice_models.items():\n            if cm.todd_curve is not None and cm.todd_curve not in m.todd_curves:\n                raise ValueError(f\"ChoiceModel {name} has unknown TOD Curve {cm.todd_curve}\")\n        return m\n\n    @model_validator(mode=\"after\")\n    def _choice_model_airline_preferences(cls, m: Config):\n        \"\"\"Check that only one way of inputting airline preference was specified.\"\"\"\n        for _name, cm in m.choice_models.items():\n            a1 = 1 if cm.airline_pref_pods is not None else 0\n            a2 = 1 if cm.airline_pref_hhi is not None else 0\n            a3 = 1 if cm.airline_pref_seat_share is not None else 0\n            if a1 + a2 + a3 &gt; 1:\n                raise ValueError(f\"ChoiceModel '{cm.name}' has more than one airline preference model specified\")\n        return m\n\n    @model_validator(mode=\"after\")\n    def _choice_model_curve_s_vs_replanning(cls, m: Config):\n        \"\"\"Check that only one way of inputting airline preference was specified.\"\"\"\n        for _name, cm in m.choice_models.items():\n            if cm.replanning is not None and (cm.early_dep is not None or cm.late_arr is not None):\n                raise ValueError(\n                    f\"ChoiceModel '{cm.name}' has replanning and early_dep / late_arr \"\n                    f\"specified, pick one or the other but not both !!!\"\n                )\n        return m\n\n    @model_validator(mode=\"after\")\n    def _choice_set_sampling(cls, m: Config):\n        \"\"\"Ensure there is a limit on the number of observations in a choice set.\n        Don't allow a choice set to be created without a specified limit of observations\n        as unlimited sampling will run out of storage very quickly\"\"\"\n        if (\n            len(m.simulation_controls.capture_choice_set_file) &gt; 0\n            and m.simulation_controls.capture_choice_set_obs is None\n        ):\n            m.simulation_controls.capture_choice_set_obs = 10000\n            warnings.warn(\n                \"capture_choice_set_obs not specified, has been set to 10000\",\n                stacklevel=2,\n            )\n        return m\n\n    @model_validator(mode=\"after\")\n    def _demand_todd_curves_exist(cls, m: Config):\n        \"\"\"Check that any TODD curves referenced in Demand objects have been defined.\"\"\"\n        for dmd in m.demands:\n            if dmd.todd_curve is not None and dmd.todd_curve not in m.todd_curves:\n                raise ValueError(f\"Demand {dmd.orig}-{dmd.dest}:{dmd.segment} has unknown TOD Curve {dmd.todd_curve}\")\n        return m\n\n    @model_validator(mode=\"after\")\n    def _booking_curves_match_dcps(cls, m: Config):\n        \"\"\"Check that all booking curves are complete and valid.\"\"\"\n        sorted_dcps = reversed(sorted(m.dcps))\n        for curve in m.booking_curves.values():\n            i = 0\n            for dcp in sorted_dcps:\n                assert dcp in curve.curve, f\"booking curve {curve.name} is missing dcp {dcp}\"\n                assert curve.curve[dcp] &gt;= i, f\"booking curve {curve.name} moves backwards at dcp {dcp}\"\n                i = curve.curve[dcp]\n        return m\n\n    @model_validator(mode=\"after\")\n    def _requested_summaries_have_data(cls, m: Config):\n        \"\"\"Check that requested summary outputs will have the data needed.\"\"\"\n        if \"local_and_flow_yields\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"pathclass_final\", \"pathclass\"}:\n                raise ValueError(\n                    \"the `local_and_flow_yields` report requires recording \"\n                    \"at least `pathclass_final` details in the database\"\n                )\n        if \"bid_price_history\" in m.outputs.reports:\n            if \"leg\" not in m.db.write_items:\n                raise ValueError(\"the `bid_price_history` report requires recording `leg` details in the database\")\n            if not m.db.store_leg_bid_prices:\n                raise ValueError(\"the `bid_price_history` report requires recording `store_leg_bid_prices` to be True\")\n        if \"demand_to_come\" in m.outputs.reports:\n            if \"demand\" not in m.db.write_items:\n                raise ValueError(\"the `demand_to_come` report requires recording `demand` details in the database\")\n        if \"demand_to_come_summary\" in m.outputs.reports:\n            if \"demand\" not in m.db.write_items:\n                raise ValueError(\n                    \"the `demand_to_come_summary` report requires recording `demand` details in the database\"\n                )\n        if \"path_forecasts\" in m.outputs.reports:\n            if \"pathclass\" not in m.db.write_items:\n                raise ValueError(\"the `path_forecasts` report requires recording `pathclass` details in the database\")\n        if \"leg_forecasts\" in m.outputs.reports:\n            if \"bucket\" not in m.db.write_items:\n                raise ValueError(\"the `leg_forecasts` report requires recording `bucket` details in the database\")\n        if \"bookings_by_timeframe\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"bookings\", \"fare\"}:\n                raise ValueError(\n                    \"the `bookings_by_timeframe` report requires recording `fare` or `bookings` details in the database\"\n                )\n        if \"total_demand\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"demand\", \"demand_final\"}:\n                raise ValueError(\n                    \"the `total_demand` report requires recording at least `demand_final` details in the database\"\n                )\n        if \"fare_class_mix\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"fare\", \"fare_final\"}:\n                raise ValueError(\n                    \"the `fare_class_mix` report requires recording at least `fare_final` details in the database\"\n                )\n        if \"load_factor_distribution\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"leg\", \"leg_final\"}:\n                raise ValueError(\n                    \"the `load_factor_distribution` report requires recording \"\n                    \"at least `leg_final` details in the database\"\n                )\n        if \"edgar\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"edgar\"}:\n                raise ValueError(\n                    \"the 'edgar' forecast accuray report requires recording 'edgar' details in the database\"\n                )\n        return m\n\n    @model_validator(mode=\"after\")\n    def _bp_controls_are_expected_but_not_set(cls, m: Config):\n        \"\"\"Warn if bid price controls are expected but not set.\"\"\"\n        for rm_system in m.rm_systems.values():\n            if \"dcp\" in rm_system.processes:\n                for step in rm_system.processes[\"dcp\"]:\n                    if isinstance(step, RmStepBase):\n                        try:\n                            req = step.require_availability_control\n                        except AttributeError:\n                            req = None\n                        if req is not None and rm_system.availability_control not in req:\n                            raise ValueError(\n                                f\"RM System {rm_system.name} requires availability control {req} for step {step.name}\"\n                            )\n        return m\n\n    __rm_steps_loaded: ClassVar[set[type[RmStepBase]]] = RmStepBase._get_subclasses()\n\n    @classmethod\n    def model_validate(\n        cls,\n        *args,\n        **kwargs,\n    ) -&gt; typing.Any:\n        \"\"\"Validate the passengersim Config inputs.\n\n        This method reloads the Config class to ensure all imported\n        RmSteps are properly registered before validation.\n\n        Parameters\n        ----------\n        obj\n            The object to validate.\n        strict : bool\n            Whether to raise an exception on invalid fields.\n        from_attributes\n            Whether to extract data from object attributes.\n        context\n            Additional context to pass to the validator.\n\n        Raises\n        ------\n        ValidationError\n            If the object could not be validated.\n\n        Returns\n        -------\n        Config\n            The validated model instance.\n        \"\"\"\n        # detect if there are any new RmSteps and reload the Config class\n        # to ensure they are properly registered\n        reloaded_class = cls\n        for k in RmStepBase._get_subclasses():\n            if k not in cls.__rm_steps_loaded:\n                # reload these to refresh for any newly defined RmSteps\n                module_parent = \".\".join(__name__.split(\".\")[:-1])\n                importlib.reload(sys.modules.get(f\"{module_parent}.rm_systems\"))\n                importlib.reload(sys.modules.get(__name__))\n                module = importlib.reload(sys.modules.get(module_parent))\n                reloaded_class = getattr(module, cls.__name__)\n        # `__tracebackhide__` tells pytest and some other tools to omit this\n        # function from tracebacks\n        __tracebackhide__ = True\n        with warnings.catch_warnings(record=True) as wz:\n            warnings.simplefilter(\"always\")  # Ensure all warnings are captured\n            result = reloaded_class.__pydantic_validator__.validate_python(*args, **kwargs)\n        for w in wz:\n            warnings.warn(w.message, category=w.category, stacklevel=2)\n        return result\n\n    def model_revalidate(\n        self,\n    ) -&gt; typing.Self:\n        \"\"\"Revalidate the passengersim Config instance.\"\"\"\n        return self.as_reloaded.model_validate(self.model_dump(serialize_as_any=True))\n\n    @classmethod\n    @property\n    def as_reloaded(cls) -&gt; type[Config]:\n        \"\"\"Get the Config class, as most recently reloaded.\"\"\"\n        module_parent = \".\".join(__name__.split(\".\")[:-1])\n        module = sys.modules.get(module_parent)\n        reloaded_class = getattr(module, cls.__name__)\n        return reloaded_class\n\n    @classmethod\n    def instance_check(cls, obj) -&gt; bool:\n        \"\"\"Check if an object is an instance of the Config class.\"\"\"\n        # module_parent = \".\".join(__name__.split(\".\")[:-1])\n        # module = sys.modules.get(module_parent)\n        # reloaded_class = getattr(module, cls.__name__)\n        return isinstance(obj, cls.as_reloaded)\n\n    def find_differences(\n        self,\n        other: Config,\n        *,\n        include: IncEx = None,\n        exclude: IncEx = None,\n    ) -&gt; dict:\n        \"\"\"Find the differences between two Config objects.\"\"\"\n        if exclude is None:\n            exclude = {\n                \"raw_license_certificate\": True,\n                \"outputs\": {\"pickle\", \"excel\", \"html\", \"log_reports\"},\n            }\n        return find_differences(\n            self.model_dump(include=include, exclude=exclude),\n            other.model_dump(include=include, exclude=exclude),\n        )\n\n    def add_output_prefix(self, prefix: pathlib.Path, spool_format: str = \"%Y%m%d-%H%M\"):\n        \"\"\"\n        Add a prefix directory to all simulation output files.\n        \"\"\"\n        if not isinstance(prefix, pathlib.Path):\n            prefix = pathlib.Path(prefix)\n        if spool_format:\n            proposal = prefix.joinpath(time.strftime(spool_format))\n            n = 0\n            while proposal.exists():\n                n += 1\n                proposal = prefix.joinpath(time.strftime(spool_format) + f\".{n}\")\n            prefix = proposal\n        prefix.mkdir(parents=True)\n\n        if self.db.filename:\n            self.db.filename = prefix.joinpath(self.db.filename)\n        if self.outputs.excel:\n            self.outputs.excel = prefix.joinpath(self.outputs.excel)\n        for sf in self.snapshot_filters:\n            if sf.directory:\n                sf.directory = prefix.joinpath(sf.directory)\n        return prefix\n\n    @model_validator(mode=\"after\")\n    def _attach_distance_to_things_without_it(self):\n        \"\"\"Attach distance in nautical miles to legs that are missing distance.\"\"\"\n        for leg in self.legs:\n            if leg.distance is None:\n                place_o = self.places.get(leg.orig, None)\n                place_d = self.places.get(leg.dest, None)\n                if place_o is not None and place_d is not None:\n                    leg.distance = great_circle(place_o, place_d)\n                if place_o is None:\n                    warnings.warn(f\"No defined place for {leg.orig}\", stacklevel=2)\n                if place_d is None:\n                    warnings.warn(f\"No defined place for {leg.dest}\", stacklevel=2)\n        for dmd in self.demands:\n            if not dmd.distance:\n                place_o = self.places.get(dmd.orig, None)\n                place_d = self.places.get(dmd.dest, None)\n                if place_o is not None and place_d is not None:\n                    dmd.distance = great_circle(place_o, place_d)\n                if place_o is None:\n                    warnings.warn(f\"No defined place for {dmd.orig}\", stacklevel=2)\n                if place_d is None:\n                    warnings.warn(f\"No defined place for {dmd.dest}\", stacklevel=2)\n        return self\n\n    @model_validator(mode=\"after\")\n    def _adjust_times_for_time_zones(self):\n        \"\"\"Adjust arrival/departure times to local time from UTC.\"\"\"\n        for leg in self.legs:\n            # the nominal time is local time but so far got stored as UTC,\n            # so we need to add the time zone offset to be actually local time\n\n            def adjust_time_zone(t, place):\n                if place is not None:\n                    tz = place.time_zone_info\n                    if tz is not None:\n                        # Alan's approach\n                        # It was converted as a local time, so unpack it and\n                        #   create a new datetime in the given TZ\n                        dt = datetime.fromtimestamp(t, tz=UTC)\n                        dt2 = datetime(\n                            dt.year,\n                            dt.month,\n                            dt.day,\n                            dt.hour,\n                            dt.minute,\n                            0,\n                            0,\n                            tzinfo=tz,\n                        )\n                        new_ts = int(dt2.timestamp())\n                        return new_ts, t - new_ts\n                return t, 0\n\n            if not leg.time_adjusted:\n                place_o = self.places.get(leg.orig, None)\n                leg.dep_time, leg.dep_time_offset = adjust_time_zone(leg.dep_time, place_o)\n                leg.orig_timezone = str(place_o.time_zone_info) if place_o else None\n                place_d = self.places.get(leg.dest, None)\n                leg.arr_time, leg.arr_time_offset = adjust_time_zone(leg.arr_time, place_d)\n                leg.dest_timezone = str(place_d.time_zone_info) if place_d else None\n                if place_o is None:\n                    warnings.warn(f\"No defined place for {leg.orig}\", stacklevel=2)\n                if place_d is None:\n                    warnings.warn(f\"No defined place for {leg.dest}\", stacklevel=2)\n                leg.time_adjusted = True\n        return self\n\n    @model_validator(mode=\"after\")\n    def _places_exist_for_circuity(cls, cfg: Config):\n        \"\"\"Circuity rules can only refer to airports in the places data.\n        The core code will not crash if the places are missing, but the rules\n        may not work as expected and that'll be a PITA to debug !!!\"\"\"\n        for rule in cfg.circuity_rules:\n            if rule.carrier != \"\" and rule.carrier is not None and rule.carrier not in cfg.carriers:\n                raise ValueError(f\"Circuity rule '{rule.name}' refers to a carrier that isn't specified in carriers\")\n            if rule.orig_airport != \"\" and rule.orig_airport is not None and rule.orig_airport not in cfg.places:\n                raise ValueError(\n                    f\"Circuity rule '{rule.name}' refers to an orig airport that isn't specified in places\"\n                )\n            if (\n                rule.connect_airport != \"\"\n                and rule.connect_airport is not None\n                and rule.connect_airport not in cfg.places\n            ):\n                raise ValueError(\n                    f\"Circuity rule '{rule.name}' refers to a connecting airport that isn't specified in places\"\n                )\n            if rule.dest_airport != \"\" and rule.dest_airport is not None and rule.dest_airport not in cfg.places:\n                raise ValueError(f\"Circuity rule '{rule.name}' refers to a dest airport that isn't specified in places\")\n\n            # Now we check state codes\n        return cfg\n\n    def __repr__(self):\n        indent = 2\n        x = []\n        i = \" \" * indent\n        for k, v in self:\n            if k in {\"legs\", \"paths\", \"fares\", \"demands\"}:\n                val = f\"&lt;list of {len(v)} {k}&gt;\"\n            elif k in {\"booking_curves\"}:\n                val = f\"&lt;dict of {len(v)} {k}&gt;\"\n            elif isinstance(v, dict):\n                val = repr_dict_with_indent(v, indent)\n            else:\n                try:\n                    val = v.__repr_with_indent__(indent)\n                except AttributeError:\n                    val = repr(v)\n            if \"\\n\" in val:\n                val_lines = val.split(\"\\n\")\n                val = \"\\n  \" + \"\\n  \".join(val_lines)\n            x.append(f\"{i}{k}: {val}\")\n        return \"passengersim.Config:\\n\" + \"\\n\".join(x)\n\n    def __getstate__(self):\n        state = super().__getstate__()\n        # do not save a user's license certificate into the state\n        if \"raw_license_certificate\" in state:\n            state[\"raw_license_certificate\"] = None\n        if \"__dict__\" in state:\n            if \"raw_license_certificate\" in state[\"__dict__\"]:\n                state[\"__dict__\"][\"raw_license_certificate\"] = None\n        return state\n\n    def __getattr__(self, name):\n        \"\"\"Allow accessing figure methods.\"\"\"\n        try:\n            return super().__getattr__(name)\n        except AttributeError:\n            if name.startswith(\"fig_\"):\n                import passengersim.config._figures\n\n                if name in passengersim.config._figures.__all__:\n                    func = getattr(passengersim.config._figures, name)\n\n                    def wrapper(*args, **kwargs):\n                        return func(self, *args, **kwargs)\n\n                    return wrapper\n            # otherwise, re-raise\n            raise\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.__rm_steps_loaded", "title": "__rm_steps_loaded  <code>class-attribute</code>", "text": "<pre><code>__rm_steps_loaded: set[type[RmStepBase]] = _get_subclasses()\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.as_reloaded", "title": "as_reloaded  <code>classmethod</code> <code>property</code>", "text": "<pre><code>as_reloaded: type[Config]\n</code></pre> <p>Get the Config class, as most recently reloaded.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.blf_curves", "title": "blf_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>blf_curves: DictOfNamed[BlfCurve] = {}\n</code></pre> <p>Booked Load Factor curves</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.booking_curves", "title": "booking_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>booking_curves: DictOfNamed[BookingCurve] = {}\n</code></pre> <p>Booking curves</p> <p>The booking curve points typically line up with the DCPs.</p> Example <p>```{yaml} booking_curves:   - name: c1     curve:       63: 0.06       56: 0.11       49: 0.15       42: 0.2       35: 0.23       31: 0.25       28: 0.28       24: 0.31       21: 0.35       17: 0.4       14: 0.5       10: 0.62       7: 0.7       5: 0.78       3: 0.95       1: 1.0</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.carriers", "title": "carriers  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carriers: DictOfNamed[Carrier] = {}\n</code></pre> <p>A list of carriers.</p> <p>One convention is to use Airline1, Airline2, ... to list the carriers in the network.  Another convention is to use IATA industry-standard two-letter airline codes.  See the IATA code search for more information.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.choice_models", "title": "choice_models  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>choice_models: DictOfNamed[ChoiceModel] = {}\n</code></pre> <p>Several choice models are programmed behind the scenes.</p> <p>The choice_models option allows the user to set the parameters used in the utility model for a particular choice model. There are two choice models currently programmed. 1. PODS-like 2. MNL, using the Lurkin et. al. paper (needs more testing and pdating)</p> <p>Need to explaining more here</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.circuity_rules", "title": "circuity_rules  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>circuity_rules: ListOfNamed[CircuityRule] = []\n</code></pre> <p>Specifies exceptions and the default rule</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.classes", "title": "classes  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>classes: list[str] = []\n</code></pre> <p>A list of fare classes.</p> <p>One convention is to use Y0, Y1, ... to label fare classes from the highest fare (Y0) to the lowest fare (Yn).  You can also use Y, B, M, H,... etc. An example of classes is below.</p> Example <pre><code>classes:\n  - Y0\n  - Y1\n  - Y2\n  - Y3\n  - Y4\n  - Y5\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.db", "title": "db  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>db: DatabaseConfig = DatabaseConfig()\n</code></pre> <p>See passengersim.config.DatabaseConfig for detailed documentation.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.dcps", "title": "dcps  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcps: list[int] = []\n</code></pre> <p>A list of DCPs (data collection points).</p> <p>The DCPs are given as integers, which represent the number of days before departure.   An example of data collection points is given below. Note that typically as you get closer to day of departure (DCP=0) the number of days between two consecutive DCP periods decreases.  The DCP intervals are shorter because as you get closer to departure, customer arrival rates tend to increase, and it is advantageous to forecast changes in demand for shorter intervals.</p> Example <pre><code>dcps: [63, 56, 49, 42, 35, 31, 28, 24, 21, 17, 14, 10, 7, 5, 3, 1]\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.demands", "title": "demands  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>demands: list[Demand] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.dwm_tolerance", "title": "dwm_tolerance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dwm_tolerance: list[dict] = []\n</code></pre> <p>Each item is a dictionary of {min_distance, max_distance, business, leisure} The segments are named, so you can add more in the future, and they will be matched agains the Demand segment name by the loader</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.fares", "title": "fares  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>fares: list[Fare] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.frat5_curves", "title": "frat5_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frat5_curves: DictOfNamed[Frat5Curve] = {}\n</code></pre> <p>FRAT5 curves are used to model sellup rates in Q-forecasting</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.legs", "title": "legs  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>legs: list[Leg] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.license_certificate", "title": "license_certificate  <code>property</code>", "text": "<pre><code>license_certificate\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.load_factor_curves", "title": "load_factor_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>load_factor_curves: DictOfNamed[LoadFactorCurve] = {}\n</code></pre> <p>FRAT5 curves are used to model sellup rates in Q-forecasting</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.markets", "title": "markets  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>markets: list[Market] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.markets_dict", "title": "markets_dict  <code>property</code>", "text": "<pre><code>markets_dict\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.outputs", "title": "outputs  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>outputs: OutputConfig = OutputConfig()\n</code></pre> <p>See [passengersim.config.OutputConfig][] for detailed documentation.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.paths", "title": "paths  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>paths: list[Path] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.places", "title": "places  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>places: DictOfNamed[Place] = {}\n</code></pre> <p>A list of places (airports, vertiports, other stations).</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.raw_license_certificate", "title": "raw_license_certificate  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>raw_license_certificate: bytes | None | bool = None\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.rm_systems", "title": "rm_systems  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>rm_systems: DictOfNamed[RmSystem] = {}\n</code></pre> <p>The revenue management systems used by the carriers in this simulation.</p> <p>See RM Systems for details.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.scenario", "title": "scenario  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>scenario: str = Field(default_factory=random_label)\n</code></pre> <p>Name for this scenario.</p> <p>The scenario name is helpful when writing different simulations to the same database so you can uniquely identify and query results for a particular scenario.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.simulation_controls", "title": "simulation_controls  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>simulation_controls: SimulationSettings = (\n    SimulationSettings()\n)\n</code></pre> <p>Controls that apply broadly to the overall simulation.</p> <p>See SimulationSettings for detailed documentation.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[SnapshotFilter] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.todd_curves", "title": "todd_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>todd_curves: DictOfNamed[ToddCurve] = {}\n</code></pre> <p>Time of Day curves</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.__getattr__", "title": "__getattr__", "text": "<pre><code>__getattr__(name)\n</code></pre> <p>Allow accessing figure methods.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>def __getattr__(self, name):\n    \"\"\"Allow accessing figure methods.\"\"\"\n    try:\n        return super().__getattr__(name)\n    except AttributeError:\n        if name.startswith(\"fig_\"):\n            import passengersim.config._figures\n\n            if name in passengersim.config._figures.__all__:\n                func = getattr(passengersim.config._figures, name)\n\n                def wrapper(*args, **kwargs):\n                    return func(self, *args, **kwargs)\n\n                return wrapper\n        # otherwise, re-raise\n        raise\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.__getstate__", "title": "__getstate__", "text": "<pre><code>__getstate__()\n</code></pre> Source code in <code>passengersim/config/base.py</code> <pre><code>def __getstate__(self):\n    state = super().__getstate__()\n    # do not save a user's license certificate into the state\n    if \"raw_license_certificate\" in state:\n        state[\"raw_license_certificate\"] = None\n    if \"__dict__\" in state:\n        if \"raw_license_certificate\" in state[\"__dict__\"]:\n            state[\"__dict__\"][\"raw_license_certificate\"] = None\n    return state\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.__repr__", "title": "__repr__", "text": "<pre><code>__repr__()\n</code></pre> Source code in <code>passengersim/config/base.py</code> <pre><code>def __repr__(self):\n    indent = 2\n    x = []\n    i = \" \" * indent\n    for k, v in self:\n        if k in {\"legs\", \"paths\", \"fares\", \"demands\"}:\n            val = f\"&lt;list of {len(v)} {k}&gt;\"\n        elif k in {\"booking_curves\"}:\n            val = f\"&lt;dict of {len(v)} {k}&gt;\"\n        elif isinstance(v, dict):\n            val = repr_dict_with_indent(v, indent)\n        else:\n            try:\n                val = v.__repr_with_indent__(indent)\n            except AttributeError:\n                val = repr(v)\n        if \"\\n\" in val:\n            val_lines = val.split(\"\\n\")\n            val = \"\\n  \" + \"\\n  \".join(val_lines)\n        x.append(f\"{i}{k}: {val}\")\n    return \"passengersim.Config:\\n\" + \"\\n\".join(x)\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.add_output_prefix", "title": "add_output_prefix", "text": "<pre><code>add_output_prefix(\n    prefix: Path, spool_format: str = \"%Y%m%d-%H%M\"\n)\n</code></pre> <p>Add a prefix directory to all simulation output files.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>def add_output_prefix(self, prefix: pathlib.Path, spool_format: str = \"%Y%m%d-%H%M\"):\n    \"\"\"\n    Add a prefix directory to all simulation output files.\n    \"\"\"\n    if not isinstance(prefix, pathlib.Path):\n        prefix = pathlib.Path(prefix)\n    if spool_format:\n        proposal = prefix.joinpath(time.strftime(spool_format))\n        n = 0\n        while proposal.exists():\n            n += 1\n            proposal = prefix.joinpath(time.strftime(spool_format) + f\".{n}\")\n        prefix = proposal\n    prefix.mkdir(parents=True)\n\n    if self.db.filename:\n        self.db.filename = prefix.joinpath(self.db.filename)\n    if self.outputs.excel:\n        self.outputs.excel = prefix.joinpath(self.outputs.excel)\n    for sf in self.snapshot_filters:\n        if sf.directory:\n            sf.directory = prefix.joinpath(sf.directory)\n    return prefix\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.find_differences", "title": "find_differences", "text": "<pre><code>find_differences(\n    other: Config,\n    *,\n    include: IncEx = None,\n    exclude: IncEx = None,\n) -&gt; dict\n</code></pre> <p>Find the differences between two Config objects.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>def find_differences(\n    self,\n    other: Config,\n    *,\n    include: IncEx = None,\n    exclude: IncEx = None,\n) -&gt; dict:\n    \"\"\"Find the differences between two Config objects.\"\"\"\n    if exclude is None:\n        exclude = {\n            \"raw_license_certificate\": True,\n            \"outputs\": {\"pickle\", \"excel\", \"html\", \"log_reports\"},\n        }\n    return find_differences(\n        self.model_dump(include=include, exclude=exclude),\n        other.model_dump(include=include, exclude=exclude),\n    )\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.instance_check", "title": "instance_check  <code>classmethod</code>", "text": "<pre><code>instance_check(obj) -&gt; bool\n</code></pre> <p>Check if an object is an instance of the Config class.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>@classmethod\ndef instance_check(cls, obj) -&gt; bool:\n    \"\"\"Check if an object is an instance of the Config class.\"\"\"\n    # module_parent = \".\".join(__name__.split(\".\")[:-1])\n    # module = sys.modules.get(module_parent)\n    # reloaded_class = getattr(module, cls.__name__)\n    return isinstance(obj, cls.as_reloaded)\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.model_revalidate", "title": "model_revalidate", "text": "<pre><code>model_revalidate() -&gt; Self\n</code></pre> <p>Revalidate the passengersim Config instance.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>def model_revalidate(\n    self,\n) -&gt; typing.Self:\n    \"\"\"Revalidate the passengersim Config instance.\"\"\"\n    return self.as_reloaded.model_validate(self.model_dump(serialize_as_any=True))\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.model_validate", "title": "model_validate  <code>classmethod</code>", "text": "<pre><code>model_validate(*args, **kwargs) -&gt; Any\n</code></pre> <p>Validate the passengersim Config inputs.</p> <p>This method reloads the Config class to ensure all imported RmSteps are properly registered before validation.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>           \u2013            <p>The object to validate.</p> </li> <li> <code>strict</code>               (<code>bool</code>)           \u2013            <p>Whether to raise an exception on invalid fields.</p> </li> <li> <code>from_attributes</code>           \u2013            <p>Whether to extract data from object attributes.</p> </li> <li> <code>context</code>           \u2013            <p>Additional context to pass to the validator.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValidationError</code>             \u2013            <p>If the object could not be validated.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config</code>           \u2013            <p>The validated model instance.</p> </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    *args,\n    **kwargs,\n) -&gt; typing.Any:\n    \"\"\"Validate the passengersim Config inputs.\n\n    This method reloads the Config class to ensure all imported\n    RmSteps are properly registered before validation.\n\n    Parameters\n    ----------\n    obj\n        The object to validate.\n    strict : bool\n        Whether to raise an exception on invalid fields.\n    from_attributes\n        Whether to extract data from object attributes.\n    context\n        Additional context to pass to the validator.\n\n    Raises\n    ------\n    ValidationError\n        If the object could not be validated.\n\n    Returns\n    -------\n    Config\n        The validated model instance.\n    \"\"\"\n    # detect if there are any new RmSteps and reload the Config class\n    # to ensure they are properly registered\n    reloaded_class = cls\n    for k in RmStepBase._get_subclasses():\n        if k not in cls.__rm_steps_loaded:\n            # reload these to refresh for any newly defined RmSteps\n            module_parent = \".\".join(__name__.split(\".\")[:-1])\n            importlib.reload(sys.modules.get(f\"{module_parent}.rm_systems\"))\n            importlib.reload(sys.modules.get(__name__))\n            module = importlib.reload(sys.modules.get(module_parent))\n            reloaded_class = getattr(module, cls.__name__)\n    # `__tracebackhide__` tells pytest and some other tools to omit this\n    # function from tracebacks\n    __tracebackhide__ = True\n    with warnings.catch_warnings(record=True) as wz:\n        warnings.simplefilter(\"always\")  # Ensure all warnings are captured\n        result = reloaded_class.__pydantic_validator__.validate_python(*args, **kwargs)\n    for w in wz:\n        warnings.warn(w.message, category=w.category, stacklevel=2)\n    return result\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.OptionalPath", "title": "OptionalPath", "text": "<p>               Bases: <code>Path</code></p> <p>A pathlib.Path that, if missing, is ignored by the Yaml loader.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>class OptionalPath(pathlib.Path):\n    \"\"\"A pathlib.Path that, if missing, is ignored by the Yaml loader.\"\"\"\n\n    pass\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig", "title": "YamlConfig", "text": "<p>               Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/base.py</code> <pre><code>class YamlConfig(PrettyModel):\n    @classmethod\n    def _load_unformatted_yaml(\n        cls: type[TConfig],\n        filenames: str | pathlib.Path | list[str] | list[pathlib.Path],\n    ) -&gt; addicty.Dict:\n        \"\"\"\n        Read from YAML to an unvalidated addicty.Dict.\n\n        Parameters\n        ----------\n        filenames : path-like or list[path-like]\n            If multiple filenames are provided, they are loaded in order\n            and values with matching keys defined in later files will overwrite\n            the ones found in earlier files.\n\n        Returns\n        -------\n        addicty.Dict\n        \"\"\"\n        if isinstance(filenames, str | bytes | os.PathLike):\n            filenames = [filenames]\n        raw_config = addicty.Dict()\n        for filename in filenames:\n            t = time.time()\n            if isinstance(filename, str) and \"\\n\" in filename:\n                # explicit YAML content cannot have include statements\n                content = addicty.Dict.load(filename, freeze=False, Loader=yaml.CSafeLoader)\n                raw_config.update(content)\n                continue\n            if not isinstance(filename, pathlib.Path):\n                filename = pathlib.Path(filename)\n            if filename.suffix in (\".pem\", \".crt\", \".cert\"):\n                # license certificate\n                with open(filename, \"rb\") as f:\n                    raw_config.raw_license_certificate = f.read()\n            else:\n                opener = smart_open\n                if filename.parts[0] in {\"https:\", \"http:\", \"s3:\"}:\n                    opener = web_opener\n                    if filename.suffix == \".gz\" or filename.suffix == \".lz4\":\n                        raise NotImplementedError(\"cannot load compressed files from web yet\")\n                if isinstance(filename, OptionalPath) and not filename.exists():\n                    continue\n                with opener(filename) as f:\n                    content = addicty.Dict.load(f, freeze=False, Loader=yaml.CSafeLoader)\n                    if content is None:\n                        warnings.warn(\n                            f\"Empty file {filename}\",\n                            skip_file_prefixes=_warn_skips,\n                            stacklevel=1,\n                        )\n                        continue\n                    include = content.pop(\"include\", None)\n                    if include is not None:\n                        if isinstance(include, str):\n                            filename.parent.joinpath(include)\n                            inclusions = [filename.parent.joinpath(include)]\n                        else:\n                            inclusions = [filename.parent.joinpath(i) for i in include]\n                        raw_config.update(cls._load_unformatted_yaml(inclusions))\n                    raw_config.update(content)\n            logger.info(\"loaded config from %s in %.2f secs\", filename, time.time() - t)\n        return raw_config\n\n    @classmethod\n    def from_yaml(\n        cls: type[TConfig],\n        filenames: pathlib.Path | list[pathlib.Path],\n        *,\n        cache_file: pathlib.Path | None = None,\n        on_validation_error: Literal[\"raise\", \"warn\"] = \"raise\",\n    ) -&gt; TConfig | addicty.Dict:\n        \"\"\"\n        Read from YAML.\n\n        Parameters\n        ----------\n        filenames : path-like or list[path-like]\n            If multiple filenames are provided, they are loaded in order\n            and values with matching keys defined in later files will overwrite\n            the ones found in earlier files.\n        cache_file : path-like, optional\n            If provided, the validated config will be cached to this file in\n            binary format using pickle.  If the cache file exists and is\n            newer than the YAML files, the cached config will be loaded\n            instead of reloading and revalidating the YAML files, which can be\n            considerably faster.\n        on_validation_error : {'raise', 'warn'}, default 'raise'\n            Whether to raise an exception or log a warning when a validation\n            error is encountered. If 'warn', the error is logged and the\n            unvalidated raw loaded yaml content (not a Config object) is returned.\n\n        Returns\n        -------\n        Config or addicty.Dict\n        \"\"\"\n        filenames = preprocess_filenames(filenames, expand_includes=False)\n        cache_is_outdated = True\n        if cache_file:\n            cache_is_outdated = check_modification_times(filenames, cache_file)\n            if cache_is_outdated:\n                logger.info(f\"cache file is {cache_is_outdated}, will reload YAML files\")\n        if not cache_file or cache_is_outdated:\n            raw_config = cls._load_unformatted_yaml(filenames)\n            t = time.time()\n            try:\n                result = cls.model_validate(raw_config.to_dict())\n            except ValidationError as e:\n                if on_validation_error == \"raise\":\n                    raise\n                warnings.warn(str(e), stacklevel=2)\n                return raw_config\n            logger.info(\"validated config in %.2f secs\", time.time() - t)\n            if cache_file:\n                t = time.time()\n                serialize_to_file(cache_file, result)\n                logger.info(\"cached config in %.2f secs\", time.time() - t)\n            return result\n        else:\n            t = time.time()\n            result = deserialize_from_file(cache_file)\n            logger.info(\"loaded config from cache in %.2f secs\", time.time() - t)\n            return result\n\n    @classmethod\n    def from_raw_yaml(cls, content: str | bytes) -&gt; Self:\n        \"\"\"\n        Read from raw YAML content.\n\n        Parameters\n        ----------\n        content : str or bytes\n            The YAML content to parse.\n\n        Returns\n        -------\n        Config\n        \"\"\"\n        if isinstance(content, bytes):\n            content = content.decode(\"utf8\")\n        raw_config = addicty.Dict.load(content, freeze=False, Loader=yaml.CSafeLoader)\n        return cls.model_validate(raw_config.to_dict())\n\n    tags: dict[str, Any] = {}\n    \"\"\"Tags that can be used in format strings in the config.\"\"\"\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _parse_format_tags(cls, data: Any) -&gt; Any:\n        \"\"\"Parse format tags in the config.\"\"\"\n        tags = {}\n        if \"tags\" in data:\n            tags.update(data[\"tags\"])\n        if \"scenario\" in data:\n            tags[\"scenario\"] = data[\"scenario\"]\n        tags[\"date_Ymd\"] = time.strftime(\"%Y-%m-%d\")\n        tags[\"time_HM\"] = time.strftime(\"%H%M\")\n\n        def apply_tags(x):\n            if isinstance(x, dict):\n                return {k: apply_tags(v) for k, v in x.items()}\n            if isinstance(x, list):\n                return [apply_tags(i) for i in x]\n            if isinstance(x, str):\n                return x.format(**tags)\n            return x\n\n        return apply_tags(data)\n\n    def to_yaml(\n        self,\n        stream: os.PathLike | io.FileIO | None = None,\n        *,\n        include: IncEx = None,\n        exclude: IncEx = None,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        warnings: bool = True,\n    ) -&gt; None | bytes:\n        \"\"\"\n        Write a config to YAML format.\n\n        Parameters\n        ----------\n        stream : Path-like or File-like, optional\n            Write the results here.  If given as a path, a new file is written\n            at this location, or give a File-like object open for writing.\n        include : list[int | str]\n            A list of fields to include in the output.\n        exclude : list[int | str]\n            A list of fields to exclude from the output.\n        exclude_unset : bool, default False\n            Whether to exclude fields that are unset or None from the output.\n        exclude_defaults : bool, default False\n            Whether to exclude fields that are set to their default value from\n            the output.\n        exclude_none : bool, default False\n            Whether to exclude fields that have a value of `None` from the output.\n        warnings : bool, default True\n            Whether to log warnings when invalid fields are encountered.\n\n        Returns\n        -------\n        bytes or None\n            When no stream is given, the YAML content is returned as bytes,\n            otherwise this method returns nothing.\n        \"\"\"\n\n        y = _path_to_str(\n            self.model_dump(\n                include=include,\n                exclude=exclude,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n                warnings=warnings,\n            )\n        )\n        b = yaml.dump(y, encoding=\"utf8\", Dumper=yaml.CSafeDumper)\n        if isinstance(stream, str):\n            stream = pathlib.Path(stream)\n        if isinstance(stream, pathlib.Path):\n            if stream.suffix == \".lz4\":\n                with smart_open(stream, \"wb\") as f:\n                    f.write(b)\n            else:\n                stream.write_bytes(b)\n        elif isinstance(stream, io.RawIOBase):\n            stream.write(b)\n        elif isinstance(stream, io.TextIOBase):\n            stream.write(b.decode())\n        else:\n            return b\n\n    def to_yaml_parts(\n        self,\n        directory: pathlib.Path | str,\n        *,\n        include: IncEx = None,\n        exclude: IncEx = None,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        warnings: bool = True,\n        general_config: tuple[str] = (\"simulation_controls\", \"tags\"),\n    ) -&gt; None:\n        \"\"\"Write to a set of YAML files, one for each top level key.\n\n        Parameters\n        ----------\n        directory : pathlib.Path or str\n            The directory to write the YAML files to. If it does not exist,\n            it will be created.\n        include : list[int | str], optional\n            A list of fields to include in the output.\n        exclude : list[int | str], optional\n            A list of fields to exclude from the output.\n        exclude_unset : bool, default False\n            Whether to exclude fields that are unset or None from the output.\n        exclude_defaults : bool, default False\n            Whether to exclude fields that are set to their default value from\n            the output.\n        exclude_none : bool, default False\n            Whether to exclude fields that have a value of `None` from the output.\n        warnings : bool, default True\n            Whether to log warnings when invalid fields are encountered.\n        \"\"\"\n        if isinstance(directory, str):\n            directory = pathlib.Path(directory)\n        if not directory.exists():\n            directory.mkdir(parents=True, exist_ok=True)\n        y = _path_to_str(\n            self.model_dump(\n                include=include,\n                exclude=exclude,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n                warnings=warnings,\n            )\n        )\n        remainder = {}\n        for key, value in y.items():\n            if key == \"raw_license_certificate\":\n                # do not write the license certificate to a file\n                continue\n            if isinstance(value, dict | list) and key not in general_config:\n                filename = directory / f\"{key}.yaml\"\n                # when the value is empty, we don't write a file for it\n                if value:\n                    with open(filename, \"w\", encoding=\"utf8\") as f:\n                        yaml.dump({key: value}, f, Dumper=yaml.CSafeDumper)\n                    # if the file just written is bigger than 1MB, compress it with lz4\n                    if filename.stat().st_size &gt; 1024 * 1024:\n                        from passengersim.utils.compression import compress_file\n\n                        compress_file(filename, rm_original=True)\n            else:\n                remainder[key] = value\n        if remainder:\n            # write the general config to a separate file\n            filename = directory / \"general.yaml\"\n            with open(filename, \"w\", encoding=\"utf8\") as f:\n                yaml.dump(remainder, f, Dumper=yaml.CSafeDumper)\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig.tags", "title": "tags  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tags: dict[str, Any] = {}\n</code></pre> <p>Tags that can be used in format strings in the config.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig.from_raw_yaml", "title": "from_raw_yaml  <code>classmethod</code>", "text": "<pre><code>from_raw_yaml(content: str | bytes) -&gt; Self\n</code></pre> <p>Read from raw YAML content.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str or bytes</code>)           \u2013            <p>The YAML content to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config</code>           \u2013            </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>@classmethod\ndef from_raw_yaml(cls, content: str | bytes) -&gt; Self:\n    \"\"\"\n    Read from raw YAML content.\n\n    Parameters\n    ----------\n    content : str or bytes\n        The YAML content to parse.\n\n    Returns\n    -------\n    Config\n    \"\"\"\n    if isinstance(content, bytes):\n        content = content.decode(\"utf8\")\n    raw_config = addicty.Dict.load(content, freeze=False, Loader=yaml.CSafeLoader)\n    return cls.model_validate(raw_config.to_dict())\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig.from_yaml", "title": "from_yaml  <code>classmethod</code>", "text": "<pre><code>from_yaml(\n    filenames: Path | list[Path],\n    *,\n    cache_file: Path | None = None,\n    on_validation_error: Literal[\"raise\", \"warn\"] = \"raise\",\n) -&gt; TConfig | Dict\n</code></pre> <p>Read from YAML.</p> <p>Parameters:</p> <ul> <li> <code>filenames</code>               (<code>path - like or list[path - like]</code>)           \u2013            <p>If multiple filenames are provided, they are loaded in order and values with matching keys defined in later files will overwrite the ones found in earlier files.</p> </li> <li> <code>cache_file</code>               (<code>path - like</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the validated config will be cached to this file in binary format using pickle.  If the cache file exists and is newer than the YAML files, the cached config will be loaded instead of reloading and revalidating the YAML files, which can be considerably faster.</p> </li> <li> <code>on_validation_error</code>               (<code>('raise', 'warn')</code>, default:                   <code>'raise'</code> )           \u2013            <p>Whether to raise an exception or log a warning when a validation error is encountered. If 'warn', the error is logged and the unvalidated raw loaded yaml content (not a Config object) is returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config or Dict</code>           \u2013            </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>@classmethod\ndef from_yaml(\n    cls: type[TConfig],\n    filenames: pathlib.Path | list[pathlib.Path],\n    *,\n    cache_file: pathlib.Path | None = None,\n    on_validation_error: Literal[\"raise\", \"warn\"] = \"raise\",\n) -&gt; TConfig | addicty.Dict:\n    \"\"\"\n    Read from YAML.\n\n    Parameters\n    ----------\n    filenames : path-like or list[path-like]\n        If multiple filenames are provided, they are loaded in order\n        and values with matching keys defined in later files will overwrite\n        the ones found in earlier files.\n    cache_file : path-like, optional\n        If provided, the validated config will be cached to this file in\n        binary format using pickle.  If the cache file exists and is\n        newer than the YAML files, the cached config will be loaded\n        instead of reloading and revalidating the YAML files, which can be\n        considerably faster.\n    on_validation_error : {'raise', 'warn'}, default 'raise'\n        Whether to raise an exception or log a warning when a validation\n        error is encountered. If 'warn', the error is logged and the\n        unvalidated raw loaded yaml content (not a Config object) is returned.\n\n    Returns\n    -------\n    Config or addicty.Dict\n    \"\"\"\n    filenames = preprocess_filenames(filenames, expand_includes=False)\n    cache_is_outdated = True\n    if cache_file:\n        cache_is_outdated = check_modification_times(filenames, cache_file)\n        if cache_is_outdated:\n            logger.info(f\"cache file is {cache_is_outdated}, will reload YAML files\")\n    if not cache_file or cache_is_outdated:\n        raw_config = cls._load_unformatted_yaml(filenames)\n        t = time.time()\n        try:\n            result = cls.model_validate(raw_config.to_dict())\n        except ValidationError as e:\n            if on_validation_error == \"raise\":\n                raise\n            warnings.warn(str(e), stacklevel=2)\n            return raw_config\n        logger.info(\"validated config in %.2f secs\", time.time() - t)\n        if cache_file:\n            t = time.time()\n            serialize_to_file(cache_file, result)\n            logger.info(\"cached config in %.2f secs\", time.time() - t)\n        return result\n    else:\n        t = time.time()\n        result = deserialize_from_file(cache_file)\n        logger.info(\"loaded config from cache in %.2f secs\", time.time() - t)\n        return result\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig.to_yaml", "title": "to_yaml", "text": "<pre><code>to_yaml(\n    stream: PathLike | FileIO | None = None,\n    *,\n    include: IncEx = None,\n    exclude: IncEx = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    warnings: bool = True,\n) -&gt; None | bytes\n</code></pre> <p>Write a config to YAML format.</p> <p>Parameters:</p> <ul> <li> <code>stream</code>               (<code>Path - like or File - like</code>, default:                   <code>None</code> )           \u2013            <p>Write the results here.  If given as a path, a new file is written at this location, or give a File-like object open for writing.</p> </li> <li> <code>include</code>               (<code>list[int | str]</code>, default:                   <code>None</code> )           \u2013            <p>A list of fields to include in the output.</p> </li> <li> <code>exclude</code>               (<code>list[int | str]</code>, default:                   <code>None</code> )           \u2013            <p>A list of fields to exclude from the output.</p> </li> <li> <code>exclude_unset</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to exclude fields that are unset or None from the output.</p> </li> <li> <code>exclude_defaults</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to exclude fields that are set to their default value from the output.</p> </li> <li> <code>exclude_none</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to exclude fields that have a value of <code>None</code> from the output.</p> </li> <li> <code>warnings</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to log warnings when invalid fields are encountered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes or None</code>           \u2013            <p>When no stream is given, the YAML content is returned as bytes, otherwise this method returns nothing.</p> </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>def to_yaml(\n    self,\n    stream: os.PathLike | io.FileIO | None = None,\n    *,\n    include: IncEx = None,\n    exclude: IncEx = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    warnings: bool = True,\n) -&gt; None | bytes:\n    \"\"\"\n    Write a config to YAML format.\n\n    Parameters\n    ----------\n    stream : Path-like or File-like, optional\n        Write the results here.  If given as a path, a new file is written\n        at this location, or give a File-like object open for writing.\n    include : list[int | str]\n        A list of fields to include in the output.\n    exclude : list[int | str]\n        A list of fields to exclude from the output.\n    exclude_unset : bool, default False\n        Whether to exclude fields that are unset or None from the output.\n    exclude_defaults : bool, default False\n        Whether to exclude fields that are set to their default value from\n        the output.\n    exclude_none : bool, default False\n        Whether to exclude fields that have a value of `None` from the output.\n    warnings : bool, default True\n        Whether to log warnings when invalid fields are encountered.\n\n    Returns\n    -------\n    bytes or None\n        When no stream is given, the YAML content is returned as bytes,\n        otherwise this method returns nothing.\n    \"\"\"\n\n    y = _path_to_str(\n        self.model_dump(\n            include=include,\n            exclude=exclude,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            warnings=warnings,\n        )\n    )\n    b = yaml.dump(y, encoding=\"utf8\", Dumper=yaml.CSafeDumper)\n    if isinstance(stream, str):\n        stream = pathlib.Path(stream)\n    if isinstance(stream, pathlib.Path):\n        if stream.suffix == \".lz4\":\n            with smart_open(stream, \"wb\") as f:\n                f.write(b)\n        else:\n            stream.write_bytes(b)\n    elif isinstance(stream, io.RawIOBase):\n        stream.write(b)\n    elif isinstance(stream, io.TextIOBase):\n        stream.write(b.decode())\n    else:\n        return b\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig.to_yaml_parts", "title": "to_yaml_parts", "text": "<pre><code>to_yaml_parts(\n    directory: Path | str,\n    *,\n    include: IncEx = None,\n    exclude: IncEx = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    warnings: bool = True,\n    general_config: tuple[str] = (\n        \"simulation_controls\",\n        \"tags\",\n    ),\n) -&gt; None\n</code></pre> <p>Write to a set of YAML files, one for each top level key.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>Path or str</code>)           \u2013            <p>The directory to write the YAML files to. If it does not exist, it will be created.</p> </li> <li> <code>include</code>               (<code>list[int | str]</code>, default:                   <code>None</code> )           \u2013            <p>A list of fields to include in the output.</p> </li> <li> <code>exclude</code>               (<code>list[int | str]</code>, default:                   <code>None</code> )           \u2013            <p>A list of fields to exclude from the output.</p> </li> <li> <code>exclude_unset</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to exclude fields that are unset or None from the output.</p> </li> <li> <code>exclude_defaults</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to exclude fields that are set to their default value from the output.</p> </li> <li> <code>exclude_none</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to exclude fields that have a value of <code>None</code> from the output.</p> </li> <li> <code>warnings</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to log warnings when invalid fields are encountered.</p> </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>def to_yaml_parts(\n    self,\n    directory: pathlib.Path | str,\n    *,\n    include: IncEx = None,\n    exclude: IncEx = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    warnings: bool = True,\n    general_config: tuple[str] = (\"simulation_controls\", \"tags\"),\n) -&gt; None:\n    \"\"\"Write to a set of YAML files, one for each top level key.\n\n    Parameters\n    ----------\n    directory : pathlib.Path or str\n        The directory to write the YAML files to. If it does not exist,\n        it will be created.\n    include : list[int | str], optional\n        A list of fields to include in the output.\n    exclude : list[int | str], optional\n        A list of fields to exclude from the output.\n    exclude_unset : bool, default False\n        Whether to exclude fields that are unset or None from the output.\n    exclude_defaults : bool, default False\n        Whether to exclude fields that are set to their default value from\n        the output.\n    exclude_none : bool, default False\n        Whether to exclude fields that have a value of `None` from the output.\n    warnings : bool, default True\n        Whether to log warnings when invalid fields are encountered.\n    \"\"\"\n    if isinstance(directory, str):\n        directory = pathlib.Path(directory)\n    if not directory.exists():\n        directory.mkdir(parents=True, exist_ok=True)\n    y = _path_to_str(\n        self.model_dump(\n            include=include,\n            exclude=exclude,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            warnings=warnings,\n        )\n    )\n    remainder = {}\n    for key, value in y.items():\n        if key == \"raw_license_certificate\":\n            # do not write the license certificate to a file\n            continue\n        if isinstance(value, dict | list) and key not in general_config:\n            filename = directory / f\"{key}.yaml\"\n            # when the value is empty, we don't write a file for it\n            if value:\n                with open(filename, \"w\", encoding=\"utf8\") as f:\n                    yaml.dump({key: value}, f, Dumper=yaml.CSafeDumper)\n                # if the file just written is bigger than 1MB, compress it with lz4\n                if filename.stat().st_size &gt; 1024 * 1024:\n                    from passengersim.utils.compression import compress_file\n\n                    compress_file(filename, rm_original=True)\n        else:\n            remainder[key] = value\n    if remainder:\n        # write the general config to a separate file\n        filename = directory / \"general.yaml\"\n        with open(filename, \"w\", encoding=\"utf8\") as f:\n            yaml.dump(remainder, f, Dumper=yaml.CSafeDumper)\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.find_differences", "title": "find_differences", "text": "<pre><code>find_differences(left, right)\n</code></pre> <p>Find the differences between two nested dictionaries.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>def find_differences(left, right):\n    \"\"\"Find the differences between two nested dictionaries.\"\"\"\n    if isinstance(left, dict) and isinstance(right, dict):\n        diff = {}\n        for key in left.keys() | right.keys():\n            if key not in right:\n                diff[key] = \"missing in right\"\n            elif key not in left:\n                diff[key] = \"missing in left\"\n            else:\n                sub_diff = find_differences(left[key], right[key])\n                if sub_diff:\n                    diff[key] = sub_diff\n        return diff\n    if isinstance(left, list) and isinstance(right, list):\n        if len(left) != len(right):\n            return \"different lengths\"\n        diff = {}\n        for i, (left_item, right_item) in enumerate(zip(left, right)):\n            sub_diff = find_differences(left_item, right_item)\n            if sub_diff:\n                diff[i] = sub_diff\n        return diff\n    if isinstance(left, dict) and not isinstance(right, dict):\n        return \"left is dict and right is not\"\n    if isinstance(right, dict) and not isinstance(left, dict):\n        return \"right is dict and left is not\"\n    if isinstance(left, list) and not isinstance(right, list):\n        return \"left is list and right is not\"\n    if isinstance(right, list) and not isinstance(left, list):\n        return \"right is list and left is not\"\n    if left == right:\n        return {}\n    return f\"{left} != {right}\"\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html", "title": "Simulation Controls", "text": ""}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings", "title": "SimulationSettings", "text": "<p>               Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/simulation_controls.py</code> <pre><code>class SimulationSettings(PrettyModel, extra=\"allow\", validate_assignment=True):\n    num_trials: conint(ge=1, le=1000) = 1\n    \"\"\"The overall number of trials to run.\n\n    Each trial is a complete simulation, including burn-in training time as well\n    as study time.  It will have a number of sequentially developed samples, each of\n    which represents one \"typical\" day of travel.\n\n    See [Counting Simulations][counting-simulations] for more details.\n    \"\"\"\n\n    num_samples: conint(ge=1, le=10000) = 600\n    \"\"\"The number of samples to run within each trial.\n\n    Each sample represents one \"typical\" day of travel.\n    See [Counting Simulations][counting-simulations] for more details.\n    \"\"\"\n\n    burn_samples: conint(ge=0, le=10000) = 100\n    \"\"\"The number of samples to burn when starting each trial.\n\n    Burned samples are used to populate a stable history of data to support\n    forecasting and optimization algorithms, but are not used to evaluate\n    performance results.\n\n    See [Counting Simulations][counting-simulations] for more details.\n    \"\"\"\n\n    double_capacity_until: int | None = None\n    \"\"\"\n    Double the capacity on all legs until this sample.\n\n    The extra capacity may reduce the statistical noise of untruncation\n    within the burn period and allow the simulation to achieve a stable\n    steady state faster.  If used, this should be set to a value at least\n    26 below the `burn_samples` value to avoid polluting the results.\n    \"\"\"\n\n    @field_validator(\"double_capacity_until\")\n    @classmethod\n    def _avoid_capacity_pollution(cls, v: int | None, info: ValidationInfo):\n        if v and v &gt;= info.data[\"burn_samples\"] - 25:\n            raise ValueError(\"doubled capacity will pollute results\")\n        return v\n\n    sys_k_factor: confloat(ge=0, le=5.0) = 0.10\n    \"\"\"\n    System-level randomness factor.\n\n    This factor controls the level of correlation in demand levels across the\n    entire system.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    mkt_k_factor: confloat(ge=0, le=5.0) = 0.20\n    \"\"\"\n    Market-level randomness factor.\n\n    This factor controls the level of correlation in demand levels across origin-\n    destination markets.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    pax_type_k_factor: confloat(ge=0, le=5.0) = 0.0\n    \"\"\"\n    Passenger-type randomness factor.\n\n    Deprecated: use `simple_k_factor` instead.\n\n    This factor add uncorrelated variance to every demand, unless there are\n    multiple demands in the same market and with the same passenger segment.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    segment_k_factor: confloat(ge=0, le=5.0) = 0.0\n    \"\"\"\n    Passenger segment randomness factor.\n\n    This factor controls the level of correlation in demand levels across\n    passenger segments.\n    \"\"\"\n\n    simple_k_factor: confloat(ge=0, le=5.0) = 0.40\n    \"\"\"\n    Passenger-type randomness factor.\n\n    This factor add uncorrelated variance to every demand.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    simple_cv100: confloat(ge=0, le=1.0) = 0.0\n    \"\"\"THIS IS A TEST\"\"\"\n\n    tf_k_factor: confloat(ge=0) = 0.1\n    \"\"\"\n    Time frame randomness factor.\n\n    This factor controls the dispersion of bookings over time, given a previously\n    identified level of total demand. See [k-factors]() for more details.\n    \"\"\"\n\n    tot_z_factor: confloat(ge=0, le=100.0) = 2.0\n    \"\"\"\n    Base level demand variance control.\n\n    This factor scales the variance in the amount of total demand for any given\n    market segment.\n\n    See [k-factors][demand-generation-k-factors] for more details.\n    \"\"\"\n\n    tf_z_factor: confloat(ge=0, le=100.0) = 2.0\n    \"\"\"\n    Timeframe demand variance control.\n\n    This factor scales the variance in the allocation of total demand to the\n    various arrival timeframes.\n\n    See [k-factors][demand-generation-k-factors] for more details.\n    \"\"\"\n\n    prorate_revenue: bool = True\n\n    save_orders: bool = False\n\n    save_all_offers: bool = False\n    \"\"\"\n    This will save all Offers, including those that would fail fare rules or availability.\n    The output choice set data will have all of these, so you can find first choice demand,\n    recapture, etc.\n    False by default\n    \"\"\"\n\n    dwm_lite: bool = True\n    \"\"\"\n    Use the \"lite\" decision window model.\n\n    The structure of this model is the same as that use by Boeing.\n    \"\"\"\n\n    max_connect_time: conint(ge=0) = 240\n    \"\"\"\n    Maximum connection time for automatically generated paths.\n\n    Any generated path that has a connection time greater than this value (expressed\n    in minutes) is invalidated.\n    \"\"\"\n\n    disable_ap: bool = False\n    \"\"\"\n    Remove all advance purchase settings used in the simulation.\n\n    This applies to all carriers and all fare products.  If active, this filter\n    is applied to all Fare definitions at the time the Config is loaded into to a\n    Simulation object.\n    \"\"\"\n\n    demand_multiplier: confloat(gt=0) = 1.0\n    \"\"\"\n    Scale all demand by this value.\n\n    Setting to a value other than 1.0 will increase or decrease\n    all demand inputs uniformly by the same multiplicative amount.\n    This is helpful when exploring how simulation results vary\n    when you have \"low demand\" scenarios\n    (e.g, demand_multiplier = 0.8), or \"high demand\" scenarios\n    (e.g., demand multiplier = 1.1).\n    \"\"\"\n\n    capacity_multiplier: confloat(gt=0) = 1.0\n    \"\"\"\n    Scale all capacities by this value.\n\n    Setting to a value other than 1.0 will increase or decrease all capacity inputs\n    uniformly by the same multiplicative amount.\n    Business class and/or first class can be quickly simulated with this option\n    \"\"\"\n\n    manual_paths: bool = False\n    \"\"\"\n    The user has provided explicit paths and connections.\n\n    If set to False, the automatic path generation algorithm is applied.\n    \"\"\"\n\n    generate_3seg: bool | None = False\n    \"\"\"\n    Use the new A* search to build connections, it can create 3seg connects\n    \"\"\"\n\n    @property\n    def use_3seg(self) -&gt; bool:\n        return self.generate_3seg\n\n    @use_3seg.setter\n    def use_3seg(self, value: bool):\n        # deprecated\n        if value:\n            warnings.warn(\n                \"`use_3seg` is deprecated, use `generate_3seg` instead\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        self.generate_3seg = bool(value)\n\n    write_raw_files: bool = False\n\n    random_seed: int | None = None\n    \"\"\"\n    Integer used to control the reproducibility of simulation results.\n\n    A seed is base value used by a pseudo-random generator to generate random\n    numbers. A fixed random seed is used to ensure the same randomness pattern\n    is reproducible and does not change between simulation runs, i.e. allows\n    subsequent runs to be conducted with the same randomness pattern as a\n    previous one. Any value set here will allow results to be repeated.\n\n    The random number generator is re-seeded at the beginning of every sample\n    in every trial with a fixed tuple of three values: this \"global\" random seed,\n    plus the sample number and trial number.  This ensures that partial results\n    are also reproducible: the simulation of sample 234 in trial 2 will be the\n    same regardless of how many samples are in trial 1.\n    \"\"\"\n\n    update_frequency: int | None = None\n\n    controller_time_zone: int | float = -21600\n    \"\"\"\n    The reference time zone for the controller (seconds relative to UTC).\n\n    Data collection points will be trigger at approximately midnight in this time zone.\n\n    This value can be input in hours instead of seconds, any absolute value less\n    than or equal to 12 will be assumed to be hours and scaled to seconds.\n\n    The default value is -6 hours, or US Central Standard Time.\n    \"\"\"\n\n    base_date: str = \"2020-03-01\"\n    \"\"\"\n    The default date used to compute relative times for travel.\n\n    Future enhancements may include multi-day modeling.\n    \"\"\"\n\n    dcp_hour: float = 0.0\n    \"\"\"\n    The hour of the day that the RM recalculation events are triggered.\n\n    If set to zero, the events happen at midnight.  Other values can\n    delay the recalculation into later in the night (or the next day).\n    \"\"\"\n\n    capture_competitor_data: bool = False\n    \"\"\"\n    Turns on the capturing of competitor data.\n\n    This feature captures lowest available fare data captured by market, for potential\n    use in competitive analysis RM strategies.\n    \"\"\"\n\n    capture_choice_set_file: str = \"\"\n    \"\"\"\n    Turns on the capturing of the choice set and writes the data to the specified file\n    \"\"\"\n\n    capture_choice_set_obs: int | None = None\n    \"\"\"\n    If this is set, PassengerSim will randomly sample the ChoiceSet data and output\n    APPROXIMATELY this many choice sets (each will have multiple items and all items\n    for the choice set will be saved and output)\n    \"\"\"\n\n    capture_choice_set_mkts: list[tuple] | None = []\n    \"\"\"Capture only these markets (O&amp;D pairs)\"\"\"\n\n    show_progress_bar: bool = True\n    \"\"\"\n    Show a progress bar while running.\n\n    The progress display requires `rich` is installed.\n    \"\"\"\n\n    # A bunch of debug flags, these are only used for development !!!\n    debug_availability: bool | None = False\n    debug_choice: bool | None = False\n    debug_connections: bool | None = False\n    debug_events: bool | None = False\n    debug_fares: bool | None = False\n    debug_offers: bool | None = False\n    debug_orders: bool | None = False\n\n    additional_settings: dict[str, Any] = {}\n    \"\"\"\n    Additional settings to pass to the simulation.\n\n    These settings are passed directly to the simulation object and can be used to\n    set various parameters that are not directly exposed in the configuration.\n    \"\"\"\n\n    @field_validator(\"controller_time_zone\", mode=\"before\")\n    def _time_zone_convert_hours_to_seconds(cls, v):\n        if -12 &lt;= v &lt;= 12:\n            v *= 3600\n        return v\n\n    def reference_epoch(self) -&gt; int:\n        \"\"\"Get the reference travel datetime in unix time.\"\"\"\n        return iso_to_unix(self.base_date) - self.controller_time_zone\n\n    timeframe_demand_allocation: Literal[\"v2\", \"pods\"] = \"v2\"\n    \"\"\"\n    Which algorithm to use for time frame demand allocation.\n    \"\"\"\n\n    allow_unused_restrictions: bool = False\n    \"\"\"\n    Allow restrictions to be defined but not used.\n\n    If set to False, any restriction that is defined as a parameter of a choice\n    model but not present on any fare, or vice versa, will raise a ValueError.\n    Users may override this behavior by setting this parameter to True, which\n    will emit a warning instead of an error.\n    \"\"\"\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.additional_settings", "title": "additional_settings  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>additional_settings: dict[str, Any] = {}\n</code></pre> <p>Additional settings to pass to the simulation.</p> <p>These settings are passed directly to the simulation object and can be used to set various parameters that are not directly exposed in the configuration.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.allow_unused_restrictions", "title": "allow_unused_restrictions  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>allow_unused_restrictions: bool = False\n</code></pre> <p>Allow restrictions to be defined but not used.</p> <p>If set to False, any restriction that is defined as a parameter of a choice model but not present on any fare, or vice versa, will raise a ValueError. Users may override this behavior by setting this parameter to True, which will emit a warning instead of an error.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.base_date", "title": "base_date  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>base_date: str = '2020-03-01'\n</code></pre> <p>The default date used to compute relative times for travel.</p> <p>Future enhancements may include multi-day modeling.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.burn_samples", "title": "burn_samples  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>burn_samples: conint(ge=0, le=10000) = 100\n</code></pre> <p>The number of samples to burn when starting each trial.</p> <p>Burned samples are used to populate a stable history of data to support forecasting and optimization algorithms, but are not used to evaluate performance results.</p> <p>See Counting Simulations for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.capacity_multiplier", "title": "capacity_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>capacity_multiplier: confloat(gt=0) = 1.0\n</code></pre> <p>Scale all capacities by this value.</p> <p>Setting to a value other than 1.0 will increase or decrease all capacity inputs uniformly by the same multiplicative amount. Business class and/or first class can be quickly simulated with this option</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.capture_choice_set_file", "title": "capture_choice_set_file  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>capture_choice_set_file: str = ''\n</code></pre> <p>Turns on the capturing of the choice set and writes the data to the specified file</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.capture_choice_set_mkts", "title": "capture_choice_set_mkts  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>capture_choice_set_mkts: list[tuple] | None = []\n</code></pre> <p>Capture only these markets (O&amp;D pairs)</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.capture_choice_set_obs", "title": "capture_choice_set_obs  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>capture_choice_set_obs: int | None = None\n</code></pre> <p>If this is set, PassengerSim will randomly sample the ChoiceSet data and output APPROXIMATELY this many choice sets (each will have multiple items and all items for the choice set will be saved and output)</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.capture_competitor_data", "title": "capture_competitor_data  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>capture_competitor_data: bool = False\n</code></pre> <p>Turns on the capturing of competitor data.</p> <p>This feature captures lowest available fare data captured by market, for potential use in competitive analysis RM strategies.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.controller_time_zone", "title": "controller_time_zone  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>controller_time_zone: int | float = -21600\n</code></pre> <p>The reference time zone for the controller (seconds relative to UTC).</p> <p>Data collection points will be trigger at approximately midnight in this time zone.</p> <p>This value can be input in hours instead of seconds, any absolute value less than or equal to 12 will be assumed to be hours and scaled to seconds.</p> <p>The default value is -6 hours, or US Central Standard Time.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.dcp_hour", "title": "dcp_hour  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcp_hour: float = 0.0\n</code></pre> <p>The hour of the day that the RM recalculation events are triggered.</p> <p>If set to zero, the events happen at midnight.  Other values can delay the recalculation into later in the night (or the next day).</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.demand_multiplier", "title": "demand_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>demand_multiplier: confloat(gt=0) = 1.0\n</code></pre> <p>Scale all demand by this value.</p> <p>Setting to a value other than 1.0 will increase or decrease all demand inputs uniformly by the same multiplicative amount. This is helpful when exploring how simulation results vary when you have \"low demand\" scenarios (e.g, demand_multiplier = 0.8), or \"high demand\" scenarios (e.g., demand multiplier = 1.1).</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.disable_ap", "title": "disable_ap  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>disable_ap: bool = False\n</code></pre> <p>Remove all advance purchase settings used in the simulation.</p> <p>This applies to all carriers and all fare products.  If active, this filter is applied to all Fare definitions at the time the Config is loaded into to a Simulation object.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.double_capacity_until", "title": "double_capacity_until  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>double_capacity_until: int | None = None\n</code></pre> <p>Double the capacity on all legs until this sample.</p> <p>The extra capacity may reduce the statistical noise of untruncation within the burn period and allow the simulation to achieve a stable steady state faster.  If used, this should be set to a value at least 26 below the <code>burn_samples</code> value to avoid polluting the results.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.dwm_lite", "title": "dwm_lite  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dwm_lite: bool = True\n</code></pre> <p>Use the \"lite\" decision window model.</p> <p>The structure of this model is the same as that use by Boeing.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.generate_3seg", "title": "generate_3seg  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>generate_3seg: bool | None = False\n</code></pre> <p>Use the new A* search to build connections, it can create 3seg connects</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.manual_paths", "title": "manual_paths  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>manual_paths: bool = False\n</code></pre> <p>The user has provided explicit paths and connections.</p> <p>If set to False, the automatic path generation algorithm is applied.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.max_connect_time", "title": "max_connect_time  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>max_connect_time: conint(ge=0) = 240\n</code></pre> <p>Maximum connection time for automatically generated paths.</p> <p>Any generated path that has a connection time greater than this value (expressed in minutes) is invalidated.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.mkt_k_factor", "title": "mkt_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>mkt_k_factor: confloat(ge=0, le=5.0) = 0.2\n</code></pre> <p>Market-level randomness factor.</p> <p>This factor controls the level of correlation in demand levels across origin- destination markets.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.num_samples", "title": "num_samples  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>num_samples: conint(ge=1, le=10000) = 600\n</code></pre> <p>The number of samples to run within each trial.</p> <p>Each sample represents one \"typical\" day of travel. See Counting Simulations for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.num_trials", "title": "num_trials  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>num_trials: conint(ge=1, le=1000) = 1\n</code></pre> <p>The overall number of trials to run.</p> <p>Each trial is a complete simulation, including burn-in training time as well as study time.  It will have a number of sequentially developed samples, each of which represents one \"typical\" day of travel.</p> <p>See Counting Simulations for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.pax_type_k_factor", "title": "pax_type_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>pax_type_k_factor: confloat(ge=0, le=5.0) = 0.0\n</code></pre> <p>Passenger-type randomness factor.</p> <p>Deprecated: use <code>simple_k_factor</code> instead.</p> <p>This factor add uncorrelated variance to every demand, unless there are multiple demands in the same market and with the same passenger segment.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.prorate_revenue", "title": "prorate_revenue  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>prorate_revenue: bool = True\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.random_seed", "title": "random_seed  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>random_seed: int | None = None\n</code></pre> <p>Integer used to control the reproducibility of simulation results.</p> <p>A seed is base value used by a pseudo-random generator to generate random numbers. A fixed random seed is used to ensure the same randomness pattern is reproducible and does not change between simulation runs, i.e. allows subsequent runs to be conducted with the same randomness pattern as a previous one. Any value set here will allow results to be repeated.</p> <p>The random number generator is re-seeded at the beginning of every sample in every trial with a fixed tuple of three values: this \"global\" random seed, plus the sample number and trial number.  This ensures that partial results are also reproducible: the simulation of sample 234 in trial 2 will be the same regardless of how many samples are in trial 1.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.save_all_offers", "title": "save_all_offers  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>save_all_offers: bool = False\n</code></pre> <p>This will save all Offers, including those that would fail fare rules or availability. The output choice set data will have all of these, so you can find first choice demand, recapture, etc. False by default</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.save_orders", "title": "save_orders  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>save_orders: bool = False\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.segment_k_factor", "title": "segment_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>segment_k_factor: confloat(ge=0, le=5.0) = 0.0\n</code></pre> <p>Passenger segment randomness factor.</p> <p>This factor controls the level of correlation in demand levels across passenger segments.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.show_progress_bar", "title": "show_progress_bar  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>show_progress_bar: bool = True\n</code></pre> <p>Show a progress bar while running.</p> <p>The progress display requires <code>rich</code> is installed.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.simple_cv100", "title": "simple_cv100  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>simple_cv100: confloat(ge=0, le=1.0) = 0.0\n</code></pre> <p>THIS IS A TEST</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.simple_k_factor", "title": "simple_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>simple_k_factor: confloat(ge=0, le=5.0) = 0.4\n</code></pre> <p>Passenger-type randomness factor.</p> <p>This factor add uncorrelated variance to every demand.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.sys_k_factor", "title": "sys_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>sys_k_factor: confloat(ge=0, le=5.0) = 0.1\n</code></pre> <p>System-level randomness factor.</p> <p>This factor controls the level of correlation in demand levels across the entire system.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.tf_k_factor", "title": "tf_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tf_k_factor: confloat(ge=0) = 0.1\n</code></pre> <p>Time frame randomness factor.</p> <p>This factor controls the dispersion of bookings over time, given a previously identified level of total demand. See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.tf_z_factor", "title": "tf_z_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tf_z_factor: confloat(ge=0, le=100.0) = 2.0\n</code></pre> <p>Timeframe demand variance control.</p> <p>This factor scales the variance in the allocation of total demand to the various arrival timeframes.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.timeframe_demand_allocation", "title": "timeframe_demand_allocation  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>timeframe_demand_allocation: Literal['v2', 'pods'] = 'v2'\n</code></pre> <p>Which algorithm to use for time frame demand allocation.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.tot_z_factor", "title": "tot_z_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tot_z_factor: confloat(ge=0, le=100.0) = 2.0\n</code></pre> <p>Base level demand variance control.</p> <p>This factor scales the variance in the amount of total demand for any given market segment.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.update_frequency", "title": "update_frequency  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>update_frequency: int | None = None\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.use_3seg", "title": "use_3seg  <code>property</code> <code>writable</code>", "text": "<pre><code>use_3seg: bool\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.write_raw_files", "title": "write_raw_files  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>write_raw_files: bool = False\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.reference_epoch", "title": "reference_epoch", "text": "<pre><code>reference_epoch() -&gt; int\n</code></pre> <p>Get the reference travel datetime in unix time.</p> Source code in <code>passengersim/config/simulation_controls.py</code> <pre><code>def reference_epoch(self) -&gt; int:\n    \"\"\"Get the reference travel datetime in unix time.\"\"\"\n    return iso_to_unix(self.base_date) - self.controller_time_zone\n</code></pre>"}, {"location": "API/config/_figures.html", "title": "figures", "text": ""}, {"location": "API/config/_figures.html#passengersim.config._figures.__all__", "title": "__all__  <code>module-attribute</code>", "text": "<pre><code>__all__ = ['fig_booking_curves', 'fig_route_map']\n</code></pre>"}, {"location": "API/config/_figures.html#passengersim.config._figures.fig_booking_curves", "title": "fig_booking_curves", "text": "<pre><code>fig_booking_curves(cfg: Config) -&gt; Chart\n</code></pre> <p>Create a figure showing all booking curves in the config.</p> Source code in <code>passengersim/config/_figures.py</code> <pre><code>def fig_booking_curves(cfg: Config) -&gt; alt.Chart:\n    \"\"\"Create a figure showing all booking curves in the config.\"\"\"\n    data = booking_curves_to_dataframe(cfg.booking_curves, add_zero_days=True)\n    data[\"proportion\"] = data.groupby([\"curve_name\"])[\"proportion\"].shift(periods=1, fill_value=0)\n\n    segments = {}\n    for demand in cfg.demands:\n        full_label = f\"{demand.segment}/{demand.curve}\"\n        if demand.curve not in segments or segments[demand.curve] == full_label:\n            segments[demand.curve] = full_label\n        else:\n            segments[demand.curve] = demand.curve\n    data[\"segment\"] = data[\"curve_name\"].map(segments)\n    return (\n        alt.Chart(data)\n        .mark_line()\n        .encode(\n            x=alt.X(\"days_prior:Q\", scale=alt.Scale(reverse=True), title=\"Days Prior to Departure\"),\n            y=alt.Y(\"proportion:Q\", title=\"Cumulative Proportion of Bookings\"),\n            color=alt.Color(\"segment:N\", title=\"Passenger Segment\"),\n        )\n    )\n</code></pre>"}, {"location": "API/config/_figures.html#passengersim.config._figures.fig_route_map", "title": "fig_route_map", "text": "<pre><code>fig_route_map(\n    cfg: Config, carrier: str | None = None\n) -&gt; Chart\n</code></pre> <p>Create a figure showing the route map.</p> Source code in <code>passengersim/config/_figures.py</code> <pre><code>def fig_route_map(cfg: Config, carrier: str | None = None) -&gt; alt.Chart:\n    \"\"\"Create a figure showing the route map.\"\"\"\n    return _legs_conus_or_world(cfg.legs, cfg.places, title=\"Route Map\", line_color=\"red\", carrier=carrier)\n</code></pre>"}, {"location": "API/config/blf_curves.html", "title": "Booked Load Factor Curves", "text": ""}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve", "title": "BlfCurve", "text": "<p>               Bases: <code>Named</code></p> <p>Define a Booked Load Factor Curve. Used for UserAction.</p> Source code in <code>passengersim/config/blf_curves.py</code> <pre><code>class BlfCurve(Named, extra=\"forbid\"):\n    \"\"\"Define a Booked Load Factor Curve. Used for UserAction.\"\"\"\n\n    #    name: str\n    min_distance: int = 0\n    max_distance: int = 25000\n    min_duration: float = 0.0\n    max_duration: float = 25.0\n    type: str | None = None\n    k_factor: float = 0.3\n    curve: dict[int, float] | list[float] = None\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.curve", "title": "curve  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>curve: dict[int, float] | list[float] = None\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.k_factor", "title": "k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>k_factor: float = 0.3\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.max_distance", "title": "max_distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>max_distance: int = 25000\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.max_duration", "title": "max_duration  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>max_duration: float = 25.0\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.min_distance", "title": "min_distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>min_distance: int = 0\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.min_duration", "title": "min_duration  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>min_duration: float = 0.0\n</code></pre>"}, {"location": "API/config/blf_curves.html#passengersim.config.blf_curves.BlfCurve.type", "title": "type  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>type: str | None = None\n</code></pre>"}, {"location": "API/config/booking_curves.html", "title": "Booking Curves", "text": ""}, {"location": "API/config/booking_curves.html#passengersim.config.booking_curves.BookingCurve", "title": "BookingCurve", "text": "<p>               Bases: <code>Named</code></p> <p>A mathematical description of the relative arrival rate of customers over time.</p> Source code in <code>passengersim/config/booking_curves.py</code> <pre><code>class BookingCurve(Named, extra=\"forbid\"):\n    \"\"\"\n    A mathematical description of the relative arrival rate of customers over time.\n    \"\"\"\n\n    curve: dict[int, float]\n    \"\"\"Define a booking curve.\n\n    For a given customer type, the booking curve gives the cumulative fraction\n    of those customers who are expected to have already \"arrived\" at any given\n    data collection point (DCP / days_prior to departure).\n    An \"arriving\" customer is one who is interested\n    in booking, but may or may not actually purchase a travel product from one\n    of the carriers, depending on the availability of products at the time of their\n    arrival.\n\n    The values (cumulative fraction of customers arriving) should increase\n    monotonically as the keys (days_prior, e.g. days to departure) decrease.\n\n    Example\n    -------\n    ```{yaml}\n    - name: business\n      curve:\n        63: 0.01\n        56: 0.02\n        49: 0.05\n        42: 0.13\n        35: 0.19\n        31: 0.23\n        28: 0.29\n        24: 0.35\n        21: 0.45\n        17: 0.54\n        14: 0.67\n        10: 0.79\n        7: 0.86\n        5: 0.91\n        3: 0.96\n        1: 1.0\n    ```\n    \"\"\"\n\n    @field_validator(\"curve\")\n    def _booking_curves_accumulate(cls, v: dict[int, float], info: ValidationInfo):\n        \"\"\"Check that all curve values do not decrease as DCP keys decrease.\"\"\"\n        sorted_days_prior = reversed(sorted(v.keys()))\n        i = 0\n        for days_prior in sorted_days_prior:\n            assert v[days_prior] &gt;= i, f\"booking curve {info.data['name']} moves backwards at dcp {days_prior}\"\n            i = v[days_prior]\n        return v\n</code></pre>"}, {"location": "API/config/booking_curves.html#passengersim.config.booking_curves.BookingCurve.curve", "title": "curve  <code>instance-attribute</code>", "text": "<pre><code>curve: dict[int, float]\n</code></pre> <p>Define a booking curve.</p> <p>For a given customer type, the booking curve gives the cumulative fraction of those customers who are expected to have already \"arrived\" at any given data collection point (DCP / days_prior to departure). An \"arriving\" customer is one who is interested in booking, but may or may not actually purchase a travel product from one of the carriers, depending on the availability of products at the time of their arrival.</p> <p>The values (cumulative fraction of customers arriving) should increase monotonically as the keys (days_prior, e.g. days to departure) decrease.</p> Example <pre><code>- name: business\n  curve:\n    63: 0.01\n    56: 0.02\n    49: 0.05\n    42: 0.13\n    35: 0.19\n    31: 0.23\n    28: 0.29\n    24: 0.35\n    21: 0.45\n    17: 0.54\n    14: 0.67\n    10: 0.79\n    7: 0.86\n    5: 0.91\n    3: 0.96\n    1: 1.0\n</code></pre>"}, {"location": "API/config/carriers.html", "title": "Carriers", "text": ""}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier", "title": "Carrier", "text": "<p>               Bases: <code>Named</code></p> <p>Configuration for passengersim.Carrier object.</p> Source code in <code>passengersim/config/carriers.py</code> <pre><code>class Carrier(Named, extra=\"forbid\"):\n    \"\"\"Configuration for passengersim.Carrier object.\"\"\"\n\n    rm_system: str\n    \"\"\"Name of the revenue management system used by this carrier.\n\n    If using a callback-style RM system, this can be given as a dict\n    instead, in which case the `name` key is extracted and the rest of\n    the dict is stored in `rm_system_options`. If a `name` key is not found,\n    a validation error is raised.\n    \"\"\"\n\n    rm_system_options: dict[str, Any] | None | Literal[False] = None\n    \"\"\"Definition of the revenue management system used by this carrier.\n\n    This can be used to declare parameters for a callback-style RM systems.\n    If `None`, then old-style PassengerSim RM systems are used.\n    \"\"\"\n\n    control: str = \"\"\n    \"\"\"Deprecated.  No effect.\n\n    The control method for availability management is defined in the RM system,\n    not in the carrier.  This ensures that the correct control method is always\n    used for each RM system.\n    \"\"\"\n\n    cp_algorithm: Optional[Literal[\"BP\", \"CBC\", \"OPT\", \"CLASSLESS\"]] = None\n    \"\"\"Used to select continuous pricing.\n\n    The default is None, which means that continuous pricing is not used.\n    If set to \"BP\", then the continuous pricing is based on the bid price,\n    i.e. the fare of the continuous priced product offered to the customer\n    is equal to the bid price of the product, modified potentially by the\n    `cp_quantize` and/or `cp_bounds` settings.  If set to \"CBC\", then the\n    continuous price is set via a class-based continuous pricing algorithm,\n    which adjusts the price of the continuous priced product based on the\n    expected willingness to pay of the customer, as defined by the `frat5`\n    curve. In constrast to the \"BP\" algorithm, the \"CBC\" algorithm sets\n    the price of the continuous priced product to be equal to the bid price\n    plus the expected marginal revenue of the product,\n\n    OPT is an experimental algorithm that uses web-shopping (similar to Infare) and\n    a choice model to try and improve the expected contribution of an airline's offer(s)\n    \"\"\"\n\n    cp_record: Literal[\"highest_closed\", \"lowest_open\"] = \"highest_closed\"\n    \"\"\"Where to record sales of continuous-prices products.\n\n    When a sale is made of a product that is offered at some modified price,\n    (i.e., a continuous price), it can be recorded as a sale in the highest\n    closed class, or in the lowest open class.  This recording is relevant\n    when forecasting demand in the various fare classes.  If recording in the\n    lowest open class, no other adjustments are made to the recording, as we\n    are selling a fare class that is open.  If recording in the highest closed,\n    users should also review the `cp_record_highest_closed_as_open` setting,\n    which controls whether the highest closed fare class is recorded as \"open\"\n    in the history data, even though it otherwise would appear to be closed.\n    \"\"\"\n\n    cp_record_highest_closed_as_open: bool = False\n    \"\"\"Record the highest closed fare class as open.\n\n    When recording history data, by default the continuous pricing algorithm\n    is ignored when getting closure status of each fare at the end of each DCP.\n    If `cp_algorithm` is set to \"highest_closed\", then the highest closed fare\n    is actually being offered (with a modified price) to the customer, and the\n    carrier may want to record this fare as open in the history data.\n\n    This setting has no effect on the actual continuous pricing algorithm at the\n    time of making offers.  It only affects the history data that is recorded.\n    This setting is only used when `cp_record` is set to \"highest_closed\",\n    otherwise it has no effect.\n    \"\"\"\n\n    cp_quantize: int | None = 0\n    \"\"\"Controls quantization (rounding) for Continuous Pricing\n       Example: If you set it to 5, the price will be rounded to the nearest $5\"\"\"\n\n    cp_bounds: float = 1.0\n    \"\"\"DEPRECATED - Controls upper and lower bounds for continuous pricing.\n       Example:  Y1 fare = $400, Y2 fare = $300\n                 The difference is $100, and a 0.25 multiplier will set the lower bound\n                 for Y1 as $375 and the upper bound for Y2 as $325\"\"\"\n\n    cp_upper_bound: float = 1.0\n    \"\"\"Controls upper bound for continuous pricing.\n       Example:  If the highest fare, Y0 = $400,\n                 then a 1.1 multiplier will allow CP to go up to $440\"\"\"\n\n    cp_scale: float = 1.0\n    \"\"\"Continuous pricing modifier scale factor.\n    This is used to scale the fare modifier when using CBC.\n    Scales the fare modifier, which was computed using WTP\"\"\"\n\n    cp_elasticity: dict | None = None\n    \"\"\"Parameters to esimate customer price elasticity for CP\n         - Defaults to being off\n         - {'accuracy': 0.8, 'multiplier': 0.5} will guess 80% accurate and multiply\n             the Frat5 value for *leisure* by 0.5\n         - Other algorithms to come in the future :-) \"\"\"\n\n    frat5: str | None = \"\"\n    \"\"\"Name of the FRAT5 curve to use.\n\n    This is the default that will be applied if not found at a more detailed level.\n    If not specified, the default frat5 from the carrier's RM system is used.\n    \"\"\"\n\n    frat5_map: dict | None = {}\n    \"\"\"Experimenting with different Frat5 curves by market\"\"\"\n\n    fare_adjustment_scale: float | None = 1.0\n\n    load_factor_curve: Any | None = None\n    \"\"\"Named Load Factor curve.\n    This is the default that will be applied if not found at a more detailed level\n    \"\"\"\n\n    brand_preference: float | None = 1.0\n    \"\"\"Used for airline preference to give premium airlines a bump\"\"\"\n\n    ancillaries: dict[str, float] | None = {}\n    \"\"\"Specifies ancillaries offered by the carrier, codes are ANC1 .. ANC4\"\"\"\n\n    classes: list[str] | list[tuple[str, str]] = []\n    \"\"\"A list of fare classes.\n\n    This list can be a simple list of fare classes, or a list of 2-tuples where\n    the first element is the fare class and the second element is the cabin.\n\n    One convention is to use Y0, Y1, ... to label fare classes from the highest\n    fare (Y0) to the lowest fare (Yn).  You can also use Y, B, M, H,... etc.\n    An example of classes is below.\n\n    Example\n    -------\n    ```{yaml}\n    classes:\n      - Y0\n      - Y1\n      - Y2\n      - Y3\n      - Y4\n      - Y5\n    ```\n\n    If using cabins, it is reasonable to name the classes in consistent manner,\n    but this is optional, and arbitrary class names are still allowed. All class\n    names should still be unique, and cabin identifiers should be replicated\n    identically for classes that share a cabin.  Thus the list might look like this:\n\n    ```{yaml}\n    classes:\n      - (F0, F)\n      - (F1, F)\n      - (Y0, Y)\n      - (Y1, Y)\n      - (Y2, Y)\n      - (Y3, Y)\n    ```\n    \"\"\"\n\n    truncation_rule: Literal[1, 2, 3] = 3\n    \"\"\"How to handle marking truncation of demand in timeframes.\n\n    If 1, then the demand is marked as truncated if the bucket or pathclass is closed at\n    the DCP that is the beginning of the timeframe.\n\n    If 2, then the demand is marked as truncated if the bucket or pathclass is closed at\n    the DCP that is the end of the timeframe.\n\n    If 3, then the demand is marked as truncated if the bucket or pathclass is closed at\n    either of the DCPs that are at the beginning or the end of the timeframe.\n    \"\"\"\n\n    proration_rule: Literal[\"distance\", \"sqrt_distance\", \"off\"] = \"distance\"\n    \"\"\"How to prorate revenue to legs and buckets for connecting paths.\n\n    If \"distance\", then the revenue is prorated based on the relatives distance\n    of the legs.  So if the first leg is 100 miles and the second leg is 400 miles,\n    then the first leg gets 20% of the revenue and the second leg gets 80%.\n\n    If \"sqrt_distance\", then the revenue is prorated based on the relative square\n    root of distance of the legs.  So if the first leg is 100 miles and the\n    second leg is 400 miles, then the first leg gets 1/3 of the revenue and the\n    second leg gets 2/3.\n\n    If \"off\", then no proration is done, and each leg and bucket gets the full\n    revenue of the path. This will lead to double counting of revenue in legs,\n    but is useful for some analyses.\n    \"\"\"\n\n    history_length: int = 26\n    \"\"\"The number of samples to keep in the carrier's history buffers.\"\"\"\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _populate_rm_system_from_def(cls, values: Any):\n        \"\"\"Pre-process input mapping for rm_systems.\n\n        If `rm_system` is given as a dict instead of a string, extract the name\n        and put the rest of the dict into `rm_system_options`.\n\n        If `rm_system` is missing or empty, but `rm_system_options` is provided and\n        has a `name` key, copy that into `rm_system`.\n\n        This is a 'before' validator so it operates on the raw input data.\n        \"\"\"\n        try:\n            if isinstance(values, dict):\n                rm_system = values.get(\"rm_system\")\n                if isinstance(rm_system, dict):\n                    # if there is an existing rm_system_options, we need to merge it\n                    existing_def = values.get(\"rm_system_options\", {})\n                    # merge existing_def into rm_system, checking for conflicts\n                    for k, v in existing_def.items():\n                        if k in rm_system and rm_system[k] != v:\n                            raise ValueError(f\"Conflict merging rm_system and rm_system_options for key '{k}'\")\n                        if k not in rm_system:\n                            rm_system[k] = v\n                    # move the dict into rm_system_options\n                    values[\"rm_system_options\"] = rm_system\n                    # extract the name into rm_system\n                    if \"name\" in rm_system:\n                        values[\"rm_system\"] = rm_system[\"name\"]\n                    else:\n                        raise ValueError(\"`rm_system` dict must have a 'name' key\")\n                if not rm_system:\n                    rm_def = values.get(\"rm_system_options\")\n                    if isinstance(rm_def, dict) and \"name\" in rm_def:\n                        # copy the name into rm_system so the rest of the model\n                        # validation has a populated value\n                        values[\"rm_system\"] = rm_def[\"name\"]\n        except Exception:\n            # Keep behavior tolerant: if anything unexpected happens, don't\n            # raise here \u2014 let later validators raise clearer errors.\n            pass\n        return values\n\n    @model_validator(mode=\"after\")\n    def _check_rm_system_from_def(self) -&gt; Self:\n        \"\"\"Check that if `rm_system_options` is provided with a name, it matches.\"\"\"\n        if isinstance(self.rm_system_options, dict) and \"name\" in self.rm_system_options:\n            if self.rm_system != self.rm_system_options[\"name\"]:\n                raise ValueError(\n                    \"`rm_system` must match `rm_system_options['name']` if `rm_system_options` is provided\"\n                )\n        return self\n\n    @field_validator(\"cp_upper_bound\")\n    def _check_cp_upper_bound(cls, v: str):\n        x = float(v)\n        if x &lt; 0.0 or x &gt; 2.0:\n            warnings.warn(\"cp_upper_bound should be in the range (0, 2)\", stacklevel=2)\n        return v\n</code></pre>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.ancillaries", "title": "ancillaries  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>ancillaries: dict[str, float] | None = {}\n</code></pre> <p>Specifies ancillaries offered by the carrier, codes are ANC1 .. ANC4</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.brand_preference", "title": "brand_preference  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>brand_preference: float | None = 1.0\n</code></pre> <p>Used for airline preference to give premium airlines a bump</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.classes", "title": "classes  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>classes: list[str] | list[tuple[str, str]] = []\n</code></pre> <p>A list of fare classes.</p> <p>This list can be a simple list of fare classes, or a list of 2-tuples where the first element is the fare class and the second element is the cabin.</p> <p>One convention is to use Y0, Y1, ... to label fare classes from the highest fare (Y0) to the lowest fare (Yn).  You can also use Y, B, M, H,... etc. An example of classes is below.</p> Example <pre><code>classes:\n  - Y0\n  - Y1\n  - Y2\n  - Y3\n  - Y4\n  - Y5\n</code></pre> <p>If using cabins, it is reasonable to name the classes in consistent manner, but this is optional, and arbitrary class names are still allowed. All class names should still be unique, and cabin identifiers should be replicated identically for classes that share a cabin.  Thus the list might look like this:</p> <pre><code>classes:\n  - (F0, F)\n  - (F1, F)\n  - (Y0, Y)\n  - (Y1, Y)\n  - (Y2, Y)\n  - (Y3, Y)\n</code></pre>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.control", "title": "control  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>control: str = ''\n</code></pre> <p>Deprecated.  No effect.</p> <p>The control method for availability management is defined in the RM system, not in the carrier.  This ensures that the correct control method is always used for each RM system.</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.cp_algorithm", "title": "cp_algorithm  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cp_algorithm: Optional[\n    Literal[\"BP\", \"CBC\", \"OPT\", \"CLASSLESS\"]\n] = None\n</code></pre> <p>Used to select continuous pricing.</p> <p>The default is None, which means that continuous pricing is not used. If set to \"BP\", then the continuous pricing is based on the bid price, i.e. the fare of the continuous priced product offered to the customer is equal to the bid price of the product, modified potentially by the <code>cp_quantize</code> and/or <code>cp_bounds</code> settings.  If set to \"CBC\", then the continuous price is set via a class-based continuous pricing algorithm, which adjusts the price of the continuous priced product based on the expected willingness to pay of the customer, as defined by the <code>frat5</code> curve. In constrast to the \"BP\" algorithm, the \"CBC\" algorithm sets the price of the continuous priced product to be equal to the bid price plus the expected marginal revenue of the product,</p> <p>OPT is an experimental algorithm that uses web-shopping (similar to Infare) and a choice model to try and improve the expected contribution of an airline's offer(s)</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.cp_bounds", "title": "cp_bounds  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cp_bounds: float = 1.0\n</code></pre> <p>DEPRECATED - Controls upper and lower bounds for continuous pricing. Example:  Y1 fare = $400, Y2 fare = $300           The difference is $100, and a 0.25 multiplier will set the lower bound           for Y1 as $375 and the upper bound for Y2 as $325</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.cp_elasticity", "title": "cp_elasticity  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cp_elasticity: dict | None = None\n</code></pre> <p>Parameters to esimate customer price elasticity for CP - Defaults to being off - {'accuracy': 0.8, 'multiplier': 0.5} will guess 80% accurate and multiply     the Frat5 value for leisure by 0.5 - Other algorithms to come in the future :-)</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.cp_quantize", "title": "cp_quantize  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cp_quantize: int | None = 0\n</code></pre> <p>Controls quantization (rounding) for Continuous Pricing Example: If you set it to 5, the price will be rounded to the nearest $5</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.cp_record", "title": "cp_record  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cp_record: Literal[\"highest_closed\", \"lowest_open\"] = (\n    \"highest_closed\"\n)\n</code></pre> <p>Where to record sales of continuous-prices products.</p> <p>When a sale is made of a product that is offered at some modified price, (i.e., a continuous price), it can be recorded as a sale in the highest closed class, or in the lowest open class.  This recording is relevant when forecasting demand in the various fare classes.  If recording in the lowest open class, no other adjustments are made to the recording, as we are selling a fare class that is open.  If recording in the highest closed, users should also review the <code>cp_record_highest_closed_as_open</code> setting, which controls whether the highest closed fare class is recorded as \"open\" in the history data, even though it otherwise would appear to be closed.</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.cp_record_highest_closed_as_open", "title": "cp_record_highest_closed_as_open  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cp_record_highest_closed_as_open: bool = False\n</code></pre> <p>Record the highest closed fare class as open.</p> <p>When recording history data, by default the continuous pricing algorithm is ignored when getting closure status of each fare at the end of each DCP. If <code>cp_algorithm</code> is set to \"highest_closed\", then the highest closed fare is actually being offered (with a modified price) to the customer, and the carrier may want to record this fare as open in the history data.</p> <p>This setting has no effect on the actual continuous pricing algorithm at the time of making offers.  It only affects the history data that is recorded. This setting is only used when <code>cp_record</code> is set to \"highest_closed\", otherwise it has no effect.</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.cp_scale", "title": "cp_scale  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cp_scale: float = 1.0\n</code></pre> <p>Continuous pricing modifier scale factor. This is used to scale the fare modifier when using CBC. Scales the fare modifier, which was computed using WTP</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.cp_upper_bound", "title": "cp_upper_bound  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cp_upper_bound: float = 1.0\n</code></pre> <p>Controls upper bound for continuous pricing. Example:  If the highest fare, Y0 = $400,           then a 1.1 multiplier will allow CP to go up to $440</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.fare_adjustment_scale", "title": "fare_adjustment_scale  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>fare_adjustment_scale: float | None = 1.0\n</code></pre>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.frat5", "title": "frat5  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frat5: str | None = ''\n</code></pre> <p>Name of the FRAT5 curve to use.</p> <p>This is the default that will be applied if not found at a more detailed level. If not specified, the default frat5 from the carrier's RM system is used.</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.frat5_map", "title": "frat5_map  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frat5_map: dict | None = {}\n</code></pre> <p>Experimenting with different Frat5 curves by market</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.history_length", "title": "history_length  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>history_length: int = 26\n</code></pre> <p>The number of samples to keep in the carrier's history buffers.</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.load_factor_curve", "title": "load_factor_curve  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>load_factor_curve: Any | None = None\n</code></pre> <p>Named Load Factor curve. This is the default that will be applied if not found at a more detailed level</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.proration_rule", "title": "proration_rule  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>proration_rule: Literal[\n    \"distance\", \"sqrt_distance\", \"off\"\n] = \"distance\"\n</code></pre> <p>How to prorate revenue to legs and buckets for connecting paths.</p> <p>If \"distance\", then the revenue is prorated based on the relatives distance of the legs.  So if the first leg is 100 miles and the second leg is 400 miles, then the first leg gets 20% of the revenue and the second leg gets 80%.</p> <p>If \"sqrt_distance\", then the revenue is prorated based on the relative square root of distance of the legs.  So if the first leg is 100 miles and the second leg is 400 miles, then the first leg gets 1/3 of the revenue and the second leg gets 2/3.</p> <p>If \"off\", then no proration is done, and each leg and bucket gets the full revenue of the path. This will lead to double counting of revenue in legs, but is useful for some analyses.</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.rm_system", "title": "rm_system  <code>instance-attribute</code>", "text": "<pre><code>rm_system: str\n</code></pre> <p>Name of the revenue management system used by this carrier.</p> <p>If using a callback-style RM system, this can be given as a dict instead, in which case the <code>name</code> key is extracted and the rest of the dict is stored in <code>rm_system_options</code>. If a <code>name</code> key is not found, a validation error is raised.</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.rm_system_options", "title": "rm_system_options  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>rm_system_options: (\n    dict[str, Any] | None | Literal[False]\n) = None\n</code></pre> <p>Definition of the revenue management system used by this carrier.</p> <p>This can be used to declare parameters for a callback-style RM systems. If <code>None</code>, then old-style PassengerSim RM systems are used.</p>"}, {"location": "API/config/carriers.html#passengersim.config.carriers.Carrier.truncation_rule", "title": "truncation_rule  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>truncation_rule: Literal[1, 2, 3] = 3\n</code></pre> <p>How to handle marking truncation of demand in timeframes.</p> <p>If 1, then the demand is marked as truncated if the bucket or pathclass is closed at the DCP that is the beginning of the timeframe.</p> <p>If 2, then the demand is marked as truncated if the bucket or pathclass is closed at the DCP that is the end of the timeframe.</p> <p>If 3, then the demand is marked as truncated if the bucket or pathclass is closed at either of the DCPs that are at the beginning or the end of the timeframe.</p>"}, {"location": "API/config/choice_model.html", "title": "Choice Models", "text": ""}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.ChoiceModel", "title": "ChoiceModel  <code>module-attribute</code>", "text": "<pre><code>ChoiceModel = Annotated[\n    PodsChoiceModel | LogitChoiceModel,\n    Field(discriminator=\"kind\"),\n]\n</code></pre> <p>Two types of choice models are available in PassengerSim.</p> <p>Use the <code>kind</code> key to select which kind of choice model you wish to parameterize.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.TwoFloats", "title": "TwoFloats  <code>module-attribute</code>", "text": "<pre><code>TwoFloats = SerializeAsAny[tuple[float, float] | None]\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.CommonChoiceModel", "title": "CommonChoiceModel", "text": "<p>               Bases: <code>Named</code></p> <p>A common base class for choice models.</p> <p>Defines restrictions and other parameters that are common to all choice models.</p> Source code in <code>passengersim/config/choice_model.py</code> <pre><code>class CommonChoiceModel(Named, extra=\"forbid\"):\n    \"\"\"A common base class for choice models.\n\n    Defines restrictions and other parameters that are common to all\n    choice models.\"\"\"\n\n    restrictions: dict[str, float] | None = None\n\n    @property\n    def r1(self):\n        \"\"\"Restriction 1.\n        This is deprecated in favor of the `restrictions` dictionary.\"\"\"\n        return self.restrictions.get(\"r1\", None)\n\n    @r1.setter\n    def r1(self, value: float):\n        self.restrictions[\"r1\"] = value\n\n    @property\n    def r2(self):\n        \"\"\"Restriction 2.\n        This is deprecated in favor of the `restrictions` dictionary.\"\"\"\n        return self.restrictions.get(\"r2\", None)\n\n    @r2.setter\n    def r2(self, value: float):\n        self.restrictions[\"r2\"] = value\n\n    @property\n    def r3(self):\n        \"\"\"Restriction 3.\n        This is deprecated in favor of the `restrictions` dictionary.\"\"\"\n        return self.restrictions.get(\"r3\", None)\n\n    @r3.setter\n    def r3(self, value: float):\n        self.restrictions[\"r3\"] = value\n\n    @property\n    def r4(self):\n        \"\"\"Restriction 4.\n        This is deprecated in favor of the `restrictions` dictionary.\"\"\"\n        return self.restrictions.get(\"r4\", None)\n\n    @r4.setter\n    def r4(self, value: float):\n        self.restrictions[\"r4\"] = value\n\n    @property\n    def r5(self):\n        \"\"\"Restriction 5.\n        This is deprecated in favor of the `restrictions` dictionary.\"\"\"\n        return self.restrictions.get(\"r5\", None)\n\n    @r4.setter\n    def r5(self, value: float):\n        self.restrictions[\"r5\"] = value\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _named_restrictions(cls, data: Any) -&gt; Any:\n        restricts = data.get(\"restrictions\", {})\n        if \"r1\" in data:\n            restricts[\"r1\"] = data.pop(\"r1\")\n        if \"r2\" in data:\n            restricts[\"r2\"] = data.pop(\"r2\")\n        if \"r3\" in data:\n            restricts[\"r3\"] = data.pop(\"r3\")\n        if \"r4\" in data:\n            restricts[\"r4\"] = data.pop(\"r4\")\n        data[\"restrictions\"] = restricts\n        return data\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.CommonChoiceModel.r1", "title": "r1  <code>property</code> <code>writable</code>", "text": "<pre><code>r1\n</code></pre> <p>Restriction 1. This is deprecated in favor of the <code>restrictions</code> dictionary.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.CommonChoiceModel.r2", "title": "r2  <code>property</code> <code>writable</code>", "text": "<pre><code>r2\n</code></pre> <p>Restriction 2. This is deprecated in favor of the <code>restrictions</code> dictionary.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.CommonChoiceModel.r3", "title": "r3  <code>property</code> <code>writable</code>", "text": "<pre><code>r3\n</code></pre> <p>Restriction 3. This is deprecated in favor of the <code>restrictions</code> dictionary.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.CommonChoiceModel.r4", "title": "r4  <code>property</code> <code>writable</code>", "text": "<pre><code>r4\n</code></pre> <p>Restriction 4. This is deprecated in favor of the <code>restrictions</code> dictionary.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.CommonChoiceModel.restrictions", "title": "restrictions  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>restrictions: dict[str, float] | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.CommonChoiceModel.r5", "title": "r5", "text": "<pre><code>r5(value: float)\n</code></pre> Source code in <code>passengersim/config/choice_model.py</code> <pre><code>@r4.setter\ndef r5(self, value: float):\n    self.restrictions[\"r5\"] = value\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel", "title": "LogitChoiceModel", "text": "<p>               Bases: <code>CommonChoiceModel</code></p> Source code in <code>passengersim/config/choice_model.py</code> <pre><code>class LogitChoiceModel(CommonChoiceModel, extra=\"forbid\"):\n    kind: Literal[\"logit\"]\n\n    emult: float | None = None\n    \"\"\"Using for WTP, a bit of a quick and dirty until we have a better approach\"\"\"\n\n    anc1_relevance: float | None = None\n    anc2_relevance: float | None = None\n    anc3_relevance: float | None = None\n    anc4_relevance: float | None = None\n\n    intercept: float = 0\n    \"\"\"This is the alternative specific constant for the no-purchase alternative.\"\"\"\n\n    nonstop: float = 0\n    duration: float = 0\n    price: float = 0\n    \"\"\"This is the parameter for the price of each alternative.\"\"\"\n\n    tod_sin2p: float = 0\n    r\"\"\"Schedule parameter.\n\n    If $t$ is departure time (in minutes after midnight local time) divided\n    by 1440, this parameter is multiplied by $sin( 2 \\pi t)$ and the result is\n    added to the utility of the particular alternative.\"\"\"\n\n    tod_sin4p: float = 0\n    r\"\"\"Schedule parameter.\n\n    If $t$ is departure time (in minutes after midnight local time) divided\n    by 1440, this parameter is multiplied by $sin( 4 \\pi t)$ and the result is\n    added to the utility of the particular alternative.\"\"\"\n\n    tod_sin6p: float = 0\n    tod_cos2p: float = 0\n    tod_cos4p: float = 0\n    tod_cos6p: float = 0\n    free_bag: float = 0\n    early_boarding: float = 0\n    same_day_change: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.anc1_relevance", "title": "anc1_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc1_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.anc2_relevance", "title": "anc2_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc2_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.anc3_relevance", "title": "anc3_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc3_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.anc4_relevance", "title": "anc4_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc4_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.duration", "title": "duration  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>duration: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.early_boarding", "title": "early_boarding  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>early_boarding: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.emult", "title": "emult  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>emult: float | None = None\n</code></pre> <p>Using for WTP, a bit of a quick and dirty until we have a better approach</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.free_bag", "title": "free_bag  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>free_bag: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.intercept", "title": "intercept  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>intercept: float = 0\n</code></pre> <p>This is the alternative specific constant for the no-purchase alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.kind", "title": "kind  <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['logit']\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.nonstop", "title": "nonstop  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>nonstop: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.price", "title": "price  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>price: float = 0\n</code></pre> <p>This is the parameter for the price of each alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.same_day_change", "title": "same_day_change  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>same_day_change: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_cos2p", "title": "tod_cos2p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_cos2p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_cos4p", "title": "tod_cos4p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_cos4p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_cos6p", "title": "tod_cos6p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_cos6p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_sin2p", "title": "tod_sin2p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_sin2p: float = 0\n</code></pre> <p>Schedule parameter.</p> <p>If \\(t\\) is departure time (in minutes after midnight local time) divided by 1440, this parameter is multiplied by \\(sin( 2 \\pi t)\\) and the result is added to the utility of the particular alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_sin4p", "title": "tod_sin4p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_sin4p: float = 0\n</code></pre> <p>Schedule parameter.</p> <p>If \\(t\\) is departure time (in minutes after midnight local time) divided by 1440, this parameter is multiplied by \\(sin( 4 \\pi t)\\) and the result is added to the utility of the particular alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_sin6p", "title": "tod_sin6p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_sin6p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel", "title": "PodsChoiceModel", "text": "<p>               Bases: <code>CommonChoiceModel</code></p> Source code in <code>passengersim/config/choice_model.py</code> <pre><code>class PodsChoiceModel(CommonChoiceModel, extra=\"forbid\"):\n    kind: Literal[\"pods\"]\n\n    emult: float | None = None\n\n    basefare_mult: float | None = None\n    basefare_mult2: float | None = 1.0\n    connect_disutility: float | None = None\n    path_quality: TwoFloats = None\n    airline_pref_pods: TwoFloats = None\n    airline_pref_hhi: TwoFloats = None\n    airline_pref_seat_share: TwoFloats = None\n    elapsed_time: TwoFloats = None\n    buffer_threshold: int | None = None\n    buffer_time: TwoFloats = None\n    tolerance: float | None = None\n    non_stop_multiplier: float | None = None\n    connection_multiplier: float | None = None\n\n    # DWM info\n    todd_curve: str | None = None\n    early_dep: dict | None = None\n    late_arr: dict | None = None\n    replanning: TwoFloats = None\n\n    # Ancillaries\n    anc1_relevance: float | None = None\n    anc2_relevance: float | None = None\n    anc3_relevance: float | None = None\n    anc4_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.airline_pref_hhi", "title": "airline_pref_hhi  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>airline_pref_hhi: TwoFloats = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.airline_pref_pods", "title": "airline_pref_pods  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>airline_pref_pods: TwoFloats = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.airline_pref_seat_share", "title": "airline_pref_seat_share  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>airline_pref_seat_share: TwoFloats = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.anc1_relevance", "title": "anc1_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc1_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.anc2_relevance", "title": "anc2_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc2_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.anc3_relevance", "title": "anc3_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc3_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.anc4_relevance", "title": "anc4_relevance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>anc4_relevance: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.basefare_mult", "title": "basefare_mult  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>basefare_mult: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.basefare_mult2", "title": "basefare_mult2  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>basefare_mult2: float | None = 1.0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.buffer_threshold", "title": "buffer_threshold  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>buffer_threshold: int | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.buffer_time", "title": "buffer_time  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>buffer_time: TwoFloats = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.connect_disutility", "title": "connect_disutility  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>connect_disutility: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.connection_multiplier", "title": "connection_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>connection_multiplier: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.early_dep", "title": "early_dep  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>early_dep: dict | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.elapsed_time", "title": "elapsed_time  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>elapsed_time: TwoFloats = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.emult", "title": "emult  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>emult: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.kind", "title": "kind  <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['pods']\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.late_arr", "title": "late_arr  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>late_arr: dict | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.non_stop_multiplier", "title": "non_stop_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>non_stop_multiplier: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.path_quality", "title": "path_quality  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>path_quality: TwoFloats = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.replanning", "title": "replanning  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>replanning: TwoFloats = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.todd_curve", "title": "todd_curve  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>todd_curve: str | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.tolerance", "title": "tolerance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tolerance: float | None = None\n</code></pre>"}, {"location": "API/config/circuity_rules.html", "title": "Circuity rules", "text": ""}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule", "title": "CircuityRule", "text": "<p>               Bases: <code>Named</code></p> Source code in <code>passengersim/config/circuity_rules.py</code> <pre><code>class CircuityRule(Named, extra=\"forbid\"):\n    carrier: str | None = None\n    orig_airport: str | None = None\n    connect_airport: str | None = None\n    dest_airport: str | None = None\n    orig_state: str | None = None\n    dest_state: str | None = None\n\n    # The max circuity will be:  alpha + beta * market_distance\n    # To make it unlimited, set a really high beta value, like 1000.0\n    # To prohibit a conection, set alpha and beta to 0.0\n    alpha: float\n    beta: float\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.alpha", "title": "alpha  <code>instance-attribute</code>", "text": "<pre><code>alpha: float\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.beta", "title": "beta  <code>instance-attribute</code>", "text": "<pre><code>beta: float\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.carrier", "title": "carrier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier: str | None = None\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.connect_airport", "title": "connect_airport  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>connect_airport: str | None = None\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.dest_airport", "title": "dest_airport  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dest_airport: str | None = None\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.dest_state", "title": "dest_state  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dest_state: str | None = None\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.orig_airport", "title": "orig_airport  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>orig_airport: str | None = None\n</code></pre>"}, {"location": "API/config/circuity_rules.html#passengersim.config.circuity_rules.CircuityRule.orig_state", "title": "orig_state  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>orig_state: str | None = None\n</code></pre>"}, {"location": "API/config/database.html", "title": "Database", "text": ""}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig", "title": "DatabaseConfig", "text": "<p>               Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/database.py</code> <pre><code>class DatabaseConfig(PrettyModel, extra=\"forbid\", validate_assignment=True):\n    engine: Literal[\"sqlite\", \"mysql\", None] = \"sqlite\"\n    \"\"\"Database engine to use.\n\n    Currently only `sqlite` is fully implemented.\"\"\"\n\n    filename: pathlib.Path | None = \"passengersim-output.sqlite\"\n    \"\"\"Name of file for SQLite output.\n\n    When using the sqlite engine, an in-memory database can be created by\n    setting this to ':memory:'.  Note that in-memory databases are not\n    persistent and will be lost when the database connection is closed.  Also,\n    in-memory databases cannot be shared between multiple processes.  When\n    using multiprocessing, all database operations must be performed in the\n    same process that created the database connection. Be sure to run summary\n    queries before closing the database connection, by identifying all database\n    summary tables in the `outputs.reports` configuration option.\n    \"\"\"\n\n    fast: bool = False\n    \"\"\"Whether to use pre-compiled SQL write instructions.\"\"\"\n\n    pragmas: list[str] = []\n    \"\"\"A list of PRAGMA commands to execute upon opening a database connection.\"\"\"\n\n    commit_count_delay: int | None = 250\n    \"\"\"Commit transactions to the database will only be honored this frequently.\n\n    By setting this number greater than 1, the transaction frequency will be reduced,\n    improving overall runtime performance by storing more data in RAM and writing to\n    persistent storage less frequently.\n    \"\"\"\n\n    write_items: set[\n        Literal[\n            \"leg\",\n            \"bucket\",\n            \"edgar\",\n            \"fare\",\n            \"demand\",\n            \"leg_daily\",\n            \"leg_final\",\n            \"bucket_final\",\n            \"fare_final\",\n            \"demand_final\",\n            \"bookings\",\n            \"pathclass\",\n            \"pathclass_daily\",\n            \"pathclass_final\",\n        ]\n    ] = {\"leg_final\", \"fare_final\", \"demand_final\", \"bookings\"}\n    \"\"\"Which items should be written to the database.\n\n    The following values can be provided in this set:\n\n    - *leg*: write every leg to the `leg_detail` table at every DCP.\n    - *leg_final*: write every leg to the `leg_detail` table only at DCP 0.\n    - *bucket*: write every leg bucket to the `leg_bucket_detail` table at every DCP.\n    - *bucket_final*: write every leg bucket to the `leg_bucket_detail` table only\n        at DCP 0.\n    - *fare*: write every fare to the `fare_detail` table at every DCP.\n    - *fare_final*: write every fare to the `fare_detail` table only at DCP 0.\n    - *demand*: write every demand to the `demand_detail` table at every DCP.\n    - *bookings*: store booking summary data at every DCP and write an aggregate\n        summary of bookings by DCP to the `bookings_by_timeframe` table at the end\n        of the simulation.\n    \"\"\"\n\n    dcp_write_hooks: list[Callable] = []\n    \"\"\"Additional callable functions that write to the database at each DCP.\n\n    Each should have a signature matching `f(db, sim, dcp)`.\n    \"\"\"\n\n    @field_validator(\"engine\", mode=\"before\")\n    def _interpret_none(cls, v):\n        \"\"\"Allow engine to be \"none\".\"\"\"\n        if isinstance(v, str) and v.lower() == \"none\":\n            v = None\n        return v\n\n    store_leg_bid_prices: bool = True\n    \"\"\"Should leg bid prices be stored in the database.\"\"\"\n\n    store_displacements: bool = True\n    \"\"\"Should leg displacements be stored in the database.\"\"\"\n</code></pre>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.commit_count_delay", "title": "commit_count_delay  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>commit_count_delay: int | None = 250\n</code></pre> <p>Commit transactions to the database will only be honored this frequently.</p> <p>By setting this number greater than 1, the transaction frequency will be reduced, improving overall runtime performance by storing more data in RAM and writing to persistent storage less frequently.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.dcp_write_hooks", "title": "dcp_write_hooks  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcp_write_hooks: list[Callable] = []\n</code></pre> <p>Additional callable functions that write to the database at each DCP.</p> <p>Each should have a signature matching <code>f(db, sim, dcp)</code>.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.engine", "title": "engine  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>engine: Literal['sqlite', 'mysql', None] = 'sqlite'\n</code></pre> <p>Database engine to use.</p> <p>Currently only <code>sqlite</code> is fully implemented.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.fast", "title": "fast  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>fast: bool = False\n</code></pre> <p>Whether to use pre-compiled SQL write instructions.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.filename", "title": "filename  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>filename: Path | None = 'passengersim-output.sqlite'\n</code></pre> <p>Name of file for SQLite output.</p> <p>When using the sqlite engine, an in-memory database can be created by setting this to ':memory:'.  Note that in-memory databases are not persistent and will be lost when the database connection is closed.  Also, in-memory databases cannot be shared between multiple processes.  When using multiprocessing, all database operations must be performed in the same process that created the database connection. Be sure to run summary queries before closing the database connection, by identifying all database summary tables in the <code>outputs.reports</code> configuration option.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.pragmas", "title": "pragmas  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>pragmas: list[str] = []\n</code></pre> <p>A list of PRAGMA commands to execute upon opening a database connection.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.store_displacements", "title": "store_displacements  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>store_displacements: bool = True\n</code></pre> <p>Should leg displacements be stored in the database.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.store_leg_bid_prices", "title": "store_leg_bid_prices  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>store_leg_bid_prices: bool = True\n</code></pre> <p>Should leg bid prices be stored in the database.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.write_items", "title": "write_items  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>write_items: set[\n    Literal[\n        \"leg\",\n        \"bucket\",\n        \"edgar\",\n        \"fare\",\n        \"demand\",\n        \"leg_daily\",\n        \"leg_final\",\n        \"bucket_final\",\n        \"fare_final\",\n        \"demand_final\",\n        \"bookings\",\n        \"pathclass\",\n        \"pathclass_daily\",\n        \"pathclass_final\",\n    ]\n] = {\"leg_final\", \"fare_final\", \"demand_final\", \"bookings\"}\n</code></pre> <p>Which items should be written to the database.</p> <p>The following values can be provided in this set:</p> <ul> <li>leg: write every leg to the <code>leg_detail</code> table at every DCP.</li> <li>leg_final: write every leg to the <code>leg_detail</code> table only at DCP 0.</li> <li>bucket: write every leg bucket to the <code>leg_bucket_detail</code> table at every DCP.</li> <li>bucket_final: write every leg bucket to the <code>leg_bucket_detail</code> table only     at DCP 0.</li> <li>fare: write every fare to the <code>fare_detail</code> table at every DCP.</li> <li>fare_final: write every fare to the <code>fare_detail</code> table only at DCP 0.</li> <li>demand: write every demand to the <code>demand_detail</code> table at every DCP.</li> <li>bookings: store booking summary data at every DCP and write an aggregate     summary of bookings by DCP to the <code>bookings_by_timeframe</code> table at the end     of the simulation.</li> </ul>"}, {"location": "API/config/dataframes.html", "title": "Dataframes", "text": ""}, {"location": "API/config/dataframes.html#passengersim.config.dataframes.booking_curves_to_dataframe", "title": "booking_curves_to_dataframe", "text": "<pre><code>booking_curves_to_dataframe(\n    booking_curves: dict[str, BookingCurve],\n    add_zero_days: bool = True,\n) -&gt; DataFrame\n</code></pre> <p>Convert booking curves from the config into a pandas DataFrame.</p> Source code in <code>passengersim/config/dataframes.py</code> <pre><code>def booking_curves_to_dataframe(booking_curves: dict[str, BookingCurve], add_zero_days: bool = True) -&gt; pd.DataFrame:\n    \"\"\"Convert booking curves from the config into a pandas DataFrame.\"\"\"\n    data = []\n    curve_names = set()\n    for curve_name, curve_def in booking_curves.items():\n        for days_prior, proportion in curve_def.curve.items():\n            data.append(\n                {\n                    \"curve_name\": curve_name,\n                    \"days_prior\": days_prior,\n                    \"proportion\": proportion,\n                }\n            )\n            curve_names.add(curve_name)\n    if add_zero_days:\n        for curve_name in curve_names:\n            data.append(\n                {\n                    \"curve_name\": curve_name,\n                    \"days_prior\": 0,\n                    \"proportion\": 1.0,\n                }\n            )\n    return pd.DataFrame(data).drop_duplicates().sort_values(by=[\"curve_name\", \"days_prior\"], ascending=[True, False])\n</code></pre>"}, {"location": "API/config/dataframes.html#passengersim.config.dataframes.demands_to_dataframe", "title": "demands_to_dataframe", "text": "<pre><code>demands_to_dataframe(demands: list[Demand]) -&gt; DataFrame\n</code></pre> <p>Convert a list of Demand objects into a pandas DataFrame.</p> Source code in <code>passengersim/config/dataframes.py</code> <pre><code>def demands_to_dataframe(demands: list[Demand]) -&gt; pd.DataFrame:\n    \"\"\"Convert a list of Demand objects into a pandas DataFrame.\"\"\"\n    data = []\n    for demand in demands:\n        data.append(\n            {\n                \"orig\": demand.orig,\n                \"dest\": demand.dest,\n                \"segment\": demand.segment,\n                \"base_demand\": demand.base_demand,\n                \"reference_fare\": demand.reference_fare,\n                \"distance\": demand.distance,\n                \"choice_model\": demand.choice_model,\n                \"dwm_tolerance\": demand.dwm_tolerance,\n                \"todd_curve\": demand.todd_curve,\n                \"curve\": demand.curve,\n                \"group_sizes\": demand.group_sizes,\n                \"prob_saturday_night\": demand.prob_saturday_night,\n                \"prob_num_days\": demand.prob_num_days,\n                \"deterministic\": demand.deterministic,\n            }\n        )\n    return pd.DataFrame(data)\n</code></pre>"}, {"location": "API/config/dataframes.html#passengersim.config.dataframes.fares_to_dataframe", "title": "fares_to_dataframe", "text": "<pre><code>fares_to_dataframe(fares: list[Fare]) -&gt; DataFrame\n</code></pre> <p>Convert a list of fares into a pandas DataFrame.</p> Source code in <code>passengersim/config/dataframes.py</code> <pre><code>def fares_to_dataframe(fares: list[Fare]) -&gt; pd.DataFrame:\n    \"\"\"Convert a list of fares into a pandas DataFrame.\"\"\"\n    data = []\n    for fare in fares:\n        data.append(\n            {\n                \"carrier\": fare.carrier,\n                \"orig\": fare.orig,\n                \"dest\": fare.dest,\n                \"booking_class\": fare.booking_class,\n                \"price\": fare.price,\n                \"advance_purchase\": fare.advance_purchase,\n                \"restrictions\": \"|\".join(fare.restrictions),\n                \"category\": fare.category,\n                \"cabin\": fare.cabin,\n                \"min_stay\": fare.min_stay,\n                \"saturday_night_required\": fare.saturday_night_required,\n            }\n        )\n    return pd.DataFrame(data)\n</code></pre>"}, {"location": "API/config/dataframes.html#passengersim.config.dataframes.legs_to_dataframe", "title": "legs_to_dataframe", "text": "<pre><code>legs_to_dataframe(legs: list[Leg]) -&gt; DataFrame\n</code></pre> <p>Convert a list of Leg objects into a pandas DataFrame.</p> Source code in <code>passengersim/config/dataframes.py</code> <pre><code>def legs_to_dataframe(legs: list[Leg]) -&gt; pd.DataFrame:\n    \"\"\"Convert a list of Leg objects into a pandas DataFrame.\"\"\"\n    data = []\n    for leg in legs:\n        data.append(\n            {\n                \"leg_id\": leg.leg_id if leg.leg_id is not None else leg.fltno,\n                \"orig\": leg.orig,\n                \"dest\": leg.dest,\n                \"orig_timezone\": leg.orig_timezone,\n                \"dest_timezone\": leg.dest_timezone,\n                \"carrier\": leg.carrier,\n                \"distance\": leg.distance,\n                \"capacity\": leg.capacity,\n                \"date\": leg.date,\n                \"dep_time\": leg.dep_time,\n                \"arr_time\": leg.arr_time,\n                \"dep_time_offset\": leg.dep_time_offset,\n                \"arr_time_offset\": leg.arr_time_offset,\n                \"time_adjusted\": leg.time_adjusted,\n                \"dep_hour_local\": leg.dep_localtime.hour + leg.dep_localtime.minute / 60.0,\n                \"arr_hour_local\": leg.arr_localtime.hour + leg.arr_localtime.minute / 60.0,\n                \"duration_minutes\": (leg.arr_time - leg.dep_time) / 60.0 if leg.arr_time and leg.dep_time else None,\n            }\n        )\n    return pd.DataFrame(data)\n</code></pre>"}, {"location": "API/config/demands.html", "title": "Demands", "text": ""}, {"location": "API/config/demands.html#passengersim.config.demands.Demand", "title": "Demand", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/demands.py</code> <pre><code>class Demand(BaseModel, extra=\"forbid\"):\n    orig: str\n    \"\"\"Origin location for this demand.\n\n    This is commonly a three letter airport code, but it need not be limited\n    to airports.  It can be any location that is relevant to the simulation.\n\n    If using 'places' for locations, this should match the 'name' field of\n    a Place object.\"\"\"\n\n    dest: str\n    \"\"\"Destination location for this demand.\n\n    This is commonly a three letter airport code, but it need not be limited\n    to airports.  It can be any location that is relevant to the simulation.\n\n    If using 'places' for locations, this should match the 'name' field of\n    a Place object.\"\"\"\n\n    segment: str\n    \"\"\"Customer segment that this demand belongs to.\n\n    For many applications, segments include 'business' and 'leisure', but\n    they are not limited to these two categories.\"\"\"\n\n    @property\n    def identifier(self):\n        \"\"\"Unique identifier for this demand.\"\"\"\n        return f\"{self.orig}~{self.dest}@{self.segment}\"\n\n    base_demand: float\n    reference_fare: float\n    distance: float | None = 0.0\n    choice_model: str | None = None\n    \"\"\"The name of the choice model that is applied for this demand.\"\"\"\n\n    dwm_tolerance: float | None = 0.0\n    \"\"\"The Decision Window is the shortest elapsed time, plus the tolerance (random draw).\"\"\"\n\n    todd_curve: str | None = None\n    \"\"\"Time Of Day curve to be used in the choice model.  These\n       can vary by length of haul, day of week, E-W directionality, etc.\n       If specified here, it will override the curve in the ChoiceModel\"\"\"\n\n    curve: str | None = None\n    \"\"\"The name of the booking curve that is applied for this demand.\n\n    Each demand is attached to a booking curve that describes the temporal\n    distribution of customer arrivals.\"\"\"\n\n    group_sizes: list[float] | None = None\n    \"\"\"Probability of each group size.\n    i.e. [0.5, 0.3, 0.2] will give 50% one pax, 30% 2 pax, etc\"\"\"\n\n    prob_saturday_night: float = False\n    \"\"\"Probability that the customer has a R/T itinerary with a Saturday night stay.\n       Using this for choice modeling and CP experiments\"\"\"\n\n    prob_num_days: list[float] = []\n    \"\"\"Probability of durations.\n       [0.1, 0.3, 0.4, 0.2] will have durations of 1, 2, 3, 4 days\n       and probability of each is specified explicitly\n       Using this for choice modeling and CP experiments\"\"\"\n\n    deterministic: bool = False\n    \"\"\"Whether the total amount of demand generated in each sample should be constant.\n\n    If this is true, there will be no variance in the total demand generated,\n    Which will be equal to the base demand modified by any market multipliers.\n    There still can be some randomness in the timeframe arrival distribution of\n    this demand, but the total demand generated in each sample will be the same.\n    \"\"\"\n\n    overrides: list[DemandOverride] = []\n    \"\"\"Used for some specialized tests.\n       Each dictionary should have 'carrier', 'discount_pct' and 'pref_adj'\"\"\"\n\n    @property\n    def choice_model_(self):\n        \"\"\"Choice model, falling back to segment name if not set explicitly.\"\"\"\n        return self.choice_model or self.segment\n\n    @field_validator(\"curve\", mode=\"before\")\n    def curve_integer_name(cls, v):\n        \"\"\"Booking curves can have integer names, treat as string.\"\"\"\n        if isinstance(v, int):\n            v = str(v)\n        return v\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.base_demand", "title": "base_demand  <code>instance-attribute</code>", "text": "<pre><code>base_demand: float\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.choice_model", "title": "choice_model  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>choice_model: str | None = None\n</code></pre> <p>The name of the choice model that is applied for this demand.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.choice_model_", "title": "choice_model_  <code>property</code>", "text": "<pre><code>choice_model_\n</code></pre> <p>Choice model, falling back to segment name if not set explicitly.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.curve", "title": "curve  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>curve: str | None = None\n</code></pre> <p>The name of the booking curve that is applied for this demand.</p> <p>Each demand is attached to a booking curve that describes the temporal distribution of customer arrivals.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre> <p>Destination location for this demand.</p> <p>This is commonly a three letter airport code, but it need not be limited to airports.  It can be any location that is relevant to the simulation.</p> <p>If using 'places' for locations, this should match the 'name' field of a Place object.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.deterministic", "title": "deterministic  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>deterministic: bool = False\n</code></pre> <p>Whether the total amount of demand generated in each sample should be constant.</p> <p>If this is true, there will be no variance in the total demand generated, Which will be equal to the base demand modified by any market multipliers. There still can be some randomness in the timeframe arrival distribution of this demand, but the total demand generated in each sample will be the same.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.distance", "title": "distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>distance: float | None = 0.0\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.dwm_tolerance", "title": "dwm_tolerance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dwm_tolerance: float | None = 0.0\n</code></pre> <p>The Decision Window is the shortest elapsed time, plus the tolerance (random draw).</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.group_sizes", "title": "group_sizes  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>group_sizes: list[float] | None = None\n</code></pre> <p>Probability of each group size. i.e. [0.5, 0.3, 0.2] will give 50% one pax, 30% 2 pax, etc</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.identifier", "title": "identifier  <code>property</code>", "text": "<pre><code>identifier\n</code></pre> <p>Unique identifier for this demand.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre> <p>Origin location for this demand.</p> <p>This is commonly a three letter airport code, but it need not be limited to airports.  It can be any location that is relevant to the simulation.</p> <p>If using 'places' for locations, this should match the 'name' field of a Place object.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.overrides", "title": "overrides  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>overrides: list[DemandOverride] = []\n</code></pre> <p>Used for some specialized tests. Each dictionary should have 'carrier', 'discount_pct' and 'pref_adj'</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.prob_num_days", "title": "prob_num_days  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>prob_num_days: list[float] = []\n</code></pre> <p>Probability of durations. [0.1, 0.3, 0.4, 0.2] will have durations of 1, 2, 3, 4 days and probability of each is specified explicitly Using this for choice modeling and CP experiments</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.prob_saturday_night", "title": "prob_saturday_night  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>prob_saturday_night: float = False\n</code></pre> <p>Probability that the customer has a R/T itinerary with a Saturday night stay. Using this for choice modeling and CP experiments</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.reference_fare", "title": "reference_fare  <code>instance-attribute</code>", "text": "<pre><code>reference_fare: float\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.segment", "title": "segment  <code>instance-attribute</code>", "text": "<pre><code>segment: str\n</code></pre> <p>Customer segment that this demand belongs to.</p> <p>For many applications, segments include 'business' and 'leisure', but they are not limited to these two categories.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.todd_curve", "title": "todd_curve  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>todd_curve: str | None = None\n</code></pre> <p>Time Of Day curve to be used in the choice model.  These can vary by length of haul, day of week, E-W directionality, etc. If specified here, it will override the curve in the ChoiceModel</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.curve_integer_name", "title": "curve_integer_name", "text": "<pre><code>curve_integer_name(v)\n</code></pre> <p>Booking curves can have integer names, treat as string.</p> Source code in <code>passengersim/config/demands.py</code> <pre><code>@field_validator(\"curve\", mode=\"before\")\ndef curve_integer_name(cls, v):\n    \"\"\"Booking curves can have integer names, treat as string.\"\"\"\n    if isinstance(v, int):\n        v = str(v)\n    return v\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.DemandOverride", "title": "DemandOverride", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/demands.py</code> <pre><code>class DemandOverride(BaseModel, extra=\"forbid\"):\n    carrier: str\n    \"\"\"Carrier code for the override.\"\"\"\n\n    discount_pct: float = 0.0\n    \"\"\"Discount percentage to apply for this override.\"\"\"\n\n    pref_adj: float = 0.0\n    \"\"\"Preference adjustment to apply for this override.\"\"\"\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.DemandOverride.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: str\n</code></pre> <p>Carrier code for the override.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.DemandOverride.discount_pct", "title": "discount_pct  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>discount_pct: float = 0.0\n</code></pre> <p>Discount percentage to apply for this override.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.DemandOverride.pref_adj", "title": "pref_adj  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>pref_adj: float = 0.0\n</code></pre> <p>Preference adjustment to apply for this override.</p>"}, {"location": "API/config/fares.html", "title": "Fares", "text": ""}, {"location": "API/config/fares.html#passengersim.config.fares.Fare", "title": "Fare", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/fares.py</code> <pre><code>class Fare(BaseModel, extra=\"forbid\"):\n    carrier: str\n    orig: str\n    dest: str\n    booking_class: str\n    price: float\n    advance_purchase: int\n    restrictions: list[str] = []\n    category: str | None = None\n    cabin: str | None = \"Y\"\n    min_stay: int = 0\n    saturday_night_required: bool | None = False\n\n    @field_validator(\"restrictions\", mode=\"before\")\n    @classmethod\n    def allow_unrestricted(cls, v):\n        \"\"\"Allow restrictions to be None or missing.\"\"\"\n        if v is None:\n            v = []\n        return v\n\n    @field_validator(\"restrictions\", mode=\"before\")\n    @classmethod\n    def allow_pipe_sep(cls, v):\n        \"\"\"Allow restrictions to be a string of pipe or slash separated values.\"\"\"\n        if isinstance(v, str):\n            v = list(filter(None, re.split(r\"[|/]\", v)))\n        return v\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.advance_purchase", "title": "advance_purchase  <code>instance-attribute</code>", "text": "<pre><code>advance_purchase: int\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.booking_class", "title": "booking_class  <code>instance-attribute</code>", "text": "<pre><code>booking_class: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.cabin", "title": "cabin  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>cabin: str | None = 'Y'\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.category", "title": "category  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>category: str | None = None\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.min_stay", "title": "min_stay  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>min_stay: int = 0\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.restrictions", "title": "restrictions  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>restrictions: list[str] = []\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.saturday_night_required", "title": "saturday_night_required  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>saturday_night_required: bool | None = False\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.allow_pipe_sep", "title": "allow_pipe_sep  <code>classmethod</code>", "text": "<pre><code>allow_pipe_sep(v)\n</code></pre> <p>Allow restrictions to be a string of pipe or slash separated values.</p> Source code in <code>passengersim/config/fares.py</code> <pre><code>@field_validator(\"restrictions\", mode=\"before\")\n@classmethod\ndef allow_pipe_sep(cls, v):\n    \"\"\"Allow restrictions to be a string of pipe or slash separated values.\"\"\"\n    if isinstance(v, str):\n        v = list(filter(None, re.split(r\"[|/]\", v)))\n    return v\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.allow_unrestricted", "title": "allow_unrestricted  <code>classmethod</code>", "text": "<pre><code>allow_unrestricted(v)\n</code></pre> <p>Allow restrictions to be None or missing.</p> Source code in <code>passengersim/config/fares.py</code> <pre><code>@field_validator(\"restrictions\", mode=\"before\")\n@classmethod\ndef allow_unrestricted(cls, v):\n    \"\"\"Allow restrictions to be None or missing.\"\"\"\n    if v is None:\n        v = []\n    return v\n</code></pre>"}, {"location": "API/config/frat5_curves.html", "title": "Frat5 Curves", "text": ""}, {"location": "API/config/frat5_curves.html#passengersim.config.frat5_curves.Frat5Curve", "title": "Frat5Curve", "text": "<p>               Bases: <code>Named</code></p> <p>FRAT5 = Fare Ratio at which 50% of customers will buy up to the higher fare.</p> Source code in <code>passengersim/config/frat5_curves.py</code> <pre><code>class Frat5Curve(Named, extra=\"forbid\"):\n    \"\"\"\n    FRAT5 = Fare Ratio at which 50% of customers will buy up to the higher fare.\n    \"\"\"\n\n    enforce_monotonic: bool = True\n    \"\"\"Enforce monotonicity of Frat 5 curves.\n\n    Typically it is expected that the Frat5 curve is monotonic, i.e. that the\n    average willingness to pay only increases as the departure date approaches.\n    It is easy to accidentally define the Frat5 curve \"backwards\", and thus\n    PassengerSim will check that the Frat5 curve is monotonically increasing\n    by default. To violate this assumption, set `enforce_monotonic` to False,\n    which will disable the check that the Frat5 curve is monotonic.\n    \"\"\"\n\n    curve: dict[int, float]\n    \"\"\"Define a Frat5 curve.\n\n    To be consistent with the econometric interpretation of the Frat5 curve,\n    the values should increase as the keys (DCPs, e.g. days to departure) decrease.\n    This implies that average willingness to pay increases as the departure date\n    approaches.\n\n    Example\n    -------\n    ```{yaml}\n    - name: curve_C\n      curve:\n        63: 1.4\n        56: 1.4\n        49: 1.5\n        42: 1.5\n        35: 1.6\n        31: 1.7\n        28: 1.8\n        24: 1.9\n        21: 2.3\n        17: 2.7\n        14: 3.2\n        10: 3.3\n        7: 3.4\n        5: 3.4\n        3: 3.5\n        1: 3.5\n    ```\n    \"\"\"\n\n    max_cap: float = 10.0\n    \"\"\"\n    Maximum Q-equivalent demand implied by any unit of demand in any fare class.\n\n    This cap is applied only on the recording of Q-equivalent demand that occurs\n    within the simulation engine itself, and not as part of any RM step.\n    Simulation-recorded Q-equivalent demand can be used by RM steps, such as\n    within PODS-like hybrid forecasting models, but the max-cap filter transform\n    is implicitly already baked in to the Q-equivalent demand before the RM step\n    can use it.\n\n    This can be contrasted against a `max_cap` parameter used in the RM step,\n    which can applied against observed demand within the RM step, but the RM step\n    receives the \"raw\" sales data, without adulteration by the simulation engine.\n    \"\"\"\n\n    @field_validator(\"curve\")\n    def _frat5_curves_accumulate(cls, v: dict[int, float], info: ValidationInfo):\n        \"\"\"Check that all curve values do not decrease as DCP keys decrease.\"\"\"\n        if \"enforce_monotonic\" in info.data and not info.data[\"enforce_monotonic\"]:\n            # if the user has explicitly set enforce_monotonic to False, then\n            # we do not check that the Frat5 curve is monotonic\n            return v\n        sorted_dcps = reversed(sorted(v.keys()))\n        i = 0\n        for dcp in sorted_dcps:\n            assert v[dcp] &gt;= i, f\"frat5 curve {info.data['name']} moves backwards at dcp {dcp}\"\n            i = v[dcp]\n        return v\n\n    @field_validator(\"curve\")\n    def _frat5_curves_gt_1(cls, v: dict[int, float], info: ValidationInfo):\n        \"\"\"Check that all curve values are greater than 1.0.\n\n        Values that are less than 1.0 imply that lowering the fare will\n        reduce demand, which is not consistent with the econometric interpretation\n        of the Frat5 curve.  Similarly, values that are exactly 1.0 imply that\n        any fare increase no matter how small will instantly reduce demand to zero,\n        which is theoretically plausible as a corner case but in practice is not\n        realistic, and will cause numerical issues in simulation.\n        \"\"\"\n        for dcp, val in v.items():\n            assert val &gt; 1.0, f\"frat5 curve {info.data['name']} is not greater than 1 at {dcp}\"\n        return v\n</code></pre>"}, {"location": "API/config/frat5_curves.html#passengersim.config.frat5_curves.Frat5Curve.curve", "title": "curve  <code>instance-attribute</code>", "text": "<pre><code>curve: dict[int, float]\n</code></pre> <p>Define a Frat5 curve.</p> <p>To be consistent with the econometric interpretation of the Frat5 curve, the values should increase as the keys (DCPs, e.g. days to departure) decrease. This implies that average willingness to pay increases as the departure date approaches.</p> Example <pre><code>- name: curve_C\n  curve:\n    63: 1.4\n    56: 1.4\n    49: 1.5\n    42: 1.5\n    35: 1.6\n    31: 1.7\n    28: 1.8\n    24: 1.9\n    21: 2.3\n    17: 2.7\n    14: 3.2\n    10: 3.3\n    7: 3.4\n    5: 3.4\n    3: 3.5\n    1: 3.5\n</code></pre>"}, {"location": "API/config/frat5_curves.html#passengersim.config.frat5_curves.Frat5Curve.enforce_monotonic", "title": "enforce_monotonic  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>enforce_monotonic: bool = True\n</code></pre> <p>Enforce monotonicity of Frat 5 curves.</p> <p>Typically it is expected that the Frat5 curve is monotonic, i.e. that the average willingness to pay only increases as the departure date approaches. It is easy to accidentally define the Frat5 curve \"backwards\", and thus PassengerSim will check that the Frat5 curve is monotonically increasing by default. To violate this assumption, set <code>enforce_monotonic</code> to False, which will disable the check that the Frat5 curve is monotonic.</p>"}, {"location": "API/config/frat5_curves.html#passengersim.config.frat5_curves.Frat5Curve.max_cap", "title": "max_cap  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>max_cap: float = 10.0\n</code></pre> <p>Maximum Q-equivalent demand implied by any unit of demand in any fare class.</p> <p>This cap is applied only on the recording of Q-equivalent demand that occurs within the simulation engine itself, and not as part of any RM step. Simulation-recorded Q-equivalent demand can be used by RM steps, such as within PODS-like hybrid forecasting models, but the max-cap filter transform is implicitly already baked in to the Q-equivalent demand before the RM step can use it.</p> <p>This can be contrasted against a <code>max_cap</code> parameter used in the RM step, which can applied against observed demand within the RM step, but the RM step receives the \"raw\" sales data, without adulteration by the simulation engine.</p>"}, {"location": "API/config/legs.html", "title": "Legs", "text": ""}, {"location": "API/config/legs.html#passengersim.config.legs.Leg", "title": "Leg", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/legs.py</code> <pre><code>class Leg(BaseModel, extra=\"forbid\"):\n    leg_id: int | None = None\n    \"\"\"A unique identifier for this leg.\n\n    Each leg in a network should have a globally unique identifier (i.e. even\n    if the carrier is different, `leg_id` values should be unique.  Note this\n    is not the same as the `fltno`, which is a label analogous to flight numbers\n    in practice, which don't need to be unique.  If the leg_id is not provided,\n    the `fltno` is used, unless the simulation already has a leg with that\n    `leg_id`, in which case a new unique leg_id will be generated.\n    \"\"\"\n\n    carrier: str\n    \"\"\"The carrier name for this leg.\"\"\"\n\n    fltno: int\n    \"\"\"A flight number identifier for this leg.\n\n    Flight numbers do not need to be unique.\n    \"\"\"\n\n    orig: str\n    \"\"\"Origination location for this leg.\"\"\"\n\n    orig_timezone: str | None = None\n    \"\"\"Timezone name for the origination location for this leg.\"\"\"\n\n    dest: str\n    \"\"\"Destination location for this leg.\"\"\"\n\n    dest_timezone: str | None = None\n    \"\"\"Timezone name for the destination location for this leg.\"\"\"\n\n    #    date: datetime = datetime.fromisoformat(\"2020-03-01\")\n    date: datetime = datetime(2020, 3, 1, tzinfo=UTC)\n    \"\"\"Departure date for this leg.\n       The initial load is local, so we have a psuedo-timestamp here, we're avoiding local timezones\n       In the overall model validation, we'll unpack it to HH:MM and use the timezone\n       to get the true UTC value\"\"\"\n\n    arr_day: int = 0\n    \"\"\"If the arrival time is on a different day, this is offset in days.\n\n    This will usually be zero (arrival date is same as departure date) but will\n    sometimes be 1 (arrives next day) or in a few pathological cases -1 or +2\n    (for travel across the international dateline).\n    \"\"\"\n\n    dep_time: int\n    \"\"\"Departure time for this leg in Unix time.\n\n    In input files, this can be specified as a string in the format \"HH:MM\",\n    with the hour in 24-hour format.\n\n    Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.\"\"\"\n\n    dep_time_offset: int = 0\n\n    @property\n    def dep_localtime(self) -&gt; datetime:\n        \"\"\"Departure time for this leg in local time at the origin.\"\"\"\n        t = datetime.fromtimestamp(self.dep_time, tz=UTC)\n        if self.orig_timezone is not None:\n            z = ZoneInfo(self.orig_timezone)\n            t = t.astimezone(z)\n        return t\n\n    arr_time: int\n    \"\"\"Arrival time for this leg in Unix time.\n\n    In input files, this can be specified as a string in the format \"HH:MM\",\n    with the hour in 24-hour format.\n\n    Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.\"\"\"\n\n    arr_time_offset: int = 0\n\n    @property\n    def arr_localtime(self) -&gt; datetime:\n        \"\"\"Arrival time for this leg in local time at the destination.\"\"\"\n        t = datetime.fromtimestamp(self.arr_time, tz=UTC)\n        if self.dest_timezone is not None:\n            z = ZoneInfo(self.dest_timezone)\n            t = t.astimezone(z)\n        return t\n\n    time_adjusted: bool = False\n    capacity: int | dict[str, int]\n    distance: float | None = None\n\n    @field_validator(\"date\", mode=\"before\")\n    def _date_from_string(cls, v):\n        if isinstance(v, str):\n            v = datetime.fromisoformat(v)\n        if v.tzinfo is None:\n            # when no timezone is specified, assume UTC (not naive)\n            v = v.replace(tzinfo=UTC)\n        return v\n\n    @field_serializer(\"date\", when_used=\"always\")\n    def serialize_date(self, date: datetime) -&gt; str:\n        if date.tzinfo is None:\n            date = date.replace(tzinfo=UTC)\n        return date.isoformat()\n\n    @field_validator(\"dep_time\", \"arr_time\", mode=\"before\")\n    def _timestring_to_int(cls, v, info: ValidationInfo):\n        if isinstance(v, str) and \":\" in v:\n            dep_time_str = v.split(\":\")\n            hh, mm = int(dep_time_str[0]), int(dep_time_str[1])\n            v = create_timestamp(info.data[\"date\"], 0, hh, mm)\n        if info.field_name == \"arr_time\":\n            if v &lt; info.data[\"dep_time\"] and info.data[\"arr_day\"] == 0:\n                v += 86400  # add a day (in seconds) as arr time is next day\n            elif info.data[\"arr_day\"] != 0:\n                v += 86400 * info.data[\"arr_day\"]  # adjust day[s] (in seconds)\n        return v\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.arr_day", "title": "arr_day  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>arr_day: int = 0\n</code></pre> <p>If the arrival time is on a different day, this is offset in days.</p> <p>This will usually be zero (arrival date is same as departure date) but will sometimes be 1 (arrives next day) or in a few pathological cases -1 or +2 (for travel across the international dateline).</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.arr_localtime", "title": "arr_localtime  <code>property</code>", "text": "<pre><code>arr_localtime: datetime\n</code></pre> <p>Arrival time for this leg in local time at the destination.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.arr_time", "title": "arr_time  <code>instance-attribute</code>", "text": "<pre><code>arr_time: int\n</code></pre> <p>Arrival time for this leg in Unix time.</p> <p>In input files, this can be specified as a string in the format \"HH:MM\", with the hour in 24-hour format.</p> <p>Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.arr_time_offset", "title": "arr_time_offset  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>arr_time_offset: int = 0\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.capacity", "title": "capacity  <code>instance-attribute</code>", "text": "<pre><code>capacity: int | dict[str, int]\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: str\n</code></pre> <p>The carrier name for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.date", "title": "date  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>date: datetime = datetime(2020, 3, 1, tzinfo=UTC)\n</code></pre> <p>Departure date for this leg. The initial load is local, so we have a psuedo-timestamp here, we're avoiding local timezones In the overall model validation, we'll unpack it to HH:MM and use the timezone to get the true UTC value</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.dep_localtime", "title": "dep_localtime  <code>property</code>", "text": "<pre><code>dep_localtime: datetime\n</code></pre> <p>Departure time for this leg in local time at the origin.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.dep_time", "title": "dep_time  <code>instance-attribute</code>", "text": "<pre><code>dep_time: int\n</code></pre> <p>Departure time for this leg in Unix time.</p> <p>In input files, this can be specified as a string in the format \"HH:MM\", with the hour in 24-hour format.</p> <p>Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.dep_time_offset", "title": "dep_time_offset  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dep_time_offset: int = 0\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre> <p>Destination location for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.dest_timezone", "title": "dest_timezone  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dest_timezone: str | None = None\n</code></pre> <p>Timezone name for the destination location for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.distance", "title": "distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>distance: float | None = None\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.fltno", "title": "fltno  <code>instance-attribute</code>", "text": "<pre><code>fltno: int\n</code></pre> <p>A flight number identifier for this leg.</p> <p>Flight numbers do not need to be unique.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.leg_id", "title": "leg_id  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>leg_id: int | None = None\n</code></pre> <p>A unique identifier for this leg.</p> <p>Each leg in a network should have a globally unique identifier (i.e. even if the carrier is different, <code>leg_id</code> values should be unique.  Note this is not the same as the <code>fltno</code>, which is a label analogous to flight numbers in practice, which don't need to be unique.  If the leg_id is not provided, the <code>fltno</code> is used, unless the simulation already has a leg with that <code>leg_id</code>, in which case a new unique leg_id will be generated.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre> <p>Origination location for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.orig_timezone", "title": "orig_timezone  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>orig_timezone: str | None = None\n</code></pre> <p>Timezone name for the origination location for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.time_adjusted", "title": "time_adjusted  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>time_adjusted: bool = False\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.serialize_date", "title": "serialize_date", "text": "<pre><code>serialize_date(date: datetime) -&gt; str\n</code></pre> Source code in <code>passengersim/config/legs.py</code> <pre><code>@field_serializer(\"date\", when_used=\"always\")\ndef serialize_date(self, date: datetime) -&gt; str:\n    if date.tzinfo is None:\n        date = date.replace(tzinfo=UTC)\n    return date.isoformat()\n</code></pre>"}, {"location": "API/config/load_factor_curves.html", "title": "Load Factor Curves", "text": ""}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve", "title": "LoadFactorCurve", "text": "<p>               Bases: <code>Named</code></p> <p>LF Curve specifies the load factor at which to close a booking class. This is designed to simulate a naive LCC that really doesn't have automated RM</p> Source code in <code>passengersim/config/load_factor_curves.py</code> <pre><code>class LoadFactorCurve(Named, extra=\"forbid\"):\n    \"\"\"\n    LF Curve specifies the load factor at which to close a booking class.\n    This is designed to simulate a naive LCC that really doesn't have automated RM\n    \"\"\"\n\n    algorithm: str\n    min_accordion: float\n    max_accordion: float\n    target_load_factor: float\n    convergence_constant: float\n    curve: dict[str, float]\n    \"\"\"Define a Load Factor curve.\n\n    Example\n    -------\n    ```{yaml}\n    - name: lf_curve_1\n      curve:\n        Y0: 1.0\n        Y1: 0.85\n        Y2: 0.75\n    ```\n    \"\"\"\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: str\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.convergence_constant", "title": "convergence_constant  <code>instance-attribute</code>", "text": "<pre><code>convergence_constant: float\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.curve", "title": "curve  <code>instance-attribute</code>", "text": "<pre><code>curve: dict[str, float]\n</code></pre> <p>Define a Load Factor curve.</p> Example <pre><code>- name: lf_curve_1\n  curve:\n    Y0: 1.0\n    Y1: 0.85\n    Y2: 0.75\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.max_accordion", "title": "max_accordion  <code>instance-attribute</code>", "text": "<pre><code>max_accordion: float\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.min_accordion", "title": "min_accordion  <code>instance-attribute</code>", "text": "<pre><code>min_accordion: float\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.target_load_factor", "title": "target_load_factor  <code>instance-attribute</code>", "text": "<pre><code>target_load_factor: float\n</code></pre>"}, {"location": "API/config/manipulate.html", "title": "Manipulate", "text": ""}, {"location": "API/config/manipulate.html#passengersim.config.manipulate.manipulate_config", "title": "manipulate_config", "text": "<pre><code>manipulate_config(\n    cfg: Config, key: str, value: Any\n) -&gt; Config\n</code></pre> <p>Manipulate a config object by setting a key to a value.</p> <p>Parameters:</p> <ul> <li> <code>cfg</code>               (<code>Config</code>)           \u2013            <p>The config object to manipulate.</p> </li> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to set.</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The value to set the key to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config</code>           \u2013            <p>The manipulated config object.</p> </li> </ul> Source code in <code>passengersim/config/manipulate.py</code> <pre><code>def manipulate_config(cfg: Config, key: str, value: Any) -&gt; Config:\n    \"\"\"Manipulate a config object by setting a key to a value.\n\n    Parameters\n    ----------\n    cfg : Config\n        The config object to manipulate.\n    key : str\n        The key to set.\n    value : Any\n        The value to set the key to.\n\n    Returns\n    -------\n    Config\n        The manipulated config object.\n    \"\"\"\n    k, *remainder = key.split(\".\")\n    remainder = \".\".join(remainder)\n    if remainder:\n        try:\n            i = int(k)\n        except ValueError:\n            self = getattr(cfg, k)\n        else:\n            self = cfg[i]\n        manipulate_config(self, remainder, value)\n    else:\n        try:\n            i = int(k)\n        except ValueError:\n            setattr(cfg, k, value)\n        else:\n            cfg[i] = value\n    return cfg\n</code></pre>"}, {"location": "API/config/manipulate.html#passengersim.config.manipulate.revalidate", "title": "revalidate", "text": "<pre><code>revalidate(model: BaseModel) -&gt; None\n</code></pre> <p>Revalidate a model using its schema.</p> Source code in <code>passengersim/config/manipulate.py</code> <pre><code>def revalidate(model: BaseModel) -&gt; None:\n    \"\"\"Revalidate a model using its schema.\"\"\"\n    schema_validator = SchemaValidator(schema=model.__pydantic_core_schema__)\n    schema_validator.validate_python(model.__dict__)\n</code></pre>"}, {"location": "API/config/manipulate.html#passengersim.config.manipulate.strip_ap_restrictions", "title": "strip_ap_restrictions", "text": "<pre><code>strip_ap_restrictions(\n    cfg: Config, inplace: bool = False\n) -&gt; Config\n</code></pre> <p>Remove advance purchase restrictions from a PassengerSim network.</p> <p>Parameters:</p> <ul> <li> <code>cfg</code>               (<code>Config</code>)           \u2013            <p>The PassengerSim network from which to strip AP restrictions.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to modify the original network in place, by default False. Setting this value to True will modify the original network config, which may be faster than creating a copy, but may also be undesirable if you want to keep the original network available for any reason.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config</code>           \u2013            <p>The PassengerSim network with AP restrictions removed.</p> </li> </ul> Source code in <code>passengersim/config/manipulate.py</code> <pre><code>def strip_ap_restrictions(cfg: Config, inplace: bool = False) -&gt; Config:\n    \"\"\"Remove advance purchase restrictions from a PassengerSim network.\n\n    Parameters\n    ----------\n    cfg : Config\n        The PassengerSim network from which to strip AP restrictions.\n    inplace : bool, optional\n        Whether to modify the original network in place, by default False.\n        Setting this value to True will modify the original network config, which\n        may be faster than creating a copy, but may also be undesirable if you\n        want to keep the original network available for any reason.\n\n    Returns\n    -------\n    Config\n        The PassengerSim network with AP restrictions removed.\n    \"\"\"\n    if not inplace:\n        cfg = cfg.model_copy(deep=True)\n    for fare in cfg.fares:\n        fare.advance_purchase = 0\n    return cfg\n</code></pre>"}, {"location": "API/config/manipulate.html#passengersim.config.manipulate.strip_fare_restrictions", "title": "strip_fare_restrictions", "text": "<pre><code>strip_fare_restrictions(\n    cfg: Config, inplace: bool = False\n) -&gt; Config\n</code></pre> <p>Remove all fare restrictions (except APs) from a PassengerSim network.</p> <p>Parameters:</p> <ul> <li> <code>cfg</code>               (<code>Config</code>)           \u2013            <p>The PassengerSim network to strip fare restrictions from.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to modify the original network in place, by default False. Setting this value to True will modify the original network config, which may be faster than creating a copy, but may also be undesirable if you want to keep the original network available for any reason.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config</code>           \u2013            <p>The PassengerSim network with fare restrictions removed.</p> </li> </ul> Source code in <code>passengersim/config/manipulate.py</code> <pre><code>def strip_fare_restrictions(cfg: Config, inplace: bool = False) -&gt; Config:\n    \"\"\"Remove all fare restrictions (except APs) from a PassengerSim network.\n\n    Parameters\n    ----------\n    cfg : Config\n        The PassengerSim network to strip fare restrictions from.\n    inplace : bool, optional\n        Whether to modify the original network in place, by default False.\n        Setting this value to True will modify the original network config, which\n        may be faster than creating a copy, but may also be undesirable if you\n        want to keep the original network available for any reason.\n\n    Returns\n    -------\n    Config\n        The PassengerSim network with fare restrictions removed.\n    \"\"\"\n    if not inplace:\n        cfg = cfg.model_copy(deep=True)\n    for cm in cfg.choice_models.values():\n        cm.restrictions.clear()\n    for fare in cfg.fares:\n        fare.restrictions.clear()\n    return cfg\n</code></pre>"}, {"location": "API/config/markets.html", "title": "Markets", "text": ""}, {"location": "API/config/markets.html#passengersim.config.markets.Market", "title": "Market", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/markets.py</code> <pre><code>class Market(BaseModel, extra=\"forbid\"):\n    orig: str\n    \"\"\"Origin location for this market.\n\n    This is commonly a three letter airport code, but it need not be limited\n    to airports.  It can be any location that is relevant to the simulation.\n\n    If using 'places' for locations, this should match the 'name' field of\n    a Place object.\"\"\"\n\n    dest: str\n    \"\"\"Destination location for this market.\n\n    This is commonly a three letter airport code, but it need not be limited\n    to airports.  It can be any location that is relevant to the simulation.\n\n    If using 'places' for locations, this should match the 'name' field of\n    a Place object.\"\"\"\n\n    demand_multiplier: float = 1.0\n    \"\"\"Multiplier on base demand for all demand segments in this market.\"\"\"\n\n    @property\n    def identifier(self) -&gt; str:\n        return f\"{self.orig}~{self.dest}\"\n</code></pre>"}, {"location": "API/config/markets.html#passengersim.config.markets.Market.demand_multiplier", "title": "demand_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>demand_multiplier: float = 1.0\n</code></pre> <p>Multiplier on base demand for all demand segments in this market.</p>"}, {"location": "API/config/markets.html#passengersim.config.markets.Market.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre> <p>Destination location for this market.</p> <p>This is commonly a three letter airport code, but it need not be limited to airports.  It can be any location that is relevant to the simulation.</p> <p>If using 'places' for locations, this should match the 'name' field of a Place object.</p>"}, {"location": "API/config/markets.html#passengersim.config.markets.Market.identifier", "title": "identifier  <code>property</code>", "text": "<pre><code>identifier: str\n</code></pre>"}, {"location": "API/config/markets.html#passengersim.config.markets.Market.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre> <p>Origin location for this market.</p> <p>This is commonly a three letter airport code, but it need not be limited to airports.  It can be any location that is relevant to the simulation.</p> <p>If using 'places' for locations, this should match the 'name' field of a Place object.</p>"}, {"location": "API/config/named.html", "title": "Named", "text": "<p>This module contains utilities for managing named objects.</p>"}, {"location": "API/config/named.html#passengersim.config.named.DictOfNamed", "title": "DictOfNamed  <code>module-attribute</code>", "text": "<pre><code>DictOfNamed = Annotated[\n    DictAttr[str, T], BeforeValidator(enforce_name)\n]\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.Dict", "title": "Dict", "text": "<p>               Bases: <code>Dict</code></p> Source code in <code>passengersim/config/named.py</code> <pre><code>class Dict(addicty.Dict):\n    def __repr__(self):\n        return dict.__repr__(self)\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls: Any, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:\n        if isinstance(source_type, types.GenericAlias) and source_type.__origin__ is Dict:\n            return core_schema.no_info_after_validator_function(cls, handler(dict[source_type.__args__]))\n        else:\n            return core_schema.no_info_after_validator_function(cls, handler(source_type))\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.Dict.__get_pydantic_core_schema__", "title": "__get_pydantic_core_schema__  <code>classmethod</code>", "text": "<pre><code>__get_pydantic_core_schema__(\n    source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; CoreSchema\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls: Any, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:\n    if isinstance(source_type, types.GenericAlias) and source_type.__origin__ is Dict:\n        return core_schema.no_info_after_validator_function(cls, handler(dict[source_type.__args__]))\n    else:\n        return core_schema.no_info_after_validator_function(cls, handler(source_type))\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.Dict.__repr__", "title": "__repr__", "text": "<pre><code>__repr__()\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>def __repr__(self):\n    return dict.__repr__(self)\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.DictAttr", "title": "DictAttr", "text": "<p>               Bases: <code>dict</code></p> Source code in <code>passengersim/config/named.py</code> <pre><code>class DictAttr(dict):\n    def __getattr__(self, item):\n        if item in self:\n            return self[item]\n        if item.lower() in self:\n            return self[item.lower()]\n        raise AttributeError(f\"no key {item}\")\n\n    def __setattr__(self, item, value):\n        self[item.lower()] = value\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls: Any, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:\n        if isinstance(source_type, types.GenericAlias) and source_type.__origin__ is DictAttr:\n            return core_schema.no_info_after_validator_function(cls, handler(dict[source_type.__args__]))\n        else:\n            return core_schema.no_info_after_validator_function(cls, handler(source_type))\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.DictAttr.__get_pydantic_core_schema__", "title": "__get_pydantic_core_schema__  <code>classmethod</code>", "text": "<pre><code>__get_pydantic_core_schema__(\n    source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; CoreSchema\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls: Any, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:\n    if isinstance(source_type, types.GenericAlias) and source_type.__origin__ is DictAttr:\n        return core_schema.no_info_after_validator_function(cls, handler(dict[source_type.__args__]))\n    else:\n        return core_schema.no_info_after_validator_function(cls, handler(source_type))\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.DictAttr.__getattr__", "title": "__getattr__", "text": "<pre><code>__getattr__(item)\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>def __getattr__(self, item):\n    if item in self:\n        return self[item]\n    if item.lower() in self:\n        return self[item.lower()]\n    raise AttributeError(f\"no key {item}\")\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.DictAttr.__setattr__", "title": "__setattr__", "text": "<pre><code>__setattr__(item, value)\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>def __setattr__(self, item, value):\n    self[item.lower()] = value\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.ListOfNamed", "title": "ListOfNamed", "text": "<p>               Bases: <code>list</code></p> Source code in <code>passengersim/config/named.py</code> <pre><code>class ListOfNamed(list):\n    @classmethod\n    def __get_pydantic_core_schema__(cls: Any, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:\n        if isinstance(source_type, types.GenericAlias) and source_type.__origin__ is ListOfNamed:\n            return core_schema.no_info_after_validator_function(cls, handler(list[source_type.__args__]))\n        else:\n            return core_schema.no_info_after_validator_function(cls, handler(source_type))\n\n    def __getattr__(self, item):\n        for step in self:\n            if getattr(step, \"step_type\", None) == item:\n                return step\n        for step in self:\n            if getattr(step, \"name\", None) == item:\n                return step\n        raise AttributeError(f\"no step with step_type or name {item}\")\n\n    def __delattr__(self, item):\n        for i, step in enumerate(self):\n            if getattr(step, \"step_type\", None) == item:\n                del self[i]\n                return\n        for i, step in enumerate(self):\n            if getattr(step, \"name\", None) == item:\n                del self[i]\n                return\n        raise AttributeError(f\"no step with step_type or name {item}\")\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.ListOfNamed.__delattr__", "title": "__delattr__", "text": "<pre><code>__delattr__(item)\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>def __delattr__(self, item):\n    for i, step in enumerate(self):\n        if getattr(step, \"step_type\", None) == item:\n            del self[i]\n            return\n    for i, step in enumerate(self):\n        if getattr(step, \"name\", None) == item:\n            del self[i]\n            return\n    raise AttributeError(f\"no step with step_type or name {item}\")\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.ListOfNamed.__get_pydantic_core_schema__", "title": "__get_pydantic_core_schema__  <code>classmethod</code>", "text": "<pre><code>__get_pydantic_core_schema__(\n    source_type: Any, handler: GetCoreSchemaHandler\n) -&gt; CoreSchema\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls: Any, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:\n    if isinstance(source_type, types.GenericAlias) and source_type.__origin__ is ListOfNamed:\n        return core_schema.no_info_after_validator_function(cls, handler(list[source_type.__args__]))\n    else:\n        return core_schema.no_info_after_validator_function(cls, handler(source_type))\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.ListOfNamed.__getattr__", "title": "__getattr__", "text": "<pre><code>__getattr__(item)\n</code></pre> Source code in <code>passengersim/config/named.py</code> <pre><code>def __getattr__(self, item):\n    for step in self:\n        if getattr(step, \"step_type\", None) == item:\n            return step\n    for step in self:\n        if getattr(step, \"name\", None) == item:\n            return step\n    raise AttributeError(f\"no step with step_type or name {item}\")\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.Named", "title": "Named", "text": "<p>               Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/named.py</code> <pre><code>class Named(PrettyModel):\n    name: str\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.Named.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.enforce_name", "title": "enforce_name", "text": "<pre><code>enforce_name(x: dict[str, T] | list[T]) -&gt; dict[str, T]\n</code></pre> <p>Enforce that each item has a unique name.</p> <p>If you provide a list, this will ensure that each item in the list has a name. If you provide a dict, the names are given by the keys of the dictionary, and this will ensure that for each value, if it also has an explicitly defined name, that name matches its key-derived name.</p> Source code in <code>passengersim/config/named.py</code> <pre><code>def enforce_name(x: dict[str, T] | list[T]) -&gt; dict[str, T]:\n    \"\"\"Enforce that each item has a unique name.\n\n    If you provide a list, this will ensure that each item in the list has a name.\n    If you provide a dict, the names are given by the keys of the dictionary, and\n    this will ensure that for each value, if it also has an explicitly defined name,\n    that name matches its key-derived name.\n    \"\"\"\n    if isinstance(x, list):\n        x_ = {}\n        for n, i in enumerate(x):\n            k = i.get(\"name\")\n            if k is None:\n                raise ValueError(f\"missing name in position {n}\")\n            x_[k] = i\n        x = x_\n    for k, v in x.items():\n        try:\n            missing_name = \"name\" not in v or not v[\"name\"]\n        except TypeError:\n            missing_name = True\n        if missing_name:\n            try:\n                v[\"name\"] = k\n            except TypeError:\n                try:\n                    v.name = k\n                except AttributeError:\n                    raise ValueError(f\"cannot assign name {k!r} to {type(v)}\") from None\n        try:\n            if v[\"name\"] != k:\n                raise ValueError(f\"explict name {v['name']!r} does not match key {k!r}\")\n        except TypeError:\n            if v.name != k:\n                raise ValueError(f\"explict name {v.name!r} does not match key {k!r}\") from None\n    return x\n</code></pre>"}, {"location": "API/config/optional_literal.html", "title": "Optional literal", "text": ""}, {"location": "API/config/optional_literal.html#passengersim.config.optional_literal.Optional", "title": "Optional  <code>module-attribute</code>", "text": "<pre><code>Optional = Annotated[\n    T | None, BeforeValidator(_interpret_none)\n]\n</code></pre>"}, {"location": "API/config/optional_literal.html#passengersim.config.optional_literal.ee", "title": "ee  <code>module-attribute</code>", "text": "<pre><code>ee = ExampleModel(optional_field='example')\n</code></pre>"}, {"location": "API/config/optional_literal.html#passengersim.config.optional_literal.example", "title": "example  <code>module-attribute</code>", "text": "<pre><code>example = ExampleModel(optional_field='noppp')\n</code></pre>"}, {"location": "API/config/optional_literal.html#passengersim.config.optional_literal.ExampleModel", "title": "ExampleModel", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/optional_literal.py</code> <pre><code>class ExampleModel(BaseModel):\n    optional_field: Optional[Literal[\"example\", \"test\"]] = None\n</code></pre>"}, {"location": "API/config/optional_literal.html#passengersim.config.optional_literal.ExampleModel.optional_field", "title": "optional_field  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>optional_field: Optional[Literal['example', 'test']] = None\n</code></pre>"}, {"location": "API/config/outputs.html", "title": "Outputs", "text": ""}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig", "title": "HtmlOutputConfig", "text": "<p>               Bases: <code>PrettyModel</code></p> <p>Configuration for HTML outputs.</p> Source code in <code>passengersim/config/outputs.py</code> <pre><code>class HtmlOutputConfig(PrettyModel, extra=\"forbid\", validate_assignment=True):\n    \"\"\"Configuration for HTML outputs.\"\"\"\n\n    filename: pathlib.Path | None = None\n    \"\"\"Write HTML outputs to this file after a run.\n\n    If this is None, no HTML outputs will be written.\"\"\"\n\n    title: str | None = None\n    \"\"\"Title of the HTML report.\n\n    If this is None, the title will be the scenario name.\"\"\"\n\n    carrier_revenues: bool = True\n    \"\"\"Include carrier revenues in the HTML report.\"\"\"\n\n    carrier_total_bookings: bool = True\n    \"\"\"Include carrier total bookings in the HTML report.\"\"\"\n\n    carrier_revenue_distribution: bool = False\n    \"\"\"Include carrier revenue distribution in the HTML report.\"\"\"\n\n    carrier_load_factors: bool = True\n    \"\"\"Include carrier load factors in the HTML report.\"\"\"\n\n    carrier_yields: bool = True\n    \"\"\"Include carrier yields in the HTML report.\"\"\"\n\n    carrier_rasm: bool = True\n    \"\"\"Include carrier RASM in the HTML report.\"\"\"\n\n    carrier_local_share: bool = True\n    \"\"\"Include carrier local share in the HTML report.\"\"\"\n\n    fare_class_mix: bool = True\n    \"\"\"Include fare class mix in the HTML report.\n\n    This figure is always by carrier.\"\"\"\n\n    bookings_by_timeframe: bool | list[str] = True\n    \"\"\"Include bookings by timeframe in the HTML report.\n\n    If this is a list of strings, include only the specified carriers.\"\"\"\n\n    leg_load_factor_distribution: bool = True\n    \"\"\"Include leg load factor distribution in the HTML report.\"\"\"\n\n    bid_price_history: bool = True\n    \"\"\"Include bid price history in the HTML report.\"\"\"\n\n    displacement_history: bool = True\n    \"\"\"Include displacement history in the HTML report.\"\"\"\n\n    carrier_table: bool = True\n    \"\"\"Include carrier table in the HTML report.\"\"\"\n\n    segmentation_by_timeframe_table: bool = True\n    \"\"\"Include segmentation by timeframe table in the HTML report.\"\"\"\n\n    other: list[str | tuple[str, dict]] = []\n\n    configs: list[str] = [\n        \"carriers\",\n        \"rm_systems\",\n        \"simulation_controls\",\n        \"db\",\n        \"outputs\",\n    ]\n    \"\"\"Include these configuration items in the HTML report.\"\"\"\n\n    metadata: bool = True\n    \"\"\"Include simulation run metadata in the HTML report.\"\"\"\n\n    def __bool__(self) -&gt; bool:\n        return self.filename is not None\n</code></pre>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.bid_price_history", "title": "bid_price_history  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>bid_price_history: bool = True\n</code></pre> <p>Include bid price history in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.bookings_by_timeframe", "title": "bookings_by_timeframe  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>bookings_by_timeframe: bool | list[str] = True\n</code></pre> <p>Include bookings by timeframe in the HTML report.</p> <p>If this is a list of strings, include only the specified carriers.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_load_factors", "title": "carrier_load_factors  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_load_factors: bool = True\n</code></pre> <p>Include carrier load factors in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_local_share", "title": "carrier_local_share  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_local_share: bool = True\n</code></pre> <p>Include carrier local share in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_rasm", "title": "carrier_rasm  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_rasm: bool = True\n</code></pre> <p>Include carrier RASM in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_revenue_distribution", "title": "carrier_revenue_distribution  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_revenue_distribution: bool = False\n</code></pre> <p>Include carrier revenue distribution in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_revenues", "title": "carrier_revenues  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_revenues: bool = True\n</code></pre> <p>Include carrier revenues in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_table", "title": "carrier_table  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_table: bool = True\n</code></pre> <p>Include carrier table in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_total_bookings", "title": "carrier_total_bookings  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_total_bookings: bool = True\n</code></pre> <p>Include carrier total bookings in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.carrier_yields", "title": "carrier_yields  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier_yields: bool = True\n</code></pre> <p>Include carrier yields in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.configs", "title": "configs  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>configs: list[str] = [\n    \"carriers\",\n    \"rm_systems\",\n    \"simulation_controls\",\n    \"db\",\n    \"outputs\",\n]\n</code></pre> <p>Include these configuration items in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.displacement_history", "title": "displacement_history  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>displacement_history: bool = True\n</code></pre> <p>Include displacement history in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.fare_class_mix", "title": "fare_class_mix  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>fare_class_mix: bool = True\n</code></pre> <p>Include fare class mix in the HTML report.</p> <p>This figure is always by carrier.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.filename", "title": "filename  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>filename: Path | None = None\n</code></pre> <p>Write HTML outputs to this file after a run.</p> <p>If this is None, no HTML outputs will be written.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.leg_load_factor_distribution", "title": "leg_load_factor_distribution  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>leg_load_factor_distribution: bool = True\n</code></pre> <p>Include leg load factor distribution in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.metadata", "title": "metadata  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>metadata: bool = True\n</code></pre> <p>Include simulation run metadata in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.other", "title": "other  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>other: list[str | tuple[str, dict]] = []\n</code></pre>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.segmentation_by_timeframe_table", "title": "segmentation_by_timeframe_table  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>segmentation_by_timeframe_table: bool = True\n</code></pre> <p>Include segmentation by timeframe table in the HTML report.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.title", "title": "title  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>title: str | None = None\n</code></pre> <p>Title of the HTML report.</p> <p>If this is None, the title will be the scenario name.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.HtmlOutputConfig.__bool__", "title": "__bool__", "text": "<pre><code>__bool__() -&gt; bool\n</code></pre> Source code in <code>passengersim/config/outputs.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    return self.filename is not None\n</code></pre>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig", "title": "OutputConfig", "text": "<p>               Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/outputs.py</code> <pre><code>class OutputConfig(PrettyModel, extra=\"forbid\", validate_assignment=True):\n    log_reports: bool = False\n    \"\"\"Write basic reports directly to the run log.\"\"\"\n\n    excel: pathlib.Path | None = None\n    \"\"\"Write excel outputs to this file after a run.\"\"\"\n\n    reports: set[str | tuple[str, ...]] = set()\n    \"\"\"Reports to include.\n\n    Database queries reports can be included here.  This is important for\n    multiprocessing runs with in-memory databases, as database results will not\n    be available after the database connection is closed in each subprocess.\n\n    If this is a set containing only \"*\", all reports will be included; this\n    may be computationally expensive.\n    \"\"\"\n\n    html: HtmlOutputConfig = HtmlOutputConfig()\n    \"\"\"Configuration for HTML outputs.\"\"\"\n\n    pickle: pathlib.Path | None = None\n    \"\"\"Write a pickle of the SimulationTables output to this file after a run.\"\"\"\n\n    disk: bool | pathlib.Path | None = True\n    \"\"\"Write the SimulationTables output to this file after a run.\n\n    This will use pxsim format, an efficient binary file that allows \"lazy\" file\n    loading.  If set to `True`, the file will be named with the same name as\n    the HTML output file, except with the extension `.pxsim`, unless there is no\n    HTML output file, in which case no file will written.\n    \"\"\"\n\n    def _get_disk_filename(self) -&gt; pathlib.Path | None:\n        \"\"\"Get the filename for the disk output.\n\n        If the disk output is set to `True`, this will return the filename of\n        the HTML output file with the extension `.pxsim`.  If there is no HTML\n        output file, this will return None.\n        \"\"\"\n        if self.disk is True and self.html.filename is not None:\n            return self.html.filename.with_suffix(\".pxsim\")\n        elif isinstance(self.disk, pathlib.Path):\n            return self.disk\n        else:\n            return None\n\n    # TODO what reports require what database items?\n    # e.g. demand_to_come requires we store all `demand` not just demand_final\n\n    @field_serializer(\"reports\", when_used=\"always\")\n    def serialize_reports(self, reports: set[str | tuple[str, ...]]) -&gt; list[str | tuple[str, ...]]:\n        # return a sorted list, first simple strings then tuples\n        return sorted(reports, key=lambda x: (isinstance(x, tuple), x))\n</code></pre>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.disk", "title": "disk  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>disk: bool | Path | None = True\n</code></pre> <p>Write the SimulationTables output to this file after a run.</p> <p>This will use pxsim format, an efficient binary file that allows \"lazy\" file loading.  If set to <code>True</code>, the file will be named with the same name as the HTML output file, except with the extension <code>.pxsim</code>, unless there is no HTML output file, in which case no file will written.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.excel", "title": "excel  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>excel: Path | None = None\n</code></pre> <p>Write excel outputs to this file after a run.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.html", "title": "html  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>html: HtmlOutputConfig = HtmlOutputConfig()\n</code></pre> <p>Configuration for HTML outputs.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.log_reports", "title": "log_reports  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>log_reports: bool = False\n</code></pre> <p>Write basic reports directly to the run log.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.pickle", "title": "pickle  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>pickle: Path | None = None\n</code></pre> <p>Write a pickle of the SimulationTables output to this file after a run.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.reports", "title": "reports  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>reports: set[str | tuple[str, ...]] = set()\n</code></pre> <p>Reports to include.</p> <p>Database queries reports can be included here.  This is important for multiprocessing runs with in-memory databases, as database results will not be available after the database connection is closed in each subprocess.</p> <p>If this is a set containing only \"*\", all reports will be included; this may be computationally expensive.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.serialize_reports", "title": "serialize_reports", "text": "<pre><code>serialize_reports(\n    reports: set[str | tuple[str, ...]],\n) -&gt; list[str | tuple[str, ...]]\n</code></pre> Source code in <code>passengersim/config/outputs.py</code> <pre><code>@field_serializer(\"reports\", when_used=\"always\")\ndef serialize_reports(self, reports: set[str | tuple[str, ...]]) -&gt; list[str | tuple[str, ...]]:\n    # return a sorted list, first simple strings then tuples\n    return sorted(reports, key=lambda x: (isinstance(x, tuple), x))\n</code></pre>"}, {"location": "API/config/paths.html", "title": "Paths", "text": ""}, {"location": "API/config/paths.html#passengersim.config.paths.Path", "title": "Path", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/paths.py</code> <pre><code>class Path(BaseModel, extra=\"forbid\"):\n    path_id: int | None = None\n    orig: str\n    dest: str\n    path_quality_index: float\n\n    legs: list[int]\n    \"\"\"Flight numbers of legs comprising the path.\"\"\"\n\n    @field_validator(\"legs\", mode=\"before\")\n    def allow_single_leg(cls, v):\n        \"\"\"Allow a single leg path to be just an int not a list of one int.\"\"\"\n        if isinstance(v, int):\n            v = [v]\n        return v\n\n    @field_validator(\"legs\")\n    def at_least_one_leg(cls, v):\n        \"\"\"There must be at least one leg.\"\"\"\n        if len(v) &lt; 1:\n            raise ValueError(\"path must have at least one leg\")\n        return v\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.legs", "title": "legs  <code>instance-attribute</code>", "text": "<pre><code>legs: list[int]\n</code></pre> <p>Flight numbers of legs comprising the path.</p>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.path_id", "title": "path_id  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>path_id: int | None = None\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.path_quality_index", "title": "path_quality_index  <code>instance-attribute</code>", "text": "<pre><code>path_quality_index: float\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.allow_single_leg", "title": "allow_single_leg", "text": "<pre><code>allow_single_leg(v)\n</code></pre> <p>Allow a single leg path to be just an int not a list of one int.</p> Source code in <code>passengersim/config/paths.py</code> <pre><code>@field_validator(\"legs\", mode=\"before\")\ndef allow_single_leg(cls, v):\n    \"\"\"Allow a single leg path to be just an int not a list of one int.\"\"\"\n    if isinstance(v, int):\n        v = [v]\n    return v\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.at_least_one_leg", "title": "at_least_one_leg", "text": "<pre><code>at_least_one_leg(v)\n</code></pre> <p>There must be at least one leg.</p> Source code in <code>passengersim/config/paths.py</code> <pre><code>@field_validator(\"legs\")\ndef at_least_one_leg(cls, v):\n    \"\"\"There must be at least one leg.\"\"\"\n    if len(v) &lt; 1:\n        raise ValueError(\"path must have at least one leg\")\n    return v\n</code></pre>"}, {"location": "API/config/places.html", "title": "Places", "text": ""}, {"location": "API/config/places.html#passengersim.config.places.MinConnectTime", "title": "MinConnectTime", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/places.py</code> <pre><code>class MinConnectTime(BaseModel, extra=\"forbid\", validate_assignment=True):\n    domestic_domestic: int\n    \"\"\"Minimum connect time for domestic to domestic connections in minutes.\"\"\"\n\n    domestic_international: int\n    \"\"\"Minimum connect time for domestic to international connections in minutes.\"\"\"\n\n    international_domestic: int\n    \"\"\"Minimum connect time for international to domestic connections in minutes.\"\"\"\n\n    international_international: int\n    \"\"\"Minimum connect time for international to international connects in minutes.\"\"\"\n</code></pre>"}, {"location": "API/config/places.html#passengersim.config.places.MinConnectTime.domestic_domestic", "title": "domestic_domestic  <code>instance-attribute</code>", "text": "<pre><code>domestic_domestic: int\n</code></pre> <p>Minimum connect time for domestic to domestic connections in minutes.</p>"}, {"location": "API/config/places.html#passengersim.config.places.MinConnectTime.domestic_international", "title": "domestic_international  <code>instance-attribute</code>", "text": "<pre><code>domestic_international: int\n</code></pre> <p>Minimum connect time for domestic to international connections in minutes.</p>"}, {"location": "API/config/places.html#passengersim.config.places.MinConnectTime.international_domestic", "title": "international_domestic  <code>instance-attribute</code>", "text": "<pre><code>international_domestic: int\n</code></pre> <p>Minimum connect time for international to domestic connections in minutes.</p>"}, {"location": "API/config/places.html#passengersim.config.places.MinConnectTime.international_international", "title": "international_international  <code>instance-attribute</code>", "text": "<pre><code>international_international: int\n</code></pre> <p>Minimum connect time for international to international connects in minutes.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place", "title": "Place", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/places.py</code> <pre><code>class Place(BaseModel, extra=\"forbid\", validate_assignment=True):\n    name: str\n    \"\"\"Identifying code for this place.\n\n    For airports, typically the three letter code.\"\"\"\n\n    label: str\n    \"\"\"A descriptive label for this place.\"\"\"\n\n    country: str | None = None\n    \"\"\"Country code.\n\n    Recommended to use ISO 3166-1 alpha-2 codes, ie. US / GB / AU / MX / etc.\"\"\"\n\n    state: str | None = None\n    \"\"\"State code\"\"\"\n\n    lat: float | None = None\n    \"\"\"Latitude in degrees.\"\"\"\n\n    lon: float | None = None\n    \"\"\"Longitude in degrees.\"\"\"\n\n    time_zone: str | None = None\n    \"\"\"\n    The time zone for this location.\n    \"\"\"\n\n    tz_offset: int | None = None\n    \"\"\"Hours offset from GMT\"\"\"\n\n    mct: Annotated[\n        MinConnectTime | int | None,\n        AfterValidator(_inflate_simple_mct),\n        BeforeValidator(_reformat_mct),\n    ] = None\n    \"\"\"\n    Default Minimum Connect Time (MCT) in minutes for this location (Airport).\n\n    This can be given as a single integer, which will be applied to all\n    connections, or differentiated by connection type (domestic-domestic,\n    domestic-international, etc.).  Connection types can be given using their\n    full name (with underscore) or using shorthand codes (DD, DI, ID, II), or\n    as a list of 4 integers in the order DD, DI, ID, II.\n\n    Future version of PassengerSim will also allow specific exceptions by\n    airline / route / etc.\n    \"\"\"\n\n    @field_validator(\"time_zone\")\n    def _valid_time_zone(cls, v: str):\n        \"\"\"Check for valid time zones.\"\"\"\n        if isinstance(v, str):\n            ZoneInfo(v)\n        return v\n\n    @property\n    def time_zone_info(self):\n        if self.time_zone is None:\n            return None  # No time zone set\n        return ZoneInfo(self.time_zone)\n</code></pre>"}, {"location": "API/config/places.html#passengersim.config.places.Place.country", "title": "country  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>country: str | None = None\n</code></pre> <p>Country code.</p> <p>Recommended to use ISO 3166-1 alpha-2 codes, ie. US / GB / AU / MX / etc.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.label", "title": "label  <code>instance-attribute</code>", "text": "<pre><code>label: str\n</code></pre> <p>A descriptive label for this place.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.lat", "title": "lat  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>lat: float | None = None\n</code></pre> <p>Latitude in degrees.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.lon", "title": "lon  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>lon: float | None = None\n</code></pre> <p>Longitude in degrees.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.mct", "title": "mct  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>mct: Annotated[\n    MinConnectTime | int | None,\n    AfterValidator(_inflate_simple_mct),\n    BeforeValidator(_reformat_mct),\n] = None\n</code></pre> <p>Default Minimum Connect Time (MCT) in minutes for this location (Airport).</p> <p>This can be given as a single integer, which will be applied to all connections, or differentiated by connection type (domestic-domestic, domestic-international, etc.).  Connection types can be given using their full name (with underscore) or using shorthand codes (DD, DI, ID, II), or as a list of 4 integers in the order DD, DI, ID, II.</p> <p>Future version of PassengerSim will also allow specific exceptions by airline / route / etc.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre> <p>Identifying code for this place.</p> <p>For airports, typically the three letter code.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.state", "title": "state  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>state: str | None = None\n</code></pre> <p>State code</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.time_zone", "title": "time_zone  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>time_zone: str | None = None\n</code></pre> <p>The time zone for this location.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.time_zone_info", "title": "time_zone_info  <code>property</code>", "text": "<pre><code>time_zone_info\n</code></pre>"}, {"location": "API/config/places.html#passengersim.config.places.Place.tz_offset", "title": "tz_offset  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tz_offset: int | None = None\n</code></pre> <p>Hours offset from GMT</p>"}, {"location": "API/config/places.html#passengersim.config.places.great_circle", "title": "great_circle", "text": "<pre><code>great_circle(place1: Place, place2: Place)\n</code></pre> <p>Using Haversine formula, to get distance between points in miles.</p> Source code in <code>passengersim/config/places.py</code> <pre><code>def great_circle(place1: Place, place2: Place):\n    \"\"\"Using Haversine formula, to get distance between points in miles.\"\"\"\n    lon1 = math.radians(place1.lon)\n    lat1 = math.radians(place1.lat)\n    lon2 = math.radians(place2.lon)\n    lat2 = math.radians(place2.lat)\n    lon_diff = lon2 - lon1\n    lat_diff = lat2 - lat1\n    a = math.sin((lat_diff) / 2.0) ** 2.0 + (math.cos(lat1) * math.cos(lat2) * (math.sin((lon_diff) / 2.0) ** 2.0))\n    angle2 = 2.0 * math.asin(min(1.0, math.sqrt(a)))\n    # Convert back to degrees.\n    angle2 = math.degrees(angle2)\n    # Each degree on a great circle of Earth is 69.0468 miles. ( 60 nautical miles )\n    distance2 = 69.0468 * angle2\n    return distance2\n</code></pre>"}, {"location": "API/config/pretty.html", "title": "Pretty", "text": ""}, {"location": "API/config/pretty.html#passengersim.config.pretty.PrettyModel", "title": "PrettyModel", "text": "<p>               Bases: <code>BaseModel</code></p> <p>Pretty-print as YAML style outputs.</p> Source code in <code>passengersim/config/pretty.py</code> <pre><code>class PrettyModel(BaseModel):\n    \"\"\"Pretty-print as YAML style outputs.\"\"\"\n\n    def __repr_with_indent__(self, indent=0):\n        x = []\n        i = \" \" * indent\n        for k, v in self:\n            try:\n                val = v.__repr_with_indent__(0)\n            except AttributeError:\n                if isinstance(v, dict):\n                    val = repr_dict_with_indent(v, indent)\n                else:\n                    val = repr(v)\n                    if isinstance(v, list) and len(val) &gt; 70:\n                        val = \"- \" + \"\\n- \".join(repr(j) for j in v)\n            if \"\\n\" in val:\n                val_lines = val.split(\"\\n\")\n                val = \"\\n  \" + \"\\n  \".join(val_lines)\n            elif isinstance(v, list):\n                val = \"\\n  - \" + \"\\n  - \".join(repr(j) for j in v)\n            x.append(f\"{i}{k}: {val}\")\n        return \"\\n\".join(x)\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}:\\n\" + self.__repr_with_indent__(2)\n</code></pre>"}, {"location": "API/config/pretty.html#passengersim.config.pretty.PrettyModel.__repr__", "title": "__repr__", "text": "<pre><code>__repr__()\n</code></pre> Source code in <code>passengersim/config/pretty.py</code> <pre><code>def __repr__(self):\n    return f\"{self.__class__.__name__}:\\n\" + self.__repr_with_indent__(2)\n</code></pre>"}, {"location": "API/config/pretty.html#passengersim.config.pretty.PrettyModel.__repr_with_indent__", "title": "__repr_with_indent__", "text": "<pre><code>__repr_with_indent__(indent=0)\n</code></pre> Source code in <code>passengersim/config/pretty.py</code> <pre><code>def __repr_with_indent__(self, indent=0):\n    x = []\n    i = \" \" * indent\n    for k, v in self:\n        try:\n            val = v.__repr_with_indent__(0)\n        except AttributeError:\n            if isinstance(v, dict):\n                val = repr_dict_with_indent(v, indent)\n            else:\n                val = repr(v)\n                if isinstance(v, list) and len(val) &gt; 70:\n                    val = \"- \" + \"\\n- \".join(repr(j) for j in v)\n        if \"\\n\" in val:\n            val_lines = val.split(\"\\n\")\n            val = \"\\n  \" + \"\\n  \".join(val_lines)\n        elif isinstance(v, list):\n            val = \"\\n  - \" + \"\\n  - \".join(repr(j) for j in v)\n        x.append(f\"{i}{k}: {val}\")\n    return \"\\n\".join(x)\n</code></pre>"}, {"location": "API/config/pretty.html#passengersim.config.pretty.repr_dict_with_indent", "title": "repr_dict_with_indent", "text": "<pre><code>repr_dict_with_indent(d: dict[str, Any], indent=0)\n</code></pre> Source code in <code>passengersim/config/pretty.py</code> <pre><code>def repr_dict_with_indent(d: dict[str, Any], indent=0):\n    x = []\n    i = \" \" * indent\n    for k, v in d.items():\n        try:\n            val = v.__repr_with_indent__(indent)\n        except AttributeError:\n            if isinstance(v, dict):\n                val = repr_dict_with_indent(v, indent)\n            else:\n                val = repr(v)\n                if isinstance(v, list) and len(val) &gt; 70:\n                    val = \"- \" + \"\\n- \".join(repr(j) for j in v)\n        if \"\\n\" in val:\n            val_lines = val.split(\"\\n\")\n            val = \"\\n  \" + \"\\n  \".join(val_lines)\n        elif isinstance(v, list):\n            val = \"\\n  - \" + \"\\n  - \".join(repr(j) for j in v)\n        x.append(f\"{i}{k}: {val}\")\n    return \"\\n\".join(x)\n</code></pre>"}, {"location": "API/config/rm_steps.html", "title": "RM Steps", "text": ""}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.DummyStep", "title": "DummyStep", "text": "<p>               Bases: <code>RmStepBase</code></p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>class DummyStep(RmStepBase):\n    step_type: Literal[\"dummy\"]\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.DummyStep.step_type", "title": "step_type  <code>instance-attribute</code>", "text": "<pre><code>step_type: Literal['dummy']\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase", "title": "RmStepBase", "text": "<p>               Bases: <code>BaseModel</code></p> <p>Base class for RmSteps.</p> <p>Every non-abstract derived class must have a <code>step_type</code> class attribute, annotated with a <code>Literal</code> value type.</p> <p>See <code>DummyStep</code> below for an example.</p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>class RmStepBase(BaseModel, extra=\"forbid\"):\n    \"\"\"\n    Base class for RmSteps.\n\n    Every non-abstract derived class must have a `step_type` class attribute,\n    annotated with a `Literal` value type.\n\n    See `DummyStep` below for an example.\n    \"\"\"\n\n    __subclasses: ClassVar[set[type[RmStepBase]]] = set()\n\n    @classmethod\n    def _get_subclasses(cls) -&gt; set[type[RmStepBase]]:\n        \"\"\"Return a set of all concrete subclasses\"\"\"\n        return cls.__subclasses.copy()\n\n    def __init_subclass__(cls, **kwargs):\n        \"\"\"Capture a list of all concrete subclasses, including nested levels\"\"\"\n        super().__init_subclass__(**kwargs)\n\n        if inspect.isabstract(cls):\n            return  # do not consider intermediate abstract base classes\n\n        annotations = inspect.get_annotations(cls, eval_str=True)\n        assert \"step_type\" in annotations, \"step_type not in annotations\"\n        annotation_step_type = typing.get_origin(annotations[\"step_type\"])\n        assert annotation_step_type == Literal, (\n            f\"annotation {annotations['step_type']} for `{cls.__name__}.step_type` \"\n            f\"is not Literal but {annotation_step_type}\"\n        )\n        found_step_type = typing.get_args(annotations[\"step_type\"])[0]\n        if cls.__name__.lower().endswith(\"step\"):\n            assert found_step_type == cls.__name__.lower()[:-4], (\n                f\"annotation Literal value {found_step_type!r} \"\n                f\"for `{cls.__name__}.step_type` is not the same as the class name \"\n                f\"(omitting 'step' suffix)\"\n            )\n        else:\n            assert found_step_type == cls.__name__.lower(), (\n                f\"annotation Literal value {found_step_type!r} \"\n                f\"for `{cls.__name__}.step_type` is not the same as the class name\"\n            )\n        cls.__subclasses.add(cls)\n\n    @classmethod\n    def as_pydantic_field(cls):\n        \"\"\"Pydantic field as a union of all subclasses, discriminated on step_type.\"\"\"\n        if len(cls.__subclasses) &gt; 1:\n            return Annotated[\n                reduce(operator.__or__, cls.__subclasses),\n                Field(discriminator=\"step_type\"),\n            ]\n        else:  # only the DummyStep\n            return Annotated[reduce(operator.__or__, cls.__subclasses), Field()]\n\n    def _factory(self):\n        \"\"\"Generate a deep copy of this RmStep.\"\"\"\n        return self.model_copy(deep=True)\n\n    def use_config(self, config):\n        \"\"\"Some RM Steps might want to check parts of the config.\"\"\"\n        pass\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase.__subclasses", "title": "__subclasses  <code>class-attribute</code>", "text": "<pre><code>__subclasses: set[type[RmStepBase]] = set()\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase.__init_subclass__", "title": "__init_subclass__", "text": "<pre><code>__init_subclass__(**kwargs)\n</code></pre> <p>Capture a list of all concrete subclasses, including nested levels</p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>def __init_subclass__(cls, **kwargs):\n    \"\"\"Capture a list of all concrete subclasses, including nested levels\"\"\"\n    super().__init_subclass__(**kwargs)\n\n    if inspect.isabstract(cls):\n        return  # do not consider intermediate abstract base classes\n\n    annotations = inspect.get_annotations(cls, eval_str=True)\n    assert \"step_type\" in annotations, \"step_type not in annotations\"\n    annotation_step_type = typing.get_origin(annotations[\"step_type\"])\n    assert annotation_step_type == Literal, (\n        f\"annotation {annotations['step_type']} for `{cls.__name__}.step_type` \"\n        f\"is not Literal but {annotation_step_type}\"\n    )\n    found_step_type = typing.get_args(annotations[\"step_type\"])[0]\n    if cls.__name__.lower().endswith(\"step\"):\n        assert found_step_type == cls.__name__.lower()[:-4], (\n            f\"annotation Literal value {found_step_type!r} \"\n            f\"for `{cls.__name__}.step_type` is not the same as the class name \"\n            f\"(omitting 'step' suffix)\"\n        )\n    else:\n        assert found_step_type == cls.__name__.lower(), (\n            f\"annotation Literal value {found_step_type!r} \"\n            f\"for `{cls.__name__}.step_type` is not the same as the class name\"\n        )\n    cls.__subclasses.add(cls)\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase.as_pydantic_field", "title": "as_pydantic_field  <code>classmethod</code>", "text": "<pre><code>as_pydantic_field()\n</code></pre> <p>Pydantic field as a union of all subclasses, discriminated on step_type.</p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>@classmethod\ndef as_pydantic_field(cls):\n    \"\"\"Pydantic field as a union of all subclasses, discriminated on step_type.\"\"\"\n    if len(cls.__subclasses) &gt; 1:\n        return Annotated[\n            reduce(operator.__or__, cls.__subclasses),\n            Field(discriminator=\"step_type\"),\n        ]\n    else:  # only the DummyStep\n        return Annotated[reduce(operator.__or__, cls.__subclasses), Field()]\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase.use_config", "title": "use_config", "text": "<pre><code>use_config(config)\n</code></pre> <p>Some RM Steps might want to check parts of the config.</p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>def use_config(self, config):\n    \"\"\"Some RM Steps might want to check parts of the config.\"\"\"\n    pass\n</code></pre>"}, {"location": "API/config/rm_systems.html", "title": "RM Systems", "text": ""}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmProcess", "title": "RmProcess  <code>module-attribute</code>", "text": "<pre><code>RmProcess = ListOfNamed[RmStep]\n</code></pre>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmStep", "title": "RmStep  <code>module-attribute</code>", "text": "<pre><code>RmStep = as_pydantic_field()\n</code></pre>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem", "title": "RmSystem", "text": "<p>               Bases: <code>Named</code></p> Source code in <code>passengersim/config/rm_systems.py</code> <pre><code>class RmSystem(Named, extra=\"forbid\"):\n    processes: DictAttr[str, RmProcess]\n\n    availability_control: Literal[\"infer\", \"leg\", \"cabin\", \"theft\", \"bp\", \"bp_loose\", \"vn\", \"classless\", \"none\"] = \"infer\"\n    \"\"\"Fare class availability algorithm for carriers using this RmSystem.\n\n    The default value will infer the appropriate control based on the steps in\n    the DCP process (This is pending implementation).\n\n    Allowed values include:\n    - \"leg\" (default): Uses leg-based controls.\n    - \"bp\": Bid price controls with strict resolution (fare must be strictly\n            greater than bid price).\n    - \"bp_loose\": Bid price controls with non-strict resolution (fare must be\n                  greater than *or equal to* bid price).\n    - \"vn\": Virtual nesting.\n    - \"none\": No controls.\n    \"\"\"\n\n    description: str = \"\"\n    \"\"\"Description of the RM system.\n\n    The description is optional and can be used to summarize the RM system.\n    It has no effect on the actual operation of the RM system.\"\"\"\n\n    frat5: str | None = None\n    \"\"\"Default Frat5 curve to use for the carrier if not otherwise defined.\n\n    Some RM systems strictly require a Frat5 curve to be defined for every\n    carrier and market. This attribute allows the user to define a default\n    Frat5 curve to be used as the global default by any carrier assigned this\n    RM system. If a carrier defines its own global `frat5` then that value will\n    override this default.  If this attribute is set to `None`, then the RM system\n    does not define a default Frat5 curve, and the carrier must define its own\n    `frat5` attribute if necessary. Some RM systems do not require a Frat5 curve\n    to be defined, in which case this attribute can be left as `None` without\n    affecting the operation of the RM system.\n    \"\"\"\n\n    @field_validator(\"processes\")\n    @classmethod\n    def _require_dcp_process(cls, value: dict[str, RmProcess]):\n        \"\"\"Ensure that every RmSystem is either empty or has a DCP process.\n\n        This validator also converts all keys to lowercase.\n        \"\"\"\n        lower_value = DictAttr()\n        for k, v in value.items():\n            lower_value[k.lower()] = v\n        if len(lower_value) and \"dcp\" not in lower_value:\n            raise ValueError(\"Non-empty RmSystem missing a `dcp` process.\")\n        return lower_value\n</code></pre>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem.availability_control", "title": "availability_control  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>availability_control: Literal[\n    \"infer\",\n    \"leg\",\n    \"cabin\",\n    \"theft\",\n    \"bp\",\n    \"bp_loose\",\n    \"vn\",\n    \"classless\",\n    \"none\",\n] = \"infer\"\n</code></pre> <p>Fare class availability algorithm for carriers using this RmSystem.</p> <p>The default value will infer the appropriate control based on the steps in the DCP process (This is pending implementation).</p> <p>Allowed values include: - \"leg\" (default): Uses leg-based controls. - \"bp\": Bid price controls with strict resolution (fare must be strictly         greater than bid price). - \"bp_loose\": Bid price controls with non-strict resolution (fare must be               greater than or equal to bid price). - \"vn\": Virtual nesting. - \"none\": No controls.</p>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem.description", "title": "description  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>description: str = ''\n</code></pre> <p>Description of the RM system.</p> <p>The description is optional and can be used to summarize the RM system. It has no effect on the actual operation of the RM system.</p>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem.frat5", "title": "frat5  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frat5: str | None = None\n</code></pre> <p>Default Frat5 curve to use for the carrier if not otherwise defined.</p> <p>Some RM systems strictly require a Frat5 curve to be defined for every carrier and market. This attribute allows the user to define a default Frat5 curve to be used as the global default by any carrier assigned this RM system. If a carrier defines its own global <code>frat5</code> then that value will override this default.  If this attribute is set to <code>None</code>, then the RM system does not define a default Frat5 curve, and the carrier must define its own <code>frat5</code> attribute if necessary. Some RM systems do not require a Frat5 curve to be defined, in which case this attribute can be left as <code>None</code> without affecting the operation of the RM system.</p>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem.processes", "title": "processes  <code>instance-attribute</code>", "text": "<pre><code>processes: DictAttr[str, RmProcess]\n</code></pre>"}, {"location": "API/config/snapshot_filter.html", "title": "Snapshot filter", "text": ""}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter", "title": "SnapshotFilter", "text": "<p>               Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>class SnapshotFilter(BaseModel, validate_assignment=True):\n    type: Literal[\n        \"fare_adj\",\n        \"forecast\",\n        \"leg_untruncation\",\n        \"path_untruncation\",\n        \"rm\",\n        \"pro_bp\",\n        \"classless_pro_bp\",\n        \"forecast_adj\",\n        \"hybrid\",\n        \"udp\",\n        None,\n    ] = None\n    title: str = \"\"\n    carrier: str = \"\"\n    trial: list[int] = []\n    sample: list[int] = []\n    dcp: list[int] = []\n    orig: list[str] = []\n    dest: list[str] = []\n    flt_no: list[int] = []\n    logger: str | None = None\n    directory: pathlib.Path | None = None\n\n    @field_validator(\"trial\", \"sample\", \"dcp\", \"orig\", \"dest\", \"flt_no\", mode=\"before\")\n    def _allow_singletons(cls, v):\n        \"\"\"Allow a singleton value that is converted to a list of one item.\"\"\"\n        if not isinstance(v, list | tuple):\n            v = [v]\n        return v\n\n    def filepath(self, sim, leg=None, path=None) -&gt; pathlib.Path | None:\n        if self.directory is None:\n            return None\n        pth = self.directory\n        if leg is not None:\n            pth = pth.joinpath(f\"carrier-{leg.carrier}\")\n        pth = pth.joinpath(f\"dpc-{sim.last_dcp}\")\n        if leg is not None:\n            pth = pth.joinpath(f\"orig-{leg.orig}\")\n        elif path is not None:\n            pth = pth.joinpath(f\"orig-{path.orig}\")\n        if leg is not None:\n            pth = pth.joinpath(f\"dest-{leg.dest}\")\n        elif path is not None:\n            pth = pth.joinpath(f\"dest-{path.dest}\")\n        if leg is not None:\n            pth = pth.joinpath(f\"fltno-{leg.flt_no}\")\n        elif path is not None:\n            pth = pth.joinpath(f\"fltno-{path.get_leg_fltno(0)}\")\n        if sim.num_trials &gt; 1:\n            pth = pth.joinpath(f\"trial-{sim.trial}\")\n        pth = pth.joinpath(f\"sample-{sim.sample}\")\n        pth.parent.mkdir(parents=True, exist_ok=True)\n        return pth.with_suffix(\".log\")\n\n    def run(self, sim, leg=None, path=None, carrier=None, orig=None, dest=None, why=False) -&gt; SnapshotInstruction:\n        # Check the filter conditions\n        info = \"\"\n\n        if len(self.trial) &gt; 0 and sim.trial not in self.trial and sim.num_trials &gt; 1:\n            return SnapshotInstruction(False, why=f\"cause {sim.trial=}\")\n        info += f\"  trial={sim.trial}\"\n\n        if len(self.sample) &gt; 0 and sim.sample not in self.sample:\n            return SnapshotInstruction(False, why=f\"cause {sim.sample=}\")\n        info += f\"  sample={sim.sample}\"\n\n        if len(self.dcp) &gt; 0 and sim.last_dcp not in self.dcp:\n            return SnapshotInstruction(False, why=f\"cause {sim.last_dcp=}\")\n        info += f\"  dcp={sim.last_dcp}\"\n\n        if leg is not None:\n            if self.carrier and leg.carrier != self.carrier:\n                return SnapshotInstruction(False, why=f\"cause {leg.carrier=}\")\n            info += f\"  carrier={leg.carrier}\"\n\n            if len(self.orig) &gt; 0 and leg.orig not in self.orig:\n                return SnapshotInstruction(False, why=f\"cause {leg.orig=}\")\n            info += f\"  orig={leg.orig}\"\n\n            if len(self.dest) &gt; 0 and leg.dest not in self.dest:\n                return SnapshotInstruction(False, why=f\"cause {leg.dest=}\")\n            info += f\"  dest={leg.dest}\"\n\n            if len(self.flt_no) &gt; 0 and leg.flt_no not in self.flt_no:\n                return SnapshotInstruction(False, why=f\"cause {leg.flt_no=}\")\n            info += f\"  flt_no={leg.flt_no}\"\n\n        if path is not None:\n            if len(self.orig) &gt; 0 and path.orig not in self.orig:\n                return SnapshotInstruction(False, why=f\"cause {path.orig=}\")\n            info += f\"  orig={path.orig}\"\n\n            if len(self.dest) &gt; 0 and path.dest not in self.dest:\n                return SnapshotInstruction(False, why=f\"cause {path.dest=}\")\n            info += f\"  dest={path.dest}\"\n\n            if len(self.flt_no) &gt; 0 and path.get_leg_fltno(0) not in self.flt_no:\n                return SnapshotInstruction(False, why=f\"cause {path.get_leg_fltno(0)=}\")\n            info += f\"  flt_no={path.get_leg_fltno(0)}\"\n\n        if carrier is not None:\n            if self.carrier and carrier != self.carrier:\n                return SnapshotInstruction(False, why=f\"cause {carrier=}\")\n            info += f\"  carrier={carrier}\"\n\n        if orig is not None:\n            if self.orig and orig not in self.orig:\n                return SnapshotInstruction(False, why=f\"cause {orig=}\")\n            info += f\"  orig={orig}\"\n\n        if dest is not None:\n            if self.carrier and dest not in self.dest:\n                return SnapshotInstruction(False, why=f\"cause {dest=}\")\n            info += f\"  dest={dest}\"\n\n        # Now do something\n        snapshot_file = self.filepath(sim, leg, path)\n        created_date = time.strftime(\"Snapshot created %Y-%m-%d %A %I:%M:%S %p\")\n        title = f\"{self.title}:{info}\\n{created_date}\\n\"\n        if len(self.title) &gt; 0 and not snapshot_file:\n            print(f\"{self.title}:{info}\", flush=True)\n\n        self._last_run_info = info\n\n        if self.type in [\"fare_adj\"]:\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type in [\"leg_untruncation\", \"path_untruncation\"]:\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type in (\"forecast\", \"forecast_adj\"):\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type == \"hybrid\":\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type == \"rm\":\n            bucket_detail = leg.print_bucket_detail()\n            snapshot_file = self.filepath(sim, leg, path)\n            if snapshot_file:\n                with snapshot_file.open(mode=\"a\") as f:\n                    f.write(title)\n                    f.write(bucket_detail)\n            else:\n                print(bucket_detail)\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type == \"pro_bp\":\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type == \"classless_pro_bp\":\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type == \"udp\":\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type is None:\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n\n        raise ValueError(f\"unknown snapshot filter type {self.type!r}\")\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.carrier", "title": "carrier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>carrier: str = ''\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.dcp", "title": "dcp  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcp: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.dest", "title": "dest  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dest: list[str] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.directory", "title": "directory  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>directory: Path | None = None\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.flt_no", "title": "flt_no  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>flt_no: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.orig", "title": "orig  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>orig: list[str] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.sample", "title": "sample  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>sample: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.title", "title": "title  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>title: str = ''\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.trial", "title": "trial  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>trial: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.type", "title": "type  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>type: Literal[\n    \"fare_adj\",\n    \"forecast\",\n    \"leg_untruncation\",\n    \"path_untruncation\",\n    \"rm\",\n    \"pro_bp\",\n    \"classless_pro_bp\",\n    \"forecast_adj\",\n    \"hybrid\",\n    \"udp\",\n    None,\n] = None\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.filepath", "title": "filepath", "text": "<pre><code>filepath(sim, leg=None, path=None) -&gt; Path | None\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def filepath(self, sim, leg=None, path=None) -&gt; pathlib.Path | None:\n    if self.directory is None:\n        return None\n    pth = self.directory\n    if leg is not None:\n        pth = pth.joinpath(f\"carrier-{leg.carrier}\")\n    pth = pth.joinpath(f\"dpc-{sim.last_dcp}\")\n    if leg is not None:\n        pth = pth.joinpath(f\"orig-{leg.orig}\")\n    elif path is not None:\n        pth = pth.joinpath(f\"orig-{path.orig}\")\n    if leg is not None:\n        pth = pth.joinpath(f\"dest-{leg.dest}\")\n    elif path is not None:\n        pth = pth.joinpath(f\"dest-{path.dest}\")\n    if leg is not None:\n        pth = pth.joinpath(f\"fltno-{leg.flt_no}\")\n    elif path is not None:\n        pth = pth.joinpath(f\"fltno-{path.get_leg_fltno(0)}\")\n    if sim.num_trials &gt; 1:\n        pth = pth.joinpath(f\"trial-{sim.trial}\")\n    pth = pth.joinpath(f\"sample-{sim.sample}\")\n    pth.parent.mkdir(parents=True, exist_ok=True)\n    return pth.with_suffix(\".log\")\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.run", "title": "run", "text": "<pre><code>run(\n    sim,\n    leg=None,\n    path=None,\n    carrier=None,\n    orig=None,\n    dest=None,\n    why=False,\n) -&gt; SnapshotInstruction\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def run(self, sim, leg=None, path=None, carrier=None, orig=None, dest=None, why=False) -&gt; SnapshotInstruction:\n    # Check the filter conditions\n    info = \"\"\n\n    if len(self.trial) &gt; 0 and sim.trial not in self.trial and sim.num_trials &gt; 1:\n        return SnapshotInstruction(False, why=f\"cause {sim.trial=}\")\n    info += f\"  trial={sim.trial}\"\n\n    if len(self.sample) &gt; 0 and sim.sample not in self.sample:\n        return SnapshotInstruction(False, why=f\"cause {sim.sample=}\")\n    info += f\"  sample={sim.sample}\"\n\n    if len(self.dcp) &gt; 0 and sim.last_dcp not in self.dcp:\n        return SnapshotInstruction(False, why=f\"cause {sim.last_dcp=}\")\n    info += f\"  dcp={sim.last_dcp}\"\n\n    if leg is not None:\n        if self.carrier and leg.carrier != self.carrier:\n            return SnapshotInstruction(False, why=f\"cause {leg.carrier=}\")\n        info += f\"  carrier={leg.carrier}\"\n\n        if len(self.orig) &gt; 0 and leg.orig not in self.orig:\n            return SnapshotInstruction(False, why=f\"cause {leg.orig=}\")\n        info += f\"  orig={leg.orig}\"\n\n        if len(self.dest) &gt; 0 and leg.dest not in self.dest:\n            return SnapshotInstruction(False, why=f\"cause {leg.dest=}\")\n        info += f\"  dest={leg.dest}\"\n\n        if len(self.flt_no) &gt; 0 and leg.flt_no not in self.flt_no:\n            return SnapshotInstruction(False, why=f\"cause {leg.flt_no=}\")\n        info += f\"  flt_no={leg.flt_no}\"\n\n    if path is not None:\n        if len(self.orig) &gt; 0 and path.orig not in self.orig:\n            return SnapshotInstruction(False, why=f\"cause {path.orig=}\")\n        info += f\"  orig={path.orig}\"\n\n        if len(self.dest) &gt; 0 and path.dest not in self.dest:\n            return SnapshotInstruction(False, why=f\"cause {path.dest=}\")\n        info += f\"  dest={path.dest}\"\n\n        if len(self.flt_no) &gt; 0 and path.get_leg_fltno(0) not in self.flt_no:\n            return SnapshotInstruction(False, why=f\"cause {path.get_leg_fltno(0)=}\")\n        info += f\"  flt_no={path.get_leg_fltno(0)}\"\n\n    if carrier is not None:\n        if self.carrier and carrier != self.carrier:\n            return SnapshotInstruction(False, why=f\"cause {carrier=}\")\n        info += f\"  carrier={carrier}\"\n\n    if orig is not None:\n        if self.orig and orig not in self.orig:\n            return SnapshotInstruction(False, why=f\"cause {orig=}\")\n        info += f\"  orig={orig}\"\n\n    if dest is not None:\n        if self.carrier and dest not in self.dest:\n            return SnapshotInstruction(False, why=f\"cause {dest=}\")\n        info += f\"  dest={dest}\"\n\n    # Now do something\n    snapshot_file = self.filepath(sim, leg, path)\n    created_date = time.strftime(\"Snapshot created %Y-%m-%d %A %I:%M:%S %p\")\n    title = f\"{self.title}:{info}\\n{created_date}\\n\"\n    if len(self.title) &gt; 0 and not snapshot_file:\n        print(f\"{self.title}:{info}\", flush=True)\n\n    self._last_run_info = info\n\n    if self.type in [\"fare_adj\"]:\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type in [\"leg_untruncation\", \"path_untruncation\"]:\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type in (\"forecast\", \"forecast_adj\"):\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type == \"hybrid\":\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type == \"rm\":\n        bucket_detail = leg.print_bucket_detail()\n        snapshot_file = self.filepath(sim, leg, path)\n        if snapshot_file:\n            with snapshot_file.open(mode=\"a\") as f:\n                f.write(title)\n                f.write(bucket_detail)\n        else:\n            print(bucket_detail)\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type == \"pro_bp\":\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type == \"classless_pro_bp\":\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type == \"udp\":\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type is None:\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n\n    raise ValueError(f\"unknown snapshot filter type {self.type!r}\")\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction", "title": "SnapshotInstruction", "text": "Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>class SnapshotInstruction:\n    def __init__(\n        self,\n        trigger: bool = False,\n        filepath: pathlib.Path | str | None = None,\n        why: str | None = None,\n        filter: SnapshotFilter | None = None,\n        mode: Literal[\"w\", \"a\"] = \"w\",\n    ):\n        self.trigger = bool(trigger)\n        \"\"\"Has this snapshot been triggered.\"\"\"\n\n        self.why = why\n        \"\"\"Explanation of why snapshot is (or is not) triggered.\"\"\"\n\n        if isinstance(filepath, str):\n            filepath = pathlib.Path(filepath)\n\n        self.filepath = filepath\n        \"\"\"Where to save snapshot content.\"\"\"\n\n        self.filter = filter\n        \"\"\"A reference to the filter that spawned this instruction.\"\"\"\n\n        self.mode = mode\n        \"\"\"Write mode for new content, `w` overwrites existing file, `a` appends.\"\"\"\n\n    def __bool__(self) -&gt; bool:\n        return self.trigger\n\n    def write(self, content: str = \"\"):\n        \"\"\"Write snapshot content to a file, or just print it\"\"\"\n        if not content:\n            return\n        if self.filepath:\n            with self.filepath.open(mode=self.mode) as f:\n                if self.why:\n                    f.write(self.why)\n                    f.write(\"\\n\")\n                if isinstance(content, bytes):\n                    content = content.decode(\"utf-8\")\n                elif not isinstance(content, str):\n                    content = str(content)\n                f.write(content)\n                if content[-1] != \"\\n\":\n                    f.write(\"\\n\")\n        else:\n            if self.why:\n                print(self.why)\n            print(content)\n\n    def write_more(self, content: str = \"\"):\n        \"\"\"Write additional snapshot content to a file, or just print it\"\"\"\n        if not content:\n            return\n        if self.filepath:\n            with self.filepath.open(mode=\"a\") as f:\n                if isinstance(content, bytes):\n                    content = content.decode(\"utf-8\")\n                elif not isinstance(content, str):\n                    content = str(content)\n                f.write(content)\n                if content[-1] != \"\\n\":\n                    f.write(\"\\n\")\n        else:\n            print(content)\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.filepath", "title": "filepath  <code>instance-attribute</code>", "text": "<pre><code>filepath = filepath\n</code></pre> <p>Where to save snapshot content.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.filter", "title": "filter  <code>instance-attribute</code>", "text": "<pre><code>filter = filter\n</code></pre> <p>A reference to the filter that spawned this instruction.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.mode", "title": "mode  <code>instance-attribute</code>", "text": "<pre><code>mode = mode\n</code></pre> <p>Write mode for new content, <code>w</code> overwrites existing file, <code>a</code> appends.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.trigger", "title": "trigger  <code>instance-attribute</code>", "text": "<pre><code>trigger = bool(trigger)\n</code></pre> <p>Has this snapshot been triggered.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.why", "title": "why  <code>instance-attribute</code>", "text": "<pre><code>why = why\n</code></pre> <p>Explanation of why snapshot is (or is not) triggered.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.__bool__", "title": "__bool__", "text": "<pre><code>__bool__() -&gt; bool\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    return self.trigger\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    trigger: bool = False,\n    filepath: Path | str | None = None,\n    why: str | None = None,\n    filter: SnapshotFilter | None = None,\n    mode: Literal[\"w\", \"a\"] = \"w\",\n)\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def __init__(\n    self,\n    trigger: bool = False,\n    filepath: pathlib.Path | str | None = None,\n    why: str | None = None,\n    filter: SnapshotFilter | None = None,\n    mode: Literal[\"w\", \"a\"] = \"w\",\n):\n    self.trigger = bool(trigger)\n    \"\"\"Has this snapshot been triggered.\"\"\"\n\n    self.why = why\n    \"\"\"Explanation of why snapshot is (or is not) triggered.\"\"\"\n\n    if isinstance(filepath, str):\n        filepath = pathlib.Path(filepath)\n\n    self.filepath = filepath\n    \"\"\"Where to save snapshot content.\"\"\"\n\n    self.filter = filter\n    \"\"\"A reference to the filter that spawned this instruction.\"\"\"\n\n    self.mode = mode\n    \"\"\"Write mode for new content, `w` overwrites existing file, `a` appends.\"\"\"\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.write", "title": "write", "text": "<pre><code>write(content: str = '')\n</code></pre> <p>Write snapshot content to a file, or just print it</p> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def write(self, content: str = \"\"):\n    \"\"\"Write snapshot content to a file, or just print it\"\"\"\n    if not content:\n        return\n    if self.filepath:\n        with self.filepath.open(mode=self.mode) as f:\n            if self.why:\n                f.write(self.why)\n                f.write(\"\\n\")\n            if isinstance(content, bytes):\n                content = content.decode(\"utf-8\")\n            elif not isinstance(content, str):\n                content = str(content)\n            f.write(content)\n            if content[-1] != \"\\n\":\n                f.write(\"\\n\")\n    else:\n        if self.why:\n            print(self.why)\n        print(content)\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.write_more", "title": "write_more", "text": "<pre><code>write_more(content: str = '')\n</code></pre> <p>Write additional snapshot content to a file, or just print it</p> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def write_more(self, content: str = \"\"):\n    \"\"\"Write additional snapshot content to a file, or just print it\"\"\"\n    if not content:\n        return\n    if self.filepath:\n        with self.filepath.open(mode=\"a\") as f:\n            if isinstance(content, bytes):\n                content = content.decode(\"utf-8\")\n            elif not isinstance(content, str):\n                content = str(content)\n            f.write(content)\n            if content[-1] != \"\\n\":\n                f.write(\"\\n\")\n    else:\n        print(content)\n</code></pre>"}, {"location": "API/config/standards.html", "title": "Standards", "text": ""}, {"location": "API/config/standards.html#passengersim.config.standards.describe_standard_rm_systems", "title": "describe_standard_rm_systems", "text": "<pre><code>describe_standard_rm_systems(stream=stdout) -&gt; str | None\n</code></pre> Source code in <code>passengersim/config/standards.py</code> <pre><code>def describe_standard_rm_systems(stream=sys.stdout) -&gt; str | None:\n    msg = \"\"\n    d = standard_rm_systems_raw()\n    for k in d:\n        msg += f\"{k}:\\n\"\n        msg += textwrap.fill(\n            d[k].get(\"description\", \"no description available\"),\n            70,\n            initial_indent=\"  \",\n            subsequent_indent=\"  \",\n        )\n        msg += \"\\n\"\n    if stream is None:\n        return msg\n    print(msg, file=stream)\n</code></pre>"}, {"location": "API/config/standards.html#passengersim.config.standards.standard_rm_systems_raw", "title": "standard_rm_systems_raw", "text": "<pre><code>standard_rm_systems_raw() -&gt; Dict\n</code></pre> Source code in <code>passengersim/config/standards.py</code> <pre><code>def standard_rm_systems_raw() -&gt; addicty.Dict:\n    with open(demo_network(\"standard-rm-systems.yaml\")) as f:\n        d = addicty.Dict.load(f, freeze=False, Loader=yaml.CSafeLoader)\n    if \"rm_systems\" not in d:\n        d.rm_systems = addicty.Dict()\n    return d.rm_systems\n</code></pre>"}, {"location": "API/config/todd_curves.html", "title": "Booking Curves", "text": ""}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve", "title": "ToddCurve", "text": "<p>               Bases: <code>PrettyModel</code></p> <p>Customer preference data for Time Of Day</p> Source code in <code>passengersim/config/todd_curves.py</code> <pre><code>class ToddCurve(PrettyModel, extra=\"forbid\"):\n    \"\"\"\n    Customer preference data for Time Of Day\n    \"\"\"\n\n    name: str = \"???\"\n    min_distance: int = 0\n    max_distance: int = 25000\n    k_factor: float = 0.3\n\n    probabilities: dict[int, float] | list[float] = None\n    \"\"\"Define a TODD curve.\n\n\n    Example\n    -------\n    ```{yaml}\n    - name: business\n      curve:\n        63: 0.01\n        56: 0.02\n        49: 0.05\n        42: 0.13\n        35: 0.19\n        31: 0.23\n        28: 0.29\n        24: 0.35\n        21: 0.45\n        17: 0.54\n        14: 0.67\n        10: 0.79\n        7: 0.86\n        5: 0.91\n        3: 0.96\n        1: 1.0\n    ```\n    \"\"\"\n</code></pre>"}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve.k_factor", "title": "k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>k_factor: float = 0.3\n</code></pre>"}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve.max_distance", "title": "max_distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>max_distance: int = 25000\n</code></pre>"}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve.min_distance", "title": "min_distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>min_distance: int = 0\n</code></pre>"}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve.name", "title": "name  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>name: str = '???'\n</code></pre>"}, {"location": "API/config/todd_curves.html#passengersim.config.todd_curves.ToddCurve.probabilities", "title": "probabilities  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>probabilities: dict[int, float] | list[float] = None\n</code></pre> <p>Define a TODD curve.</p> Example <pre><code>- name: business\n  curve:\n    63: 0.01\n    56: 0.02\n    49: 0.05\n    42: 0.13\n    35: 0.19\n    31: 0.23\n    28: 0.29\n    24: 0.35\n    21: 0.45\n    17: 0.54\n    14: 0.67\n    10: 0.79\n    7: 0.86\n    5: 0.91\n    3: 0.96\n    1: 1.0\n</code></pre>"}, {"location": "API/database/index.html", "title": "Database", "text": ""}, {"location": "API/database/index.html#passengersim.database.database.leg_bucket_sql", "title": "leg_bucket_sql  <code>module-attribute</code>", "text": "<pre><code>leg_bucket_sql = {}\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.n_commit", "title": "n_commit  <code>module-attribute</code>", "text": "<pre><code>n_commit = 0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database", "title": "Database", "text": "<p>A wrapper to manage transactions for PassengerSim on SQLite.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>class Database:\n    \"\"\"A wrapper to manage transactions for PassengerSim on SQLite.\"\"\"\n\n    def __init__(\n        self,\n        engine: Literal[\"sqlite\", None] = \"sqlite\",\n        filename=None,\n        pragmas: Iterable[str] = (),\n        commit_count_delay: int | None = 250,\n    ):\n        if isinstance(engine, str) and engine.endswith(\".sqlite\") and filename is None:\n            filename = engine\n            engine = \"sqlite\"\n        self._connection = None\n        self.engine = engine\n        self.filename = filename\n        self.pragmas = pragmas\n        self._counter = 0\n        self._commit_count_delay = commit_count_delay\n        if self._commit_count_delay is not None:\n            self.commit = self._commit_by_count\n        else:\n            self.commit = self._commit_raw\n        self.open()\n\n    def __getattr__(self, item):\n        return getattr(self._connection, item)\n\n    def open(self, filename: str | None = None):\n        \"\"\"Open the connection if it is not already open.\"\"\"\n        if self._connection is not None:\n            raise ConnectionError(\"the connection is already open\")\n        self.filename = filename or self.filename\n        if self.engine is None:\n            self._connection = None\n        elif self.engine == \"sqlite\" and self.filename is None:\n            self._connection = None\n        elif self.engine == \"sqlite\":\n            if self.filename != \":memory:\":\n                Path(self.filename).parent.mkdir(exist_ok=True, parents=True)\n            logger.info(f\"connecting to sqlite database: {self.filename}\")\n            self._connection = sqlite3.Connection(self.filename)\n            self._connection.create_aggregate(\"VARIANCE\", 1, _VarianceFunc)\n            self._connection.create_aggregate(\"STDEV\", 1, _StdevFunc)\n            for pragma in self.pragmas:\n                self._connection.execute(f\"PRAGMA {pragma};\")\n            self._connection.execute(\"BEGIN TRANSACTION;\")\n            logger.debug(\"initializing sqlite tables\")\n            from .tables import create_tables\n\n            create_tables(self)\n        else:\n            raise NotImplementedError(f\"unknown engine {self.engine!r}\")\n\n    def close(self):\n        \"\"\"Flush pending operations and close the connection.\"\"\"\n        if self._connection:\n            if self._connection.in_transaction:\n                self._connection.execute(\"COMMIT;\")\n            self._connection.close()\n            self._connection = None\n\n    def _commit_by_count(self):\n        self._counter += 1\n        if self._counter &gt;= self._commit_count_delay:\n            self._commit_raw()\n            self._counter = 0\n\n    def _commit_raw(self):\n        if self._connection:\n            if self._connection.in_transaction:\n                self._connection.execute(\"COMMIT;\")\n            self._connection.execute(\"BEGIN TRANSACTION;\")\n\n    def __enter__(self):\n        if self._connection:\n            return self._connection.__enter__()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self._connection:\n            return self._connection.__exit__(exc_type, exc_val, exc_tb)\n\n    @property\n    def is_open(self) -&gt; bool:\n        return self._connection is not None\n\n    def sql_placeholders(self, n: int):\n        \"\"\"A parenthesis enclosed set of `n` placeholders for the selected engine.\"\"\"\n        if self.engine == \"sqlite\":\n            x = \"?\"\n        else:\n            x = \"%s\"\n        return \"(\" + \", \".join(x for _ in range(n)) + \")\"\n\n    def delete_experiment(self, name: str):\n        if self.is_open:\n            logger.debug(f\"deleting existing scenario {name!r} from database\")\n            self.execute(\"DELETE FROM leg_detail WHERE scenario = ?\", (name,))\n            self.execute(\"DELETE FROM leg_bucket_detail WHERE scenario = ?\", (name,))\n            self.execute(\"DELETE FROM demand_detail WHERE scenario = ?\", (name,))\n            self.execute(\"DELETE FROM fare_detail WHERE scenario = ?\", (name,))\n            self._commit_raw()\n        else:\n            logger.debug(f\"database not open, cannot delete {name!r}\")\n\n    def save_configs(self, cfg: Config) -&gt; None:\n        \"\"\"Save configs into the database.\"\"\"\n        from passengersim import __version__\n\n        self.execute(\n            \"\"\"\n        INSERT OR REPLACE INTO runtime_configs(\n            scenario, pxsim_version, configs\n        ) VALUES (?1, ?2, ?3)\n        \"\"\",\n            (\n                cfg.scenario,\n                str(__version__),\n                cfg.model_dump_json(exclude={\"db\": \"dcp_write_hooks\", \"raw_license_certificate\": True}),\n            ),\n        )\n\n    def load_raw_configs(self, scenario=None) -&gt; dict | Any:\n        import json\n\n        if scenario:\n            rawjson = next(\n                self.execute(\n                    \"SELECT configs, max(updated_at) FROM runtime_configs \" \"WHERE scenario = ?1\",\n                    (scenario,),\n                )\n            )[0]\n        else:\n            rawjson = next(self.execute(\"SELECT configs, max(updated_at) FROM runtime_configs\"))[0]\n        result = json.loads(rawjson)\n        if not isinstance(result, dict):\n            warnings.warn(\"malformed configs, not a mapping\", stacklevel=2)\n        return result\n\n    def load_configs(self, scenario=None, on_validation_error: Literal[\"raise\", \"ignore\"] = \"raise\") -&gt; Config | Any:\n        raw = self.load_raw_configs(scenario)\n\n        from pydantic import ValidationError\n\n        try:\n            return Config.model_validate(raw)\n        except ValidationError as err:\n            logger.error(f\"error loading configs: {err}\")\n            if on_validation_error == \"raise\":\n                raise\n            else:\n                return raw\n\n    def save_details(self: Database, db_writer: DbWriter, sim: SimulationEngine, dcp: int):\n        \"\"\"\n        Save details, can be done at each RRD/DCP and at the end of the run\n        \"\"\"\n        if not sim.save_timeframe_details and dcp &gt; 0:\n            return\n        if sim.config.db.fast and isinstance(self._connection, sqlite3.Connection):\n            _internal_log = db_writer.write_to_sqlite(\n                self._connection,\n                dcp,\n                store_bid_prices=sim.config.db.store_leg_bid_prices,\n                store_displacements=sim.config.db.store_displacements,\n            )\n        else:\n            for leg in sim.legs:\n                if \"leg\" in sim.config.db.write_items:\n                    save_leg(self, sim, leg, dcp)\n                if \"bucket\" in sim.config.db.write_items:\n                    save_leg_bucket_multi(self, sim, leg, dcp)\n            if \"fare\" in sim.config.db.write_items:\n                save_fare_multi(self, sim, dcp)\n            if \"demand\" in sim.config.db.write_items:\n                save_demand_multi(self, sim, dcp)\n        # hooks for custom writers written in Python, may be slow\n        for f in sim.config.db.dcp_write_hooks:\n            f(self, sim, dcp)\n        self.commit()\n\n    def save_final(self: Database, sim: SimulationEngine):\n        sim.final_write_to_sqlite(self._connection)\n\n    def dataframe(self, query: str, params: list | tuple | dict | None = None, dtype=None):\n        \"\"\"Run a SQL query and return the results as a pandas DataFrame.\"\"\"\n        if not self.is_open:\n            raise ValueError(\"database is not open\")\n        import pandas as pd\n\n        return pd.read_sql_query(query, self._connection, params=params, dtype=dtype)\n\n    def schema(self, name: str):\n        \"\"\"Get a table schema from the SQLite database.\"\"\"\n        if not self.is_open:\n            raise ValueError(\"database is not open\")\n        try:\n            return next(self.execute(\"SELECT sql FROM sqlite_master WHERE name = ?1\", (name,)))[0]\n        except Exception:\n            raise\n\n    def save_dataframe(\n        self,\n        name: str,\n        df: pd.DataFrame,\n        if_exists: Literal[\"fail\", \"replace\", \"append\"] = \"replace\",\n    ):\n        \"\"\"Save a dataframe as a table in this database.\"\"\"\n        df.to_sql(name, self._connection, if_exists=if_exists)\n\n    def table_names(self) -&gt; list[str]:\n        \"\"\"List of all tables in the database.\"\"\"\n        qry = \"SELECT name FROM sqlite_master WHERE type=='table'\"\n        return [i[0] for i in self._connection.execute(qry)]\n\n    def table_info(self, table_name: str) -&gt; pd.DataFrame:\n        \"\"\"Get info about a table\"\"\"\n        df = self.dataframe(f\"PRAGMA table_info({table_name})\")\n        return df.set_index(\"cid\")\n\n    def index_names(self, table_name) -&gt; list[str]:\n        \"\"\"List of all named indexes on a given table.\"\"\"\n        qry = \"SELECT name FROM sqlite_master WHERE type=='index' AND tbl_name==?1\"\n        return [i[0] for i in self._connection.execute(qry, (table_name,))]\n\n    def add_indexes(self, fare_detail=True, leg_detail=True):\n        any_work = False\n        if fare_detail and \"fare_detail_idx_2\" not in self.index_names(\"fare_detail\"):\n            logger.info(\"adding index on fare_detail\")\n            idx = \"\"\"\n            CREATE INDEX fare_detail_idx_2\n            ON fare_detail (\n                fare_id, scenario, trial, sample, days_prior\n            );\n            \"\"\"\n            self._connection.execute(idx)\n            self._connection.commit()\n            self._connection.execute(\"BEGIN TRANSACTION;\")\n            any_work = True\n\n        if leg_detail and \"leg_detail_idx_2\" not in self.index_names(\"leg_detail\"):\n            logger.info(\"adding index on leg_detail\")\n            idx = \"\"\"\n            CREATE INDEX leg_detail_idx_2\n            ON leg_detail (scenario, trial, sample, days_prior, leg_id);\n            \"\"\"\n            self._connection.execute(idx)\n            self._connection.commit()\n            self._connection.execute(\"BEGIN TRANSACTION;\")\n            any_work = True\n\n        if any_work:\n            logger.info(\"completed adding indexes\")\n\n    def backup(self, dst: Path | str | sqlite3.Connection, show_progress: bool = True):\n        \"\"\"Back up this database to another copy.\"\"\"\n        if self.engine != \"sqlite\":\n            raise NotImplementedError(f\"no backup available for engine={self.engine!r}\")\n        if not self.is_open:\n            raise OSError(\"database connection is not open\")\n\n        def _progress(status, remaining, total):\n            if remaining:\n                print(f\"Copied {total - remaining} of {total} pages...\")\n            else:\n                print(f\"Copied all {total} pages.\")\n\n        if not isinstance(dst, sqlite3.Connection):\n            dst = sqlite3.connect(dst)\n        if self._connection.in_transaction:\n            self._connection.execute(\"COMMIT;\")\n        with dst:\n            self._connection.backup(dst, pages=10000, progress=_progress if show_progress else None)\n        self._connection.execute(\"BEGIN TRANSACTION;\")\n        dst.close()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._commit_count_delay", "title": "_commit_count_delay  <code>instance-attribute</code>", "text": "<pre><code>_commit_count_delay = commit_count_delay\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._connection", "title": "_connection  <code>instance-attribute</code>", "text": "<pre><code>_connection = None\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._counter", "title": "_counter  <code>instance-attribute</code>", "text": "<pre><code>_counter = 0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.commit", "title": "commit  <code>instance-attribute</code>", "text": "<pre><code>commit = _commit_by_count\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.engine", "title": "engine  <code>instance-attribute</code>", "text": "<pre><code>engine = engine\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.filename", "title": "filename  <code>instance-attribute</code>", "text": "<pre><code>filename = filename\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.is_open", "title": "is_open  <code>property</code>", "text": "<pre><code>is_open: bool\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.pragmas", "title": "pragmas  <code>instance-attribute</code>", "text": "<pre><code>pragmas = pragmas\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.__enter__", "title": "__enter__", "text": "<pre><code>__enter__()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __enter__(self):\n    if self._connection:\n        return self._connection.__enter__()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.__exit__", "title": "__exit__", "text": "<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    if self._connection:\n        return self._connection.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.__getattr__", "title": "__getattr__", "text": "<pre><code>__getattr__(item)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __getattr__(self, item):\n    return getattr(self._connection, item)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    engine: Literal[\"sqlite\", None] = \"sqlite\",\n    filename=None,\n    pragmas: Iterable[str] = (),\n    commit_count_delay: int | None = 250,\n)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __init__(\n    self,\n    engine: Literal[\"sqlite\", None] = \"sqlite\",\n    filename=None,\n    pragmas: Iterable[str] = (),\n    commit_count_delay: int | None = 250,\n):\n    if isinstance(engine, str) and engine.endswith(\".sqlite\") and filename is None:\n        filename = engine\n        engine = \"sqlite\"\n    self._connection = None\n    self.engine = engine\n    self.filename = filename\n    self.pragmas = pragmas\n    self._counter = 0\n    self._commit_count_delay = commit_count_delay\n    if self._commit_count_delay is not None:\n        self.commit = self._commit_by_count\n    else:\n        self.commit = self._commit_raw\n    self.open()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._commit_by_count", "title": "_commit_by_count", "text": "<pre><code>_commit_by_count()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def _commit_by_count(self):\n    self._counter += 1\n    if self._counter &gt;= self._commit_count_delay:\n        self._commit_raw()\n        self._counter = 0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._commit_raw", "title": "_commit_raw", "text": "<pre><code>_commit_raw()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def _commit_raw(self):\n    if self._connection:\n        if self._connection.in_transaction:\n            self._connection.execute(\"COMMIT;\")\n        self._connection.execute(\"BEGIN TRANSACTION;\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.add_indexes", "title": "add_indexes", "text": "<pre><code>add_indexes(fare_detail=True, leg_detail=True)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def add_indexes(self, fare_detail=True, leg_detail=True):\n    any_work = False\n    if fare_detail and \"fare_detail_idx_2\" not in self.index_names(\"fare_detail\"):\n        logger.info(\"adding index on fare_detail\")\n        idx = \"\"\"\n        CREATE INDEX fare_detail_idx_2\n        ON fare_detail (\n            fare_id, scenario, trial, sample, days_prior\n        );\n        \"\"\"\n        self._connection.execute(idx)\n        self._connection.commit()\n        self._connection.execute(\"BEGIN TRANSACTION;\")\n        any_work = True\n\n    if leg_detail and \"leg_detail_idx_2\" not in self.index_names(\"leg_detail\"):\n        logger.info(\"adding index on leg_detail\")\n        idx = \"\"\"\n        CREATE INDEX leg_detail_idx_2\n        ON leg_detail (scenario, trial, sample, days_prior, leg_id);\n        \"\"\"\n        self._connection.execute(idx)\n        self._connection.commit()\n        self._connection.execute(\"BEGIN TRANSACTION;\")\n        any_work = True\n\n    if any_work:\n        logger.info(\"completed adding indexes\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.backup", "title": "backup", "text": "<pre><code>backup(\n    dst: Path | str | Connection, show_progress: bool = True\n)\n</code></pre> <p>Back up this database to another copy.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def backup(self, dst: Path | str | sqlite3.Connection, show_progress: bool = True):\n    \"\"\"Back up this database to another copy.\"\"\"\n    if self.engine != \"sqlite\":\n        raise NotImplementedError(f\"no backup available for engine={self.engine!r}\")\n    if not self.is_open:\n        raise OSError(\"database connection is not open\")\n\n    def _progress(status, remaining, total):\n        if remaining:\n            print(f\"Copied {total - remaining} of {total} pages...\")\n        else:\n            print(f\"Copied all {total} pages.\")\n\n    if not isinstance(dst, sqlite3.Connection):\n        dst = sqlite3.connect(dst)\n    if self._connection.in_transaction:\n        self._connection.execute(\"COMMIT;\")\n    with dst:\n        self._connection.backup(dst, pages=10000, progress=_progress if show_progress else None)\n    self._connection.execute(\"BEGIN TRANSACTION;\")\n    dst.close()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.close", "title": "close", "text": "<pre><code>close()\n</code></pre> <p>Flush pending operations and close the connection.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def close(self):\n    \"\"\"Flush pending operations and close the connection.\"\"\"\n    if self._connection:\n        if self._connection.in_transaction:\n            self._connection.execute(\"COMMIT;\")\n        self._connection.close()\n        self._connection = None\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.dataframe", "title": "dataframe", "text": "<pre><code>dataframe(\n    query: str,\n    params: list | tuple | dict | None = None,\n    dtype=None,\n)\n</code></pre> <p>Run a SQL query and return the results as a pandas DataFrame.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def dataframe(self, query: str, params: list | tuple | dict | None = None, dtype=None):\n    \"\"\"Run a SQL query and return the results as a pandas DataFrame.\"\"\"\n    if not self.is_open:\n        raise ValueError(\"database is not open\")\n    import pandas as pd\n\n    return pd.read_sql_query(query, self._connection, params=params, dtype=dtype)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.delete_experiment", "title": "delete_experiment", "text": "<pre><code>delete_experiment(name: str)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def delete_experiment(self, name: str):\n    if self.is_open:\n        logger.debug(f\"deleting existing scenario {name!r} from database\")\n        self.execute(\"DELETE FROM leg_detail WHERE scenario = ?\", (name,))\n        self.execute(\"DELETE FROM leg_bucket_detail WHERE scenario = ?\", (name,))\n        self.execute(\"DELETE FROM demand_detail WHERE scenario = ?\", (name,))\n        self.execute(\"DELETE FROM fare_detail WHERE scenario = ?\", (name,))\n        self._commit_raw()\n    else:\n        logger.debug(f\"database not open, cannot delete {name!r}\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.index_names", "title": "index_names", "text": "<pre><code>index_names(table_name) -&gt; list[str]\n</code></pre> <p>List of all named indexes on a given table.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def index_names(self, table_name) -&gt; list[str]:\n    \"\"\"List of all named indexes on a given table.\"\"\"\n    qry = \"SELECT name FROM sqlite_master WHERE type=='index' AND tbl_name==?1\"\n    return [i[0] for i in self._connection.execute(qry, (table_name,))]\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.load_configs", "title": "load_configs", "text": "<pre><code>load_configs(\n    scenario=None,\n    on_validation_error: Literal[\n        \"raise\", \"ignore\"\n    ] = \"raise\",\n) -&gt; Config | Any\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def load_configs(self, scenario=None, on_validation_error: Literal[\"raise\", \"ignore\"] = \"raise\") -&gt; Config | Any:\n    raw = self.load_raw_configs(scenario)\n\n    from pydantic import ValidationError\n\n    try:\n        return Config.model_validate(raw)\n    except ValidationError as err:\n        logger.error(f\"error loading configs: {err}\")\n        if on_validation_error == \"raise\":\n            raise\n        else:\n            return raw\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.load_raw_configs", "title": "load_raw_configs", "text": "<pre><code>load_raw_configs(scenario=None) -&gt; dict | Any\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def load_raw_configs(self, scenario=None) -&gt; dict | Any:\n    import json\n\n    if scenario:\n        rawjson = next(\n            self.execute(\n                \"SELECT configs, max(updated_at) FROM runtime_configs \" \"WHERE scenario = ?1\",\n                (scenario,),\n            )\n        )[0]\n    else:\n        rawjson = next(self.execute(\"SELECT configs, max(updated_at) FROM runtime_configs\"))[0]\n    result = json.loads(rawjson)\n    if not isinstance(result, dict):\n        warnings.warn(\"malformed configs, not a mapping\", stacklevel=2)\n    return result\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.open", "title": "open", "text": "<pre><code>open(filename: str | None = None)\n</code></pre> <p>Open the connection if it is not already open.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def open(self, filename: str | None = None):\n    \"\"\"Open the connection if it is not already open.\"\"\"\n    if self._connection is not None:\n        raise ConnectionError(\"the connection is already open\")\n    self.filename = filename or self.filename\n    if self.engine is None:\n        self._connection = None\n    elif self.engine == \"sqlite\" and self.filename is None:\n        self._connection = None\n    elif self.engine == \"sqlite\":\n        if self.filename != \":memory:\":\n            Path(self.filename).parent.mkdir(exist_ok=True, parents=True)\n        logger.info(f\"connecting to sqlite database: {self.filename}\")\n        self._connection = sqlite3.Connection(self.filename)\n        self._connection.create_aggregate(\"VARIANCE\", 1, _VarianceFunc)\n        self._connection.create_aggregate(\"STDEV\", 1, _StdevFunc)\n        for pragma in self.pragmas:\n            self._connection.execute(f\"PRAGMA {pragma};\")\n        self._connection.execute(\"BEGIN TRANSACTION;\")\n        logger.debug(\"initializing sqlite tables\")\n        from .tables import create_tables\n\n        create_tables(self)\n    else:\n        raise NotImplementedError(f\"unknown engine {self.engine!r}\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.save_configs", "title": "save_configs", "text": "<pre><code>save_configs(cfg: Config) -&gt; None\n</code></pre> <p>Save configs into the database.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_configs(self, cfg: Config) -&gt; None:\n    \"\"\"Save configs into the database.\"\"\"\n    from passengersim import __version__\n\n    self.execute(\n        \"\"\"\n    INSERT OR REPLACE INTO runtime_configs(\n        scenario, pxsim_version, configs\n    ) VALUES (?1, ?2, ?3)\n    \"\"\",\n        (\n            cfg.scenario,\n            str(__version__),\n            cfg.model_dump_json(exclude={\"db\": \"dcp_write_hooks\", \"raw_license_certificate\": True}),\n        ),\n    )\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.save_dataframe", "title": "save_dataframe", "text": "<pre><code>save_dataframe(\n    name: str,\n    df: DataFrame,\n    if_exists: Literal[\n        \"fail\", \"replace\", \"append\"\n    ] = \"replace\",\n)\n</code></pre> <p>Save a dataframe as a table in this database.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_dataframe(\n    self,\n    name: str,\n    df: pd.DataFrame,\n    if_exists: Literal[\"fail\", \"replace\", \"append\"] = \"replace\",\n):\n    \"\"\"Save a dataframe as a table in this database.\"\"\"\n    df.to_sql(name, self._connection, if_exists=if_exists)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.save_details", "title": "save_details", "text": "<pre><code>save_details(\n    db_writer: DbWriter, sim: SimulationEngine, dcp: int\n)\n</code></pre> <p>Save details, can be done at each RRD/DCP and at the end of the run</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_details(self: Database, db_writer: DbWriter, sim: SimulationEngine, dcp: int):\n    \"\"\"\n    Save details, can be done at each RRD/DCP and at the end of the run\n    \"\"\"\n    if not sim.save_timeframe_details and dcp &gt; 0:\n        return\n    if sim.config.db.fast and isinstance(self._connection, sqlite3.Connection):\n        _internal_log = db_writer.write_to_sqlite(\n            self._connection,\n            dcp,\n            store_bid_prices=sim.config.db.store_leg_bid_prices,\n            store_displacements=sim.config.db.store_displacements,\n        )\n    else:\n        for leg in sim.legs:\n            if \"leg\" in sim.config.db.write_items:\n                save_leg(self, sim, leg, dcp)\n            if \"bucket\" in sim.config.db.write_items:\n                save_leg_bucket_multi(self, sim, leg, dcp)\n        if \"fare\" in sim.config.db.write_items:\n            save_fare_multi(self, sim, dcp)\n        if \"demand\" in sim.config.db.write_items:\n            save_demand_multi(self, sim, dcp)\n    # hooks for custom writers written in Python, may be slow\n    for f in sim.config.db.dcp_write_hooks:\n        f(self, sim, dcp)\n    self.commit()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.save_final", "title": "save_final", "text": "<pre><code>save_final(sim: SimulationEngine)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_final(self: Database, sim: SimulationEngine):\n    sim.final_write_to_sqlite(self._connection)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.schema", "title": "schema", "text": "<pre><code>schema(name: str)\n</code></pre> <p>Get a table schema from the SQLite database.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def schema(self, name: str):\n    \"\"\"Get a table schema from the SQLite database.\"\"\"\n    if not self.is_open:\n        raise ValueError(\"database is not open\")\n    try:\n        return next(self.execute(\"SELECT sql FROM sqlite_master WHERE name = ?1\", (name,)))[0]\n    except Exception:\n        raise\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.sql_placeholders", "title": "sql_placeholders", "text": "<pre><code>sql_placeholders(n: int)\n</code></pre> <p>A parenthesis enclosed set of <code>n</code> placeholders for the selected engine.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def sql_placeholders(self, n: int):\n    \"\"\"A parenthesis enclosed set of `n` placeholders for the selected engine.\"\"\"\n    if self.engine == \"sqlite\":\n        x = \"?\"\n    else:\n        x = \"%s\"\n    return \"(\" + \", \".join(x for _ in range(n)) + \")\"\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.table_info", "title": "table_info", "text": "<pre><code>table_info(table_name: str) -&gt; DataFrame\n</code></pre> <p>Get info about a table</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def table_info(self, table_name: str) -&gt; pd.DataFrame:\n    \"\"\"Get info about a table\"\"\"\n    df = self.dataframe(f\"PRAGMA table_info({table_name})\")\n    return df.set_index(\"cid\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.table_names", "title": "table_names", "text": "<pre><code>table_names() -&gt; list[str]\n</code></pre> <p>List of all tables in the database.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def table_names(self) -&gt; list[str]:\n    \"\"\"List of all tables in the database.\"\"\"\n    qry = \"SELECT name FROM sqlite_master WHERE type=='table'\"\n    return [i[0] for i in self._connection.execute(qry)]\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._StdevFunc", "title": "_StdevFunc", "text": "<p>               Bases: <code>_VarianceFunc</code></p> Source code in <code>passengersim/database/database.py</code> <pre><code>class _StdevFunc(_VarianceFunc):\n    def finalize(self):\n        if self.k &lt; 3:\n            return None\n        return math.sqrt(self.S / (self.k - 2))\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._StdevFunc.finalize", "title": "finalize", "text": "<pre><code>finalize()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def finalize(self):\n    if self.k &lt; 3:\n        return None\n    return math.sqrt(self.S / (self.k - 2))\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc", "title": "_VarianceFunc", "text": "Source code in <code>passengersim/database/database.py</code> <pre><code>class _VarianceFunc:\n    def __init__(self):\n        self.M = 0.0\n        self.S = 0.0\n        self.k = 1\n\n    def step(self, value):\n        if value is None:\n            return\n        tM = self.M\n        self.M += (value - tM) / self.k\n        self.S += (value - tM) * (value - self.M)\n        self.k += 1\n\n    def finalize(self):\n        if self.k &lt; 3:\n            return None\n        return self.S / (self.k - 2)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.M", "title": "M  <code>instance-attribute</code>", "text": "<pre><code>M = 0.0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.S", "title": "S  <code>instance-attribute</code>", "text": "<pre><code>S = 0.0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.k", "title": "k  <code>instance-attribute</code>", "text": "<pre><code>k = 1\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.__init__", "title": "__init__", "text": "<pre><code>__init__()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __init__(self):\n    self.M = 0.0\n    self.S = 0.0\n    self.k = 1\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.finalize", "title": "finalize", "text": "<pre><code>finalize()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def finalize(self):\n    if self.k &lt; 3:\n        return None\n    return self.S / (self.k - 2)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.step", "title": "step", "text": "<pre><code>step(value)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def step(self, value):\n    if value is None:\n        return\n    tM = self.M\n    self.M += (value - tM) / self.k\n    self.S += (value - tM) * (value - self.M)\n    self.k += 1\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.compute_rrd", "title": "compute_rrd", "text": "<pre><code>compute_rrd(sim: SimulationEngine, dep_time: float)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def compute_rrd(sim: SimulationEngine, dep_time: float):\n    tmp = int(dep_time / 86400) * 86400\n    days_prior = int((tmp - sim.last_event_time) / 86400)\n    if sim.num_events() == 0:\n        days_prior = 0\n    return days_prior\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.delete_experiment", "title": "delete_experiment", "text": "<pre><code>delete_experiment(cnx: Database, name)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def delete_experiment(cnx: Database, name):\n    with cnx:\n        logger.info(f\"deleting existing scenario {name!r} from database\")\n        cnx.execute(f\"DELETE FROM leg_detail WHERE scenario = '{name}' \")\n        cnx.execute(f\"DELETE FROM leg_bucket_detail WHERE scenario = '{name}' \")\n        cnx.execute(f\"DELETE FROM demand_detail WHERE scenario = '{name}' \")\n        cnx.execute(f\"DELETE FROM fare_detail WHERE scenario = '{name}' \")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.get_database_connection", "title": "get_database_connection", "text": "<pre><code>get_database_connection(\n    engine: Literal[\"sqlite\", None] = \"sqlite\",\n    filename: Path = None,\n    pragmas: Iterable[str] = (),\n    commit_count_delay: int | None = 250,\n)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def get_database_connection(\n    engine: Literal[\"sqlite\", None] = \"sqlite\",\n    filename: Path = None,\n    pragmas: Iterable[str] = (),\n    commit_count_delay: int | None = 250,\n):\n    return Database(\n        engine=engine,\n        filename=filename,\n        pragmas=pragmas,\n        commit_count_delay=commit_count_delay,\n    )\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.save_demand_multi", "title": "save_demand_multi", "text": "<pre><code>save_demand_multi(\n    cnx: Database, sim: SimulationEngine, dcp\n) -&gt; string\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_demand_multi(cnx: Database, sim: SimulationEngine, dcp) -&gt; string:\n    data_list = []\n    for dmd in sim.demands:\n        data_list.append(\n            (\n                sim.name,\n                sim.iteration,\n                sim.trial,\n                sim.sample,\n                dcp,\n                dmd.orig,\n                dmd.dest,\n                dmd.segment,\n                dmd.scenario_demand,\n                dmd.sold,\n                dmd.revenue,\n            )\n        )\n        # if dmd.sold &gt; dmd.scenario_demand:\n        #     print(f\"{dmd.orig=}, {dmd.dest=}, {dmd.segment},\n        #     {dmd.sold}, {dmd.scenario_demand}\")\n\n    try:\n        cursor = cnx.cursor()\n        sql = f\"\"\"INSERT INTO demand_detail\n                (scenario, iteration, trial, sample, days_prior,\n                 orig, dest, segment, sample_demand, sold, revenue)\n                VALUES ({sql_placeholders(cnx, 11)})\"\"\"\n        cursor.executemany(sql, data_list)\n        return True\n    except Exception as err:\n        print(f\"Doh !!! demand_detail: {err}\")\n        return False\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.save_fare_multi", "title": "save_fare_multi", "text": "<pre><code>save_fare_multi(\n    cnx: Database, sim: SimulationEngine, dcp\n) -&gt; string\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_fare_multi(cnx: Database, sim: SimulationEngine, dcp) -&gt; string:\n    data_list = []\n    for fare in sim.fares:\n        data_list.append(\n            (\n                sim.name,\n                sim.iteration,\n                sim.trial,\n                sim.sample,\n                dcp,\n                fare.sold,\n                fare.sold_business,\n                fare.fare_id,\n            )\n        )\n    try:\n        cursor = cnx.cursor()\n        sql = f\"\"\"INSERT INTO fare_detail\n                (scenario, iteration, trial, sample, days_prior,\n                 sold, sold_business, fare_id)\n                VALUES ({sql_placeholders(cnx, 8)})\"\"\"\n        cursor.executemany(sql, data_list)\n        return True\n    except Exception as err:\n        print(f\"Doh !!! fare: {err}\")\n        return False\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.save_leg", "title": "save_leg", "text": "<pre><code>save_leg(cnx, sim, leg, dcp) -&gt; string\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_leg(cnx, sim, leg, dcp) -&gt; string:\n    _dep_time = datetime.utcfromtimestamp(leg.dep_time).strftime(\"%Y-%m-%d %H:%M:%S\")\n    try:\n        cursor = cnx.cursor()\n        sql = f\"\"\"INSERT INTO leg_detail\n                (scenario, iteration, trial, sample, days_prior, leg_id, sold, revenue)\n                VALUES ({sql_placeholders(cnx, 8)})\"\"\"\n        cursor.execute(\n            sql,\n            (\n                sim.name,\n                sim.iteration,\n                sim.trial,\n                sim.sample,\n                dcp,\n                leg.leg_id,\n                leg.sold,\n                leg.revenue,\n            ),\n        )\n        return True\n    except Exception as err:\n        print(f\"Doh !!! leg_detail: {err}\")\n        return False\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.save_leg_bucket_multi", "title": "save_leg_bucket_multi", "text": "<pre><code>save_leg_bucket_multi(\n    cnx: Database,\n    sim: SimulationEngine,\n    leg,\n    dcp,\n    commit=False,\n) -&gt; string\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_leg_bucket_multi(cnx: Database, sim: SimulationEngine, leg, dcp, commit=False) -&gt; string:\n    try:\n        cursor = cnx.cursor()\n        cnx_type = type(cnx).__name__\n        if cnx_type not in leg_bucket_sql:\n            sql = leg_bucket_sql[cnx_type] = f\"\"\"INSERT INTO leg_bucket_detail\n                (scenario, iteration, trial, sample, days_prior, leg_id,\n                bucket_number, name, auth, revenue, sold, untruncated_demand,\n                forecast_mean) VALUES ({sql_placeholders(cnx, 13)})\"\"\"\n        else:\n            sql = leg_bucket_sql.get(cnx_type)\n        data_list = []\n        for n, bkt in enumerate(leg.buckets):\n            data = (\n                sim.name,\n                sim.iteration,\n                sim.trial,\n                sim.sample,\n                dcp,\n                leg.leg_id,\n                n,\n                bkt.name,\n                bkt.alloc,\n                bkt.revenue,\n                bkt.sold,\n                bkt.untruncated_demand,\n                bkt.fcst_mean,\n            )\n            data_list.append(data)\n\n        cursor.executemany(sql, data_list)\n        if commit:\n            cnx.commit()\n        cursor.close()\n        return True\n    except Exception as err:\n        print(f\"Doh !!! leg_bucket_detail: {err}\")\n        return False\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.sql_placeholders", "title": "sql_placeholders", "text": "<pre><code>sql_placeholders(cnx, n: int)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def sql_placeholders(cnx, n: int):\n    if isinstance(cnx, Database):\n        return sql_placeholders(cnx._connection, n)\n    elif isinstance(cnx, sqlite3.Connection):\n        x = \"?\"\n    else:\n        x = \"%s\"\n    return \", \".join(x for _ in range(n))\n</code></pre>"}, {"location": "API/database/common-queries.html", "title": "Common Queries", "text": ""}, {"location": "API/database/common-queries.html#passengersim.database.common_queries._leg_bucket_trace", "title": "_leg_bucket_trace", "text": "<pre><code>_leg_bucket_trace(\n    target_cols: str,\n    cnx: Database,\n    scenario: str | None = None,\n    burn_samples: int = 100,\n    carrier: str | None = None,\n    leg_id: int | None = None,\n    booking_class: str | None = None,\n    days_prior: int | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Recorded forecast of demand by leg.</p> <p>This query requires that the simulation was run while recording leg bucket details (i.e. with the <code>bucket</code> flag set on <code>Config.db.write_items</code>).  This function is provided primarily for testing and debugging purposes.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The forecasts will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> <li> <code>carrier</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this carrier.</p> </li> <li> <code>leg_id</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this leg.</p> </li> <li> <code>booking_class</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this booking class.</p> </li> <li> <code>days_prior</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this many days prior to departure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by any of <code>carrier</code>, <code>leg_id</code>, <code>booking_class</code>, and/or <code>days_prior</code> that were not filtered, and has these columns: - <code>forecast_mean</code>: Forecast mean (mu). - <code>forecast_stdev</code>: Forecast standard deviation (sigma). - <code>forecast_closed_in_tf</code>: Fraction of time the timeframe was     closed in the data used to make a forecast. - <code>forecast_closed_in_tf</code>: Fraction of time any future timeframe     was closed in the data used to make a forecast.</p> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def _leg_bucket_trace(\n    target_cols: str,\n    cnx: \"Database\",\n    scenario: str | None = None,\n    burn_samples: int = 100,\n    carrier: str | None = None,\n    leg_id: int | None = None,\n    booking_class: str | None = None,\n    days_prior: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Recorded forecast of demand by leg.\n\n    This query requires that the simulation was run while recording leg bucket\n    details (i.e. with the `bucket` flag set on `Config.db.write_items`).  This\n    function is provided primarily for testing and debugging purposes.\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The forecasts will be analyzed ignoring this many samples from the\n        beginning of each trial.\n    carrier : str, optional\n        If provided, only return forecasts for this carrier.\n    leg_id : int, optional\n        If provided, only return forecasts for this leg.\n    booking_class : str, optional\n        If provided, only return forecasts for this booking class.\n    days_prior : int, optional\n        If provided, only return forecasts for this many days prior to departure.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by any of `carrier`, `leg_id`,\n        `booking_class`, and/or `days_prior` that were not filtered, and has\n        these columns:\n        - `forecast_mean`: Forecast mean (mu).\n        - `forecast_stdev`: Forecast standard deviation (sigma).\n        - `forecast_closed_in_tf`: Fraction of time the timeframe was\n            closed in the data used to make a forecast.\n        - `forecast_closed_in_tf`: Fraction of time any future timeframe\n            was closed in the data used to make a forecast.\n    \"\"\"\n    conditions = []\n    indexers = []\n    columns = []\n    if scenario is not None:\n        conditions.append(\"scenario = @scenario\")\n    if burn_samples is not None:\n        conditions.append(\"sample &gt;= @burn_samples\")\n    if carrier is not None:\n        conditions.append(\"carrier = @carrier\")\n    elif leg_id is None:\n        indexers.append(\"carrier\")\n        columns.append(\"carrier\")\n    if leg_id is not None:\n        conditions.append(\"leg_id = @leg_id\")\n    else:\n        indexers.append(\"leg_id\")\n        columns.append(\"leg_id\")\n    if booking_class is not None:\n        conditions.append(\"name = @booking_class\")\n    else:\n        indexers.append(\"booking_class\")\n        columns.append(\"name as booking_class\")\n    if days_prior is not None:\n        conditions.append(\"days_prior = @days_prior\")\n    else:\n        indexers.append(\"days_prior\")\n        columns.append(\"days_prior\")\n    qry = \"\"\"\n    SELECT\n        {cols}{comma}\n        sample,\n        {target_cols}\n    FROM\n        leg_bucket_detail LEFT JOIN leg_defs USING (leg_id)\n    WHERE\n        {conds}\n    \"\"\".format(\n        target_cols=target_cols,\n        cols=\", \".join(columns),\n        conds=\" AND \".join(conditions),\n        comma=\",\" if columns else \"\",\n    )\n    return cnx.dataframe(\n        qry,\n        dict(\n            scenario=scenario,\n            burn_samples=burn_samples,\n            carrier=carrier,\n            leg_id=leg_id,\n            booking_class=booking_class,\n            days_prior=days_prior,\n        ),\n    ).set_index(indexers + [\"sample\"])\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.bid_price_history", "title": "bid_price_history", "text": "<pre><code>bid_price_history(\n    cnx: Database,\n    scenario: str,\n    burn_samples: int = 100,\n    weighting: Literal[\"equal\", \"capacity\"] = \"equal\",\n) -&gt; DataFrame\n</code></pre> <p>Compute average bid price history over all legs for each carrier.</p> <p>This query requires that the simulation was run while recording leg details (i.e. with the <code>leg</code> flag set on <code>Config.db.write_items</code>), including bid prices.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The bid prices will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> <li> <code>weighting</code>               (<code>(equal, capacity)</code>, default:                   <code>'equal'</code> )           \u2013            <p>How to weight the bid prices.  If 'equal', then each leg is weighted equally.  If 'capacity', then each leg is weighted by its total capacity.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>carrier</code> and <code>days_prior</code>, and has these columns:</p> <ul> <li><code>bid_price_mean</code>: Average bid price across all samples and all legs</li> <li><code>bid_price_stdev</code>: Sample standard deviation of bid prices across all     samples and all legs</li> <li><code>fraction_some_cap</code>: Fraction of all legs across all samples that have     non-zero capacity available for sale.</li> <li><code>fraction_zero_cap</code>: Fraction of all legs across all samples that have     zero capacity available for sale.  Bid prices are computed for these     legs but are not really meaningful.</li> <li><code>some_cap_bid_price_mean</code>: Average bid price across all samples and     all legs conditional on the leg having non-zero capacity.</li> <li><code>some_cap_bid_price_stdev</code>: Sample standard deviation of bid prices     across all samples and all legs conditional on the leg having     non-zero capacity.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def bid_price_history(\n    cnx: Database,\n    scenario: str,\n    burn_samples: int = 100,\n    weighting: Literal[\"equal\", \"capacity\"] = \"equal\",\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute average bid price history over all legs for each carrier.\n\n    This query requires that the simulation was run while recording leg\n    details (i.e. with the `leg` flag set on `Config.db.write_items`),\n    including bid prices.\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The bid prices will be analyzed ignoring this many samples from the\n        beginning of each trial.\n    weighting : {'equal', 'capacity'}, default 'equal'\n        How to weight the bid prices.  If 'equal', then each leg is weighted\n        equally.  If 'capacity', then each leg is weighted by its total capacity.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `carrier` and `days_prior`, and has\n        these columns:\n\n        - `bid_price_mean`: Average bid price across all samples and all legs\n        - `bid_price_stdev`: Sample standard deviation of bid prices across all\n            samples and all legs\n        - `fraction_some_cap`: Fraction of all legs across all samples that have\n            non-zero capacity available for sale.\n        - `fraction_zero_cap`: Fraction of all legs across all samples that have\n            zero capacity available for sale.  Bid prices are computed for these\n            legs but are not really meaningful.\n        - `some_cap_bid_price_mean`: Average bid price across all samples and\n            all legs conditional on the leg having non-zero capacity.\n        - `some_cap_bid_price_stdev`: Sample standard deviation of bid prices\n            across all samples and all legs conditional on the leg having\n            non-zero capacity.\n\n    \"\"\"\n    if weighting not in (\"equal\", \"capacity\"):\n        raise ValueError(f\"unknown weighting {weighting}\")\n    preqry = \"\"\"\n    CREATE TABLE IF NOT EXISTS bid_price_general_summary AS\n    SELECT\n        scenario,\n        carrier,\n        days_prior,\n        avg(bid_price) as bid_price_mean,\n        stdev(bid_price) as bid_price_stdev,\n        avg(CASE WHEN leg_detail.sold &lt; leg_defs.capacity THEN 1.0 ELSE 0.0 END)\n            as fraction_some_cap,\n        avg(CASE WHEN leg_detail.sold &lt; leg_defs.capacity THEN 0.0 ELSE 1.0 END)\n            as fraction_zero_cap\n    FROM leg_detail\n        LEFT JOIN leg_defs ON leg_detail.leg_id = leg_defs.leg_id\n    WHERE\n        sample &gt;= ?1\n    GROUP BY\n        carrier, days_prior\n    \"\"\"\n    cnx.execute(preqry, (burn_samples,))\n    try:\n        cnx._commit_raw()\n    except sqlite3.OperationalError:\n        preqry = preqry.replace(\"CREATE TABLE IF NOT EXISTS\", \"CREATE TEMP TABLE IF NOT EXISTS\")\n        cnx.execute(preqry, (burn_samples,))\n    qry = \"\"\"\n    SELECT\n        carrier,\n        days_prior,\n        bid_price_mean,\n        bid_price_stdev,\n        fraction_some_cap,\n        fraction_zero_cap\n    FROM bid_price_general_summary WHERE scenario == ?1\n    \"\"\"\n    bph = cnx.dataframe(\n        qry,\n        (scenario,),\n    )\n    preqry2 = \"\"\"\n    CREATE TABLE IF NOT EXISTS bid_price_somecap_summary AS\n    SELECT\n        scenario,\n        carrier,\n        days_prior,\n        avg(bid_price) as some_cap_bid_price_mean_unweighted,\n        stdev(bid_price) as some_cap_bid_price_stdev,\n        (SUM(bid_price * leg_defs.capacity) / SUM(leg_defs.capacity))\n            as some_cap_bid_price_mean_capweighted\n    FROM leg_detail\n        LEFT JOIN leg_defs ON leg_detail.leg_id = leg_defs.leg_id\n    WHERE\n        sample &gt;= ?1\n        AND leg_detail.sold &lt; leg_defs.capacity\n    GROUP BY\n        carrier, days_prior\n    \"\"\"\n    cnx.execute(preqry2, (burn_samples,))\n    try:\n        cnx._commit_raw()\n    except sqlite3.OperationalError:\n        preqry2 = preqry2.replace(\"CREATE TABLE IF NOT EXISTS\", \"CREATE TEMP TABLE IF NOT EXISTS\")\n        cnx.execute(preqry2, (burn_samples,))\n    qry2 = \"\"\"\n    SELECT\n        carrier, days_prior,\n        some_cap_bid_price_mean_unweighted,\n        some_cap_bid_price_stdev,\n        some_cap_bid_price_mean_capweighted\n    FROM bid_price_somecap_summary WHERE scenario == ?1\n    \"\"\"\n    bph_some_cap = cnx.dataframe(\n        qry2,\n        (scenario,),\n    ).set_index([\"carrier\", \"days_prior\"])\n    bph = bph.set_index([\"carrier\", \"days_prior\"]).join(bph_some_cap)\n    bph = bph.sort_index(ascending=(True, False))\n    if weighting == \"equal\":\n        bph[\"some_cap_bid_price_mean\"] = bph[\"some_cap_bid_price_mean_unweighted\"]\n    elif weighting == \"capacity\":\n        bph[\"some_cap_bid_price_mean\"] = bph[\"some_cap_bid_price_mean_capweighted\"]\n    else:\n        raise ValueError(f\"unknown weighting {weighting}\")\n    return bph\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.bookings_by_timeframe", "title": "bookings_by_timeframe", "text": "<pre><code>bookings_by_timeframe(\n    cnx: Database,\n    scenario: str,\n    from_fare_detail: bool = False,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Average bookings and revenue by carrier, booking class, and timeframe.</p> <p>This query requires that the simulation was run while recording supporting details (i.e. with the <code>bookings</code> or <code>fare</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>from_fare_detail</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Reconstruct this table from the <code>fare_detail</code> table.  This is generally slower than accessing the <code>bookings</code> table directly, and also requires substantially more data to have been saved into the database by setting the <code>fare</code> flag on <code>Config.db.write_items</code></p> </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The bookings will be computed ignoring this many samples from the beginning of each trial. This argument is nominally ignored by this query unless <code>from_fare_detail</code> is true, although the simulator will have already ignored the burned samples when storing the data in the bookings table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>trial</code>, <code>carrier</code>, <code>class</code>, and <code>days_prior</code>, and has these columns:</p> <ul> <li><code>avg_sold</code>: Average number of sales.</li> <li><code>avg_business</code>: Average number of sales to passengers in the business segment.</li> <li><code>avg_leisure</code>: Average number of sales to leisure passengers.</li> <li><code>avg_revenue</code>: Average total revenue earned from customers booking in this     booking class in this time period.</li> <li><code>avg_price</code>: Average price per ticket from customers booking in this booking     class in this time period</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def bookings_by_timeframe(\n    cnx: Database,\n    scenario: str,\n    from_fare_detail: bool = False,\n    burn_samples: int = 100,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Average bookings and revenue by carrier, booking class, and timeframe.\n\n    This query requires that the simulation was run while recording supporting\n    details (i.e. with the `bookings` or `fare` flags set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    from_fare_detail : bool, default False\n        Reconstruct this table from the `fare_detail` table.  This is generally\n        slower than accessing the `bookings` table directly, and also requires\n        substantially more data to have been saved into the database by setting\n        the `fare` flag on `Config.db.write_items`\n    burn_samples : int, default 100\n        The bookings will be computed ignoring this many samples from the\n        beginning of each trial. This argument is nominally ignored by this query\n        unless `from_fare_detail` is true, although the simulator will have already\n        ignored the burned samples when storing the data in the bookings table.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `trial`, `carrier`, `class`,\n        and `days_prior`, and has these columns:\n\n        - `avg_sold`: Average number of sales.\n        - `avg_business`: Average number of sales to passengers in the business segment.\n        - `avg_leisure`: Average number of sales to leisure passengers.\n        - `avg_revenue`: Average total revenue earned from customers booking in this\n            booking class in this time period.\n        - `avg_price`: Average price per ticket from customers booking in this booking\n            class in this time period\n    \"\"\"\n    qry_fare = \"\"\"\n    SELECT trial, carrier, booking_class, days_prior,\n           (AVG(sold)) AS avg_sold,\n           (AVG(sold_business)) AS avg_business,\n           (AVG(sold_leisure)) AS avg_leisure,\n           (AVG(revenue)) AS avg_revenue,\n           (AVG(revenue) / AVG(sold)) AS avg_price,\n           (SUM(sold)) AS tot_sold\n    FROM (SELECT trial, scenario, carrier, booking_class, days_prior,\n                 SUM(sold) AS sold,\n                 SUM(sold_business) AS sold_business,\n                 SUM(sold - sold_business) AS sold_leisure,\n                 SUM(sold * price) AS revenue\n          FROM fare_detail LEFT JOIN fare_defs USING (fare_id)\n          WHERE\n                sample &gt;= ?2\n                AND scenario = ?1\n          GROUP BY trial, sample, carrier, booking_class, days_prior) a\n    GROUP BY carrier, booking_class, days_prior, trial\n    ORDER BY carrier, booking_class, days_prior, trial;\n    \"\"\"\n\n    if from_fare_detail:\n        return cnx.dataframe(qry_fare, (scenario, burn_samples)).set_index(\n            [\"trial\", \"carrier\", \"booking_class\", \"days_prior\"]\n        )\n\n    qry_bookings = \"\"\"\n    SELECT\n        trial,\n        carrier,\n        booking_class,\n        days_prior,\n        avg_sold,\n        avg_business,\n        avg_leisure,\n        avg_revenue,\n        avg_price\n    FROM\n        bookings_by_timeframe\n    WHERE\n        scenario = ?1\n    GROUP BY\n        carrier, booking_class, days_prior, trial\n    ORDER BY\n        carrier, booking_class, days_prior, trial;\n    \"\"\"\n    return cnx.dataframe(qry_bookings, (scenario,)).set_index([\"trial\", \"carrier\", \"booking_class\", \"days_prior\"])\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.carrier_history", "title": "carrier_history", "text": "<pre><code>carrier_history(\n    cnx: Database,\n    *,\n    scenario: str = None,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Sample-level details of carrier-level measures.</p> <p>This query delivers sample-by-sample aggregated summary results for the various carriers in the simulation. It requires that the simulation was run while recording leg bucket details (i.e. with the <code>bucket</code> flag set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The history will be returned ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>iteration</code>, <code>trial</code> and <code>sample</code>, and columns defined with a two-level MultiIndex.  The second level of the columns MultiIndex represents the carriers, while the top level includes these columns:</p> <ul> <li><code>forecast_mean</code>: Forecast mean (mu) at the beginning of the booking     curve, summed over all this carrier's legs in this sample.</li> <li><code>forecast_stdev</code>: Forecast standard deviation (sigma) at the beginning     of the booking curve, aggregated over all this carrier's legs in this     sample.</li> <li><code>sold</code>: Total bookings accepted by this carrier in this sample.</li> <li><code>revenue</code>: Total revenue for this carrier in this sample.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def carrier_history(cnx: Database, *, scenario: str = None, burn_samples: int = 100) -&gt; pd.DataFrame:\n    \"\"\"\n    Sample-level details of carrier-level measures.\n\n    This query delivers sample-by-sample aggregated summary results for the\n    various carriers in the simulation. It requires that the simulation was\n    run while recording leg bucket details (i.e. with the `bucket` flag set\n    on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str, optional\n    burn_samples : int, default 100\n        The history will be returned ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `iteration`, `trial` and `sample`,\n        and columns defined with a two-level MultiIndex.  The second level of\n        the columns MultiIndex represents the carriers, while the top level\n        includes these columns:\n\n        - `forecast_mean`: Forecast mean (mu) at the beginning of the booking\n            curve, summed over all this carrier's legs in this sample.\n        - `forecast_stdev`: Forecast standard deviation (sigma) at the beginning\n            of the booking curve, aggregated over all this carrier's legs in this\n            sample.\n        - `sold`: Total bookings accepted by this carrier in this sample.\n        - `revenue`: Total revenue for this carrier in this sample.\n    \"\"\"\n    # Provides content similar to PODS *.HST output file.\n    qry_params = {\"burn_samples\": burn_samples}\n    if scenario is not None:\n        qry_params[\"scenario\"] = scenario\n        max_days_prior = int(\n            cnx.dataframe(\n                \"\"\"\n                SELECT max(days_prior) FROM leg_bucket_detail WHERE scenario == ?1\n                \"\"\",\n                (scenario,),\n            ).iloc[0, 0]\n        )\n    else:\n        max_days_prior = int(\n            cnx.dataframe(\n                \"\"\"\n                SELECT max(days_prior) FROM leg_bucket_detail\n                \"\"\",\n            ).iloc[0, 0]\n        )\n    qry_params[\"max_days_prior\"] = max_days_prior\n    qry1 = \"\"\"\n    SELECT\n        iteration, trial, sample, carrier,\n        sum(forecast_mean) as forecast_mean,\n        sqrt(sum(forecast_stdev*forecast_stdev)) as forecast_stdev\n    FROM leg_bucket_detail LEFT JOIN leg_defs USING (leg_id)\n    WHERE days_prior == @max_days_prior\n      AND scenario == @scenario\n      AND sample &gt;= @burn_samples\n    GROUP BY iteration, trial, sample, carrier\n    \"\"\"\n    if scenario is None:\n        qry1 = qry1.replace(\"AND scenario == @scenario\", \"\")\n    bd1 = cnx.dataframe(qry1, qry_params).set_index([\"iteration\", \"trial\", \"sample\", \"carrier\"])\n    qry2 = \"\"\"\n    SELECT\n        iteration, trial, sample, carrier,\n        sum(sold) as sold,\n        sum(revenue) as revenue\n    FROM leg_bucket_detail LEFT JOIN leg_defs USING (leg_id)\n    WHERE days_prior == 0\n      AND scenario == @scenario\n      AND sample &gt;= @burn_samples\n    GROUP BY iteration, trial, sample, carrier\n    \"\"\"\n    if scenario is None:\n        qry2 = qry2.replace(\"AND scenario == @scenario\", \"\")\n    bd2 = cnx.dataframe(qry2, qry_params).set_index([\"iteration\", \"trial\", \"sample\", \"carrier\"])\n    return pd.concat([bd1, bd2], axis=1).unstack(\"carrier\")\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.demand_to_come", "title": "demand_to_come", "text": "<pre><code>demand_to_come(\n    cnx: Database,\n    *,\n    scenario: str = None,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Demand by market and timeframe across each sample.</p> <p>This query delivers sample-by-sample timeframe demand results for the various markets (origin, destination, passenger type) in the simulation. It requires that the simulation was run while recording demand details (i.e. with the <code>demand</code> flag set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The demand will be returned ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>iteration</code>, <code>trial</code>, <code>sample</code>, <code>segment</code>, <code>orig</code>, and <code>dest</code>; and has columns defined by the DCPs. The values stored are the total remaining demand to come at each DCP.</p> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def demand_to_come(cnx: Database, *, scenario: str = None, burn_samples: int = 100) -&gt; pd.DataFrame:\n    \"\"\"\n    Demand by market and timeframe across each sample.\n\n    This query delivers sample-by-sample timeframe demand results for the\n    various markets (origin, destination, passenger type) in the simulation.\n    It requires that the simulation was run while recording demand details\n    (i.e. with the `demand` flag set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str, optional\n    burn_samples : int, default 100\n        The demand will be returned ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `iteration`, `trial`, `sample`,\n        `segment`, `orig`, and `dest`; and has columns defined by the DCPs.\n        The values stored are the total remaining demand to come at each DCP.\n    \"\"\"\n    # Provides content similar to PODS *.DHS output file, but with market level detail\n    qry = \"\"\"\n    SELECT\n        iteration, trial, sample, segment, orig, dest, days_prior, sold, no_go,\n        (round(sample_demand) - sold - no_go) AS future_demand\n    FROM\n        demand_detail\n    WHERE\n        sample &gt;= ?1\n        AND scenario = ?2\n    \"\"\"\n    if scenario is None:\n        qry = qry.replace(\"AND scenario = ?2\", \"\")\n        params = (burn_samples,)\n    else:\n        params = (burn_samples, scenario)\n    dmd = cnx.dataframe(qry, params, dtype={\"future_demand\": np.int32})\n    dhs = (\n        dmd.set_index([\"iteration\", \"trial\", \"sample\", \"segment\", \"orig\", \"dest\", \"days_prior\"])[\"future_demand\"]\n        .unstack(\"days_prior\")\n        .sort_values(by=\"days_prior\", axis=1, ascending=False)\n    )\n    return dhs\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.demand_to_come_summary", "title": "demand_to_come_summary", "text": "<pre><code>demand_to_come_summary(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; DataFrame\n</code></pre> <p>Demand by market and timeframe across each sample.</p> <p>This query delivers sample-by-sample timeframe demand results for the various markets (origin, destination, passenger type) in the simulation. It requires that the simulation was run while recording demand details (i.e. with the <code>demand</code> flag set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The demand will be returned ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>iteration</code>, <code>trial</code>, <code>sample</code>, <code>segment</code>, <code>orig</code>, and <code>dest</code>; and has columns defined by the DCPs. The values stored are the total remaining demand to come at each DCP.</p> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def demand_to_come_summary(cnx: Database, scenario: str, burn_samples: int = 100) -&gt; pd.DataFrame:\n    \"\"\"\n    Demand by market and timeframe across each sample.\n\n    This query delivers sample-by-sample timeframe demand results for the\n    various markets (origin, destination, passenger type) in the simulation.\n    It requires that the simulation was run while recording demand details\n    (i.e. with the `demand` flag set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The demand will be returned ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `iteration`, `trial`, `sample`,\n        `segment`, `orig`, and `dest`; and has columns defined by the DCPs.\n        The values stored are the total remaining demand to come at each DCP.\n    \"\"\"\n    # Provides content similar to PODS *.DHS output file, but with market level detail\n    qry = \"\"\"\n    CREATE TABLE IF NOT EXISTS demand_to_come_summary AS\n    WITH tmp_demand_summary AS (\n        SELECT\n            scenario, iteration, trial, sample, segment, days_prior,\n            SUM(round(sample_demand) - sold - no_go) AS future_demand\n        FROM\n            demand_detail\n        GROUP BY\n            scenario, iteration, trial, sample, segment, days_prior\n    )\n    SELECT\n        scenario, segment, days_prior,\n        AVG(future_demand) as mean_future_demand,\n        STDEV(future_demand) as stdev_future_demand\n    FROM\n        tmp_demand_summary\n    WHERE\n        sample &gt;= ?1\n    GROUP BY\n        segment, days_prior\n    ORDER BY\n        segment, days_prior DESC\n    \"\"\"\n    cnx.execute(qry, (burn_samples,))\n    cnx._commit_raw()\n\n    qry = \"\"\"\n    SELECT\n        segment, days_prior, mean_future_demand, stdev_future_demand\n    FROM demand_to_come_summary\n    WHERE scenario = ?1\n    \"\"\"\n    dmd = cnx.dataframe(qry, (scenario,))\n    dhs = dmd.set_index([\"segment\", \"days_prior\"])\n    return dhs\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.displacement_history", "title": "displacement_history", "text": "<pre><code>displacement_history(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; DataFrame\n</code></pre> <p>Compute average displacement cost history over all legs for each carrier.</p> <p>This query requires that the simulation was run while recording leg details (i.e. with the <code>leg</code> flag set on <code>Config.db.write_items</code>), including displacement costs.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The bid prices will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>carrier</code> and <code>days_prior</code>, and has these columns:</p> <ul> <li><code>displacement_mean</code>: Average displacement cost across all samples and     all legs</li> <li><code>displacement_stdev</code>: Sample standard deviation of displacement cost     across all samples and all legs</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def displacement_history(\n    cnx: Database,\n    scenario: str,\n    burn_samples: int = 100,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute average displacement cost history over all legs for each carrier.\n\n    This query requires that the simulation was run while recording leg\n    details (i.e. with the `leg` flag set on `Config.db.write_items`),\n    including displacement costs.\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The bid prices will be analyzed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `carrier` and `days_prior`, and has\n        these columns:\n\n        - `displacement_mean`: Average displacement cost across all samples and\n            all legs\n        - `displacement_stdev`: Sample standard deviation of displacement cost\n            across all samples and all legs\n    \"\"\"\n    preqry = \"\"\"\n    CREATE TABLE IF NOT EXISTS displacement_summary AS\n    SELECT\n        scenario,\n        carrier,\n        days_prior,\n        avg(displacement) as displacement_mean,\n        stdev(displacement) as displacement_stdev\n    FROM leg_detail\n        LEFT JOIN leg_defs ON leg_detail.leg_id = leg_defs.leg_id\n    WHERE\n        sample &gt;= ?1\n    GROUP BY\n        scenario, carrier, days_prior\n    ORDER BY\n        carrier, days_prior DESC\n    \"\"\"\n    cnx.execute(preqry, (burn_samples,))\n    try:\n        cnx._commit_raw()\n    except sqlite3.OperationalError:\n        preqry = preqry.replace(\"CREATE TABLE IF NOT EXISTS\", \"CREATE TEMP TABLE IF NOT EXISTS\")\n        cnx.execute(preqry, (burn_samples,))\n    qry = \"\"\"\n    SELECT carrier, days_prior, displacement_mean, displacement_stdev\n    FROM displacement_summary\n    WHERE scenario == ?1\n    \"\"\"\n    df = cnx.dataframe(\n        qry,\n        (scenario,),\n    )\n    df = df.set_index([\"carrier\", \"days_prior\"])\n    return df\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.edgar", "title": "edgar", "text": "<pre><code>edgar(\n    cnx: Database,\n    *,\n    scenario: str = None,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Forecast accuracy information.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The demand will be returned ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>iteration</code>, <code>trial</code>, <code>sample</code>, <code>segment</code>, <code>orig</code>, and <code>dest</code>; and has columns defined by the DCPs. The values stored are the total remaining demand to come at each DCP.</p> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def edgar(cnx: Database, *, scenario: str = None, burn_samples: int = 100) -&gt; pd.DataFrame:\n    \"\"\"\n    Forecast accuracy information.\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str, optional\n    burn_samples : int, default 100\n        The demand will be returned ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `iteration`, `trial`, `sample`,\n        `segment`, `orig`, and `dest`; and has columns defined by the DCPs.\n        The values stored are the total remaining demand to come at each DCP.\n    \"\"\"\n    # Provides content similar to PODS *.DHS output file, but with market level detail\n\n    qry = \"\"\"\n        SELECT\n            iteration, trial, sample, timeframe, path_id, booking_class, sold,\n            sold_priceable, forecast_mean, forecast_stdev, closed\n        FROM\n            edgar\n        WHERE\n            sample &gt;= ?1\n            AND scenario = ?2\n        \"\"\"\n\n    if scenario is None:\n        qry = qry.replace(\"AND scenario = ?2\", \"\")\n        params = (burn_samples,)\n    else:\n        params = (burn_samples, scenario)\n    e = cnx.dataframe(qry, params)  # , dtype={\"edgar\": np.int32})\n    return e\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.fare_class_mix", "title": "fare_class_mix", "text": "<pre><code>fare_class_mix(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; DataFrame\n</code></pre> <p>Fare class mix by carrier.</p> <p>This query requires that the simulation was run while recording final fare details (i.e. with the <code>fare</code> or <code>fare_final</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The average total demand will be computed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>carrier</code> and <code>booking_class</code>, and has these columns:</p> <ul> <li><code>avg_sold</code>: Average number of sales in this booking class.</li> <li><code>avg_revenue</code>: Average total revenue earned from customers booking in     this booking class.</li> <li><code>avg_price</code>: Average price per ticket from customers booking in this     booking class.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def fare_class_mix(cnx: Database, scenario: str, burn_samples: int = 100) -&gt; pd.DataFrame:\n    \"\"\"\n    Fare class mix by carrier.\n\n    This query requires that the simulation was run while recording final fare\n    details (i.e. with the `fare` or `fare_final` flags set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The average total demand will be computed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `carrier` and `booking_class`, and\n        has these columns:\n\n        - `avg_sold`: Average number of sales in this booking class.\n        - `avg_revenue`: Average total revenue earned from customers booking in\n            this booking class.\n        - `avg_price`: Average price per ticket from customers booking in this\n            booking class.\n    \"\"\"\n    pre_qry = \"\"\"\n    CREATE TABLE IF NOT EXISTS fare_summary AS\n    SELECT\n        trial, sample, scenario, carrier, booking_class,\n        SUM(sold) AS sold,\n        SUM(sold * price) AS revenue\n    FROM\n        fare_detail LEFT JOIN fare_defs USING (fare_id)\n    WHERE\n        days_prior = 0\n    GROUP BY\n        trial, sample, scenario, carrier, booking_class\n    \"\"\"\n    cnx.execute(pre_qry)\n    cnx._commit_raw()\n\n    qry = \"\"\"\n    SELECT carrier, booking_class,\n           (AVG(sold)) AS avg_sold,\n           (AVG(revenue)) AS avg_revenue,\n           (AVG(revenue) / AVG(sold)) AS avg_price\n    FROM\n        fare_summary\n    WHERE\n        sample &gt;= ?2\n        AND scenario = ?1\n    GROUP BY carrier, booking_class\n    ORDER BY carrier, booking_class;\n    \"\"\"\n    return cnx.dataframe(qry, (scenario, burn_samples)).set_index([\"carrier\", \"booking_class\"])\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.leg_detail", "title": "leg_detail", "text": "<pre><code>leg_detail(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; DataFrame\n</code></pre> <p>Dump leg_detail into a dataframe</p> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def leg_detail(\n        cnx: Database,\n        scenario: str,\n        burn_samples: int = 100,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Dump leg_detail into a dataframe\n    \"\"\"\n\n    qry = \"\"\"\n    SELECT l.trial, l.sample, l.leg_id, d.carrier, d.flt_no, d.orig, d.dest,\n           l.days_prior, l.sold, l.revenue, l.local_sold, l.local_revenue, l.bid_price \n    FROM leg_detail l\n    JOIN leg_defs d USING (leg_id)\n    \"\"\"\n    df = cnx.dataframe(\n        qry,\n#        (scenario,),\n    )\n#    print(f\"Dataframe has {len(df)} rows, scenario = {scenario}\")\n#    df = df.set_index([\"trial\", \"sample\", \"flt_no\", \"orig\", \"dest\", \"days_prior\"])\n    return df\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.leg_forecast_trace", "title": "leg_forecast_trace", "text": "<pre><code>leg_forecast_trace(\n    cnx: Database,\n    scenario: str | None = None,\n    burn_samples: int = 100,\n    carrier: str | None = None,\n    leg_id: int | None = None,\n    booking_class: str | None = None,\n    days_prior: int | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Recorded forecast of demand by leg.</p> <p>This query requires that the simulation was run while recording leg bucket details (i.e. with the <code>bucket</code> flag set on <code>Config.db.write_items</code>).  This function is provided primarily for testing and debugging purposes.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The forecasts will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> <li> <code>carrier</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this carrier.</p> </li> <li> <code>leg_id</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this leg.</p> </li> <li> <code>booking_class</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this booking class.</p> </li> <li> <code>days_prior</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this many days prior to departure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by any of <code>carrier</code>, <code>leg_id</code>, <code>booking_class</code>, and/or <code>days_prior</code> that were not filtered, and has these columns: - <code>forecast_mean</code>: Forecast mean (mu). - <code>forecast_stdev</code>: Forecast standard deviation (sigma). - <code>forecast_closed_in_tf</code>: Fraction of time the timeframe was     closed in the data used to make a forecast. - <code>forecast_closed_in_tf</code>: Fraction of time any future timeframe     was closed in the data used to make a forecast.</p> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def leg_forecast_trace(\n    cnx: \"Database\",\n    scenario: str | None = None,\n    burn_samples: int = 100,\n    carrier: str | None = None,\n    leg_id: int | None = None,\n    booking_class: str | None = None,\n    days_prior: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Recorded forecast of demand by leg.\n\n    This query requires that the simulation was run while recording leg bucket\n    details (i.e. with the `bucket` flag set on `Config.db.write_items`).  This\n    function is provided primarily for testing and debugging purposes.\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The forecasts will be analyzed ignoring this many samples from the\n        beginning of each trial.\n    carrier : str, optional\n        If provided, only return forecasts for this carrier.\n    leg_id : int, optional\n        If provided, only return forecasts for this leg.\n    booking_class : str, optional\n        If provided, only return forecasts for this booking class.\n    days_prior : int, optional\n        If provided, only return forecasts for this many days prior to departure.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by any of `carrier`, `leg_id`,\n        `booking_class`, and/or `days_prior` that were not filtered, and has\n        these columns:\n        - `forecast_mean`: Forecast mean (mu).\n        - `forecast_stdev`: Forecast standard deviation (sigma).\n        - `forecast_closed_in_tf`: Fraction of time the timeframe was\n            closed in the data used to make a forecast.\n        - `forecast_closed_in_tf`: Fraction of time any future timeframe\n            was closed in the data used to make a forecast.\n    \"\"\"\n    return _leg_bucket_trace(\n        \"forecast_mean, forecast_stdev, \" \"forecast_closed_in_tf, forecast_closed_in_future\",\n        cnx,\n        scenario=scenario,\n        burn_samples=burn_samples,\n        carrier=carrier,\n        leg_id=leg_id,\n        booking_class=booking_class,\n        days_prior=days_prior,\n    )\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.leg_forecasts", "title": "leg_forecasts", "text": "<pre><code>leg_forecasts(\n    cnx: Database,\n    *,\n    scenario: str = None,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Average forecasts of demand by leg, bucket, and days to departure.</p> <p>This query requires that the simulation was run while recording leg bucket details (i.e. with the <code>bucket</code> flag set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The forecasts will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>carrier</code>, <code>leg_id</code>, <code>bucket_number</code>, <code>booking_class</code> and <code>days_prior</code>, and has these columns:</p> <ul> <li><code>forecast_mean</code>: Average forecast mean (mu).</li> <li><code>forecast_stdev</code>: Average forecast standard deviation (sigma).</li> <li><code>forecast_closed_in_tf</code>: Average fraction of time the timeframe was     closed in the data used to make a forecast.</li> <li><code>forecast_closed_in_tf</code>: Average fraction of time any future timeframe     was closed in the data used to make a forecast.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def leg_forecasts(cnx: Database, *, scenario: str = None, burn_samples: int = 100) -&gt; pd.DataFrame:\n    \"\"\"\n    Average forecasts of demand by leg, bucket, and days to departure.\n\n    This query requires that the simulation was run while recording leg bucket\n    details (i.e. with the `bucket` flag set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The forecasts will be analyzed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `carrier`, `leg_id`,\n        `bucket_number`, `booking_class` and `days_prior`, and has these columns:\n\n        - `forecast_mean`: Average forecast mean (mu).\n        - `forecast_stdev`: Average forecast standard deviation (sigma).\n        - `forecast_closed_in_tf`: Average fraction of time the timeframe was\n            closed in the data used to make a forecast.\n        - `forecast_closed_in_tf`: Average fraction of time any future timeframe\n            was closed in the data used to make a forecast.\n    \"\"\"\n    qry = \"\"\"\n    SELECT\n        carrier,\n        leg_id,\n        bucket_number,\n        name as booking_class,\n        days_prior,\n        AVG(forecast_mean) as forecast_mean,\n        AVG(forecast_stdev) as forecast_stdev,\n        AVG(forecast_closed_in_tf) as forecast_closed_in_tf,\n        AVG(forecast_closed_in_future) as forecast_closed_in_future\n    FROM\n        leg_bucket_detail LEFT JOIN leg_defs USING (leg_id)\n    WHERE\n        sample &gt;= ?1\n        AND scenario = ?2\n    GROUP BY\n        carrier, leg_id, bucket_number, name, days_prior\n    \"\"\"\n    if scenario is None:\n        qry = qry.replace(\"AND scenario = ?2\", \"\")\n        params = (burn_samples,)\n    else:\n        params = (burn_samples, scenario)\n    return cnx.dataframe(qry, params).set_index([\"carrier\", \"leg_id\", \"bucket_number\", \"booking_class\", \"days_prior\"])\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.leg_local_and_flow_by_class", "title": "leg_local_and_flow_by_class", "text": "<pre><code>leg_local_and_flow_by_class(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; DataFrame\n</code></pre> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def leg_local_and_flow_by_class(cnx: Database, scenario: str, burn_samples: int = 100) -&gt; pd.DataFrame:\n    logger.info(\"creating pthcls temp table\")\n    cnx.execute(\n        \"\"\"\n        CREATE TEMP TABLE IF NOT EXISTS pthcls AS\n        SELECT\n            sold, leg1, booking_class, iteration, trial, sample\n        FROM\n            path_class_detail LEFT JOIN path_defs USING(path_id)\n        WHERE\n            days_prior == 0\n            AND leg2 IS NULL\n            AND scenario == ?1\n            AND sample &gt;= ?2\n        \"\"\",\n        (\n            scenario,\n            burn_samples,\n        ),\n    )\n\n    logger.info(\"indexing pthcls temp table\")\n    cnx.execute(\n        \"\"\"\n        CREATE INDEX IF NOT EXISTS idx_pthcls_1 ON pthcls (\n            iteration, trial, sample, leg1, booking_class\n        );\n        \"\"\"\n    )\n\n    logger.info(\"running leg_local_and_flow_by_class query\")\n    qry = \"\"\"\n    SELECT\n        leg_id,\n        leg_defs.carrier,\n        leg_defs.orig,\n        leg_defs.dest,\n        leg_bucket_detail.name as booking_class,\n        AVG(leg_bucket_detail.sold) AS carried_all,\n        IFNULL(AVG(pthcls.sold), 0) AS carried_loc\n    FROM\n        leg_bucket_detail\n        LEFT JOIN leg_defs USING (leg_id)\n        LEFT JOIN pthcls ON\n            leg_id == pthcls.leg1\n            AND leg_bucket_detail.name == pthcls.booking_class\n            AND leg_bucket_detail.iteration == pthcls.iteration\n            AND leg_bucket_detail.trial == pthcls.trial\n            AND leg_bucket_detail.sample == pthcls.sample\n    WHERE\n        leg_bucket_detail.scenario == ?1\n        AND leg_bucket_detail.sample &gt;= ?2\n        AND days_prior == 0\n    GROUP BY\n        leg_id,\n        leg_defs.carrier,\n        leg_defs.orig,\n        leg_defs.dest,\n        leg_bucket_detail.name\n    \"\"\"\n    df = cnx.dataframe(\n        qry,\n        (\n            scenario,\n            burn_samples,\n        ),\n    )\n    return df\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.leg_sales_trace", "title": "leg_sales_trace", "text": "<pre><code>leg_sales_trace(\n    cnx: Database,\n    scenario: str | None = None,\n    burn_samples: int = 100,\n    carrier: str | None = None,\n    leg_id: int | None = None,\n    booking_class: str | None = None,\n    days_prior: int | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Recorded forecast of demand by leg.</p> <p>This query requires that the simulation was run while recording leg bucket details (i.e. with the <code>bucket</code> flag set on <code>Config.db.write_items</code>).  This function is provided primarily for testing and debugging purposes.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The forecasts will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> <li> <code>carrier</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this carrier.</p> </li> <li> <code>leg_id</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this leg.</p> </li> <li> <code>booking_class</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this booking class.</p> </li> <li> <code>days_prior</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return forecasts for this many days prior to departure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by any of <code>carrier</code>, <code>leg_id</code>, <code>booking_class</code>, and/or <code>days_prior</code> that were not filtered, and has these columns: <code>sold</code>, <code>revenue</code>, <code>auth</code></p> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def leg_sales_trace(\n    cnx: \"Database\",\n    scenario: str | None = None,\n    burn_samples: int = 100,\n    carrier: str | None = None,\n    leg_id: int | None = None,\n    booking_class: str | None = None,\n    days_prior: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Recorded forecast of demand by leg.\n\n    This query requires that the simulation was run while recording leg bucket\n    details (i.e. with the `bucket` flag set on `Config.db.write_items`).  This\n    function is provided primarily for testing and debugging purposes.\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The forecasts will be analyzed ignoring this many samples from the\n        beginning of each trial.\n    carrier : str, optional\n        If provided, only return forecasts for this carrier.\n    leg_id : int, optional\n        If provided, only return forecasts for this leg.\n    booking_class : str, optional\n        If provided, only return forecasts for this booking class.\n    days_prior : int, optional\n        If provided, only return forecasts for this many days prior to departure.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by any of `carrier`, `leg_id`,\n        `booking_class`, and/or `days_prior` that were not filtered, and has\n        these columns: `sold`, `revenue`, `auth`\n    \"\"\"\n    return _leg_bucket_trace(\n        \"sold, revenue, auth\",\n        cnx,\n        scenario=scenario,\n        burn_samples=burn_samples,\n        carrier=carrier,\n        leg_id=leg_id,\n        booking_class=booking_class,\n        days_prior=days_prior,\n    )\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.load_factor_distribution", "title": "load_factor_distribution", "text": "<pre><code>load_factor_distribution(\n    cnx: Database,\n    scenario: str,\n    burn_samples: int = 100,\n    cutoffs=(0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95),\n) -&gt; DataFrame\n</code></pre> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def load_factor_distribution(\n    cnx: Database,\n    scenario: str,\n    burn_samples: int = 100,\n    cutoffs=(0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95),\n) -&gt; pd.DataFrame:\n    cutoffs = sorted([float(j) for j in cutoffs])\n    if 0.0 not in cutoffs:\n        cutoffs = [0.0] + cutoffs\n    if 1.0 not in cutoffs:\n        cutoffs = cutoffs + [1.0]\n    vars = []\n    for i in range(len(cutoffs) - 2):\n        vars.append(\n            f\"count(CASE WHEN lf&gt;= {cutoffs[i]} AND lf &lt; {cutoffs[i+1]} THEN 1 END) \"\n            f\"AS '{cutoffs[i]} - {cutoffs[i+1]}'\"\n        )\n    vars.append(\n        f\"count(CASE WHEN lf&gt;= {cutoffs[-2]} AND lf &lt;= {cutoffs[-1]} THEN 1 END) \" f\"AS '{cutoffs[-2]} - {cutoffs[-1]}'\"\n    )\n    vars = \",\\n        \".join(vars)\n    qry = f\"\"\"\n    SELECT\n        carrier,\n        {vars}\n    FROM (\n        SELECT carrier, sold, capacity, (1.0*sold)/capacity AS lf\n        FROM leg_detail\n                   JOIN leg_defs USING (leg_id)\n          WHERE days_prior = 0  -- only after all sales are recorded\n            AND sample &gt;= ?2    -- only after burn period\n            AND scenario = ?1   -- only for this scenario\n    )\n    GROUP BY carrier\n    \"\"\"\n    return cnx.dataframe(qry, (scenario, burn_samples))\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.load_factors", "title": "load_factors", "text": "<pre><code>load_factors(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; DataFrame\n</code></pre> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def load_factors(cnx: Database, scenario: str, burn_samples: int = 100) -&gt; pd.DataFrame:\n    qry = \"\"\"\n    SELECT carrier,\n           ROUND(AVG(sold)) AS avg_legs_sold,\n           ROUND(AVG(100.0 * sold / cap), 2) AS avg_leg_lf,\n           ROUND(AVG(100.0 * rpm / asm), 2) AS sys_lf,\n           ROUND(AVG(revenue), 2) AS avg_rev,\n           ROUND(AVG(revenue / asm), 3) AS yield,\n           ROUND(AVG(revenue) / AVG(sold)) AS avg_leg_price,\n           COUNT(*) AS n_obs\n    FROM (SELECT trial, sample, carrier,\n                 SUM(sold) AS sold,\n                 SUM(capacity) AS cap,\n                 SUM(sold * distance) AS rpm,\n                 SUM(capacity * distance) AS asm,\n                 SUM(revenue) AS revenue\n          FROM leg_detail\n                   JOIN leg_defs USING (leg_id)\n          WHERE days_prior = 0\n            AND sample &gt;= ?2\n            AND scenario = ?1\n          GROUP BY trial, sample, carrier\n         ) tmp\n    GROUP BY carrier\n    \"\"\"\n    return cnx.dataframe(qry, (scenario, burn_samples))\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.local_and_flow_yields", "title": "local_and_flow_yields", "text": "<pre><code>local_and_flow_yields(\n    cnx: Database,\n    *,\n    scenario: str = None,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Compute yields for local (nonstop) and flow (connecting) passengers.</p> <p>This query requires that the simulation was run while recording path class details (i.e. with the <code>pathclass</code> or <code>pathclass_final</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The yields will be computed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def local_and_flow_yields(cnx: Database, *, scenario: str = None, burn_samples: int = 100) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute yields for local (nonstop) and flow (connecting) passengers.\n\n    This query requires that the simulation was run while recording path class\n    details (i.e. with the `pathclass` or `pathclass_final` flags set on\n    `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str, optional\n    burn_samples : int, default 100\n        The yields will be computed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n    \"\"\"\n    qry = \"\"\"\n    WITH path_yields AS (\n        SELECT\n            iteration, trial, sample, path_id, leg1, leg2,\n            SUM(sold) as total_sold,\n            SUM(revenue) as total_revenue,\n            distance,\n            SUM(revenue) / (SUM(sold) * distance) AS yield,\n            leg2 IS NULL AS local\n        FROM\n            path_class_detail\n            LEFT JOIN path_defs USING (path_id)\n        WHERE\n            days_prior == 0\n            AND sample &gt;= ?1\n            AND scenario == ?2\n        GROUP BY\n            path_id\n    )\n    SELECT\n        leg_id, carrier, orig, dest, capacity, leg_defs.distance,\n        yield AS local_yield,\n        CAST(total_sold AS REAL) /\n            (total_sold + IFNULL(f1.flow_sold, 0) + IFNULL(f2.flow_sold, 0))\n            AS local_fraction,\n        (IFNULL(f1.flow_revenue, 0) + IFNULL(f2.flow_revenue, 0))\n            / (IFNULL(f1.flow_rpm, 0) + IFNULL(f2.flow_rpm, 0))\n            AS flow_yield\n    FROM\n        leg_defs\n        LEFT JOIN path_yields locals\n        ON locals.leg1 == leg_id AND locals.leg2 IS NULL\n        LEFT JOIN (\n            SELECT\n                leg1,\n                SUM(total_sold) AS flow_sold,\n                SUM(total_revenue) AS flow_revenue,\n                SUM(total_sold * distance) AS flow_rpm\n            FROM\n                path_yields\n            WHERE\n                leg2 IS NOT NULL\n            GROUP BY leg1\n        ) f1 ON f1.leg1 == leg_defs.leg_id\n        LEFT JOIN (\n            SELECT\n                leg2,\n                SUM(total_sold) AS flow_sold,\n                SUM(total_revenue) AS flow_revenue,\n                SUM(total_sold * distance) AS flow_rpm\n            FROM\n                path_yields\n            GROUP BY leg2\n        ) f2 ON f2.leg2 == leg_defs.leg_id\n    \"\"\"\n    if scenario is None:\n        qry = qry.replace(\"AND scenario == ?2\", \"\")\n        params = (burn_samples,)\n    else:\n        params = (burn_samples, scenario)\n    df = cnx.dataframe(qry, params)\n    return df\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.od_fare_class_mix", "title": "od_fare_class_mix", "text": "<pre><code>od_fare_class_mix(\n    cnx: Database,\n    orig: str,\n    dest: str,\n    scenario: str,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Fare class mix by carrier for a particular origin-destination market.</p> <p>This query requires that the simulation was run while recording final fare details (i.e. with the <code>fare</code> or <code>fare_final</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>orig</code>               (<code>str</code>)           \u2013            <p>Origin and destination to query.</p> </li> <li> <code>dest</code>               (<code>str</code>)           \u2013            <p>Origin and destination to query.</p> </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The average total demand will be computed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>carrier</code> and <code>booking_class</code>, and has these columns:</p> <ul> <li><code>avg_sold</code>: Average number of sales in this booking class.</li> <li><code>avg_revenue</code>: Average total revenue earned from customers booking in     this booking class.</li> <li><code>avg_price</code>: Average price per ticket from customers booking in this     booking class.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def od_fare_class_mix(cnx: Database, orig: str, dest: str, scenario: str, burn_samples: int = 100) -&gt; pd.DataFrame:\n    \"\"\"\n    Fare class mix by carrier for a particular origin-destination market.\n\n    This query requires that the simulation was run while recording final fare\n    details (i.e. with the `fare` or `fare_final` flags set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    orig, dest : str\n        Origin and destination to query.\n    scenario : str\n    burn_samples : int, default 100\n        The average total demand will be computed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `carrier` and `booking_class`, and\n        has these columns:\n\n        - `avg_sold`: Average number of sales in this booking class.\n        - `avg_revenue`: Average total revenue earned from customers booking in\n            this booking class.\n        - `avg_price`: Average price per ticket from customers booking in this\n            booking class.\n    \"\"\"\n\n    qry = \"\"\"\n    SELECT carrier, booking_class,\n           (AVG(sold)) AS avg_sold,\n           (AVG(revenue)) AS avg_revenue,\n           (AVG(revenue) / AVG(sold)) AS avg_price\n    FROM (\n            SELECT\n                trial, scenario, carrier, booking_class,\n                SUM(sold) AS sold,\n                SUM(sold * price) AS revenue,\n                COUNT(*) AS nobs\n            FROM\n                fare_detail LEFT JOIN fare_defs USING (fare_id)\n            WHERE\n                days_prior = 0\n                AND sample &gt;= ?2\n                AND scenario = ?1\n                AND orig = ?3\n                AND dest = ?4\n            GROUP BY\n                trial, sample, carrier, booking_class\n    ) tmp\n    GROUP BY carrier, booking_class\n    ORDER BY carrier, booking_class;\n    \"\"\"\n    return cnx.dataframe(qry, (scenario, burn_samples, orig, dest)).set_index([\"carrier\", \"booking_class\"])\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.path_forecasts", "title": "path_forecasts", "text": "<pre><code>path_forecasts(\n    cnx: Database,\n    *,\n    scenario: str = None,\n    burn_samples: int = 100,\n) -&gt; DataFrame\n</code></pre> <p>Average forecasts of demand by path, class, and days to departure.</p> <p>This query requires that the simulation was run while recording path-class details (i.e. with the <code>pathclass</code> flag set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The forecasts will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The resulting dataframe is indexed by <code>path_id</code>, <code>booking_class</code> and <code>days_prior</code>, and has these columns:</p> <ul> <li><code>forecast_mean</code>: Average forecast mean (mu).</li> <li><code>forecast_stdev</code>: Average forecast standard deviation (sigma).</li> <li><code>forecast_closed_in_tf</code>: Average fraction of time the timeframe was     closed in the data used to make a forecast.</li> <li><code>forecast_closed_in_tf</code>: Average fraction of time any future timeframe     was closed in the data used to make a forecast.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def path_forecasts(cnx: Database, *, scenario: str = None, burn_samples: int = 100) -&gt; pd.DataFrame:\n    \"\"\"\n    Average forecasts of demand by path, class, and days to departure.\n\n    This query requires that the simulation was run while recording path-class\n    details (i.e. with the `pathclass` flag set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The forecasts will be analyzed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `path_id`, `booking_class` and\n        `days_prior`, and has these columns:\n\n        - `forecast_mean`: Average forecast mean (mu).\n        - `forecast_stdev`: Average forecast standard deviation (sigma).\n        - `forecast_closed_in_tf`: Average fraction of time the timeframe was\n            closed in the data used to make a forecast.\n        - `forecast_closed_in_tf`: Average fraction of time any future timeframe\n            was closed in the data used to make a forecast.\n    \"\"\"\n    qry = \"\"\"\n    SELECT\n        path_id,\n        booking_class,\n        days_prior,\n        AVG(forecast_mean) as forecast_mean,\n        AVG(forecast_stdev) as forecast_stdev,\n        AVG(forecast_closed_in_tf) as forecast_closed_in_tf,\n        AVG(forecast_closed_in_future) as forecast_closed_in_future,\n        AVG(adjusted_price) as adjusted_price\n    FROM\n        path_class_detail\n    WHERE\n        sample &gt;= ?1\n        AND scenario = ?2\n    GROUP BY\n        path_id, booking_class, days_prior\n    \"\"\"\n    if scenario is None:\n        qry = qry.replace(\"AND scenario = ?2\", \"\")\n        params = (burn_samples,)\n    else:\n        params = (burn_samples, scenario)\n    return cnx.dataframe(qry, params).set_index([\"path_id\", \"booking_class\", \"days_prior\"])\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.total_demand", "title": "total_demand", "text": "<pre><code>total_demand(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; float\n</code></pre> <p>Average total demand.</p> <p>This query requires that the simulation was run while recording final demand details (i.e. with the <code>demand</code> or <code>demand_final</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>scenario</code>               (<code>str</code>)           \u2013            </li> <li> <code>burn_samples</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The average total demand will be computed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def total_demand(cnx: Database, scenario: str, burn_samples: int = 100) -&gt; float:\n    \"\"\"\n    Average total demand.\n\n    This query requires that the simulation was run while recording final demand\n    details (i.e. with the `demand` or `demand_final` flags set on\n    `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The average total demand will be computed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    float\n    \"\"\"\n    qry = \"\"\"\n    SELECT AVG(sample_demand)\n    FROM (\n        SELECT\n            SUM(sample_demand) AS sample_demand\n        FROM\n            demand_detail\n        WHERE\n            days_prior = 0\n            AND sample &gt;= ?2\n            AND scenario = ?1\n        GROUP BY\n            trial, sample) tmp;\n    \"\"\"\n    return cnx.dataframe(qry, (scenario, burn_samples)).iloc[0, 0]\n</code></pre>"}, {"location": "API/database/tables.html", "title": "Tables", "text": ""}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_booking_curve", "title": "create_table_booking_curve", "text": "<pre><code>create_table_booking_curve(\n    cnx: Database, primary_key: bool = True\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_booking_curve(cnx: Database, primary_key: bool = True):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS booking_curve (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        carrier\t\t\tVARCHAR(10) NOT NULL,\n        orig\t\t\tVARCHAR(10) NOT NULL,\n        dest\t\t\tVARCHAR(10) NOT NULL,\n        flt_no\t\t\tINT NOT NULL,\n        days_prior  \tINT NOT NULL,\n        ratio           FLOAT NOT NULL\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(primary_key=\", PRIMARY KEY(scenario, carrier, \" \"orig, dest, flt_no, days_prior)\")\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_bookings_by_timeframe", "title": "create_table_bookings_by_timeframe", "text": "<pre><code>create_table_bookings_by_timeframe(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_bookings_by_timeframe(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS bookings_by_timeframe\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        trial       \tINT NOT NULL,\n        carrier\t\t\tVARCHAR(10) NOT NULL,\n        booking_class   VARCHAR(10) NOT NULL,\n        days_prior\t\tINT NOT NULL,\n        tot_sold\t\tFLOAT,\n        avg_sold\t\tFLOAT,\n        avg_business\tFLOAT,\n        avg_leisure     FLOAT,\n        avg_revenue     FLOAT,\n        avg_price       FLOAT,\n        updated_at\t\tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(primary_key=\", PRIMARY KEY(scenario, carrier, booking_class, days_prior)\")\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_configs", "title": "create_table_configs", "text": "<pre><code>create_table_configs(cnx: Database)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_configs(cnx: Database):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS runtime_configs (\n        scenario\t\tTEXT PRIMARY KEY,\n        pxsim_version   TEXT,\n        configs         TEXT,\n        updated_at\t    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n    );\n    \"\"\"\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_demand_detail", "title": "create_table_demand_detail", "text": "<pre><code>create_table_demand_detail(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_demand_detail(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS demand_detail\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        iteration\t\tINT NOT NULL,\n        trial\t    \tINT NOT NULL,\n        sample  \t\tINT NOT NULL,\n        days_prior\t    INT NOT NULL,\n        segment\t\t\tVARCHAR(10) NOT NULL,\n        orig\t\t\tVARCHAR(10) NOT NULL,\n        dest\t\t\tVARCHAR(10) NOT NULL,\n        updated_at\t\tDATETIME NOT NULL DEFAuLT CURRENT_TIMESTAMP,\n        sample_demand   FLOAT,\n        sold\t\t\tINT,\n        no_go\t\t\tINT,\n        revenue\t\t\tFLOAT\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, \" \"sample, days_prior, segment, orig, dest)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_distance", "title": "create_table_distance", "text": "<pre><code>create_table_distance(\n    cnx: Database, primary_key: bool = True\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_distance(cnx: Database, primary_key: bool = True):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS distance (\n        orig\t\t\tVARCHAR(10) NOT NULL,\n        dest\t\t\tVARCHAR(10) NOT NULL,\n        miles           FLOAT\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(primary_key=\", PRIMARY KEY(orig, dest)\")\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_edgar", "title": "create_table_edgar", "text": "<pre><code>create_table_edgar(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> <p>Forecast accuracy data, modeled after UA's EDGAR approach</p> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_edgar(cnx: Database, primary_key: bool = False):\n    \"\"\"Forecast accuracy data, modeled after UA's EDGAR approach\"\"\"\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS edgar\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        iteration\t\tINT NOT NULL,\n        trial\t    \tINT NOT NULL,\n        sample  \t\tINT NOT NULL,\n        timeframe   \tINT NOT NULL,\n        path_id\t\t\tINT NOT NULL,\n        booking_class   VARCHAR(10) NOT NULL,\n        sold\t\t\tINT,\n        sold_priceable  INT,\n        forecast_mean   FLOAT,\n        forecast_stdev  FLOAT,\n        closed          FLOAT,\n        updated_at\t\tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, timeframe, \" \"path_id, booking_class)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_fare_defs", "title": "create_table_fare_defs", "text": "<pre><code>create_table_fare_defs(\n    cnx: Database, fares: Iterable | None = None\n) -&gt; None\n</code></pre> <p>Create and populate a static database table of fares.</p> <p>The contents of this table is static input data, used but not mutated by the simulator.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>fares</code>               (<code>Iterable[Fare]</code>, default:                   <code>None</code> )           \u2013            <p>The fares to store in the database.</p> </li> </ul> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_fare_defs(cnx: Database, fares: Iterable | None = None) -&gt; None:\n    \"\"\"\n    Create and populate a static database table of fares.\n\n    The contents of this table is static input data, used but not mutated\n    by the simulator.\n\n    Parameters\n    ----------\n    cnx : Database\n    fares : Iterable[Fare]\n        The fares to store in the database.\n    \"\"\"\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS fare_defs\n    (\n        fare_id       INTEGER PRIMARY KEY,\n        carrier       VARCHAR(10) NOT NULL,\n        orig          VARCHAR(10) NOT NULL,\n        dest          VARCHAR(10) NOT NULL,\n        booking_class VARCHAR(10) NOT NULL,\n        price         FLOAT NOT NULL,\n        restrictions  VARCHAR(20) NOT NULL,\n        category      VARCHAR(20)\n    );\n    \"\"\"\n    cnx.execute(sql)\n    sql2 = \"\"\"\n    CREATE INDEX IF NOT EXISTS fare_defs_idx_2\n    ON fare_defs (\n        carrier, booking_class\n    );\n    \"\"\"\n    cnx.execute(sql2)\n    for fare in fares:\n        cnx.execute(\n            \"\"\"\n            INSERT OR REPLACE INTO fare_defs(\n                fare_id,\n                carrier,\n                orig,\n                dest,\n                booking_class,\n                price,\n                restrictions,\n                category\n            ) VALUES (\n                ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8\n            )\n            \"\"\",\n            (\n                fare.fare_id,\n                fare.carrier_name,\n                fare.orig,\n                fare.dest,\n                fare.booking_class,\n                fare.price,\n                \",\".join([str(r) for r in fare.get_restrictions()]),\n                fare.category,\n            ),\n        )\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_fare_detail", "title": "create_table_fare_detail", "text": "<pre><code>create_table_fare_detail(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_fare_detail(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS fare_detail\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        iteration\t\tINT NOT NULL,\n        trial\t    \tINT NOT NULL,\n        sample  \t\tINT NOT NULL,\n        days_prior \t\tINT NOT NULL,\n        fare_id         INT NOT NULL,\n        sold\t\t\tINT,\n        sold_business\tINT,\n        updated_at\t\tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, \"\n            \"days_prior, carrier, orig, dest, booking_class)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_fare_restriction_defs", "title": "create_table_fare_restriction_defs", "text": "<pre><code>create_table_fare_restriction_defs(\n    cnx: Database, restrictions: list[str]\n) -&gt; None\n</code></pre> <p>Create and populate a static database table of fare restrictions.</p> <p>The contents of this table is static input data, used but not mutated by the simulator.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>restrictions</code>               (<code>list[str]</code>)           \u2013            <p>The restrictions to store in the database.</p> </li> </ul> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_fare_restriction_defs(cnx: Database, restrictions: list[str]) -&gt; None:\n    \"\"\"\n    Create and populate a static database table of fare restrictions.\n\n    The contents of this table is static input data, used but not mutated\n    by the simulator.\n\n    Parameters\n    ----------\n    cnx : Database\n    restrictions : list[str]\n        The restrictions to store in the database.\n    \"\"\"\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS fare_restriction_defs\n    (\n        restriction_id INTEGER PRIMARY KEY,\n        restriction TEXT NOT NULL\n    );\n    \"\"\"\n    cnx.execute(sql)\n    for idx, restriction in enumerate(restrictions, start=1):\n        cnx.execute(\n            \"\"\"\n            INSERT OR REPLACE INTO fare_restriction_defs(\n                restriction_id,\n                restriction\n            ) VALUES (\n                ?1, ?2\n            )\n            \"\"\",\n            (idx, restriction),\n        )\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_leg_bucket_detail", "title": "create_table_leg_bucket_detail", "text": "<pre><code>create_table_leg_bucket_detail(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_leg_bucket_detail(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS leg_bucket_detail\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        iteration\t\tINT NOT NULL,\n        trial\t    \tINT NOT NULL,\n        sample  \t\tINT NOT NULL,\n        days_prior   \tINT NOT NULL,\n        leg_id          INT NOT NULL,\n        cabin_code      VARCHAR(10) NOT NULL DEFAULT \"\",\n        bucket_number   INT NOT NULL,\n        name            VARCHAR(10) NOT NULL,\n        auth    \t\tINT,\n        revenue    \t\tFLOAT,\n        sold\t\t\tINT,\n        untruncated_demand     FLOAT,\n        forecast_mean   FLOAT,\n        forecast_stdev  FLOAT,\n        forecast_closed_in_tf FLOAT,\n        forecast_closed_in_future FLOAT,\n        updated_at\t\tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, days_prior, \"\n            \"carrier, orig, dest, flt_no, dep_date, bucket_number)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_leg_defs", "title": "create_table_leg_defs", "text": "<pre><code>create_table_leg_defs(\n    cnx: Database, legs: Iterable | None = None\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_leg_defs(cnx: Database, legs: Iterable | None = None):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS leg_defs\n    (\n        leg_id INTEGER PRIMARY KEY,\n        flt_no INTEGER,\n        carrier TEXT,\n        orig TEXT,\n        dest TEXT,\n        dep_time INTEGER,\n        arr_time INTEGER,\n        capacity INTEGER,\n        distance FLOAT\n    );\n    \"\"\"\n    cnx.execute(sql)\n    for leg in legs:\n        cnx.execute(\n            \"\"\"\n            INSERT OR REPLACE INTO leg_defs(\n                leg_id,\n                flt_no,\n                carrier,\n                orig,\n                dest,\n                dep_time,\n                arr_time,\n                capacity,\n                distance\n            ) VALUES (\n                ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9\n            )\n            \"\"\",\n            (\n                leg.leg_id,\n                leg.flt_no,\n                leg.carrier_name if hasattr(leg, \"carrier_name\") else leg.carrier,  # TODO remove this\n                leg.orig,\n                leg.dest,\n                leg.dep_time,\n                leg.arr_time,\n                leg.capacity,\n                leg.distance,\n            ),\n        )\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_leg_detail", "title": "create_table_leg_detail", "text": "<pre><code>create_table_leg_detail(\n    cnx: Database, primary_key: bool = False\n) -&gt; None\n</code></pre> <p>Create the <code>leg_detail</code> table in the database.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>               (<code>Database</code>)           \u2013            </li> <li> <code>primary_key</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> </ul> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_leg_detail(cnx: Database, primary_key: bool = False) -&gt; None:\n    \"\"\"\n    Create the `leg_detail` table in the database.\n\n    Parameters\n    ----------\n    cnx : Database\n    primary_key : bool, default False\n    \"\"\"\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS leg_detail\n    (\n        scenario\t    \tVARCHAR(20) NOT NULL,\n        iteration\t    \tINT NOT NULL,\n        trial\t        \tINT NOT NULL,\n        sample  \t    \tINT NOT NULL,\n        days_prior       \tINT NOT NULL,\n        leg_id\t\t    \tINT NOT NULL,\n        updated_at\t    \tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        sold\t    \t\tINT,\n        revenue             FLOAT,\n        local_sold\t    \tINT,\n        local_revenue       FLOAT,\n        q_demand            FLOAT,\n        untruncated_demand  FLOAT,\n        forecast_mean       FLOAT,\n        bid_price           FLOAT,\n        displacement        FLOAT\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, \"\n            \"carrier, orig, dest, flt_no, days_prior, dep_date)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_path_class_detail", "title": "create_table_path_class_detail", "text": "<pre><code>create_table_path_class_detail(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_path_class_detail(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS path_class_detail\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        iteration\t\tINT NOT NULL,\n        trial\t    \tINT NOT NULL,\n        sample  \t\tINT NOT NULL,\n        days_prior   \tINT NOT NULL,\n        path_id\t\t\tINT NOT NULL,\n        booking_class   VARCHAR(10) NOT NULL,\n        sold\t\t\tINT,\n        sold_priceable  INT,\n        revenue         FLOAT,\n        forecast_mean   FLOAT,\n        forecast_stdev  FLOAT,\n        forecast_closed_in_tf FLOAT,\n        forecast_closed_in_future FLOAT,\n        adjusted_price  FLOAT,\n        updated_at\t\tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, days_prior, \" \"path_id, booking_class)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_path_defs", "title": "create_table_path_defs", "text": "<pre><code>create_table_path_defs(\n    cnx: Database, paths: Iterable | None = None\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_path_defs(cnx: Database, paths: Iterable | None = None):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS path_defs\n    (\n        path_id INTEGER PRIMARY KEY,\n        carrier TEXT,\n        orig TEXT,\n        stop1 TEXT,\n        dest TEXT,\n        leg1 INTEGER,\n        leg2 INTEGER,\n        distance FLOAT\n    );\n    \"\"\"\n    cnx.execute(sql)\n    for pth in paths:\n        connects = pth.num_legs() &gt; 1\n        cnx.execute(\n            \"\"\"\n            INSERT OR REPLACE INTO path_defs(\n                path_id,\n                carrier,\n                orig,\n                stop1,\n                dest,\n                leg1,\n                leg2,\n                distance\n            ) VALUES (\n                ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8\n            )\n            \"\"\",\n            (\n                pth.path_id,\n                pth.get_leg_carrier(0),\n                pth.orig,\n                pth.get_leg_dest(0) if connects else None,\n                pth.dest,\n                pth.get_leg_id(0),\n                pth.get_leg_id(1) if connects else None,\n                pth.get_total_distance(),\n            ),\n        )\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_tables", "title": "create_tables", "text": "<pre><code>create_tables(\n    cnx: Database,\n    primary_keys: dict[str, bool] | None = None,\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_tables(cnx: Database, primary_keys: dict[str, bool] | None = None):\n    pk = dict(\n        leg=False,\n        leg_bucket=False,\n        demand=False,\n        edgar=False,\n        fare=False,\n        booking_curve=True,\n        distance=True,\n        bookings=False,\n        path_class=False,\n    )\n    if primary_keys is not None:\n        pk.update(primary_keys)\n    create_table_configs(cnx)\n    create_table_leg_detail(cnx, pk[\"leg\"])\n    create_table_leg_bucket_detail(cnx, pk[\"leg_bucket\"])\n    create_table_demand_detail(cnx, pk[\"demand\"])\n    create_table_fare_detail(cnx, pk[\"fare\"])\n    create_table_bookings_by_timeframe(cnx, pk[\"bookings\"])\n    create_table_booking_curve(cnx, pk[\"booking_curve\"])\n    create_table_path_class_detail(cnx, pk[\"path_class\"])\n    create_table_edgar(cnx, pk[\"edgar\"])\n    create_table_distance(cnx, pk[\"distance\"])\n    cnx._commit_raw()\n</code></pre>"}, {"location": "Tutorials/index.html", "title": "Tutorials", "text": "<p>This section includes some tutorials to demonstrate some of the capabilities of PassengerSim.  These examples are built upon a very simple three market network with two carriers.  Each airline offers a pair of flights from BOS to ORD, and another pair from ORD to LAX.  Passenger demands are constructed for each single-leg market, as well as for the connecting market BOS-LAX.</p>"}, {"location": "Tutorials/index.html#3mkt-al1", "title": "3MKT AL1", "text": "<pre><code>graph LR\n    BOS--&gt;|101| ORD;\n    BOS--&gt;|102| ORD;\n    ORD--&gt;|111| LAX;\n    ORD--&gt;|112| LAX;</code></pre>"}, {"location": "Tutorials/index.html#3mkt-al2", "title": "3MKT AL2", "text": "<pre><code>graph LR\n    BOS--&gt;|201| ORD;\n    BOS--&gt;|202| ORD;\n    ORD--&gt;|211| LAX;\n    ORD--&gt;|212| LAX;</code></pre>"}, {"location": "Tutorials/3MKT/3mkt-01.nbconvert.html", "title": "Simple FCFS", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> <p>This example uses network/01-base.yaml configuration file. Within a Jupyter notebook, we can directly initialize a PassengerSim <code>Simulation</code> instance from this file using the <code>from_yaml</code> class constructor:</p> In\u00a0[2]: Copied! <pre>sim = pax.Simulation.from_yaml(\"network/01-base.yaml\")\n</pre> sim = pax.Simulation.from_yaml(\"network/01-base.yaml\") <pre>/var/folders/l1/yt63lf3n60b1dc25d_y2d1q80000gn/T/ipykernel_91892/2459294051.py:1: UserWarning: Restriction 'R2' found in fares but not used in any choice model\n  sim = pax.Simulation.from_yaml(\"network/01-base.yaml\")\n/var/folders/l1/yt63lf3n60b1dc25d_y2d1q80000gn/T/ipykernel_91892/2459294051.py:1: UserWarning: Restriction 'R1' found in fares but not used in any choice model\n  sim = pax.Simulation.from_yaml(\"network/01-base.yaml\")\n/var/folders/l1/yt63lf3n60b1dc25d_y2d1q80000gn/T/ipykernel_91892/2459294051.py:1: UserWarning: Restriction 'R3' found in fares but not used in any choice model\n  sim = pax.Simulation.from_yaml(\"network/01-base.yaml\")\n</pre> <p>Running the simulation is as simple as calling the <code>run</code> command, which runs the simulation and returns a summary output object.</p> In\u00a0[3]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 2.10 seconds\n</pre> <p>The contents of the final summary is controlled by <code>Config.outputs.reports</code>, which allows the user to add reports for more detail, or drop some unneccessary reports to improve runtime (sometimes substantially).</p> In\u00a0[4]: Copied! <pre>sim.config.outputs.reports\n</pre> sim.config.outputs.reports Out[4]: <pre>{'bookings_by_timeframe',\n 'carrier_history',\n 'demand_to_come',\n 'fare_class_mix',\n 'leg_forecasts',\n 'load_factors',\n 'total_demand'}</pre> <p>For this example, several default reports are included, which allows us to access a number of pre-packaged visualizations for the results.</p> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_carrier_mileage()\n</pre> summary.fig_carrier_mileage() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[8]: <p>All demand is in the lowest fare class, because the simulation has no restrictions against customers simply buying the least expensive fare.</p> In\u00a0[9]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[9]: <p>We are not limited to the pre-packaged visualizations. The various summary tables available in the <code>summary</code> object are all just regular pandas DataFrames, so we can use all the usual Python and Pandas tools for analysis. For example, the <code>demand_to_come</code> table summarizes the total demand to come at each timeframe for every simulation sample.</p> In\u00a0[10]: Copied! <pre>summary.demand_to_come\n</pre> summary.demand_to_come Out[10]: days_prior 63 56 49 42 35 31 28 24 21 17 14 10 7 5 3 1 0 iteration trial sample segment orig dest 0 0 100 business BOS LAX 65 61 57 55 51 51 49 48 42 39 39 31 25 19 14 4 0 ORD 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ORD LAX 68 63 59 59 54 52 50 48 47 44 36 32 25 20 16 4 0 leisure BOS LAX 71 58 56 49 43 39 35 30 28 21 16 12 7 7 4 1 0 ORD 49 43 39 34 32 31 27 24 19 15 13 11 11 10 6 1 0 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 499 business BOS ORD 83 77 75 72 70 66 65 62 59 56 55 45 36 27 21 2 0 ORD LAX 155 141 134 131 120 115 114 111 106 99 91 81 62 46 32 12 0 leisure BOS LAX 215 182 165 148 126 113 109 89 84 64 51 42 35 35 20 7 0 ORD 133 111 105 91 76 65 58 49 47 33 26 18 18 15 6 2 0 ORD LAX 198 165 146 132 114 102 95 74 57 51 43 32 24 21 11 4 0 <p>2400 rows \u00d7 17 columns</p> <p>With this data, we can do whatever analysis we like.  Here we'll compute the correlation between total demands (from the beginning of the booking curve at DCP 63 all the way to the end) of different passenger types in different markets.</p> In\u00a0[11]: Copied! <pre>summary.demand_to_come[63].unstack([\"segment\", \"orig\", \"dest\"]).corr()\n</pre> summary.demand_to_come[63].unstack([\"segment\", \"orig\", \"dest\"]).corr() Out[11]: segment business leisure orig BOS ORD BOS ORD dest LAX ORD LAX LAX ORD LAX segment orig dest business BOS LAX 1.000000 0.083927 0.231989 0.337721 0.109801 0.136725 ORD 0.083927 1.000000 0.132940 0.117638 0.371579 0.111497 ORD LAX 0.231989 0.132940 1.000000 0.190033 0.217089 0.352117 leisure BOS LAX 0.337721 0.117638 0.190033 1.000000 0.156787 0.140052 ORD 0.109801 0.371579 0.217089 0.156787 1.000000 0.147393 ORD LAX 0.136725 0.111497 0.352117 0.140052 0.147393 1.000000 <p>The <code>summary</code> object also has a command to dump all the summary tables to an Excel workbook, if you prefer to analyze the results there instead of in Jupyter.</p> In\u00a0[12]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-01.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-01.xlsx\") <p>Download 3mkt-01.xlsx</p> In\u00a0[13]: Copied! <pre>import targets\n\ntarget = targets.load(1, sim.config)\n</pre> import targets  target = targets.load(1, sim.config) In\u00a0[14]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[15]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_segmentation_by_timeframe(\"bookings\", by_carrier=False, by_class=True)\n</pre> comps.fig_segmentation_by_timeframe(\"bookings\", by_carrier=False, by_class=True) Out[17]: <p>We can look at carrier forecasts of demand on individual legs.</p> In\u00a0[18]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"]) Out[18]: <p>We can compare the mean and standard deviation of demand to come.</p> In\u00a0[19]: Copied! <pre>comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\") Out[19]: <p>We can even take arbitrary functions that apply pandas tools, and have them run automatically against multiple summary objects. For example, we can look at the variance-covariance matrix of aggregate demand by passenger type, and compare those matrices for both the simulation and the target.</p> In\u00a0[20]: Copied! <pre>comps.apply(lambda s: s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov())\n</pre> comps.apply(lambda s: s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov()) Out[20]: segment business leisure source segment simulation business 3665.319273 2224.550439 leisure 2224.550439 5590.625157 target business 3249.598992 1955.419868 leisure 1955.419868 5359.555328"}, {"location": "Tutorials/3MKT/3mkt-01.nbconvert.html#simple-fcfs", "title": "Simple FCFS\u00b6", "text": "<p>This is a very simple network, with only 3 markets, used to demonstrate some features of PassengerSim.</p>"}, {"location": "Tutorials/3MKT/3mkt-01.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": "<p>In addition to summary reports for a single run, we can also use PassengerSim's <code>contrast</code> package to compare simulation runs to each other, or against exogenously defined target results.</p>"}, {"location": "Tutorials/3MKT/3mkt-02.nbconvert.html", "title": "FCFS with Product Restrictions", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> <p>This example adds the network/02-buyup.yaml configuration file, to enable the product restrictions.</p> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml([\"network/01-base.yaml\", \"network/02-buyup.yaml\"])\n</pre> cfg = pax.Config.from_yaml([\"network/01-base.yaml\", \"network/02-buyup.yaml\"]) <p>The configuration can be manipulated in Python after loading.  This allows for a more interactive experience, where individual input values can readily be altered for a given analysis.</p> In\u00a0[3]: Copied! <pre>cfg.simulation_controls.num_trials = 4\n</pre> cfg.simulation_controls.num_trials = 4 <p>After all the desired changes have been completed, we use the <code>Config</code> to initialize the <code>Simulation</code>.</p> In\u00a0[4]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[5]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 11.12 seconds\n</pre> In\u00a0[6]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[9]: In\u00a0[10]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-02.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-02.xlsx\") <p>Download 3mkt-02.xlsx</p> In\u00a0[11]: Copied! <pre>import targets\n\ntarget = targets.load(2, cfg)\n</pre> import targets  target = targets.load(2, cfg) In\u00a0[12]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[13]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_segmentation_by_timeframe(\"bookings\", by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_segmentation_by_timeframe(\"bookings\", by_carrier=\"AL1\", by_class=True) Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=111)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=111) Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=111, agg_booking_classes=True)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=111, agg_booking_classes=True) Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=101)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=101) Out[19]:"}, {"location": "Tutorials/3MKT/3mkt-02.nbconvert.html#fcfs-with-product-restrictions", "title": "FCFS with Product Restrictions\u00b6", "text": "<p>In this example, we add product restrictions to the simulation.  These restrictions will cause some passengers to \"buy up\" to a fare product other than the lowest price.</p>"}, {"location": "Tutorials/3MKT/3mkt-02.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-03.nbconvert.html", "title": "FCFS with AP and Product Restrictions", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> <p>In prior examples, the configuration were given in one or more external file, passed to the <code>from_yaml</code> constructor as arguments.  We can also craft multi-line yaml content directly in a Python string, and pass that directly to the same contructor.  Here, we will turn the <code>disable_ap</code> switch off, and add a snapshot filter.</p> In\u00a0[2]: Copied! <pre>with_AP = \"\"\"\nsimulation_controls:\n  disable_ap: false\n\nsnapshot_filters:\n- type: leg_untruncation\n  airline: AL1\n  sample: 400\n  flt_no: 101\n  directory: snapshots/em\n\"\"\"\n</pre> with_AP = \"\"\" simulation_controls:   disable_ap: false  snapshot_filters: - type: leg_untruncation   airline: AL1   sample: 400   flt_no: 101   directory: snapshots/em \"\"\" <p>Snapshot filters can be triggered at limited specific points within a large simulation, and they will write out details intermediate results for that specific point.  The example snapshot filter here will provide extra output into the leg untruncation for a single flight on a single sample in the simulation.  Storing this level of detail for every flight for every sample would generally be gratuitous, slowing the simulation significantly and writing out excessively large files, but the snapshots give the ability to see and explore details from deep inside the simulation.</p> In\u00a0[3]: Copied! <pre>cfg = pax.Config.from_yaml([\"network/01-base.yaml\", \"network/02-buyup.yaml\", with_AP])\n</pre> cfg = pax.Config.from_yaml([\"network/01-base.yaml\", \"network/02-buyup.yaml\", with_AP]) In\u00a0[4]: Copied! <pre>cfg.simulation_controls.num_trials = 4\n</pre> cfg.simulation_controls.num_trials = 4 In\u00a0[5]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[6]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 9.76 seconds\n</pre> In\u00a0[7]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[10]: In\u00a0[11]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-03.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-03.xlsx\") <p>Download 3mkt-03.xlsx</p> In\u00a0[12]: Copied! <pre>import targets\n\ntarget = targets.load(3, cfg)\n</pre> import targets  target = targets.load(3, cfg) In\u00a0[13]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[14]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=101)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=101) Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=111)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_leg_id=111) Out[19]: In\u00a0[20]: Copied! <pre>contrast.fig_leg_forecasts(comps, of=[\"mu\", \"sigma\"], by_leg_id=101, agg_booking_classes=True)\n</pre> contrast.fig_leg_forecasts(comps, of=[\"mu\", \"sigma\"], by_leg_id=101, agg_booking_classes=True) Out[20]:"}, {"location": "Tutorials/3MKT/3mkt-03.nbconvert.html#fcfs-with-ap-and-product-restrictions", "title": "FCFS with AP and Product Restrictions\u00b6", "text": "<p>In this example, on top of product restrictions we also add advance purchase (AP) restrictions to the simulation.  These restrictions close lower priced fare class products as the day of departure approaches.</p> <p>In this example, we will also demostrate adding yaml configuration content in a Jupyter notebook before loading configs, and adding a snapshot filter to the simulation.</p>"}, {"location": "Tutorials/3MKT/3mkt-03.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-04.nbconvert.html", "title": "EMSR-B with Low Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> <p>The yaml file for this example contains an explicit <code>include</code> instruction directly in the file. This emulates calling multiple file names in the <code>from_yaml</code> command, but the other file references are written directly into the code, so that groups of configurations can be managed together easily, without necessarily needing the user to carefully assemble the correct set of filenames every time they run the simulation.</p> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n\nshow_file(\"network/04-emsrb-low-demand.yaml\")\n</pre> from passengersim.utils.codeview import show_file  show_file(\"network/04-emsrb-low-demand.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 0.5\n\ncarriers:\n  - name: AL1\n    rm_system: rm_no_detruncation\n  - name: AL2\n    rm_system: rm_no_detruncation\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml(\n    [\n        \"network/04-emsrb-low-demand.yaml\",\n    ]\n)\n</pre> sim = pax.Simulation.from_yaml(     [         \"network/04-emsrb-low-demand.yaml\",     ] ) In\u00a0[4]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 1.68 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-04.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-04.xlsx\") <p>Download 3mkt-04.xlsx</p> In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(4, sim.config)\n</pre> import targets  target = targets.load(4, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[12]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[12]: In\u00a0[13]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[15]:"}, {"location": "Tutorials/3MKT/3mkt-04.nbconvert.html#emsr-b-with-low-demand", "title": "EMSR-B with Low Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Demand is simulated at a level 50% lower than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-04.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-05.nbconvert.html", "title": "EMSR-B", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n\nshow_file(\"network/05-emsrb.yaml\")\n</pre> from passengersim.utils.codeview import show_file  show_file(\"network/05-emsrb.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.0\n\ncarriers:\n  - name: AL1\n    rm_system: rm_no_detruncation\n  - name: AL2\n    rm_system: rm_no_detruncation\n\ndb:\n  write_items:\n    - leg_final\n    - fare_final\n    - demand_final\n    - bookings\n    - bucket\n\noutputs:\n  reports:\n    - leg_forecasts\n    - fare_class_mix\n    - load_factors\n    - bookings_by_timeframe\n    - total_demand\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml(\n    [\n        \"network/05-emsrb.yaml\",\n    ]\n)\n</pre> sim = pax.Simulation.from_yaml(     [         \"network/05-emsrb.yaml\",     ] ) In\u00a0[4]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 1.52 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-05.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-05.xlsx\") In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(5, sim.config)\n</pre> import targets  target = targets.load(5, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[12]: Copied! <pre>contrast.fig_carrier_revenues(comps)\n</pre> contrast.fig_carrier_revenues(comps) Out[12]: In\u00a0[13]: Copied! <pre>contrast.fig_carrier_load_factors(comps)\n</pre> contrast.fig_carrier_load_factors(comps) Out[13]: In\u00a0[14]: Copied! <pre>contrast.fig_fare_class_mix(comps)\n</pre> contrast.fig_fare_class_mix(comps) Out[14]: In\u00a0[15]: Copied! <pre>contrast.fig_leg_forecasts(comps, by_leg_id=101)\n</pre> contrast.fig_leg_forecasts(comps, by_leg_id=101) Out[15]: In\u00a0[16]: Copied! <pre>contrast.fig_leg_forecasts(comps, by_leg_id=111, of=[\"mu\", \"sigma\"])\n</pre> contrast.fig_leg_forecasts(comps, by_leg_id=111, of=[\"mu\", \"sigma\"]) Out[16]: In\u00a0[17]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_class=True, by_carrier=\"AL1\")\n</pre> contrast.fig_bookings_by_timeframe(comps, by_class=True, by_carrier=\"AL1\") Out[17]:"}, {"location": "Tutorials/3MKT/3mkt-05.nbconvert.html#emsr-b", "title": "EMSR-B\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Demand is simulated at normal levels.</p>"}, {"location": "Tutorials/3MKT/3mkt-05.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-06.nbconvert.html", "title": "EMSR-B with High Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n\nshow_file(\"network/06-emsrb-high-demand.yaml\")\n</pre> from passengersim.utils.codeview import show_file  show_file(\"network/06-emsrb-high-demand.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.1\n\ncarriers:\n  - name: AL1\n    rm_system: rm_no_detruncation\n  - name: AL2\n    rm_system: rm_no_detruncation\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml(\n    [\n        \"network/06-emsrb-high-demand.yaml\",\n    ]\n)\n</pre> sim = pax.Simulation.from_yaml(     [         \"network/06-emsrb-high-demand.yaml\",     ] ) In\u00a0[4]: Copied! <pre>summary = sim.run(log_reports=False)\n</pre> summary = sim.run(log_reports=False) <pre></pre> <pre>Task Completed after 2.11 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-06.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-06.xlsx\") In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(6, sim.config)\n</pre> import targets  target = targets.load(6, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[12]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[12]: In\u00a0[13]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"]) Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=211, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=211, of=[\"mu\", \"sigma\"]) Out[17]:"}, {"location": "Tutorials/3MKT/3mkt-06.nbconvert.html#emsr-b-with-high-demand", "title": "EMSR-B with High Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Demand is simulated at a level 10% higher than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-06.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-07.nbconvert.html", "title": "EM Untruncation with Low Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n\nshow_file(\"network/07-untrunc-em-low-demand.yaml\")\n</pre> from passengersim.utils.codeview import show_file  show_file(\"network/07-untrunc-em-low-demand.yaml\") <pre>include:\n  - 08-untrunc-em.yaml\n\nsimulation_controls:\n  demand_multiplier: 0.5\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml(\n    [\n        \"network/07-untrunc-em-low-demand.yaml\",\n    ]\n)\n</pre> sim = pax.Simulation.from_yaml(     [         \"network/07-untrunc-em-low-demand.yaml\",     ] ) In\u00a0[4]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 1.94 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-07.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-07.xlsx\") In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(7, sim.config)\n</pre> import targets  target = targets.load(7, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[12]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\")\n</pre> contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\") Out[12]: In\u00a0[13]: Copied! <pre>contrast.fig_carrier_revenues(comps)\n</pre> contrast.fig_carrier_revenues(comps) Out[13]: In\u00a0[14]: Copied! <pre>contrast.fig_fare_class_mix(comps)\n</pre> contrast.fig_fare_class_mix(comps) Out[14]: In\u00a0[15]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\", by_class=True)\n</pre> contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\", by_class=True) Out[15]:"}, {"location": "Tutorials/3MKT/3mkt-07.nbconvert.html#em-untruncation-with-low-demand", "title": "EM Untruncation with Low Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Additionally, the EM algorithm is employed to detruncate censored demand. Demand is simulated at a level 50% lower than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-07.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-08.nbconvert.html", "title": "EM Untruncation", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/08-untrunc-em.yaml\")\n</pre> show_file(\"network/08-untrunc-em.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.0\n\nrm_systems:\n  rm_test1:\n    availability_control: leg\n    processes:\n      DCP:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        name: forecast\n        algorithm: additive_pickup\n        alpha: 0.15\n        kind: leg\n      - step_type: emsr\n        name: optimization\n        algorithm: emsrb\n        kind: leg\n\ncarriers:\n  - name: AL1\n    rm_system: rm_test1\n  - name: AL2\n    rm_system: rm_test1\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml(\n    [\n        \"network/08-untrunc-em.yaml\",\n    ]\n)\n</pre> cfg = pax.Config.from_yaml(     [         \"network/08-untrunc-em.yaml\",     ] ) In\u00a0[5]: Copied! <pre>cfg.simulation_controls.num_trials = 6\n</pre> cfg.simulation_controls.num_trials = 6 In\u00a0[6]: Copied! <pre>cfg.outputs.reports.add(\"local_and_flow_yields\")\n</pre> cfg.outputs.reports.add(\"local_and_flow_yields\") In\u00a0[7]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[8]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 14.60 seconds\n</pre> In\u00a0[9]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[11]: In\u00a0[12]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[12]: In\u00a0[13]: Copied! <pre>summary.local_and_flow_yields\n</pre> summary.local_and_flow_yields Out[13]: leg_id carrier orig dest capacity distance local_yield local_fraction flow_yield 0 101 AL1 BOS ORD 100 863.753282 0.227482 0.418117 0.161239 1 102 AL1 BOS ORD 100 863.753282 0.228197 0.420482 0.160945 2 111 AL1 ORD LAX 120 1739.799337 0.175858 0.545889 0.161239 3 112 AL1 ORD LAX 120 1739.799337 0.176321 0.547027 0.160945 4 201 AL2 BOS ORD 100 863.753282 0.228448 0.419410 0.160955 5 202 AL2 BOS ORD 100 863.753282 0.227963 0.418427 0.161525 6 211 AL2 ORD LAX 120 1739.799337 0.175946 0.546921 0.160955 7 212 AL2 ORD LAX 120 1739.799337 0.176034 0.546186 0.161525 In\u00a0[14]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-08.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-08.xlsx\") In\u00a0[15]: Copied! <pre>import targets\n\ntarget = targets.load(8, cfg)\n</pre> import targets  target = targets.load(8, cfg) In\u00a0[16]: Copied! <pre>from passengersim import contrast\n</pre> from passengersim import contrast In\u00a0[17]: Copied! <pre>comps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[18]: Copied! <pre>comps.fig_demand_to_come(\"mean\")\n</pre> comps.fig_demand_to_come(\"mean\") Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"std\") Out[19]: In\u00a0[20]: Copied! <pre>comps.apply(lambda s: (s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov()))\n</pre> comps.apply(lambda s: (s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov())) Out[20]: segment business leisure source segment simulation business 3263.099012 1976.758878 leisure 1976.758878 5291.913397 target business 3249.598992 1955.419868 leisure 1955.419868 5359.555328 In\u00a0[21]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\", by_class=True)\n</pre> contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\", by_class=True) Out[21]: In\u00a0[22]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[22]: In\u00a0[23]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[23]: In\u00a0[24]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[24]: In\u00a0[25]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[25]: In\u00a0[26]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"]) Out[26]: In\u00a0[27]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"]) Out[27]: In\u00a0[28]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"]) Out[28]:"}, {"location": "Tutorials/3MKT/3mkt-08.nbconvert.html#em-untruncation", "title": "EM Untruncation\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Additionally, the EM algorithm is employed to detruncate censored demand. Demand is simulated at normal levels.</p>"}, {"location": "Tutorials/3MKT/3mkt-08.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-09.nbconvert.html", "title": "EM Untruncation with High Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/09-untrunc-em-high-demand.yaml\")\n</pre> show_file(\"network/09-untrunc-em-high-demand.yaml\") <pre>include:\n  - 08-untrunc-em.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.1\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml(\n    [\n        \"network/09-untrunc-em-high-demand.yaml\",\n    ]\n)\n</pre> cfg = pax.Config.from_yaml(     [         \"network/09-untrunc-em-high-demand.yaml\",     ] ) In\u00a0[5]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[6]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 2.50 seconds\n</pre> In\u00a0[7]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[10]: In\u00a0[11]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-09.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-09.xlsx\") In\u00a0[12]: Copied! <pre>import targets\n\ntarget = targets.load(9, cfg)\n</pre> import targets  target = targets.load(9, cfg) In\u00a0[13]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[14]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=False, by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=False, by_class=True) Out[19]: In\u00a0[20]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"]) Out[20]: In\u00a0[21]: Copied! <pre>comps.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"]) Out[21]: In\u00a0[22]: Copied! <pre>from passengersim.utils.targets import computed_targets\n\nc_targets = computed_targets(cfg)\n</pre> from passengersim.utils.targets import computed_targets  c_targets = computed_targets(cfg) In\u00a0[23]: Copied! <pre>contrast.fig_bookings_by_timeframe(\n    {\n        \"c_targets\": c_targets,\n        \"simulation\": summary,\n        \"target\": target,\n    },\n    by_carrier=False,\n    by_class=True,\n)\n</pre> contrast.fig_bookings_by_timeframe(     {         \"c_targets\": c_targets,         \"simulation\": summary,         \"target\": target,     },     by_carrier=False,     by_class=True, ) Out[23]:"}, {"location": "Tutorials/3MKT/3mkt-09.nbconvert.html#em-untruncation-with-high-demand", "title": "EM Untruncation with High Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Additionally, the EM algorithm is employed to detruncate censored demand. Demand is simulated at a level 10% higher than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-09.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-10.nbconvert.html", "title": "ProBP", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/10-probp.yaml\")\n</pre> show_file(\"network/10-probp.yaml\") <pre>include:\n  - 08-untrunc-em.yaml\n\nscenario: 3MKTproBP\n\ndb:\n  write_items:\n    - leg_final\n    - fare_final\n    - demand_final\n    - bookings\n    - bucket\n    - pathclass\n    - leg\n    - demand\n\nsimulation_controls:\n  num_trials: 10\n  show_progress_bar: false\n\nrm_systems:\n  rm_probp:\n    availability_control: bp\n    processes:\n      DCP:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: em\n        kind: path\n      - step_type: forecast\n        name: path_forecast\n        algorithm: additive_pickup\n        kind: path\n      - step_type: probp\n        name: optimization\n      - step_type: aggregation  # not needed for algorithm, but gives leg forecast data for output\n        name: aggregate\n\ncarriers:\n  - name: AL1\n    rm_system: rm_probp\n  - name: AL2\n    rm_system: rm_probp\n\nsnapshot_filters:\n   - type: pro_bp\n     title: ProBP Snapshot\n     sample: [120, 290, 499]\n     dcp: [63, 56, 21]\n     flt_no: 111\n     airline: AL1\n     directory: snapshots/probp\n\noutputs:\n  reports:\n    - fare_class_mix\n    - load_factors\n    - bookings_by_timeframe\n    - total_demand\n    - leg_forecasts\n    - path_forecasts\n    - [od_fare_class_mix, BOS, ORD]\n    - [od_fare_class_mix, BOS, LAX]\n    - [od_fare_class_mix, ORD, LAX]\n    - demand_to_come\n    - carrier_history\n    - bid_price_history\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml([\"network/10-probp.yaml\"])\n</pre> cfg = pax.Config.from_yaml([\"network/10-probp.yaml\"]) In\u00a0[5]: Copied! <pre>cfg.simulation_controls.num_trials = 2\n</pre> cfg.simulation_controls.num_trials = 2 In\u00a0[6]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[7]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() In\u00a0[8]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[11]: In\u00a0[12]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-10.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-10.xlsx\") In\u00a0[13]: Copied! <pre>import targets\n\ntarget = targets.load(10, cfg)\n</pre> import targets  target = targets.load(10, cfg) In\u00a0[14]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[15]: Copied! <pre>comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\") Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[19]: In\u00a0[20]: Copied! <pre>comps.fig_segmentation_by_timeframe(\"bookings\", by_carrier=\"AL1\", by_class=True, source_labels=True)\n</pre> comps.fig_segmentation_by_timeframe(\"bookings\", by_carrier=\"AL1\", by_class=True, source_labels=True) Out[20]: In\u00a0[21]: Copied! <pre>print(sim.path_names()[1])\ncomps.fig_path_forecasts(by_path_id=1, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[1]) comps.fig_path_forecasts(by_path_id=1, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path 1: BOS~ORD, (AL1:101 BOS-ORD)\n</pre> Out[21]: In\u00a0[22]: Copied! <pre>print(sim.path_names()[5])\ncomps.fig_path_forecasts(by_path_id=5, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[5]) comps.fig_path_forecasts(by_path_id=5, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path 5: ORD~LAX, (AL1:111 ORD-LAX)\n</pre> Out[22]: In\u00a0[23]: Copied! <pre>print(sim.path_names()[9])\ncomps.fig_path_forecasts(by_path_id=9, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[9]) comps.fig_path_forecasts(by_path_id=9, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path 9: BOS~LAX, (AL1:101 BOS-ORD) (AL1:111 ORD-LAX)\n</pre> Out[23]: In\u00a0[24]: Copied! <pre>comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\")\n</pre> comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\") Out[24]: In\u00a0[25]: Copied! <pre>comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\", show_stdev=1)\n</pre> comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\", show_stdev=1) Out[25]: In\u00a0[26]: Copied! <pre>from passengersim.extra.forecast_viz import fig_forecasts_and_bid_prices\n</pre> from passengersim.extra.forecast_viz import fig_forecasts_and_bid_prices In\u00a0[27]: Copied! <pre>fig_forecasts_and_bid_prices(\n    sim,\n    trial=0,\n    days_prior=63,\n    leg_id=111,\n)\n</pre> fig_forecasts_and_bid_prices(     sim,     trial=0,     days_prior=63,     leg_id=111, ) Out[27]:"}, {"location": "Tutorials/3MKT/3mkt-10.nbconvert.html#probp", "title": "ProBP\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-10.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-11.nbconvert.html", "title": "ProBP with Daily Reoptimization", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/11-probp-daily.yaml\")\n</pre> show_file(\"network/11-probp-daily.yaml\") <pre>include:\n  - 10-probp.yaml\n\nscenario: 3MKTproBP-Daily\n\nrm_systems:\n  rm_probp:\n    processes:\n      DAILY:\n        - step_type: forecastadjustment\n          algorithm: timeframe\n          kind: path\n        - step_type: probp\n          name: optimization\n\nsimulation_controls:\n  show_progress_bar: true\n\ndb:\n  write_items:\n    - leg_final\n    - fare_final\n    - demand_final\n    - bookings\n    - bucket\n    - pathclass\n    - leg\n    - demand\n    - leg_daily\n    - pathclass_daily\n\nsnapshot_filters:\n  - type: pro_bp\n    title: ProBP Snapshot\n    sample: [ 120, 290, 499 ]\n    dcp: [ 63, 56, 21 ]\n    flt_no: 111\n    airline: AL1\n    directory: snapshots/probp\n  - type: forecast_adj\n    title: Forecast Adj Snapshot\n    sample: [ 120, 290, 499 ]\n    flt_no: 111\n    airline: AL1\n    directory: snapshots/fcst-adj\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml(\"network/11-probp-daily.yaml\")\ncfg.simulation_controls.num_trials = 1\n</pre> cfg = pax.Config.from_yaml(\"network/11-probp-daily.yaml\") cfg.simulation_controls.num_trials = 1 In\u00a0[5]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[6]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 5.97 seconds\n</pre> In\u00a0[7]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[10]: In\u00a0[11]: Copied! <pre>import targets\n\ntarget = targets.load(11, cfg)\n</pre> import targets  target = targets.load(11, cfg) In\u00a0[12]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast(\n    {\n        \"simulation\": summary,\n        \"target\": target,\n    }\n)\n</pre> from passengersim import contrast  comps = contrast.Contrast(     {         \"simulation\": summary,         \"target\": target,     } ) In\u00a0[13]: Copied! <pre>comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\") Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_segmentation_by_timeframe(\"bookings\", by_carrier=\"AL1\", by_class=True, source_labels=True)\n</pre> comps.fig_segmentation_by_timeframe(\"bookings\", by_carrier=\"AL1\", by_class=True, source_labels=True) Out[18]: In\u00a0[19]: Copied! <pre>print(sim.path_names()[1])\ncomps.fig_path_forecasts(by_path_id=1, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[1]) comps.fig_path_forecasts(by_path_id=1, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path 1: BOS~ORD, (AL1:101 BOS-ORD)\n</pre> Out[19]: In\u00a0[20]: Copied! <pre>print(sim.path_names()[5])\ncomps.fig_path_forecasts(by_path_id=5, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[5]) comps.fig_path_forecasts(by_path_id=5, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path 5: ORD~LAX, (AL1:111 ORD-LAX)\n</pre> Out[20]: In\u00a0[21]: Copied! <pre>print(sim.path_names()[9])\ncomps.fig_path_forecasts(by_path_id=9, of=[\"mu\", \"sigma\", \"closed\"])\n</pre> print(sim.path_names()[9]) comps.fig_path_forecasts(by_path_id=9, of=[\"mu\", \"sigma\", \"closed\"]) <pre>Path 9: BOS~LAX, (AL1:101 BOS-ORD) (AL1:111 ORD-LAX)\n</pre> Out[21]: In\u00a0[22]: Copied! <pre>comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\")\n</pre> comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\") Out[22]: In\u00a0[23]: Copied! <pre>comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\", show_stdev=1)\n</pre> comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\", show_stdev=1) Out[23]: In\u00a0[24]: Copied! <pre>from passengersim.extra.forecast_viz import fig_forecasts_and_bid_prices\n</pre> from passengersim.extra.forecast_viz import fig_forecasts_and_bid_prices In\u00a0[25]: Copied! <pre>fig_forecasts_and_bid_prices(\n    sim,\n    trial=0,\n    days_prior=63,\n    leg_id=111,\n)\n</pre> fig_forecasts_and_bid_prices(     sim,     trial=0,     days_prior=63,     leg_id=111, ) Out[25]: In\u00a0[26]: Copied! <pre>fig_forecasts_and_bid_prices(\n    sim,\n    trial=0,\n    days_prior=63,\n    leg_id=101,\n)\n</pre> fig_forecasts_and_bid_prices(     sim,     trial=0,     days_prior=63,     leg_id=101, ) Out[26]:"}, {"location": "Tutorials/3MKT/3mkt-11.nbconvert.html#probp-with-daily-reoptimization", "title": "ProBP with Daily Reoptimization\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-11.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-50.nbconvert.html", "title": "Custom Forecaster", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> <p>We'll first run a simulation without the change as a baseline.  As this tutorial is meant as a technology demonstration and not for serious statistical analysis, we'll only run one trial so it goes fast, and we won't worry about statistical validity.</p> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(\"network/08-untrunc-em.yaml\")\ncfg.simulation_controls.num_trials = 1\n</pre> cfg = pax.Config.from_yaml(\"network/08-untrunc-em.yaml\") cfg.simulation_controls.num_trials = 1 In\u00a0[3]: Copied! <pre>sim = pax.Simulation(cfg)\nbaseline_summary = sim.run()\n</pre> sim = pax.Simulation(cfg) baseline_summary = sim.run() <pre></pre> <pre>Task Completed after 2.40 seconds\n</pre> In\u00a0[4]: Copied! <pre>baseline_summary.fig_carrier_revenues()\n</pre> baseline_summary.fig_carrier_revenues() Out[4]: <p>Now we swap in our custom forecast algorithm.</p> In\u00a0[5]: Copied! <pre>from passengersim.extra.olympic_forecast import OlympicForecastStep  # noqa: F401\n\nextra_config = \"\"\"\nrm_systems:\n  rm_test2:\n    availability_control: leg\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: olympicforecast\n      - step_type: emsr\n        algorithm: emsrb\ncarriers:\n  - name: AL1\n    rm_system: rm_test2\n  - name: AL2\n    rm_system: rm_test1\n\"\"\"\n\ncfg = pax.Config.from_yaml(\n    [\n        \"network/08-untrunc-em.yaml\",\n        extra_config,\n    ]\n)\ncfg.simulation_controls.num_trials = 1\n</pre> from passengersim.extra.olympic_forecast import OlympicForecastStep  # noqa: F401  extra_config = \"\"\" rm_systems:   rm_test2:     availability_control: leg     processes:       DCP:       - step_type: untruncation         algorithm: em         kind: leg       - step_type: olympicforecast       - step_type: emsr         algorithm: emsrb carriers:   - name: AL1     rm_system: rm_test2   - name: AL2     rm_system: rm_test1 \"\"\"  cfg = pax.Config.from_yaml(     [         \"network/08-untrunc-em.yaml\",         extra_config,     ] ) cfg.simulation_controls.num_trials = 1 In\u00a0[6]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[7]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 2.34 seconds\n</pre> In\u00a0[8]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[8]: In\u00a0[9]: Copied! <pre>from passengersim.contrast import Contrast\n\ncomp = Contrast(Baseline=baseline_summary, Olympic=summary)\n</pre> from passengersim.contrast import Contrast  comp = Contrast(Baseline=baseline_summary, Olympic=summary) In\u00a0[10]: Copied! <pre>comp.fig_carrier_revenues()\n</pre> comp.fig_carrier_revenues() Out[10]: In\u00a0[11]: Copied! <pre>comp.fig_carrier_load_factors()\n</pre> comp.fig_carrier_load_factors() Out[11]: In\u00a0[12]: Copied! <pre>comp.fig_fare_class_mix()\n</pre> comp.fig_fare_class_mix() Out[12]: In\u00a0[13]: Copied! <pre>comp.fig_segmentation_by_timeframe(\"bookings\", by_carrier=\"AL1\", by_class=True, source_labels=True)\n</pre> comp.fig_segmentation_by_timeframe(\"bookings\", by_carrier=\"AL1\", by_class=True, source_labels=True) Out[13]: In\u00a0[14]: Copied! <pre>comp.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"])\n</pre> comp.fig_leg_forecasts(by_leg_id=101, of=[\"mu\", \"sigma\"]) Out[14]: In\u00a0[15]: Copied! <pre>comp.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"])\n</pre> comp.fig_leg_forecasts(by_leg_id=111, of=[\"mu\", \"sigma\"]) Out[15]:"}, {"location": "Tutorials/3MKT/3mkt-50.nbconvert.html#custom-forecaster", "title": "Custom Forecaster\u00b6", "text": "<p>In this example, we use a custom forecast algorithm, the \"Olympic Average\", implemented in Python.  In this forecast, the mean (mu) forecast for any bucket is computed by taking the 26 historical values, discarding the highest and lowest, and taking the mean of the remaining 24 values.</p>"}, {"location": "Tutorials/3MKT/3mkt-50.nbconvert.html#comparing-results", "title": "Comparing Results\u00b6", "text": ""}, {"location": "Tutorials/3MKT/gallery/EE.nbconvert.html", "title": "Basic Simulation", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> <p>Using PassengerSim generally involves three steps: configuring a simulation, running it, and analyzing the results.  The first and last of these steps rely primarily on the open-source <code>passengersim</code> code that runs entirely in Python, while running a simulation relies on the <code>passengersim.core</code> library, which is the proprietary licensed code.</p> <p>To get started, we will load a PassengerSim configuration from YAML input files. These files are structured plain text inputs that define everything needed to run a simulation: carriers, flight legs, passenger choice models, simulation controls, and more.  The demo YAML file shown below shows how one of these YAML input files might be structured, with \"include\" statements that point to files containing much of the fundamental network configuration and a handful of specific settings can supplement or replace settings from the included files.</p> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n\nshow_file(pax.demo_network(\"3MKT/DEMO\"))\n</pre> from passengersim.utils.codeview import show_file  show_file(pax.demo_network(\"3MKT/DEMO\")) <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.0\n  num_trials: 2\n  num_samples: 400\n  burn_samples: 50\n  random_seed: 314\n\ncarriers:\n  AL1:\n    rm_system: E\n  AL2:\n    rm_system: E\n\ndb: null\n\noutputs:\n  reports: []\n</pre> <p>We can load the YAML files into a <code>Config</code> object, which will both handle loading the raw content and validating that it includes everything necessary to prepare a PassengerSim simulation.</p> In\u00a0[3]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/DEMO\"))\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/DEMO\")) <p>After loading, it's possible to modify the <code>Config</code> object in Python to change aspects of a simulation. For this example, we won't change anything here, and just create the <code>Simulation</code> object from the existing <code>Config</code>.  We can choose to create a regular <code>Simulation</code> which will run all trials and samples sequentially in a single process, or a <code>MultiSimulation</code> which will run each trial in parallel, with each trial running in a seperate subprocess.  The later option is generally much faster on multi-core computers, but detailed simulation model development or debugging can usually be done more conveniently in the single process workflow.</p> <p>Since our demo is configured to run two trials, we'll run a <code>MultiSimulation</code>.</p> In\u00a0[4]: Copied! <pre>sim = pax.MultiSimulation(cfg)\n</pre> sim = pax.MultiSimulation(cfg) <p>Running the simulation is as simple as calling the <code>run</code> command, which runs the simulation and returns a summary output object.</p> In\u00a0[5]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <p>By default, PassengerSim will generate a summary output that includes a wide variety of aggregated summary output data, which can be reviewed or visualized using an included suite of analysis tools.</p> In\u00a0[6]: Copied! <pre>summary\n</pre> summary Out[6]: <pre>&lt;passengersim.summaries.SimulationTables created on 2025-11-12&gt;\n * bid_price_history (256 row DataFrame)\n * cabins (5600 row DataFrame)\n * carriers (2 row DataFrame)\n * carrier_history (NoneType)\n * carrier_history2 (1400 row DataFrame)\n * forecast_accuracy (NoneType)\n * cp_segmentation (12 row DataFrame)\n * demand_to_come_summary (34 row DataFrame)\n * demand_to_come (NoneType)\n * demands (6 row DataFrame)\n * displacement_history (68 row DataFrame)\n * fare_class_mix (12 row DataFrame)\n * path_forecasts (NoneType)\n * leg_forecasts (NoneType)\n * edgar (NoneType)\n * legbuckets (48 row DataFrame)\n * legs (8 row DataFrame)\n * leg_detail (NoneType)\n * local_and_flow_yields (NoneType)\n * pathclasses (72 row DataFrame)\n * path_legs (16 row DataFrame)\n * paths (12 row DataFrame)\n * segmentation_by_timeframe (335 row DataFrame)\n * segmentation_detail (NoneType)\n&lt;*&gt;</pre> <p>The raw data of the summary tables shown can be accessed via direct attribute access on the <code>SimulationTables</code> object.  For example, we can see the summary data collected on the legs like this:</p> In\u00a0[7]: Copied! <pre>summary.legs\n</pre> summary.legs Out[7]: carrier flt_no orig dest distance gt_sold gt_capacity gt_sold_local gt_revenue avg_load_factor avg_local leg_id 101 AL1 101 BOS ORD 863.753282 59070 70000 24791 9.579868e+06 84.385714 41.968851 102 AL1 102 BOS ORD 863.753282 59022 70000 24830 9.620903e+06 84.317143 42.069059 201 AL2 201 BOS ORD 863.753282 59096 70000 24785 9.624332e+06 84.422857 41.940233 202 AL2 202 BOS ORD 863.753282 59088 70000 24926 9.665881e+06 84.411429 42.184538 111 AL1 111 ORD LAX 1739.799337 75043 84000 40764 2.211726e+07 89.336905 54.320856 112 AL1 112 ORD LAX 1739.799337 75141 84000 40949 2.223502e+07 89.453571 54.496214 211 AL2 211 ORD LAX 1739.799337 75223 84000 40912 2.225997e+07 89.551190 54.387621 212 AL2 212 ORD LAX 1739.799337 75193 84000 41031 2.228137e+07 89.515476 54.567579 <p>In addition to accessing the raw data, PassengerSim also has a built-in collection of visualization tools for reviewing the data.  These tools include aggregate summary figures, e.g. some figures showing carrier revenue, load factors, or RASM.</p> In\u00a0[8]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_carrier_rasm()\n</pre> summary.fig_carrier_rasm() Out[10]: <p>We can also examine more detailed slices of simulation results.  One commonly used visualization show the fare class mix across all bookings on each carrier.</p> In\u00a0[11]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[11]: <p>We can also dive deeper into this fare class data, to look not just at how many bookings are in each fare class, but also when those bookings occured and what passenger segments they came from.  The figure below clearly shows that the lower fare classes are booked almost exclusively by leisure travlers, and primarily in the early time frames.</p> In\u00a0[12]: Copied! <pre>summary.fig_bookings_by_timeframe(by_class=True, by_carrier=\"AL1\")\n</pre> summary.fig_bookings_by_timeframe(by_class=True, by_carrier=\"AL1\") Out[12]: <p>We can also do a deeper dive into the passengers on an individual leg, to look at the breakdown of their path origins and destinations, and the fare classes sold on that particular leg.</p> In\u00a0[13]: Copied! <pre>summary.fig_select_leg_analysis(101)\n</pre> summary.fig_select_leg_analysis(101) Out[13]: <p>A different perspective on the results can be seen in this figure of carrier revenue results, which are plotted sample-by-sample. Here we can see how carrier do against each other: if AL1 is having a good day, is AL2 also having a similarly good day?</p> In\u00a0[14]: Copied! <pre>summary.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\")\n</pre> summary.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\") Out[14]:"}, {"location": "Tutorials/3MKT/gallery/EE.nbconvert.html#basic-simulation", "title": "Basic Simulation\u00b6", "text": "<p>In this example, we will demonstrate some of the basics of PassengerSim. We'll interface with the tool through the <code>passengersim</code> Python interface, which is imported into Python in the same manner as any other Python library.</p>"}, {"location": "Tutorials/3MKT/gallery/LL.nbconvert.html", "title": "Unrestricted Networks", "text": "In\u00a0[1]: Copied! <pre>import altair as alt\nimport numpy as np\nimport pandas as pd\n\nimport passengersim as pax\nfrom passengersim.contrast import Contrast\n\npax.versions()\n</pre> import altair as alt import numpy as np import pandas as pd  import passengersim as pax from passengersim.contrast import Contrast  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/DEMO\"))\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/DEMO\")) <p>In this example, we will work with a completely fenceless marketplace.  To convert the typical 3MKT network into a restriction-free network, we could iterate through all the fares and remove restrictions, or we can can use some pre-packaged functions to strip the restrictions.</p> In\u00a0[3]: Copied! <pre>from passengersim.config.manipulate import strip_ap_restrictions, strip_fare_restrictions\n\ncfg = strip_fare_restrictions(cfg)\ncfg = strip_ap_restrictions(cfg)\n</pre> from passengersim.config.manipulate import strip_ap_restrictions, strip_fare_restrictions  cfg = strip_fare_restrictions(cfg) cfg = strip_ap_restrictions(cfg) <p>Now we have completely unrestricted markets.  We could run this network just like this, although we get what might be to some a surprising result...</p> In\u00a0[4]: Copied! <pre>sim = pax.MultiSimulation(cfg)\nsummary = sim.run()\nsummary.fig_carrier_revenues()\n</pre> sim = pax.MultiSimulation(cfg) summary = sim.run() summary.fig_carrier_revenues() <pre></pre> Out[4]: <p>Looking at the carrier revenues, we can see that the average revenue for each carrier is now wildly less than the $91k we saw on the restricted network.</p> <p>Looking at the fare class mix, the reason for this collapse becomes clear: both carriers are now selling exclusively Y5 tickets (the cheapest fare class). From the customers's perspective, this is perfectly reasonable -- without any restrictions, there's no reason to buy anything other than the cheapest fare available.</p> In\u00a0[5]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[5]: <p>From the carrier's perspective, clearly something is wrong.  While customers will only purchase the lowest available fare, we would expect that carriers would want to optimize their networks by sometimes making the lowest available fare not actually the lowest possible fare.</p> <p>The problem in this case is in the use of standard class-based forecasting. These forecasts assume demand for each fare class is independent, and that we can forecast the level of demand for each fare class based on the historical demand for that fare class.  But in our simulation that gets us into a catch-22: the lack of sales in higher classes results in forecasting zero demand for those higher classes, and that zero forecast means the optimizer never closes the lowest fare class to try to save space for higher class customers (because it thinks there aren't any).</p> <p>To solve this problem, we need to use a different kind of forecast, which accounts for the propensity for at least some customers to buy up to a higher fare class if the class they prefer is closed.  The RM system \"L\" uses the same leg-based optimizer as \"E\", but instead of using standard forecasting it switches to conditional forecasting, which relaxes the independent demands by fare class assumption, and instead assumes that customers who purchase the lowest available fare are \"priceable\" customers, and that some fraction of those customers will still buy if the fare were higher.  This fraction changes over the booking horizon, with generally lower fractions for early bookings and higher fractions for late bookings; how large that fraction is and how it changes over time is decribed by a \"Frat5 curve\", which we will ascribe to each carrier.</p> In\u00a0[6]: Copied! <pre>cfg.carriers.AL1.rm_system = \"L\"\ncfg.carriers.AL2.rm_system = \"L\"\ncfg.carriers.AL1.frat5 = \"curve_C\"\ncfg.carriers.AL2.frat5 = \"curve_C\"\n\nsim2 = pax.MultiSimulation(cfg)\nsummary2 = sim2.run()\n\ncomp2 = Contrast(E=summary, L=summary2)\n</pre> cfg.carriers.AL1.rm_system = \"L\" cfg.carriers.AL2.rm_system = \"L\" cfg.carriers.AL1.frat5 = \"curve_C\" cfg.carriers.AL2.frat5 = \"curve_C\"  sim2 = pax.MultiSimulation(cfg) summary2 = sim2.run()  comp2 = Contrast(E=summary, L=summary2) <pre></pre> In\u00a0[7]: Copied! <pre>comp2.fig_carrier_revenues()\n</pre> comp2.fig_carrier_revenues() Out[7]: In\u00a0[8]: Copied! <pre>comp2.fig_fare_class_mix()\n</pre> comp2.fig_fare_class_mix() Out[8]: In\u00a0[9]: Copied! <pre>comp2.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comp2.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[9]: <p>The use of the conditional forecaster introduces a much larger universe of possible options to chose from for simulated carriers. Some of these options are highly consequential, and others are less so.</p> <p>For example, we can consider choosing among various Frat5 curves, which control the assumed levels of sellup across the booking curve.  The available \"standard\" curves look like this:</p> In\u00a0[10]: Copied! <pre># load all standard frat5 curves in a PassengerSim config\nstd_frat5 = pax.Config.from_yaml(pax.demo_network(\"standard-frat5.yaml\"))\n\n# convert to a dataframe for analysis\ndf = pd.concat(\n    {\n        curvename: pd.Series(std_frat5.frat5_curves[curvename].curve, name=\"frat5_value\")\n        for curvename in std_frat5.frat5_curves\n    },\n    axis=0,\n    names=[\"curve_name\", \"days_prior\"],\n).reset_index()\n\n# plot using Altair\nalt.Chart(df).mark_line().encode(\n    x=alt.X(\"days_prior\", sort=\"descending\"),\n    y=alt.Y(\"frat5_value\", scale=alt.Scale(domain=[1, 4])),\n    color=\"curve_name\",\n    tooltip=[\"curve_name\", \"days_prior\", \"frat5_value\"],\n).properties(title=\"Standard Frat5 Curves\")\n</pre> # load all standard frat5 curves in a PassengerSim config std_frat5 = pax.Config.from_yaml(pax.demo_network(\"standard-frat5.yaml\"))  # convert to a dataframe for analysis df = pd.concat(     {         curvename: pd.Series(std_frat5.frat5_curves[curvename].curve, name=\"frat5_value\")         for curvename in std_frat5.frat5_curves     },     axis=0,     names=[\"curve_name\", \"days_prior\"], ).reset_index()  # plot using Altair alt.Chart(df).mark_line().encode(     x=alt.X(\"days_prior\", sort=\"descending\"),     y=alt.Y(\"frat5_value\", scale=alt.Scale(domain=[1, 4])),     color=\"curve_name\",     tooltip=[\"curve_name\", \"days_prior\", \"frat5_value\"], ).properties(title=\"Standard Frat5 Curves\") Out[10]: <p>We can assign to AL1 a different Frat5 curve, to change the rate at which the forecast predicts buy-up.</p> In\u00a0[11]: Copied! <pre>cfg.carriers.AL1.frat5 = \"curve_E\"\n\nsim3 = pax.MultiSimulation(cfg)\nsummary3 = sim3.run()\n\ncomp3 = Contrast(curve_C=summary2, curve_E=summary3)\ncomp3.fig_carrier_revenues()\n</pre> cfg.carriers.AL1.frat5 = \"curve_E\"  sim3 = pax.MultiSimulation(cfg) summary3 = sim3.run()  comp3 = Contrast(curve_C=summary2, curve_E=summary3) comp3.fig_carrier_revenues() <pre></pre> Out[11]: <p>Apparently, we've made things substantially worse for AL1 with this change. Perhaps moving in the other direction would be more helpful</p> In\u00a0[12]: Copied! <pre>cfg.carriers.AL1.frat5 = \"curve_A\"\n\nsim4 = pax.MultiSimulation(cfg)\nsummary4 = sim4.run()\n\ncomp4 = Contrast(curve_E=summary3, curve_C=summary2, curve_A=summary4)\ncomp4.fig_carrier_revenues()\n</pre> cfg.carriers.AL1.frat5 = \"curve_A\"  sim4 = pax.MultiSimulation(cfg) summary4 = sim4.run()  comp4 = Contrast(curve_E=summary3, curve_C=summary2, curve_A=summary4) comp4.fig_carrier_revenues() <pre></pre> Out[12]: <p>Looks like using \"curve_A\" for AL1 gives the best revenue result.  We can also look at how the fare class mix changes with the various curves.</p> In\u00a0[13]: Copied! <pre>comp4.fig_fare_class_mix()\n</pre> comp4.fig_fare_class_mix() Out[13]: <p>It is interesting to note here how the results are also changing for AL2. This is expected; since PassengerSim is simulating the entire competitive environment, it is to be expected that other carriers can see changes in their results even if they don't change their own RM strategies.</p> <p>The head-to-head revenue figure can show us some details about when the Frat5 curve matter most.  Spoiler alert: it's the higher demand days.</p> In\u00a0[14]: Copied! <pre>summary4.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\", mean_adjusted=False)\n</pre> summary4.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\", mean_adjusted=False) Out[14]:"}, {"location": "Tutorials/3MKT/gallery/LL.nbconvert.html#unrestricted-networks", "title": "Unrestricted Networks\u00b6", "text": "<p>In the modern day market place, many carriers find themselves operating in much less restricted markets, where they cannot rely on imposing fare fences or restrictions to entice higher willingness-to-pay customers to purchase high price tickets.</p>"}, {"location": "Tutorials/3MKT/gallery/PE.nbconvert.html", "title": "ProBP Optimization", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> <p>Just as in the previous example, we begin by loading the network configuration from YAML input files.</p> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/DEMO\"))\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/DEMO\")) <p>For this simulation, however, we don't want to just use the all the inputs exactly as loaded from our demo config files. In order to change the RM system for AL1, we can assign a new named system to the <code>rm_system</code> attribute for that carrier:</p> In\u00a0[3]: Copied! <pre>cfg.carriers.AL1.rm_system = \"P\"\n</pre> cfg.carriers.AL1.rm_system = \"P\" <p>The ProBP RM system is one of the standard RM systems available for use in PassengerSim, so this is all that's needed to use it. But for this example, we're also going to explore some of the \"options\" that can be set on many of the pre-configured RM systems. For the ProBP system, one of the options is the use of a bid price vector, instead of a fixed daily bid price.  For our first look at this system, we'll turn off the bid price vector, like this:</p> In\u00a0[4]: Copied! <pre>cfg.carriers.AL1.rm_system_options = {\"bid_price_vector\": False}\n</pre> cfg.carriers.AL1.rm_system_options = {\"bid_price_vector\": False} <p>Now that we've finished modifying our configuration, we can use it to create and run a simulation</p> In\u00a0[5]: Copied! <pre>sim = pax.MultiSimulation(cfg)\nsummary = sim.run()\n</pre> sim = pax.MultiSimulation(cfg) summary = sim.run() <pre></pre> <p>We can then review some of the same reports as the previous example, to get an idea of the benefit of using the path-based ProBP system instead of the leg-based EMSR-B.</p> In\u00a0[6]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[6]: <p>Since the 3MKT network is perfectly symmetric (both AL1 and AL2 have identical flight legs with identical schedules and capacities in every possible market) when both carriers were running the \"E\" system we saw average revenues that were neck-and-neck at $90.75k.  Now with AL1  running \"P\", we see average revenues on that carrier have gone up  almost 1%, to $91.52.</p> In\u00a0[7]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[7]: <p>We also see a change in load factors, with AL1 achieving those improved revenue numbers while also having a slightly lower average load factor.</p> In\u00a0[8]: Copied! <pre>summary.fig_carrier_rasm()\n</pre> summary.fig_carrier_rasm() Out[8]: <p>The revenue per available seat mile follows the same pattern as the top line revenue number (as it must -- we have not changed the \"ASM\" denominator).</p> In\u00a0[9]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[9]: <p>In the fare class mix, we can see that AL1 is achieving these results by cutting back on seats sold to the lower fare classes, leaving more room for the higher revenue fare classes who tend to book closer to departure.</p> In\u00a0[10]: Copied! <pre>summary.fig_bookings_by_timeframe(by_class=True, by_carrier=\"AL1\")\n</pre> summary.fig_bookings_by_timeframe(by_class=True, by_carrier=\"AL1\") Out[10]: <p>The head-to-head revenue figure can give us a little more insight into why the path-based algorithm performs better.  When we looked at this figure for the E vs E simulation, the cloud of simulation results was clearly symmetric around the red \"even\" line: on busy days or slow days, the two carriers tended to do better or worse together, with the likelihood of AL1 or AL2 coming out ahead being more or less a coin flip no matter what the overall demand looked like on any sampled day.</p> In\u00a0[11]: Copied! <pre>summary.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\")\n</pre> summary.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\") Out[11]: <p>The story is different in the figure above: there is a distinct bias visible in the point cloud relative to the red \"balanced\" line. On slow days, both carriers tend to end up with less revenue than average but AL2 is typically takes a smaller hit than AL1.  But on busier days, which in this simulation are more frequent than slow days, AL1 tends to benefit more.</p> In\u00a0[12]: Copied! <pre>cfg.carriers.AL1.rm_system_options = {\"bid_price_vector\": True}\nsim2 = pax.MultiSimulation(cfg)\nsummary2 = sim2.run()\n</pre> cfg.carriers.AL1.rm_system_options = {\"bid_price_vector\": True} sim2 = pax.MultiSimulation(cfg) summary2 = sim2.run() <pre></pre> <p>We can compare two simulation runs using PassengerSim's <code>Contrast</code> tools.</p> In\u00a0[13]: Copied! <pre>from passengersim.contrast import Contrast\n\ncomp = Contrast({\"w/o BP Vector\": summary, \"with BP Vector\": summary2})\n</pre> from passengersim.contrast import Contrast  comp = Contrast({\"w/o BP Vector\": summary, \"with BP Vector\": summary2}) <p>Variants of many of the visualizations we've already seen are available for the <code>Contrast</code> class, including for comparing carrier summary statistics like revenue and load factor.</p> In\u00a0[14]: Copied! <pre>comp.fig_carrier_revenues()\n</pre> comp.fig_carrier_revenues() Out[14]: <p>It appears that AL1 is able to squeeze out even more revenue by using the bid price vector.</p> In\u00a0[15]: Copied! <pre>comp.fig_carrier_load_factors()\n</pre> comp.fig_carrier_load_factors() Out[15]: <p>Unlike the switch from E to P, which resulted in more revenue but lower load factors, the addition of the bid price vector now results in more revenue and higher load factors.</p> <p>To understand what is happening a little bit more, we can examine the bid price history figure.</p> In\u00a0[16]: Copied! <pre>comp.fig_bid_price_history(by_carrier=\"AL1\")\n</pre> comp.fig_bid_price_history(by_carrier=\"AL1\") Out[16]: <p>This figure shows that when we turn on the bid price vector, the average bid prices for legs operated by AL1 tend to run a little bit lower across most of the booking horizon, but run much higher in the final few days before departure.</p>"}, {"location": "Tutorials/3MKT/gallery/PE.nbconvert.html#probp-optimization", "title": "ProBP Optimization\u00b6", "text": "<p>In this example, we will look at the benefits of using a path-based RM system.  We will use PassengerSim to simulate the same demo network as the previous example, except we will have one of the carriers using ProBP instead of EMSR-B.</p>"}, {"location": "Tutorials/3MKT/gallery/PE.nbconvert.html#using-the-bid-price-vector", "title": "Using the Bid Price Vector\u00b6", "text": "<p>Earlier, we turned off the bid price vector option for ProBP. Let's turn it back on and see what happens.</p>"}, {"location": "Tutorials/3MKT/gallery/QC.nbconvert.html", "title": "Q Forecasting", "text": "In\u00a0[1]: Copied! <pre>from textwrap import fill\n\nimport numpy as np\nimport pandas as pd\n\nimport passengersim as pax\n\npax.versions()\n</pre> from textwrap import fill  import numpy as np import pandas as pd  import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\"))\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\")) <p>In this example, we will work with a completely fenceless marketplace.  To convert the typical 3MKT network into a restriction-free network, we can use a tool to strip the restrictions.</p> In\u00a0[3]: Copied! <pre>from passengersim.config.manipulate import strip_all_restrictions\n\ncfg = strip_all_restrictions(cfg)\n</pre> from passengersim.config.manipulate import strip_all_restrictions  cfg = strip_all_restrictions(cfg) <pre>\n---------------------------------------------------------------------------\nImportError                               Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 from passengersim.config.manipulate import strip_all_restrictions\n      3 cfg = strip_all_restrictions(cfg)\n\nImportError: cannot import name 'strip_all_restrictions' from 'passengersim.config.manipulate' (/Users/jpn/Git/umbrella/passengersim-public/passengersim/config/manipulate.py)</pre> In\u00a0[\u00a0]: Copied! <pre>cfg.carriers.AL1.rm_system = \"Q\"\ncfg.carriers.AL2.rm_system = \"C\"\n</pre> cfg.carriers.AL1.rm_system = \"Q\" cfg.carriers.AL2.rm_system = \"C\" <p>We need to revalidate the congfiguration to be able to view or modify the RM system definitions prior to initializing the simulation.</p> In\u00a0[\u00a0]: Copied! <pre>cfg = cfg.model_revalidate()\n</pre> cfg = cfg.model_revalidate() In\u00a0[\u00a0]: Copied! <pre>print(fill(cfg.rm_systems.Q.description))\n</pre> print(fill(cfg.rm_systems.Q.description)) In\u00a0[\u00a0]: Copied! <pre>print(fill(cfg.rm_systems.C.description))\n</pre> print(fill(cfg.rm_systems.C.description)) In\u00a0[\u00a0]: Copied! <pre>cfg.simulation_controls.num_trials = 1\ncfg.simulation_controls.num_samples = 600\n</pre> cfg.simulation_controls.num_trials = 1 cfg.simulation_controls.num_samples = 600 In\u00a0[\u00a0]: Copied! <pre>sim = pax.Simulation(cfg)\nsummary = sim.run()\n</pre> sim = pax.Simulation(cfg) summary = sim.run() In\u00a0[\u00a0]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() In\u00a0[\u00a0]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() In\u00a0[\u00a0]: Copied! <pre>summary.fig_carrier_rasm()\n</pre> summary.fig_carrier_rasm() In\u00a0[\u00a0]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() In\u00a0[\u00a0]: Copied! <pre>summary.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\")\n</pre> summary.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\") In\u00a0[\u00a0]: Copied! <pre>cfg2 = cfg.model_copy(deep=True)\ndel cfg2.rm_systems.Q.processes.dcp.q_untruncation\n</pre> cfg2 = cfg.model_copy(deep=True) del cfg2.rm_systems.Q.processes.dcp.q_untruncation In\u00a0[\u00a0]: Copied! <pre>summary2 = pax.Simulation(cfg2).run()\n</pre> summary2 = pax.Simulation(cfg2).run() In\u00a0[\u00a0]: Copied! <pre>summary2.fig_carrier_revenues()\n</pre> summary2.fig_carrier_revenues() In\u00a0[\u00a0]: Copied! <pre>summary2.fig_carrier_load_factors()\n</pre> summary2.fig_carrier_load_factors() In\u00a0[\u00a0]: Copied! <pre>summary2.fig_carrier_rasm()\n</pre> summary2.fig_carrier_rasm() In\u00a0[\u00a0]: Copied! <pre>summary2.fig_fare_class_mix()\n</pre> summary2.fig_fare_class_mix() In\u00a0[\u00a0]: Copied! <pre>summary2.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\")\n</pre> summary2.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\") In\u00a0[\u00a0]: Copied! <pre>cfg3 = cfg.model_copy(deep=True)\ncfg3.carriers.AL1.rm_system = \"F\"\ncfg3.carriers.AL2.rm_system = \"M\"\n</pre> cfg3 = cfg.model_copy(deep=True) cfg3.carriers.AL1.rm_system = \"F\" cfg3.carriers.AL2.rm_system = \"M\" In\u00a0[\u00a0]: Copied! <pre>cfg3 = cfg3.model_revalidate()\n</pre> cfg3 = cfg3.model_revalidate() In\u00a0[\u00a0]: Copied! <pre>print(fill(cfg3.rm_systems.F.description))\n</pre> print(fill(cfg3.rm_systems.F.description)) In\u00a0[\u00a0]: Copied! <pre>print(fill(cfg3.rm_systems.M.description))\n</pre> print(fill(cfg3.rm_systems.M.description)) In\u00a0[\u00a0]: Copied! <pre>sim3 = pax.Simulation(cfg3)\nsummary3 = sim3.run()\n</pre> sim3 = pax.Simulation(cfg3) summary3 = sim3.run() In\u00a0[\u00a0]: Copied! <pre>summary3.fig_carrier_revenues()\n</pre> summary3.fig_carrier_revenues() In\u00a0[\u00a0]: Copied! <pre>summary3.fig_carrier_load_factors()\n</pre> summary3.fig_carrier_load_factors() In\u00a0[\u00a0]: Copied! <pre>summary3.fig_carrier_rasm()\n</pre> summary3.fig_carrier_rasm() In\u00a0[\u00a0]: Copied! <pre>summary3.fig_fare_class_mix()\n</pre> summary3.fig_fare_class_mix() In\u00a0[\u00a0]: Copied! <pre>summary3.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\")\n</pre> summary3.fig_carrier_head_to_head_revenue(\"AL1\", \"AL2\")"}, {"location": "Tutorials/3MKT/gallery/QC.nbconvert.html#q-forecasting", "title": "Q Forecasting\u00b6", "text": ""}, {"location": "Tutorials/3MKT/gallery/QC.nbconvert.html#without-priceable-detruncation", "title": "Without Priceable Detruncation\u00b6", "text": "<p>We can remove the detruncation of priceable demand from the Q system, and re-evaluate to see the difference.</p>"}, {"location": "Tutorials/3MKT/gallery/QC.nbconvert.html#applying-fare-adjustment", "title": "Applying Fare Adjustment\u00b6", "text": ""}, {"location": "Tutorials/3MKT/gallery/hybrid-cond-forecasting.nbconvert.html", "title": "Hybrid Conditional Forecasting", "text": "In\u00a0[1]: Copied! <pre>import altair as alt\nimport numpy as np\nimport pandas as pd\n\nimport passengersim as pax\nfrom passengersim.experiments import Experiments\n\npax.versions()\n</pre> import altair as alt import numpy as np import pandas as pd  import passengersim as pax from passengersim.experiments import Experiments  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/DEMO\"))\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/DEMO\")) In\u00a0[3]: Copied! <pre>experiments = Experiments(cfg, output_dir=\"temp\")\n</pre> experiments = Experiments(cfg, output_dir=\"temp\") In\u00a0[4]: Copied! <pre>@experiments\ndef EE(cfg: pax.Config) -&gt; pax.Config:\n    return cfg\n\n\n@experiments\ndef LE(cfg: pax.Config) -&gt; pax.Config:\n    cfg.carriers.AL1.rm_system = \"L\"\n    cfg.carriers.AL1.rm_system_options = {}\n    cfg.carriers.AL1.frat5 = \"curve_C\"\n    return cfg\n\n@experiments\ndef ME(cfg: pax.Config) -&gt; pax.Config:\n    cfg.carriers.AL1.rm_system = \"M\"\n    cfg.carriers.AL1.rm_system_options = {}\n    cfg.carriers.AL1.frat5 = \"curve_C\"\n    return cfg\n</pre> @experiments def EE(cfg: pax.Config) -&gt; pax.Config:     return cfg   @experiments def LE(cfg: pax.Config) -&gt; pax.Config:     cfg.carriers.AL1.rm_system = \"L\"     cfg.carriers.AL1.rm_system_options = {}     cfg.carriers.AL1.frat5 = \"curve_C\"     return cfg  @experiments def ME(cfg: pax.Config) -&gt; pax.Config:     cfg.carriers.AL1.rm_system = \"M\"     cfg.carriers.AL1.rm_system_options = {}     cfg.carriers.AL1.frat5 = \"curve_C\"     return cfg   In\u00a0[5]: Copied! <pre>result = experiments.run(write_report=False, use_existing=False)\n</pre> result = experiments.run(write_report=False, use_existing=False) <pre></pre> In\u00a0[6]: Copied! <pre>result.fig_carrier_revenues()\n</pre> result.fig_carrier_revenues() Out[6]: In\u00a0[7]: Copied! <pre>result.fig_carrier_load_factors()\n</pre> result.fig_carrier_load_factors() Out[7]: In\u00a0[8]: Copied! <pre>result.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> result.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[8]:"}, {"location": "Tutorials/3MKT/gallery/hybrid-cond-forecasting.nbconvert.html#hybrid-conditional-forecasting", "title": "Hybrid Conditional Forecasting\u00b6", "text": ""}, {"location": "Tutorials/3MKT/gallery/intro-3mkt.nbconvert.html", "title": "The 3MKT Network", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/DEMO\"))\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/DEMO\")) <p>This network, as its name suggests, includes a simulation of ... three markets, where each market is defined by an origin-destination pair:</p> <ul> <li>Boston BOS to Chicago ORD,</li> <li>Chicago ORD to Los Angeles LAX, and</li> <li>Boston BOS to Los Angeles LAX.</li> </ul> <p>Each market has some market demand that consists of potential passengers, who would like to travel from the origin to the destination on a simulated day. That demand is composed of two passenger segments: business and leisure.</p> In\u00a0[3]: Copied! <pre>from passengersim.config.dataframes import demands_to_dataframe\n\ndemands_to_dataframe(cfg.demands)\n</pre> from passengersim.config.dataframes import demands_to_dataframe  demands_to_dataframe(cfg.demands) Out[3]: orig dest segment base_demand reference_fare distance choice_model dwm_tolerance todd_curve curve group_sizes prob_saturday_night prob_num_days deterministic 0 BOS ORD business 70.0 250.0 863.753282 business 0.0 None c1 None False [] False 1 BOS ORD leisure 90.0 100.0 863.753282 leisure 0.0 None c2 None False [] False 2 ORD LAX business 120.0 375.0 1739.799337 business 0.0 None c1 None False [] False 3 ORD LAX leisure 150.0 150.0 1739.799337 leisure 0.0 None c2 None False [] False 4 BOS LAX business 100.0 500.0 2603.449105 business 0.0 None c1 None False [] False 5 BOS LAX leisure 140.0 200.0 2603.449105 leisure 0.0 None c2 None False [] False In\u00a0[4]: Copied! <pre>cfg.demands\n</pre> cfg.demands Out[4]: <pre>[Demand(orig='BOS', dest='ORD', segment='business', base_demand=70.0, reference_fare=250.0, distance=863.7532821438833, choice_model='business', dwm_tolerance=0.0, todd_curve=None, curve='c1', group_sizes=None, prob_saturday_night=False, prob_num_days=[], deterministic=False, overrides=[]),\n Demand(orig='BOS', dest='ORD', segment='leisure', base_demand=90.0, reference_fare=100.0, distance=863.7532821438833, choice_model='leisure', dwm_tolerance=0.0, todd_curve=None, curve='c2', group_sizes=None, prob_saturday_night=False, prob_num_days=[], deterministic=False, overrides=[]),\n Demand(orig='ORD', dest='LAX', segment='business', base_demand=120.0, reference_fare=375.0, distance=1739.79933695373, choice_model='business', dwm_tolerance=0.0, todd_curve=None, curve='c1', group_sizes=None, prob_saturday_night=False, prob_num_days=[], deterministic=False, overrides=[]),\n Demand(orig='ORD', dest='LAX', segment='leisure', base_demand=150.0, reference_fare=150.0, distance=1739.79933695373, choice_model='leisure', dwm_tolerance=0.0, todd_curve=None, curve='c2', group_sizes=None, prob_saturday_night=False, prob_num_days=[], deterministic=False, overrides=[]),\n Demand(orig='BOS', dest='LAX', segment='business', base_demand=100.0, reference_fare=500.0, distance=2603.4491052979865, choice_model='business', dwm_tolerance=0.0, todd_curve=None, curve='c1', group_sizes=None, prob_saturday_night=False, prob_num_days=[], deterministic=False, overrides=[]),\n Demand(orig='BOS', dest='LAX', segment='leisure', base_demand=140.0, reference_fare=200.0, distance=2603.4491052979865, choice_model='leisure', dwm_tolerance=0.0, todd_curve=None, curve='c2', group_sizes=None, prob_saturday_night=False, prob_num_days=[], deterministic=False, overrides=[])]</pre> <p>Customers from these two segments have quite different purchase preferences, and arrive to book seats (or walk away without a booking) with quite different time distributions.</p> In\u00a0[5]: Copied! <pre>cfg.fig_booking_curves()\n</pre> cfg.fig_booking_curves() Out[5]: <p>Each of these markets is served by two carriers, who fly identical schedules. Each carrier offers two flights per day from BOS to ORD, and two more from ORD to LAX.</p> In\u00a0[6]: Copied! <pre>from passengersim.config.dataframes import legs_to_dataframe\n\nlegs_to_dataframe(cfg.legs)\n</pre> from passengersim.config.dataframes import legs_to_dataframe  legs_to_dataframe(cfg.legs) Out[6]: leg_id orig dest orig_timezone dest_timezone carrier distance capacity date dep_time arr_time dep_time_offset arr_time_offset time_adjusted dep_hour_local arr_hour_local duration_minutes 0 101 BOS ORD America/New_York America/Chicago AL1 863.753282 100 2020-03-01 00:00:00+00:00 1583067600 1583078400 -18000 -21600 True 8.0 10.0 180.0 1 102 BOS ORD America/New_York America/Chicago AL1 863.753282 100 2020-03-01 00:00:00+00:00 1583089200 1583100000 -18000 -21600 True 14.0 16.0 180.0 2 201 BOS ORD America/New_York America/Chicago AL2 863.753282 100 2020-03-01 00:00:00+00:00 1583067600 1583078400 -18000 -21600 True 8.0 10.0 180.0 3 202 BOS ORD America/New_York America/Chicago AL2 863.753282 100 2020-03-01 00:00:00+00:00 1583089200 1583100000 -18000 -21600 True 14.0 16.0 180.0 4 111 ORD LAX America/Chicago America/Los_Angeles AL1 1739.799337 120 2020-03-01 00:00:00+00:00 1583082000 1583096400 -21600 -28800 True 11.0 13.0 240.0 5 112 ORD LAX America/Chicago America/Los_Angeles AL1 1739.799337 120 2020-03-01 00:00:00+00:00 1583103600 1583118000 -21600 -28800 True 17.0 19.0 240.0 6 211 ORD LAX America/Chicago America/Los_Angeles AL2 1739.799337 120 2020-03-01 00:00:00+00:00 1583082000 1583096400 -21600 -28800 True 11.0 13.0 240.0 7 212 ORD LAX America/Chicago America/Los_Angeles AL2 1739.799337 120 2020-03-01 00:00:00+00:00 1583103600 1583118000 -21600 -28800 True 17.0 19.0 240.0 In\u00a0[7]: Copied! <pre>cfg.fig_route_map()\n</pre> cfg.fig_route_map() Out[7]: <p>Each carrier offers six fare classes in each market, labeled as \"Y0\" through \"Y5\". The prices and restrictions imposed are consistent across the carriers within each market.</p> In\u00a0[8]: Copied! <pre>from passengersim.config.dataframes import fares_to_dataframe\n\nfares_to_dataframe(cfg.fares)\n</pre> from passengersim.config.dataframes import fares_to_dataframe  fares_to_dataframe(cfg.fares) Out[8]: carrier orig dest booking_class price advance_purchase restrictions category cabin min_stay saturday_night_required 0 AL1 BOS ORD Y0 400.0 0 None Y 0 False 1 AL1 BOS ORD Y1 300.0 0 R2 None Y 0 False 2 AL1 BOS ORD Y2 200.0 3 R1 None Y 0 False 3 AL1 BOS ORD Y3 150.0 7 R1|R2 None Y 0 False 4 AL1 BOS ORD Y4 125.0 14 R1|R3 None Y 0 False 5 AL1 BOS ORD Y5 100.0 21 R1|R2|R3 None Y 0 False 6 AL1 ORD LAX Y0 500.0 0 None Y 0 False 7 AL1 ORD LAX Y1 400.0 0 R2 None Y 0 False 8 AL1 ORD LAX Y2 300.0 3 R1 None Y 0 False 9 AL1 ORD LAX Y3 225.0 7 R1|R2 None Y 0 False 10 AL1 ORD LAX Y4 175.0 14 R1|R3 None Y 0 False 11 AL1 ORD LAX Y5 150.0 21 R1|R2|R3 None Y 0 False 12 AL1 BOS LAX Y0 750.0 0 None Y 0 False 13 AL1 BOS LAX Y1 625.0 0 R2 None Y 0 False 14 AL1 BOS LAX Y2 450.0 3 R1 None Y 0 False 15 AL1 BOS LAX Y3 325.0 7 R1|R2 None Y 0 False 16 AL1 BOS LAX Y4 250.0 14 R1|R3 None Y 0 False 17 AL1 BOS LAX Y5 200.0 21 R1|R2|R3 None Y 0 False 18 AL2 BOS ORD Y0 400.0 0 None Y 0 False 19 AL2 BOS ORD Y1 300.0 0 R2 None Y 0 False 20 AL2 BOS ORD Y2 200.0 3 R1 None Y 0 False 21 AL2 BOS ORD Y3 150.0 7 R1|R2 None Y 0 False 22 AL2 BOS ORD Y4 125.0 14 R1|R3 None Y 0 False 23 AL2 BOS ORD Y5 100.0 21 R1|R2|R3 None Y 0 False 24 AL2 ORD LAX Y0 500.0 0 None Y 0 False 25 AL2 ORD LAX Y1 400.0 0 R2 None Y 0 False 26 AL2 ORD LAX Y2 300.0 3 R1 None Y 0 False 27 AL2 ORD LAX Y3 225.0 7 R1|R2 None Y 0 False 28 AL2 ORD LAX Y4 175.0 14 R1|R3 None Y 0 False 29 AL2 ORD LAX Y5 150.0 21 R1|R2|R3 None Y 0 False 30 AL2 BOS LAX Y0 750.0 0 None Y 0 False 31 AL2 BOS LAX Y1 625.0 0 R2 None Y 0 False 32 AL2 BOS LAX Y2 450.0 3 R1 None Y 0 False 33 AL2 BOS LAX Y3 325.0 7 R1|R2 None Y 0 False 34 AL2 BOS LAX Y4 250.0 14 R1|R3 None Y 0 False 35 AL2 BOS LAX Y5 200.0 21 R1|R2|R3 None Y 0 False"}, {"location": "Tutorials/3MKT/gallery/intro-3mkt.nbconvert.html#the-3mkt-network", "title": "The 3MKT Network\u00b6", "text": "<p>PassengerSim includes a demo network called three market and commonly written as \"3MKT\".</p>"}, {"location": "Tutorials/3MKT/gallery/olympic-fcst.nbconvert.html", "title": "Custom Forecaster", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> <p>We'll first run a simulation without the change as a baseline.  As this tutorial is meant as a technology demonstration and not for serious statistical analysis, we'll only run a small sample so it goes fast, and we won't worry about statistical validity.</p> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/DEMO\"))\ncfg.simulation_controls.num_samples = 150\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/DEMO\")) cfg.simulation_controls.num_samples = 150 In\u00a0[3]: Copied! <pre>sim = pax.MultiSimulation(cfg)\nbaseline_summary = sim.run()\n</pre> sim = pax.MultiSimulation(cfg) baseline_summary = sim.run() <pre></pre> In\u00a0[4]: Copied! <pre>baseline_summary.fig_carrier_revenues()\n</pre> baseline_summary.fig_carrier_revenues() Out[4]: <p>Now we'll write our custom RM system.  This is going to be done in two parts: first, we will write our custom forecast algorithm as a <code>RmAction</code>. Then we'll define a <code>RmSys</code> that uses that custom forecast algorithm.</p> In\u00a0[5]: Copied! <pre>from passengersim.rm import RmAction\n\n\nclass OlympicForecast(RmAction):\n    \"\"\"\n    In this step, we use a custom forecast algorithm, the \"Olympic Average\",\n    implemented in Python.  In this forecast, the mean (mu) forecast for any\n    bucket is computed by taking the 26 historical values, discarding the highest\n    and lowest, and taking the mean of the remaining 24 values.\n\n    This forecaster is meant primarily as a technology demonstration for how\n    to implement a custom RM step in Python.\n    \"\"\"\n\n    requires: set[str] = {\"leg_demand\"}\n    produces: set[str] = {\"leg_forecast\"}\n    frequency = \"dcp\"\n\n    def run(self, sim: pax.Simulation, days_prior: int):\n        if not self.should_run(sim, days_prior):\n            return\n        dcp_index = self.get_dcp_index(days_prior)\n        for leg in sim.eng.legs.set_filters(carrier=self.carrier):\n            for bkt in leg.buckets:\n                # get historic demand, for all recorded departures and remaining TFs\n                history = bkt.forecast.get_detruncated_demand_array()[:, dcp_index:]\n                # sum historic demand to come over all remaining time periods\n                hdtc = history.sum(1)\n                # compute average pickup excluding min and max\n                avg_pickup = (hdtc.sum() - hdtc.max() - hdtc.min()) / (hdtc.size - 2)\n                # set forecast mean excluding outliers\n                bkt.fcst_mean = avg_pickup\n                # compute standard dev as normal, including outliers\n                bkt.fcst_std_dev = history.std()\n</pre> from passengersim.rm import RmAction   class OlympicForecast(RmAction):     \"\"\"     In this step, we use a custom forecast algorithm, the \"Olympic Average\",     implemented in Python.  In this forecast, the mean (mu) forecast for any     bucket is computed by taking the 26 historical values, discarding the highest     and lowest, and taking the mean of the remaining 24 values.      This forecaster is meant primarily as a technology demonstration for how     to implement a custom RM step in Python.     \"\"\"      requires: set[str] = {\"leg_demand\"}     produces: set[str] = {\"leg_forecast\"}     frequency = \"dcp\"      def run(self, sim: pax.Simulation, days_prior: int):         if not self.should_run(sim, days_prior):             return         dcp_index = self.get_dcp_index(days_prior)         for leg in sim.eng.legs.set_filters(carrier=self.carrier):             for bkt in leg.buckets:                 # get historic demand, for all recorded departures and remaining TFs                 history = bkt.forecast.get_detruncated_demand_array()[:, dcp_index:]                 # sum historic demand to come over all remaining time periods                 hdtc = history.sum(1)                 # compute average pickup excluding min and max                 avg_pickup = (hdtc.sum() - hdtc.max() - hdtc.min()) / (hdtc.size - 2)                 # set forecast mean excluding outliers                 bkt.fcst_mean = avg_pickup                 # compute standard dev as normal, including outliers                 bkt.fcst_std_dev = history.std() <p>Now we have our custom forecaster. But this isn't a whole RM system; we still need to handle demand untruncation before we do forecasting, and then to have some kind of optimizer that will do something with the forecasts.  For these other things, we'll draw from PassengerSim's standard library of RM components to build a complete RM system.</p> In\u00a0[6]: Copied! <pre>from passengersim.rm import RmSys, register_rm_system\nfrom passengersim.rm.emsr import ExpectedMarginalSeatRevenue\nfrom passengersim.rm.untruncation import LegUntruncation\n\n\n@register_rm_system\nclass Olympic(RmSys):\n    \"\"\"A custom RM system using Olympic Average forecasting.\"\"\"\n\n    availability_control = \"leg\"\n    \"\"\"This RM system uses leg-level class allocation availability controls.\"\"\"\n\n    actions = [\n        LegUntruncation,\n        OlympicForecast,\n        ExpectedMarginalSeatRevenue,\n    ]\n</pre> from passengersim.rm import RmSys, register_rm_system from passengersim.rm.emsr import ExpectedMarginalSeatRevenue from passengersim.rm.untruncation import LegUntruncation   @register_rm_system class Olympic(RmSys):     \"\"\"A custom RM system using Olympic Average forecasting.\"\"\"      availability_control = \"leg\"     \"\"\"This RM system uses leg-level class allocation availability controls.\"\"\"      actions = [         LegUntruncation,         OlympicForecast,         ExpectedMarginalSeatRevenue,     ] <p>The last thing to do is to actually assign this system to a carrier who will use it. The <code>register_rm_system</code> reads the name of the class that it is decorating, and makes that class available as a named RM system that you can use in configs.</p> In\u00a0[7]: Copied! <pre>cfg.carriers.AL1.rm_system = \"Olympic\"\n</pre> cfg.carriers.AL1.rm_system = \"Olympic\" <p>Now we're ready to run, and see what chaos we have wrought.</p> In\u00a0[8]: Copied! <pre>sim = pax.MultiSimulation(cfg)\nsummary = sim.run()\n</pre> sim = pax.MultiSimulation(cfg) summary = sim.run() <pre></pre> In\u00a0[9]: Copied! <pre>from passengersim.contrast import Contrast\n\ncomp = Contrast(Baseline=baseline_summary, Olympic=summary)\ncomp.fig_carrier_revenues()\n</pre> from passengersim.contrast import Contrast  comp = Contrast(Baseline=baseline_summary, Olympic=summary) comp.fig_carrier_revenues() Out[9]: <p>Taking a look at the revenue results, we see that the Olympic forecaster has turned in less than record settings revenues.  This is a small sample, so we shouldn't necessarily read a whole lot into this result, but we can at least say it's not looking promising at this point.  We can take a look through some of the other output reports to see if anything stands out to us as good or bad.</p> In\u00a0[10]: Copied! <pre>comp.fig_carrier_load_factors()\n</pre> comp.fig_carrier_load_factors() Out[10]: In\u00a0[11]: Copied! <pre>comp.fig_fare_class_mix()\n</pre> comp.fig_fare_class_mix() Out[11]: In\u00a0[12]: Copied! <pre>comp.fig_segmentation_by_timeframe(\"bookings\", by_carrier=\"AL1\", by_class=True, source_labels=True)\n</pre> comp.fig_segmentation_by_timeframe(\"bookings\", by_carrier=\"AL1\", by_class=True, source_labels=True) Out[12]: <p>The other thing we may want to keep in mind is runtime. Even on this tiny network and with a tiny number of samples, the custom RM system takes noticably longer to run.</p> In\u00a0[13]: Copied! <pre>baseline_summary.metadata(\"time.runtime\"), summary.metadata(\"time.runtime\")\n</pre> baseline_summary.metadata(\"time.runtime\"), summary.metadata(\"time.runtime\") Out[13]: <pre>(2.0357649326324463, 2.7809760570526123)</pre> <p>Customization is great as it adds lots of flexibility to the system, but it's not completely free. Passing data into Python for the custom tools, and processing that data in a Python environment is typically a bit (or sometimes a lot) slower than running the same mathematical algorithms in well optimized C/C++ code.  To maximize the speed that the Simulator runs, users should generally use RM actions from PassengerSim's standard library whenever possible.</p>"}, {"location": "Tutorials/3MKT/gallery/olympic-fcst.nbconvert.html#custom-forecaster", "title": "Custom Forecaster\u00b6", "text": "<p>In this example, we use a custom forecast algorithm, the \"Olympic Average\", implemented in Python.  In this forecast, the mean (mu) forecast for any bucket is computed by taking the 26 historical values, discarding the highest and lowest, and taking the mean of the remaining 24 values.</p> <p>Do try this at home -- but not at work</p> <p> We're not suggesting this is a great idea, it's merely a straightforward idea that we can use to demostrate how to implement a custom RM action in PassengerSim. </p>"}, {"location": "Tutorials/3MKT/gallery/olympic-fcst.nbconvert.html#comparing-results", "title": "Comparing Results\u00b6", "text": ""}, {"location": "user-guide/cli.html", "title": "Command Line Interface", "text": "<p>AirSim Command Line Interface</p> <p>Usage:</p> <pre><code>$ python -m AirSim [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>info</code></li> <li><code>run</code></li> </ul>"}, {"location": "user-guide/cli.html#python-m-airsim-info", "title": "<code>python -m AirSim info</code>", "text": "<p>Usage:</p> <pre><code>$ python -m AirSim info [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul>"}, {"location": "user-guide/cli.html#python-m-airsim-run", "title": "<code>python -m AirSim run</code>", "text": "<p>Usage:</p> <pre><code>$ python -m AirSim run [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>-n, --network-file PATH</code>: A file that defines the network and various simulation options.  [required]</li> <li><code>-a, --airports-file PATH</code>: A file that defines the airports used in the simulation.</li> <li><code>-o, --out-dir PATH</code>: Out files are written to this directory.</li> <li><code>--db-engine TEXT</code>: [default: sqlite]</li> <li><code>--db-filename TEXT</code>: Use this filename for the output database file. Applies to the the SQLite engine only.  [default: airsim-output.sqlite]</li> <li><code>--fast / --slow</code>: For the SQLite engine only, running in 'fast' mode will store everything in an in-memory first, and dump the entire database to disk only when the simulation is complete.  This can be quite advantageous when the write speed of the disk is slow.  [default: slow]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"}, {"location": "user-guide/dynamic-config.nbconvert.html", "title": "Dynamic Configuration", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> <p>Let's start by loading our demo model from its YAML files into a PassengerSim <code>Config</code> object.</p> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/08-untrunc-em\"))\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/08-untrunc-em\")) <p>The <code>cfg</code> now holds the data that defines everything about the simulation that will be run, including the carriers, RM systems, networks, ... everything.  Before we use this config to initialize a simulation, we can inspect and even modify it in Python.  For example, let's take a look at the flight legs in this network.</p> In\u00a0[3]: Copied! <pre>cfg.legs\n</pre> cfg.legs Out[3]: <pre>[Leg(leg_id=None, carrier='AL1', fltno=101, orig='BOS', orig_timezone='America/New_York', dest='ORD', dest_timezone='America/Chicago', date=datetime.datetime(2020, 3, 1, 0, 0, tzinfo=datetime.timezone.utc), arr_day=0, dep_time=1583067600, dep_time_offset=-18000, arr_time=1583078400, arr_time_offset=-21600, time_adjusted=True, capacity=100, distance=863.7532821438833),\n Leg(leg_id=None, carrier='AL1', fltno=102, orig='BOS', orig_timezone='America/New_York', dest='ORD', dest_timezone='America/Chicago', date=datetime.datetime(2020, 3, 1, 0, 0, tzinfo=datetime.timezone.utc), arr_day=0, dep_time=1583089200, dep_time_offset=-18000, arr_time=1583100000, arr_time_offset=-21600, time_adjusted=True, capacity=100, distance=863.7532821438833),\n Leg(leg_id=None, carrier='AL2', fltno=201, orig='BOS', orig_timezone='America/New_York', dest='ORD', dest_timezone='America/Chicago', date=datetime.datetime(2020, 3, 1, 0, 0, tzinfo=datetime.timezone.utc), arr_day=0, dep_time=1583067600, dep_time_offset=-18000, arr_time=1583078400, arr_time_offset=-21600, time_adjusted=True, capacity=100, distance=863.7532821438833),\n Leg(leg_id=None, carrier='AL2', fltno=202, orig='BOS', orig_timezone='America/New_York', dest='ORD', dest_timezone='America/Chicago', date=datetime.datetime(2020, 3, 1, 0, 0, tzinfo=datetime.timezone.utc), arr_day=0, dep_time=1583089200, dep_time_offset=-18000, arr_time=1583100000, arr_time_offset=-21600, time_adjusted=True, capacity=100, distance=863.7532821438833),\n Leg(leg_id=None, carrier='AL1', fltno=111, orig='ORD', orig_timezone='America/Chicago', dest='LAX', dest_timezone='America/Los_Angeles', date=datetime.datetime(2020, 3, 1, 0, 0, tzinfo=datetime.timezone.utc), arr_day=0, dep_time=1583082000, dep_time_offset=-21600, arr_time=1583096400, arr_time_offset=-28800, time_adjusted=True, capacity=120, distance=1739.79933695373),\n Leg(leg_id=None, carrier='AL1', fltno=112, orig='ORD', orig_timezone='America/Chicago', dest='LAX', dest_timezone='America/Los_Angeles', date=datetime.datetime(2020, 3, 1, 0, 0, tzinfo=datetime.timezone.utc), arr_day=0, dep_time=1583103600, dep_time_offset=-21600, arr_time=1583118000, arr_time_offset=-28800, time_adjusted=True, capacity=120, distance=1739.79933695373),\n Leg(leg_id=None, carrier='AL2', fltno=211, orig='ORD', orig_timezone='America/Chicago', dest='LAX', dest_timezone='America/Los_Angeles', date=datetime.datetime(2020, 3, 1, 0, 0, tzinfo=datetime.timezone.utc), arr_day=0, dep_time=1583082000, dep_time_offset=-21600, arr_time=1583096400, arr_time_offset=-28800, time_adjusted=True, capacity=120, distance=1739.79933695373),\n Leg(leg_id=None, carrier='AL2', fltno=212, orig='ORD', orig_timezone='America/Chicago', dest='LAX', dest_timezone='America/Los_Angeles', date=datetime.datetime(2020, 3, 1, 0, 0, tzinfo=datetime.timezone.utc), arr_day=0, dep_time=1583103600, dep_time_offset=-21600, arr_time=1583118000, arr_time_offset=-28800, time_adjusted=True, capacity=120, distance=1739.79933695373)]</pre> <p>We can see here a list of legs, and each leg has all the attributes needed to define it in the simulation: origin, destination, departure and arrival times, capacity, and more. We can manipulate these attributes if we like.  Let's make the capacity on that first leg a little larger.</p> In\u00a0[4]: Copied! <pre>cfg.legs[0].capacity = 180\n</pre> cfg.legs[0].capacity = 180 <p>We can do the same and peek in on the network fares.</p> In\u00a0[5]: Copied! <pre>cfg.fares\n</pre> cfg.fares Out[5]: <pre>[Fare(carrier='AL1', orig='BOS', dest='ORD', booking_class='Y0', price=400.0, advance_purchase=0, restrictions=[], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='BOS', dest='ORD', booking_class='Y1', price=300.0, advance_purchase=0, restrictions=['R2'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='BOS', dest='ORD', booking_class='Y2', price=200.0, advance_purchase=3, restrictions=['R1'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='BOS', dest='ORD', booking_class='Y3', price=150.0, advance_purchase=7, restrictions=['R1', 'R2'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='BOS', dest='ORD', booking_class='Y4', price=125.0, advance_purchase=14, restrictions=['R1', 'R3'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='BOS', dest='ORD', booking_class='Y5', price=100.0, advance_purchase=21, restrictions=['R1', 'R2', 'R3'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='ORD', dest='LAX', booking_class='Y0', price=500.0, advance_purchase=0, restrictions=[], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='ORD', dest='LAX', booking_class='Y1', price=400.0, advance_purchase=0, restrictions=['R2'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='ORD', dest='LAX', booking_class='Y2', price=300.0, advance_purchase=3, restrictions=['R1'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='ORD', dest='LAX', booking_class='Y3', price=225.0, advance_purchase=7, restrictions=['R1', 'R2'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='ORD', dest='LAX', booking_class='Y4', price=175.0, advance_purchase=14, restrictions=['R1', 'R3'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='ORD', dest='LAX', booking_class='Y5', price=150.0, advance_purchase=21, restrictions=['R1', 'R2', 'R3'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='BOS', dest='LAX', booking_class='Y0', price=750.0, advance_purchase=0, restrictions=[], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='BOS', dest='LAX', booking_class='Y1', price=625.0, advance_purchase=0, restrictions=['R2'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='BOS', dest='LAX', booking_class='Y2', price=450.0, advance_purchase=3, restrictions=['R1'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='BOS', dest='LAX', booking_class='Y3', price=325.0, advance_purchase=7, restrictions=['R1', 'R2'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='BOS', dest='LAX', booking_class='Y4', price=250.0, advance_purchase=14, restrictions=['R1', 'R3'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL1', orig='BOS', dest='LAX', booking_class='Y5', price=200.0, advance_purchase=21, restrictions=['R1', 'R2', 'R3'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='BOS', dest='ORD', booking_class='Y0', price=400.0, advance_purchase=0, restrictions=[], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='BOS', dest='ORD', booking_class='Y1', price=300.0, advance_purchase=0, restrictions=['R2'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='BOS', dest='ORD', booking_class='Y2', price=200.0, advance_purchase=3, restrictions=['R1'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='BOS', dest='ORD', booking_class='Y3', price=150.0, advance_purchase=7, restrictions=['R1', 'R2'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='BOS', dest='ORD', booking_class='Y4', price=125.0, advance_purchase=14, restrictions=['R1', 'R3'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='BOS', dest='ORD', booking_class='Y5', price=100.0, advance_purchase=21, restrictions=['R1', 'R2', 'R3'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='ORD', dest='LAX', booking_class='Y0', price=500.0, advance_purchase=0, restrictions=[], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='ORD', dest='LAX', booking_class='Y1', price=400.0, advance_purchase=0, restrictions=['R2'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='ORD', dest='LAX', booking_class='Y2', price=300.0, advance_purchase=3, restrictions=['R1'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='ORD', dest='LAX', booking_class='Y3', price=225.0, advance_purchase=7, restrictions=['R1', 'R2'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='ORD', dest='LAX', booking_class='Y4', price=175.0, advance_purchase=14, restrictions=['R1', 'R3'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='ORD', dest='LAX', booking_class='Y5', price=150.0, advance_purchase=21, restrictions=['R1', 'R2', 'R3'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='BOS', dest='LAX', booking_class='Y0', price=750.0, advance_purchase=0, restrictions=[], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='BOS', dest='LAX', booking_class='Y1', price=625.0, advance_purchase=0, restrictions=['R2'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='BOS', dest='LAX', booking_class='Y2', price=450.0, advance_purchase=3, restrictions=['R1'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='BOS', dest='LAX', booking_class='Y3', price=325.0, advance_purchase=7, restrictions=['R1', 'R2'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='BOS', dest='LAX', booking_class='Y4', price=250.0, advance_purchase=14, restrictions=['R1', 'R3'], category=None, cabin='Y', min_stay=0, saturday_night_required=False),\n Fare(carrier='AL2', orig='BOS', dest='LAX', booking_class='Y5', price=200.0, advance_purchase=21, restrictions=['R1', 'R2', 'R3'], category=None, cabin='Y', min_stay=0, saturday_night_required=False)]</pre> <p>There are a lot of fares for our tiny little network.  Perhaps we don't want to edit them one at a time. We can do a little Python programming to modify fares all at once according to some logic.  We put a bigger plane on one of AL1's Boston to Chicago legs, so let's lower their fares in that market a smidge to help fill that plane.</p> In\u00a0[6]: Copied! <pre>for f in cfg.fares:\n    if f.carrier == \"AL1\" and f.orig == \"BOS\" and f.dest == \"ORD\":\n        f.price -= 5.0\n</pre> for f in cfg.fares:     if f.carrier == \"AL1\" and f.orig == \"BOS\" and f.dest == \"ORD\":         f.price -= 5.0 <p>Not all our changes need to be about the network; we can also manipulate the settings for the simulation itself.  Our modified network is just a small experiment, we we don't need to sit around waiting for a statistically useful number of samples to run. Let's cut way back so our simulation runs faster.</p> In\u00a0[7]: Copied! <pre>cfg.simulation_controls.num_trials = 2\ncfg.simulation_controls.num_samples = 200\n</pre> cfg.simulation_controls.num_trials = 2 cfg.simulation_controls.num_samples = 200 <p>Now that we've modified our <code>cfg</code> all we want, we can use it to initialize a simulation to run.</p> In\u00a0[8]: Copied! <pre>sim = pax.Simulation(cfg)\nsummary = sim.run()\n</pre> sim = pax.Simulation(cfg) summary = sim.run() <pre></pre> <pre>Task Completed after 1.90 seconds\n</pre> <p>Having run the simulation, we can take a quick peek at the results.</p> In\u00a0[9]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_carrier_rasm()\n</pre> summary.fig_carrier_rasm() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[11]:"}, {"location": "user-guide/dynamic-config.nbconvert.html#dynamic-configuration", "title": "Dynamic Configuration\u00b6", "text": "<p>Most of the time, we are not actually interested in just running a simulation that we've pre-configured in files on disk. Instead, we will want to load a simulation from pre-configured in files on disk, but then change a couple things before we run it.  Perhaps we're debugging a new RM system, and want to just run a few iterations to see if it works.  Or maybe we have a model mostly ready to go, but we want to modify a couple of RM system parameters, or change the level of demand, or just monkey around with the network schedule a bit.</p> <p>We can do all of that and more, right here in Python, especially in a Jupyter notebook.</p>"}, {"location": "user-guide/experiments.nbconvert.html", "title": "Experiments", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> <p>The experimentation starts with a base config.</p> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/08-untrunc-em\"))\ncfg.simulation_controls.num_trials = 1\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/08-untrunc-em\")) cfg.simulation_controls.num_trials = 1 <p>Then, we create an <code>Experiments</code> object, which will manage our set of experiments somewhat automatically. This object takes our baseline config as an argument, as well as allows us to set a directory where all experimental output will be stored.</p> In\u00a0[4]: Copied! <pre>from passengersim.experiments import Experiments\n\nexperiments = Experiments(cfg, output_dir=\"demo-output\")\n</pre> from passengersim.experiments import Experiments  experiments = Experiments(cfg, output_dir=\"demo-output\") <p>Now we can define one or more experiments, although as you'll see quickly, the real power of this interface comes when there is more than one experiment.</p> <p>Each experiment is defined by a function that accepts a Config as an argument, and returns a possibly modified Config.  Within this function, you can make any modifications desired: changing simulation controls, swapping out revenue management systems for one or more carriers, or even changing the network structure itself.  Each experiment function is prefixed by the experiments object as decorator, and each should have a unique function name that will be used to identify it.</p> In\u00a0[5]: Copied! <pre>@experiments\ndef baseline(cfg: pax.Config) -&gt; pax.Config:\n    return cfg\n\n\n@experiments\ndef low_dmd(cfg: pax.Config) -&gt; pax.Config:\n    cfg.simulation_controls.demand_multiplier = 0.9\n    return cfg\n\n\n@experiments\ndef high_dmd(cfg):\n    cfg.simulation_controls.demand_multiplier = 1.1\n    return cfg\n</pre> @experiments def baseline(cfg: pax.Config) -&gt; pax.Config:     return cfg   @experiments def low_dmd(cfg: pax.Config) -&gt; pax.Config:     cfg.simulation_controls.demand_multiplier = 0.9     return cfg   @experiments def high_dmd(cfg):     cfg.simulation_controls.demand_multiplier = 1.1     return cfg <p>Finally, we can run all the experiments as a batch using the <code>run</code> command on the <code>Experiments</code> object.</p> In\u00a0[6]: Copied! <pre>summaries = experiments.run()\n</pre> summaries = experiments.run() <pre></pre> <p>The return value from this batch run is a passengersim <code>Contrast</code> object, which can be used to review the results interactively in a Jupyter notebook.</p> In\u00a0[7]: Copied! <pre>summaries.fig_carrier_revenues()\n</pre> summaries.fig_carrier_revenues() Out[7]: In\u00a0[8]: Copied! <pre>summaries.fig_fare_class_mix()\n</pre> summaries.fig_fare_class_mix() Out[8]: <p>When we ran the experiments, the <code>demo-output</code> directory was populated with outputs from each experiment, including a pickle file storing the summary results, as well as an HTML output file that includes key figures and metadata describing the results from that experiment.</p> In\u00a0[9]: Copied! <pre>from passengersim.utils.show_dir import display_directory_contents\n\ndisplay_directory_contents(\"demo-output\")\n</pre> from passengersim.utils.show_dir import display_directory_contents  display_directory_contents(\"demo-output\") <pre>demo-output/\n  high_dmd/\n    passengersim_output.20251112-090433.html\n    passengersim_output.20251112-090433.pxsim\n  low_dmd/\n    passengersim_output.20251112-090428.html\n    passengersim_output.20251112-090428.pxsim\n  experiments-summary.20251112-090433.html\n  baseline/\n    passengersim_output.20251112-090424.pxsim\n    passengersim_output.20251112-090424.html\n</pre> <p>We can change an existing experiment explicitly by writing a new experiment with the same tag, or implicitly by editing the Jupyter notebook and re-running the entire notebook.  Here, we will just edit one experiment by overwriting it (note we do get a warning when we do this).</p> In\u00a0[10]: Copied! <pre>@experiments\ndef high_dmd(cfg):  # noqa: F811\n    cfg.simulation_controls.demand_multiplier = 1.2\n    return cfg\n</pre> @experiments def high_dmd(cfg):  # noqa: F811     cfg.simulation_controls.demand_multiplier = 1.2     return cfg <pre>/var/folders/l1/yt63lf3n60b1dc25d_y2d1q80000gn/T/ipykernel_93232/1986293878.py:1: UserWarning: Overwriting existing experiment tag: high_dmd\n  @experiments\n</pre> <p>If we now re-run the set of experiments, PassengerSim will detect that some of the experiments are have been run already, and not re-run them in favor of simply reloading from disk.  The loaded results configurations are compared against the experiment configuration, to confirm it is still the same.  For the first two experiments, this is the case and the simulation is not re-run.  The change we made in the last experiment is detected, and the loaded results are then discarded in favor of re-running the simulation.</p> In\u00a0[11]: Copied! <pre>summaries2 = experiments.run()\n</pre> summaries2 = experiments.run() <pre></pre> In\u00a0[12]: Copied! <pre>summaries2.fig_carrier_revenues()\n</pre> summaries2.fig_carrier_revenues() Out[12]: In\u00a0[13]: Copied! <pre>summaries2.fig_fare_class_mix()\n</pre> summaries2.fig_fare_class_mix() Out[13]: <p>If we inspect the <code>demo-output</code> directory, we will see that the results from the old experiment are still available if needed, but they are timestamped so we can clearly identify them as older.</p> In\u00a0[14]: Copied! <pre>display_directory_contents(\"demo-output\")\n</pre> display_directory_contents(\"demo-output\") <pre>demo-output/\n  high_dmd/\n    passengersim_output.20251112-090433.html\n    passengersim_output.20251112-090433.pxsim\n  experiments-summary.20251112-090434.html\n  low_dmd/\n    passengersim_output.20251112-090428.html\n    passengersim_output.20251112-090428.pxsim\n  experiments-summary.20251112-090433.html\n  baseline/\n    passengersim_output.20251112-090424.pxsim\n    passengersim_output.20251112-090424.html\n</pre> <p>We can write out a report of the experiments, which contains a variety of standard outputs.</p> In\u00a0[15]: Copied! <pre>out_file = summaries2.write_report(\"demo-output/meta-summary.html\", base_config=cfg)\n</pre> out_file = summaries2.write_report(\"demo-output/meta-summary.html\", base_config=cfg) In\u00a0[16]: Copied! <pre>from passengersim.utils.iframe import preview_html\n\npreview_html(out_file)\n</pre> from passengersim.utils.iframe import preview_html  preview_html(out_file)"}, {"location": "user-guide/experiments.nbconvert.html#experiments", "title": "Experiments\u00b6", "text": "<p>The experiments interface allows the user to easily run and compare a number of different scenarios.</p>"}, {"location": "user-guide/how-it-works.html", "title": "How PassengerSim Works", "text": "<p>PasengerSim is a tool that simulates several aspects of passenger travel, including airline revenue management operations, market level passenger demand, and individual customer choice processes.</p>"}, {"location": "user-guide/how-it-works.html#counting-simulations", "title": "Counting Simulations", "text": "<p>A simulation run consists of a number of independent trials, and each trial is made up of a sequence of dependent samples -- earlier samples in a trial are used to develop forecasts and train optimization algorithms used by carriers in later samples of the same trial.</p> <p>The number of trials is set by the <code>num_trials</code> configuration, and the number of samples in each trial is set by <code>num_samples</code>. Both values can be found in the <code>simulation_controls</code> configuration inputs.</p> <p>We can think of a sample as a \"typical\" departure day.  When generating results, the first X samples from each trial as these are during a \"burn period\" when the simulation is getting started and sufficient history is being generated to use for forecasts and other steps.  The nuber of samples in the burn period is set by the <code>burn_samples</code> configuration value.</p>"}, {"location": "user-guide/how-it-works.html#simulation-randomness", "title": "Simulation Randomness", "text": ""}, {"location": "user-guide/how-it-works.html#demand-generation-k-factors", "title": "Demand Generation K-Factors", "text": "<p>There are multiple sources of variability that is introduced in the simulation. Variability in the level of demand by passenger type on any given day for any origin-destination pair is controlled by a number of k-factors, which are used to create some correlation across various dimensions of demand.</p> <p>Three k-factors are used to introduce correlation in demand across all markets in the system and between business/leisure demand within a market. The equation to generate the mean demand for a given market and passenger type is given as:</p> <p>\\(\\mu'_{OD-Biz} = \\mu_{OD-Biz} + (SRN \\times k_{sys}) + (MRN \\times k_{mkt}) + (PRN \\times k_{paxtype})\\)</p> <p>where SRN, MRN, and PRN are random numbers associated with the system, market, and passenger k-factors, respectively.</p> <p>The intuition behind using three k-factors is that even across a \"typical\" departure day (like Wednesdays) we may have high demand days across the system and low demand days across the system.  Likewise, if business demand is above average, we expect that leisure demand may also be above average. Intuitively, when generating demands, for a given sample (or departure day in the simulation), we add the term (SRN x <code>sys_k_factor</code>) to every single market and passenger in the system for that departure day, we add a unique (MRN x <code>mkt_k_factor</code>) to each origin-destination market in the sample, and we add a unique (PRN x <code>pax_type_k_factor</code>) for each passenger type within the market. The addition of the (SRN x <code>sys_k_factor</code>) to \"everything\" in the sample creates a system-level correlation (i.e., demand on a given departure date or sample could be \"high\" across the system or \"low\" compared to average).</p> <p>The addition of the (MRN x <code>mkt_k_factor</code>) to a market creates a market-level correlation (i.e., if business demand is running higher than average in the market, we expect leisure demand will run higher than average in general as well).</p> <p>The use of the (PRN x <code>pax_type_k_factor</code>) ensures that there is some random component that is independent between business and leisure passengers in a given market.</p> <p>In addition to the k-factors that are used to introduce correlation, we have a z-factor. We assume that actual demand, given mean demand, will vary across samples (or departure dates) according to a constant z-factor given as \\(\\mu\\) divided by \\(\\sigma^2\\).</p> <p>Given different levels of aggregation, we expect that <code>sys_k_factor</code> &lt; <code>mkt_k_factor</code> &lt; <code>pax_type_k_factor</code>.</p> <p>Once we generate the means and std dev for correlated demands by OD and pax type using the methodology described above, we use these to generate the \u201cactual\u201d demands for a sample using the equation</p> <p>\\(\\mu'_{OD-Biz} + NRV x \\sigma'_{OD-Biz}\\),</p> <p>where NRV is a normal random variable.</p>"}, {"location": "user-guide/how-it-works.html#demand-allocation-to-time-periods", "title": "Demand Allocation to Time Periods", "text": "<p>The demand generation above is used to find the total demand for each passenger type in each market on each travel day.  This total value is subsequently distributed over the booking time periods.</p> <p>While the methodology for this is not (yet) explained here, note that the <code>tf_k_factor</code> is used to generate variability in how demand is allocated to the different time frames (also using the booking curves as a key input).</p>"}, {"location": "user-guide/installation.html", "title": "Installation", "text": "<pre><code>PassengerSim is currently available only for Mac and Linux operating systems.\nSupport for other operating systems is not planned for the near future.\n</code></pre>"}, {"location": "user-guide/installation.html#before-you-begin-install-conda-if-needed", "title": "Before you begin: install <code>conda</code> if needed", "text": "<p>PassengerSim is a Python package that is most easily installed in an environment managed by <code>conda</code>.  To check if you have <code>conda</code> installed, open a terminal and type <code>conda --version</code>.  If you see a version number, you have <code>conda</code>.</p> <p>If you have <code>conda</code>, but with an outdated version (i.e. less than 24), you can update it by running <code>conda update conda</code>.</p> <p>If you don't have <code>conda</code>, you can install it by pasting the following command into your terminal:</p> <pre><code>curl -L -O https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-$(uname)-$(uname -m).sh\nbash Miniforge3-$(uname)-$(uname -m).sh\n</code></pre>"}, {"location": "user-guide/installation.html#installing-passengersim", "title": "Installing PassengerSim", "text": "<p>If you have received a file named something like <code>install-passengersim-mac-v0.0-20240101.sh</code>, you can use it to install PassengerSim in a conda environment.  To do so, open a terminal and navigate to the directory where the file is located.  Then, run the following command:</p> <pre><code>bash install-passengersim-mac-v0.0-20240101.sh\n</code></pre> <p>Tip</p> <p>Don't copy-paste the command above, as the exact filename of the installation script will vary based on the version of PassengerSim and the release data.  Instead, use the filename of the file you have received.</p>"}, {"location": "user-guide/installation.html#changing-the-conda-environment-name", "title": "Changing the conda environment name", "text": "<p>The default install will put PassengerSim in a conda environment named <code>SKY</code>.  If you already have a conda environment named <code>SKY</code>, the installation script will update the environment to the relevant version of PassengerSim.  If you prefer to install PassengerSim in a different environment (e.g. <code>myenv</code>), you can specify the environment name as an argument to the installation script:</p> <pre><code>bash install-passengersim-mac-v0.0-20240101.sh -n myenv\n</code></pre>"}, {"location": "user-guide/installation.html#running-passengersim", "title": "Running PassengerSim", "text": "<p>After the installation is complete, you can start a Jupyter Lab session from the environment by running the following command:</p> <pre><code>conda run -n SKY jupyter lab\n</code></pre> <p>If you installed PassengerSim in an environment named something other than <code>SKY</code>, replace <code>SKY</code> in the command above with the name of the environment you used.</p>"}, {"location": "user-guide/installation.html#alternative-installation-docker", "title": "Alternative Installation: Docker", "text": "<p>Do you have a link to a <code>sky</code> docker image file? If not, these are not the install instructions you are looking for. If you do have a link, go ahead and download the file.  If you are installing on Windows or an Intel-based Mac, you want the amd64 image.  For installing on more recent Apple Silicon-based Macs, use an arm64 image.</p> <p>In addition to the image file, you'll want to download and install Docker Desktop for your computer.  Once it's installed, make sure it's running (you should be able to open and see Docker's dashboard).</p> <p>Then, open a console terminal and change to the directory where the docker image <code>sky.tar</code> file has been saved.  It might be named something slightly different from <code>sky.tar</code>, in which case change the filename in the commands you type to match the filename of the image file you have.  The first step is to run</p> <pre><code>docker load --input sky.tar\n</code></pre> <p>This command may take a few moments to complete, as the content of the downloaded image file will be imported into docker.  You'll need several free gigabytes of hard disk space to complete this step, so if you encounter unexplained EOF errors here that may be the problem.</p> <p>After the docker image is loaded, you should see a <code>sky</code> image in the docker desktop dashboard.  If you can see it, you should then be able to start a container with this image using the following command:</p> Mac/LinuxWindows <pre><code>docker run -p 8899:8899 --rm --volume \"$(pwd)\":/tmp/workplace/work sky:latest\n</code></pre> <pre><code>docker run -p 8899:8899 --rm --volume \"%cd%\":/tmp/workplace/work sky:latest\n</code></pre> <p>Within this command, we have:</p> <ul> <li><code>-p 8899:8899</code> tells docker to expose the container's port 8899 (which has been   configured to be the port served by Jupyter Lab) to localhost.</li> <li><code>--rm</code> means to remove the container when it exits, so there isn't an   extraneous container image file left on your file system.</li> <li><code>--volume \"...\":/tmp/workplace/work</code> makes the current working directory   available inside Jupyter Lab in a directory named <code>work</code> (the container has   been configured with <code>/tmp/workplace</code> as the base location for Jupyter).</li> <li><code>sky:latest</code> tells Docker to use the latest version of the user image   that was installed in the <code>docker load</code> step above.  If your installed   docker image (as shown in the Docker Dashboard) has a different name than   <code>sky</code> then change the command to give the corrent image name.</li> </ul>"}, {"location": "user-guide/untruncation.html", "title": "Untruncation", "text": "<p>Write a description of this concept here.</p>"}, {"location": "user-guide/writing-configs.html", "title": "Config Files", "text": "<p>Most control of the simulation is done via configuration files written in YAML format.</p>"}, {"location": "user-guide/writing-configs.html#simulation-controls", "title": "Simulation Controls", "text": "<pre><code>scenario: Three Market Test Network\nsimulation_controls:\n  random_seed: 42\n  num_trials: 1\n  num_samples: 300\n  sys_k_factor: 0.1\n  mkt_k_factor: 0.2\n  pax_type_k_factor: 0.4\n  tf_k_factor: 0.1\n  tot_z_factor: 2.0\n  tf_z_factor: 2.0\n  prorate_revenue: true\n  dwm_lite: false\n  max_connect_time: 120\n  disable_ap: false\n  demand_multiplier: 1.0\n  manual_paths: true\n</code></pre>"}, {"location": "user-guide/writing-configs.html#rm-systems", "title": "RM Systems", "text": "<p>The <code>rm_systems</code> key allows the user to define one or more revenue management systems that may be used by carriers.</p> <p>These systems can either be defined as a list, where each item in the list defines both a name and steps, or you can write the same instruction as a nested mapping, with the names as keys and the values giving the other attributes of each RM system, (for now, just a list of steps) like this:</p> as listas dict <p><pre><code>rm_systems:\n- name: rm_test1\n  steps:\n  - step_type: untruncation  #(1)!\n    name: untruncation\n    algorithm: em\n    kind: leg\n  - step_type: forecast\n    name: forecast\n    algorithm: exp_smoothing\n    alpha: 0.1\n    kind: leg\n  - step_type: optimization\n    name: optimization\n    algorithm: emsrb  #(2)!\n    kind: leg\n</code></pre></p> <ol> <li> Untruncation allows us to figure out how much demand was censored.</li> <li>If you define different RM systems, you can attach different optimization algorithms, such as     ProBP.</li> </ol> <p><pre><code>rm_systems:\n  rm_test1:\n    steps:\n    - step_type: untruncation  #(1)!\n      name: untruncation\n      algorithm: em\n      kind: leg\n    - step_type: forecast\n      name: forecast\n      algorithm: exp_smoothing\n      alpha: 0.1\n      kind: leg\n    - step_type: optimization\n      name: optimization\n      algorithm: emsrb  #(2)!\n      kind: leg\n</code></pre></p> <ol> <li> Untruncation allows us to figure out how much demand was censored.</li> <li>If you define different RM systems, you can attach different optimization algorithms, such as     ProBP.</li> </ol>"}, {"location": "user-guide/writing-configs.html#passenger-choice-models", "title": "Passenger Choice Models", "text": "<pre><code>choice_models:\n  business:\n    kind: pods\n    emult: 1.6\n    basefare_mult: 2.5\n    path_quality:  [38.30,  0.10]\n    airline_pref_pods:  [-12.29,  0.17]\n    tolerance: 2.0\n    r1: 0.30\n    r2: 0.10\n    r3: 0.20\n    r4: 0.15\n  leisure:\n    kind: pods\n    emult: 1.5\n    basefare_mult: 1.0\n    path_quality:  [2.02, 0.12]\n    airline_pref_pods:  [-1.98, 0.11]\n    tolerance: 5.0\n    r1: 0.30\n    r2: 0.15\n    r3: 0.25\n    r4: 0.20\n</code></pre>"}, {"location": "user-guide/writing-configs.html#define-carriers", "title": "Define Carriers", "text": "<pre><code>carriers:\n- name: AL1\n  rm_system: rm_test1\n- name: AL2\n  rm_system: rm_test1\n- name: AL3\n  rm_system: rm_test1\n- name: AL4\n  rm_system: rm_test1\n</code></pre>"}, {"location": "user-guide/writing-configs.html#define-booking-classes", "title": "Define Booking Classes", "text": "<pre><code>classes:\n- Y0\n- Y1\n- Y2\n- Y3\n- Y4\n- Y5\n- Y6\n- Y7\n- Y8\n- Y9\n</code></pre>"}, {"location": "user-guide/writing-configs.html#data-collection-points-dcps", "title": "Data Collection Points (DCPs)", "text": "<pre><code>dcps:\n- 63\n- 56\n- 49\n- 42\n- 35\n- 31\n- 28\n- 24\n- 21\n- 17\n- 14\n- 10\n- 7\n- 5\n- 3\n- 1\n</code></pre>"}, {"location": "user-guide/writing-configs.html#booking-curves", "title": "Booking Curves", "text": "<pre><code>booking_curves:\n- name: '1'\n  curve:\n    63: 0.01\n    56: 0.02\n    49: 0.05\n    42: 0.13\n    35: 0.19\n    31: 0.23\n    28: 0.29\n    24: 0.35\n    21: 0.45\n    17: 0.54\n    14: 0.67\n    10: 0.79\n    7: 0.86\n    5: 0.91\n    3: 0.96\n    1: 1.0\n- name: '2'\n  curve:\n    63: 0.13\n    56: 0.22\n    49: 0.37\n    42: 0.52\n    35: 0.64\n    31: 0.7\n    28: 0.75\n    24: 0.78\n    21: 0.83\n    17: 0.87\n    14: 0.91\n    10: 0.94\n    7: 0.96\n    5: 0.98\n    3: 0.99\n    1: 1.0\n- name: '3'\n  curve:\n    63: 0.04\n    56: 0.06\n    49: 0.12\n    42: 0.26\n    35: 0.35\n    31: 0.41\n    28: 0.48\n    24: 0.54\n    21: 0.63\n    17: 0.7\n    14: 0.81\n    10: 0.88\n    7: 0.93\n    5: 0.96\n    3: 0.98\n    1: 1.0\n- name: '4'\n  curve:\n    63: 0.21\n    56: 0.35\n    49: 0.53\n    42: 0.67\n    35: 0.76\n    31: 0.8\n    28: 0.83\n    24: 0.85\n    21: 0.88\n    17: 0.91\n    14: 0.94\n    10: 0.96\n    7: 0.97\n    5: 0.98\n    3: 0.99\n    1: 1.0\n</code></pre>"}, {"location": "user-guide/writing-configs.html#legs", "title": "Legs", "text": "<pre><code>legs:\n- carrier: AL1\n  fltno: 1\n  orig: BOS\n  dest: SFO\n  date: '2020-01-01'\n  dep_time: 08:00\n  arr_time: '10:00'\n  capacity: 100\n  distance: 867.0\n- carrier: AL2\n  fltno: 2\n  orig: BOS\n  dest: SFO\n  date: '2020-01-01'\n  dep_time: '14:00'\n  arr_time: '16:00'\n  capacity: 100\n  distance: 867.0\n...\n</code></pre>"}, {"location": "user-guide/writing-configs.html#paths", "title": "Paths", "text": "<pre><code>paths:\n- orig: BOS\n  dest: SFO\n  path_quality_index: 1.0\n  legs:\n  - 1\n- orig: BOS\n  dest: SFO\n  path_quality_index: 1.0\n  legs:\n  - 2\n- orig: BOS\n  dest: ORD\n  path_quality_index: 1.0\n  legs:\n  - 3\n...\n</code></pre>"}, {"location": "user-guide/database/index.html", "title": "Database", "text": "<p>The default data storage solution for PassengerSim is a SQLite database file.</p>"}, {"location": "user-guide/database/index.html#database-tables", "title": "Database Tables", "text": "<p>The following tables are created when running a simulation:</p> Table Description carrier_summary Aggregate summary information on carrier performance. leg_summary Aggregate summary information on legs. leg_defs Static data about network legs leg_detail Simulation data at the leg level leg_bucket_detail Simulation data at the leg-bucket level path_class_detail Simulation data at the path-class level demand_detail Simulation data at the demand level fare_detail Simulation data at the fare level bookings_by_timeframe Aggregate summary simulation data on bookings by timeframe and bookings class"}, {"location": "user-guide/database/index.html#common-queries", "title": "Common Queries", "text": "<p>PassengerSim has a number of pre-packaged functions that query the database of results to provide useful summary tables.</p> Query Description <code>bid_price_history</code> Compute average bid price history over all legs for each carrier <code>bookings_by_timeframe</code> Average bookings and revenue by carrier, booking class, and timeframe <code>carrier_history</code> Sample-level details of carrier-level measures <code>demand_to_come</code> Demand by market and timeframe across each sample <code>fare_class_mix</code> Fare class mix by carrier <code>leg_forecasts</code> Average forecasts of demand by leg, bucket, and days to departure <code>local_and_flow_yields</code> Yields for local (nonstop) and flow (connecting) passengers by leg <code>od_fare_class_mix</code> Fare class mix by carrier for a particular origin-destination market <code>path_forecasts</code> Average forecasts of demand by path, class, and days to departure <code>total_demand</code> Average total demand"}, {"location": "user-guide/database/bookings_by_timeframe.html", "title": "Bookings by Timeframe", "text": "<p>The <code>bookings_by_timeframe</code> database table stores aggregate summary information about simulated bookings by timeframe, carrier, booking class, and passenger segment. Unlike various other \"detail\" tables, it does not store the results from any single sample, but instead has information aggregated over all samples in each trial.</p> <p>The table is created by the <code>create_table_bookings_by_timeframe</code> function, and (potentially) populated during a simulation run.  To be populated with data, the \"bookings\" flag must be set on <code>Config.db.write_items</code>.</p>"}, {"location": "user-guide/database/bookings_by_timeframe.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> trial INT NOT NULL carrier VARCHAR(10) NOT NULL Carrier name booking_class VARCHAR(10) NOT NULL days_prior INT NOT NULL Days before departure tot_sold FLOAT Total sales for the carrier and booking class, through this timeframe avg_sold FLOAT Average number of sales (per sample) avg_business FLOAT Average number of sales to business customers avg_leisure FLOAT Average number of sales to leisure customers avg_revenue FLOAT Average revenue from sales avg_price FLOAT Average price sold updated_at DATETIME NOT NULL Time each row was written to the database <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/carrier_summary.html", "title": "Carrier Summary", "text": "<p>The <code>carrier_summary</code> database table stores aggregate summary information about the various carriers in the simulation.  It is always generated after a simulation run and does not need to be activated by any configuration setting.</p>"}, {"location": "user-guide/database/carrier_summary.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description carrier TEXT Carrier name sold REAL Average number of sold sys_lf REAL Average system load factor avg_leg_lf REAL Average leg load factor avg_rev INTEGER Average revenue avg_price REAL Average price of seats sold asm INTEGER Available seat miles rpm INTEGER Revenue passenger miles yield REAL Average revenue per revenue passenger mile"}, {"location": "user-guide/database/demand_detail.html", "title": "Demand Detail", "text": "<p>The <code>demand_detail</code> database table stores details about the results of the simulation at the demand level.</p> <p>The table is created by the <code>create_table_demand_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"demand\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"demand_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> </ul>"}, {"location": "user-guide/database/demand_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial days_prior INT NOT NULL Days before departure segment VARCHAR(10) NOT NULL Customer segment, typically business or leisure orig VARCHAR(10) NOT NULL Origin (typically an airport code or similar) dest VARCHAR(10) NOT NULL Destination (typically an airport code or similar) updated_at DATETIME NOT NULL Time each row was written to the database sample_demand FLOAT sold INT Number of customers in this demand bucket who bought something no_go INT Number of customers in this demand bucket who bought nothing revenue FLOAT Revenue attributable to these customers <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/distance.html", "title": "Distance", "text": "<p>The <code>distance</code> database table stores the distance between locations (airports and/or other travel nodes). It contains static data not dependent on running the simulation. The table is created by the <code>create_table_distance</code> function.</p>"}, {"location": "user-guide/database/distance.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description orig VARCHAR(10) NOT NULL Origin (typically an airport code or similar) dest VARCHAR(10) NOT NULL Destination (typically an airport code or similar) miles FLOAT Distance between nodes in miles"}, {"location": "user-guide/database/fare_defs.html", "title": "Fare Definitions", "text": "<p>The <code>fare_defs</code> database table stores static details about the fares in the simulation.  Simulation results at the fare level are stored in the <code>fare_details</code> table instead.</p> <p>The <code>fare_defs</code> table is created by the create_table_fare_defs function, which is called in the Simulation initialization step, so it should be available and populated for every simulation run.</p>"}, {"location": "user-guide/database/fare_defs.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description fare_id INTEGER PRIMARY KEY Unique identifier for a given fare <sup>1</sup> carrier VARCHAR(10) NOT NULL Name of carrier for this leg orig VARCHAR(10) NOT NULL Origin (typically an airport code or similar) dest VARCHAR(10) NOT NULL Destination (typically an airport code or similar) booking_class VARCHAR(10) NOT NULL price INTEGER restrictions VARCHAR(20) NOT NULL Comma delimited list of fare restrictions category VARCHAR(20) Optional fare category (e.g. International, Domestic Restricted, etc) <sup>2</sup> <ol> <li> <p><code>fare_id</code> values are not specified in the user's configuration file, but instead unique values are generated as Fare objects are created as the simulation is initialized.\u00a0\u21a9</p> </li> <li> <p>The <code>category</code> has no material effect on the simulation, but is stored in the database table and can be used for analysis of results after a simulation is complete, e.g. to look at results for just international bookings, or just in domestic restricted markets where LCC's are not operating, etc.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/fare_detail.html", "title": "Fare Detail", "text": "<p>The <code>fare_detail</code> database table stores details about the results of the simulation at the fare level.</p> <p>The table is created by the <code>create_table_fare_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"fare\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"fare_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> </ul>"}, {"location": "user-guide/database/fare_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial days_prior INT NOT NULL Days before departure carrier VARCHAR(10) NOT NULL Carrier name orig VARCHAR(10) NOT NULL Origin (typically an airport code or similar) dest VARCHAR(10) NOT NULL Destination (typically an airport code or similar) booking_class VARCHAR(10) NOT NULL sold INT Number of customers buying this fare product sold_business INT Number of businss customers buying this fare product price FLOAT Price of this fare updated_at DATETIME NOT NULL Time each row was written to the database <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/leg_bucket_detail.html", "title": "Leg Bucket Detail", "text": "<p>The <code>leg_bucket_detail</code> database table stores details about the results of the simulation at the leg-bucket level.</p> <p>The table is created by the <code>create_table_leg_bucket_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"bucket\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"bucket_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> </ul>"}, {"location": "user-guide/database/leg_bucket_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial days_prior INT NOT NULL Days before departure flt_no INT NOT NULL Unique identifier for a given leg <sup>2</sup> bucket_number INT NOT NULL Bucket number (sequential from 0) name VARCHAR(10) NOT NULL Bucket name auth INT Number of seats in this bucket (or higher) available to be sold revenue FLOAT Revenue attributed to this bucket from seats sold sold INT Number of seats sold at this point in time untruncated_demand FLOAT forecast_mean FLOAT forecast_stdev FLOAT forecast_closed_in_tf FLOAT forecast_closed_in_future FLOAT updated_at DATETIME NOT NULL Time each row was written to the database <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> <li> <p>In the \"real world\" the limitations of current technology make it such that flight numbers are not necessary unique by leg, as a single carrier may have multiple segments sharing the same flight number, and multiple carriers will have completely unrelated flights with the same flight number.  To simplify data processing, PassengerSim uses a unique id for every travel segment. Networks in PassengerSim that are derived from realistic sources will require some modest preprocessing to create unique flight numbers for every leg.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/leg_defs.html", "title": "Leg Definitions", "text": "<p>The <code>leg_defs</code> database table stores static details about the legs in the simulation.  Simulation results at the leg level are stored in the <code>leg_details</code> table instead.</p> <p>The <code>leg_defs</code> table is created by the create_table_leg_defs function, which is called in the Simulation initialization step, so it should be available and populated for every simulation run.</p>"}, {"location": "user-guide/database/leg_defs.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description leg_id INTEGER PRIMARY KEY Unique identifier for a given leg <sup>1</sup> flt_no INTEGER Flight number label for this leg carrier TEXT Name of carrier for this leg orig TEXT Origin (typically an airport code or similar) dest TEXT Destination (typically an airport code or similar) dep_time INTEGER arr_time INTEGER capacity INTEGER Number of seats on this leg distance FLOAT Distance from <code>orig</code> to <code>dest</code> in miles. <ol> <li> <p>In the \"real world\" the limitations of current technology make it such that flight numbers are not necessary unique by leg, as a single carrier may have multiple segments sharing the same flight number, and multiple carriers will have completely unrelated flights with the same flight number.  To simplify data processing, PassengerSim uses a unique id for every travel segment. Networks in PassengerSim that are derived from realistic sources can still store flight numbers as a nominal label for every leg, but they are not used for anything except certain post-simulation reporting features.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/leg_detail.html", "title": "Leg Detail", "text": "<p>The <code>leg_detail</code> database table stores details about the results of the simulation at the leg level.  Facts about the leg which are not dependent on the simulation are stored in the <code>leg_defs</code> table instead.</p> <p>The table is created by the <code>create_table_leg_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"leg\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"leg_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> <li> <p>\"leg_daily\": The table will be populated at the end of each day during the simulation. Note this will produce a lot of output, and is probably not desirable for most simulation exercises.</p> </li> </ul>"}, {"location": "user-guide/database/leg_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial days_prior INT NOT NULL Days before departure flt_no INT NOT NULL Unique identifier for a given leg <sup>3</sup> updated_at DATETIME NOT NULL Time each row was written to the database sold INT Number of seats sold at this point in time revenue FLOAT Revenue attributed to this leg from seats sold q_demand FLOAT untruncated_demand FLOAT forecast_mean FLOAT Forecast of mean demand to come before departure bid_price FLOAT Computed bid price for this leg at this time <sup>2</sup> <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> <li> <p>Bid prices are only computed if there is a RM that provides an instruction to do the computation.  If there is no calculated bid price, this column will be blank.\u00a0\u21a9</p> </li> <li> <p>In the \"real world\" the limitations of current technology make it such that flight numbers are not necessary unique by leg, as a single carrier may have multiple segments sharing the same flight number, and multiple carriers will have completely unrelated flights with the same flight number.  To simplify data processing, PassengerSim uses a unique id for every travel segment. Networks in PassengerSim that are derived from realistic sources will require some modest preprocessing to create unique flight numbers for every leg.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/leg_summary.html", "title": "Leg Summary", "text": "<p>The <code>leg_summary</code> database table stores aggregate summary information about the various legs in the simulation.  It is always generated after a simulation run and does not need to be activated by any configuration setting.</p>"}, {"location": "user-guide/database/leg_summary.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description carrier TEXT Carrier name flt_no INTEGER Leg identifier orig TEXT Leg Origin dest TEXT Leg Destination avg_sold REAL Average number of seats sold avg_rev INTEGER Average revenue lf REAL Average leg load factor"}, {"location": "user-guide/database/path_class_detail.html", "title": "Path Class Detail", "text": "<p>The <code>path_class_detail</code> database table stores details about the results of the simulation at the path-class level.</p> <p>The table is created by the <code>create_table_path_class_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"pathclass\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"pathclass_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> </ul>"}, {"location": "user-guide/database/path_class_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial days_prior INT NOT NULL Days before departure path_id INT NOT NULL Unique identifier for a given path booking_class VARCHAR(10) NOT NULL Booking class name sold INT Number of seats sold at this point in time revenue FLOAT Revenue attributed to this bucket from seats sold untruncated_demand FLOAT forecast_mean FLOAT forecast_stdev FLOAT forecast_closed_in_tf FLOAT forecast_closed_in_future FLOAT updated_at DATETIME NOT NULL Time each row was written to the database <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/processing-outputs/basic-usage.nbconvert.html", "title": "Summary Outputs", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/08-untrunc-em\"))\ncfg.simulation_controls.num_samples = 300\ncfg.simulation_controls.num_trials = 2\nsim = pax.Simulation(cfg)\nsummary = sim.run()\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT/08-untrunc-em\")) cfg.simulation_controls.num_samples = 300 cfg.simulation_controls.num_trials = 2 sim = pax.Simulation(cfg) summary = sim.run() <pre></pre> <pre>Task Completed after 3.52 seconds\n</pre> <p>The simple <code>repr</code> of this object has a bit of information about what data is in there. You can view this in a Jupyter notebook by putting the object as the last line of a cell (or just by itself):</p> In\u00a0[3]: Copied! <pre>summary\n</pre> summary Out[3]: <pre>&lt;passengersim.summaries.SimulationTables created on 2025-11-12&gt;\n * bid_price_history (256 row DataFrame)\n * cabins (3200 row DataFrame)\n * carriers (2 row DataFrame)\n * carrier_history2 (800 row DataFrame)\n * forecast_accuracy (NoneType)\n * cp_segmentation (12 row DataFrame)\n * demand_to_come_summary (34 row DataFrame)\n * demands (6 row DataFrame)\n * displacement_history (68 row DataFrame)\n * fare_class_mix (12 row DataFrame)\n * legbuckets (48 row DataFrame)\n * legs (8 row DataFrame)\n * pathclasses (72 row DataFrame)\n * path_legs (16 row DataFrame)\n * paths (12 row DataFrame)\n * segmentation_by_timeframe (336 row DataFrame)\n&lt;*&gt;</pre> <p>We can see here there are a variety of tables stored as pandas DataFrames. We can access the raw values of any of these dataframes directly in Python as an attribute on the <code>SimulationTables</code> object.</p> In\u00a0[4]: Copied! <pre>summary.carriers\n</pre> summary.carriers Out[4]: control avg_rev avg_sold truncation_rule avg_leg_lf asm rpm ancillary_rev avg_local_leg_pax avg_total_leg_pax cp_sold cp_revenue avg_price yield rasm sys_lf local_pct_leg_pax local_pct_bookings carrier AL1 leg 90920.1875 285.9675 3 86.790729 590302.497298 519508.421436 0.0 188.8825 383.0525 0.0 0.0 317.938883 0.175012 0.154023 88.007153 49.309820 66.050338 AL2 leg 90614.6250 285.3625 3 86.622292 590302.497298 519025.918143 0.0 188.3300 382.3950 0.0 0.0 317.542161 0.174586 0.153505 87.925415 49.250121 65.996759 <p>There is also some metadata stored on the summary, which can be accessed via the <code>metadata</code> method.</p> In\u00a0[5]: Copied! <pre>summary.metadata()\n</pre> summary.metadata() Out[5]: <pre>{'time.created': '2025-11-12T15:04:42.392102+00:00',\n 'machine.system': 'Darwin',\n 'machine.release': '24.5.0',\n 'machine.version': 'Darwin Kernel Version 24.5.0: Tue Apr 22 19:54:33 PDT 2025; root:xnu-11417.121.6~2/RELEASE_ARM64_T8122',\n 'machine.machine': 'arm64',\n 'machine.processor': 'arm',\n 'machine.architecture': ('64bit', ''),\n 'machine.node': 'Nightshade.local',\n 'machine.platform': 'macOS-15.5-arm64-arm-64bit',\n 'machine.python_version': '3.12.11',\n 'machine.cpu_count': 8,\n 'version.passengersim': '0.58',\n 'version.passengersim_core': '0.59.dev1+g671876c7d'}</pre> <p>You can access the metadata for a specific key by passing that key as an argument to the method.</p> In\u00a0[6]: Copied! <pre>summary.metadata(\"time\")\n</pre> summary.metadata(\"time\") Out[6]: <pre>{'created': '2025-11-12T15:04:42.392102+00:00'}</pre> In\u00a0[9]: Copied! <pre>summary.to_pickle(\"saved-outputs/summary\")\n</pre> summary.to_pickle(\"saved-outputs/summary\") Out[9]: <pre>PosixPath('saved-outputs/summary.20251112-090442.pkl.lz4')</pre> <p>The method will automatically add the appropriate file extension and write the file to disk. By default, it will also add a timestamp, so that you will not overwrite existing similar files.</p> In\u00a0[10]: Copied! <pre>from passengersim.utils.show_dir import display_directory_contents\n\ndisplay_directory_contents(\"saved-outputs\")\n</pre> from passengersim.utils.show_dir import display_directory_contents  display_directory_contents(\"saved-outputs\") <pre>saved-outputs/\n  summary.20251112-090442.pkl.lz4\n</pre> <p>Restoring from this pickle file can be done, surprisingly enough, using the <code>from_pickle</code> method.  You can call this method with the same filename as <code>to_pickle</code>, and it will load the file with the most recent timestamp if there is one or more matching file(s) with various timestamps.  To load a specific pickle file that may or may not be the most recent, you can call this method with the complete actual filename, including the timestamp and \".pkl\" or \".pkl.lz4\" suffix.</p> In\u00a0[11]: Copied! <pre>resummary = pax.SimulationTables.from_pickle(\"saved-outputs/summary\")\nresummary\n</pre> resummary = pax.SimulationTables.from_pickle(\"saved-outputs/summary\") resummary Out[11]: <pre>&lt;passengersim.summaries.SimulationTables created on 2025-11-12&gt;\n * bid_price_history (256 row DataFrame)\n * cabins (3200 row DataFrame)\n * carriers (2 row DataFrame)\n * carrier_history2 (800 row DataFrame)\n * forecast_accuracy (NoneType)\n * cp_segmentation (12 row DataFrame)\n * demand_to_come_summary (34 row DataFrame)\n * demands (6 row DataFrame)\n * displacement_history (68 row DataFrame)\n * fare_class_mix (12 row DataFrame)\n * legbuckets (48 row DataFrame)\n * legs (8 row DataFrame)\n * pathclasses (72 row DataFrame)\n * path_legs (16 row DataFrame)\n * paths (12 row DataFrame)\n * segmentation_by_timeframe (336 row DataFrame)\n&lt;*&gt;</pre> <p>Once loaded, you can confirm which file was loaded, as that is added to the metadata at load time:</p> In\u00a0[12]: Copied! <pre>resummary.metadata(\"loaded\")\n</pre> resummary.metadata(\"loaded\") Out[12]: <pre>{'filename': 'saved-outputs/summary.20251112-090442.pkl.lz4',\n 'time': '2025-11-12T15:04:42.494660+00:00'}</pre> In\u00a0[13]: Copied! <pre>summary.to_file(\"saved-outputs/summary\")\n\ndisplay_directory_contents(\"saved-outputs\")\n</pre> summary.to_file(\"saved-outputs/summary\")  display_directory_contents(\"saved-outputs\") <pre>saved-outputs/\n  summary.20251112-090442.pkl.lz4\n  summary.20251112-090442.pxsim\n</pre> <p>When opening the file, only the most basic metadata is loaded by the <code>from_file</code> method, and the rest is identified as available on demand from storage.</p> In\u00a0[14]: Copied! <pre>resummary2 = pax.SimulationTables.from_file(\"saved-outputs/summary\")\nresummary2\n</pre> resummary2 = pax.SimulationTables.from_file(\"saved-outputs/summary\") resummary2 Out[14]: <pre>&lt;passengersim.summaries.SimulationTables created on 2025-11-12&gt;\n * bid_price_history (available in file storage)\n * cabins (available in file storage)\n * carrier_history2 (available in file storage)\n * carriers (available in file storage)\n * cp_segmentation (available in file storage)\n * demand_to_come_summary (available in file storage)\n * demands (available in file storage)\n * displacement_history (available in file storage)\n * fare_class_mix (available in file storage)\n * forecast_accuracy (available in file storage)\n * legbuckets (available in file storage)\n * legs (available in file storage)\n * path_legs (available in file storage)\n * pathclasses (available in file storage)\n * paths (available in file storage)\n * segmentation_by_timeframe (available in file storage)\n&lt;*&gt;</pre> <p>The metadata about this file is available under the \"store\" key instead of \"loaded\".</p> In\u00a0[15]: Copied! <pre>resummary2.metadata(\"store\")\n</pre> resummary2.metadata(\"store\") Out[15]: <pre>{'filename': 'saved-outputs/summary.20251112-090442.pxsim'}</pre> <p>Accessing data will load just that table from the file.  this includes accessing a table explicity (by calling for it), or implicitly (e.g. by creating a figure using the data).</p> In\u00a0[16]: Copied! <pre>resummary2.carriers\n</pre> resummary2.carriers Out[16]: control avg_rev avg_sold truncation_rule avg_leg_lf asm rpm ancillary_rev avg_local_leg_pax avg_total_leg_pax cp_sold cp_revenue avg_price yield rasm sys_lf local_pct_leg_pax local_pct_bookings carrier AL1 leg 90920.1875 285.9675 3 86.790729 590302.497298 519508.421436 0.0 188.8825 383.0525 0.0 0.0 317.938883 0.175012 0.154023 88.007153 49.309820 66.050338 AL2 leg 90614.6250 285.3625 3 86.622292 590302.497298 519025.918143 0.0 188.3300 382.3950 0.0 0.0 317.542161 0.174586 0.153505 87.925415 49.250121 65.996759 In\u00a0[17]: Copied! <pre>resummary2.fig_fare_class_mix()\n</pre> resummary2.fig_fare_class_mix() Out[17]: <p>We can see in the objects <code>repr</code> that the carriers and fare_class_mix tables have been loaded, but the rest are still only in the storage file.</p> In\u00a0[18]: Copied! <pre>resummary2\n</pre> resummary2 Out[18]: <pre>&lt;passengersim.summaries.SimulationTables created on 2025-11-12&gt;\n * carriers (2 row DataFrame)\n * fare_class_mix (12 row DataFrame)\n * bid_price_history (available in file storage)\n * cabins (available in file storage)\n * carrier_history2 (available in file storage)\n * cp_segmentation (available in file storage)\n * demand_to_come_summary (available in file storage)\n * demands (available in file storage)\n * displacement_history (available in file storage)\n * forecast_accuracy (available in file storage)\n * legbuckets (available in file storage)\n * legs (available in file storage)\n * path_legs (available in file storage)\n * pathclasses (available in file storage)\n * paths (available in file storage)\n * segmentation_by_timeframe (available in file storage)\n&lt;*&gt;</pre>"}, {"location": "user-guide/processing-outputs/basic-usage.nbconvert.html#summary-outputs", "title": "Summary Outputs\u00b6", "text": "<p>When you run a simulation in PassengerSim, you will get a <code>SimulationTables</code> object. This objects embeds a variety of summary infomation from the run.</p>"}, {"location": "user-guide/processing-outputs/basic-usage.nbconvert.html#saving-and-restoring", "title": "Saving and Restoring\u00b6", "text": "<p>Running a PassengerSim simulation on a practical network can take some time, so it is desirable to save your results after a run.  This allows you to come back to the analyze those results later, or compare against other future scenario permutations.  Saving outputs is done efficiently in the <code>pickle</code> format by using the <code>to_pickle</code> method.  This will automatically also use LZ4 compression if available, which will reduce the filesize considerably.</p>"}, {"location": "user-guide/processing-outputs/basic-usage.nbconvert.html#lazy-data-access", "title": "Lazy Data Access\u00b6", "text": "<p>When it is time to load the data, the pickle format is an all-or-nothing file format: if you only need a tiny bit of information from the file (e.g. what was AL1's revenue?) you still need to read all the data in the file: legs, paths, etc. PassengerSim also includes an alternative file format that stores the various data tables from the <code>SimulationTables</code> in independently loadable sections.  This format otherwise works the same as the pickle file, but uses <code>to_file</code> and <code>from_file</code>, and it creates files with a \"*.pxsim\" extension.</p>"}, {"location": "user-guide/processing-outputs/callbacks.nbconvert.html", "title": "Callbacks", "text": "In\u00a0[1]: Copied! <pre>import pandas as pd\n\nimport passengersim as pax\n\npax.versions()\n</pre> import pandas as pd  import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> <p>Here, we'll run a quick demo using the \"3MKT\" example model.  We'll give AL1 the 'P' RM system to make it interesting.</p> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\"))\n\ncfg.simulation_controls.num_samples = 100\ncfg.simulation_controls.burn_samples = 50\ncfg.simulation_controls.num_trials = 1\ncfg.db = None\ncfg.outputs.reports.clear()\n\ncfg.carriers.AL1.rm_system = \"P\"\n\nsim = pax.Simulation(cfg)\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\"))  cfg.simulation_controls.num_samples = 100 cfg.simulation_controls.burn_samples = 50 cfg.simulation_controls.num_trials = 1 cfg.db = None cfg.outputs.reports.clear()  cfg.carriers.AL1.rm_system = \"P\"  sim = pax.Simulation(cfg) In\u00a0[3]: Copied! <pre>@sim.end_sample_callback\ndef collect_carrier_revenue(sim: pax.Simulation) -&gt; dict | None:\n    if sim.eng.sample &lt; sim.eng.burn_samples:\n        return\n    return {c.name: c.revenue for c in sim.eng.carriers}\n</pre> @sim.end_sample_callback def collect_carrier_revenue(sim: pax.Simulation) -&gt; dict | None:     if sim.eng.sample &lt; sim.eng.burn_samples:         return     return {c.name: c.revenue for c in sim.eng.carriers} <p>The daily callback operates similarly, except it accepts a second argument that gives the number of days prior to departure for this day.  You don't need to use the second argument in the callback function, but you need to including in the function signature (and you can use it if desired, e.g. to collect data only at DCPs instead of every day).  In the example here, we collect daily carrier revenue, but only every 7th sample, which is a good way to reduce the overhead from collecting detailed data.</p> In\u00a0[4]: Copied! <pre>@sim.daily_callback\ndef collect_carrier_revenue_detail(sim: pax.Simulation, days_prior: int) -&gt; dict | None:\n    if sim.eng.sample &lt; sim.eng.burn_samples:\n        return\n    if sim.eng.sample % 7 == 0:\n        return {c.name: c.revenue for c in sim.eng.carriers}\n</pre> @sim.daily_callback def collect_carrier_revenue_detail(sim: pax.Simulation, days_prior: int) -&gt; dict | None:     if sim.eng.sample &lt; sim.eng.burn_samples:         return     if sim.eng.sample % 7 == 0:         return {c.name: c.revenue for c in sim.eng.carriers} <p>Multiple callbacks of the same kind can be attached (i.e. there can be two end_sample callbacks).  The only limitation is that the named values in the return values of each callback function must be unique, or else they will overwrite one another.</p> <p>For example, suppose we also want to count for each carrier the number of passengers departing each airport on each sample day. The previous end sample callback stored revenue values in a dictionary keyed by carrier name, so if we don't want to overwrite that, we need to use a different key. One way to avoid that is to just nest the output of the callback function in another dictionary with a unique top level key.</p> In\u00a0[5]: Copied! <pre>from collections import defaultdict\n\n\n@sim.end_sample_callback\ndef collect_passenger_counts(sim: pax.Simulation) -&gt; dict | None:\n    if sim.eng.sample &lt; sim.eng.burn_samples:\n        return\n    paxcount = defaultdict(lambda: defaultdict(int))\n    for leg in sim.eng.legs:\n        paxcount[leg.carrier.name][leg.orig] += leg.sold\n    # convert defaultdict to a regular dict, not necessary but pickles smaller\n    paxcount = {carrier: dict(airports) for carrier, airports in paxcount.items()}\n    return {\"psgr_by_airport\": paxcount}\n</pre> from collections import defaultdict   @sim.end_sample_callback def collect_passenger_counts(sim: pax.Simulation) -&gt; dict | None:     if sim.eng.sample &lt; sim.eng.burn_samples:         return     paxcount = defaultdict(lambda: defaultdict(int))     for leg in sim.eng.legs:         paxcount[leg.carrier.name][leg.orig] += leg.sold     # convert defaultdict to a regular dict, not necessary but pickles smaller     paxcount = {carrier: dict(airports) for carrier, airports in paxcount.items()}     return {\"psgr_by_airport\": paxcount} <p>One of the nifty features of callbacks is that they can access anything available in the simulation, not just sales and revenue data from carriers. For example, we can inspect demand objects directly, and see how many potential passengers were simulated so far, and how many didn't make a booking on any airlines (i.e. the \"no-go\" customers).</p> In\u00a0[6]: Copied! <pre>@sim.daily_callback\ndef count_nogo(sim: pax.Simulation, days_prior: int) -&gt; dict | None:\n    if sim.eng.sample &lt; sim.eng.burn_samples:\n        return\n    if sim.eng.sample % 7 == 0:\n        return\n    if days_prior &gt; 0 and days_prior not in sim.config.dcps:\n        # Only count \"nogo\" (unsold) demand at DCPs, and at departure (days_prior == 0)\n        return\n    nogo_count = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))\n    for dmd in sim.eng.demands:\n        nogo_count[dmd.orig][dmd.dest][dmd.segment] += dmd.unsold\n    # convert defaultdict to a regular dict, not necessary but pickles smaller\n    nogo_count = {orig: {dest: dict(seg) for dest, seg in dests.items()} for orig, dests in nogo_count.items()}\n    return {\"nogo\": nogo_count}\n</pre> @sim.daily_callback def count_nogo(sim: pax.Simulation, days_prior: int) -&gt; dict | None:     if sim.eng.sample &lt; sim.eng.burn_samples:         return     if sim.eng.sample % 7 == 0:         return     if days_prior &gt; 0 and days_prior not in sim.config.dcps:         # Only count \"nogo\" (unsold) demand at DCPs, and at departure (days_prior == 0)         return     nogo_count = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))     for dmd in sim.eng.demands:         nogo_count[dmd.orig][dmd.dest][dmd.segment] += dmd.unsold     # convert defaultdict to a regular dict, not necessary but pickles smaller     nogo_count = {orig: {dest: dict(seg) for dest, seg in dests.items()} for orig, dests in nogo_count.items()}     return {\"nogo\": nogo_count} In\u00a0[7]: Copied! <pre>duplicate_sim = pax.Simulation(cfg)\nduplicate_sim.end_sample_callback(collect_carrier_revenue)\nduplicate_sim.daily_callback(collect_carrier_revenue_detail);\n</pre> duplicate_sim = pax.Simulation(cfg) duplicate_sim.end_sample_callback(collect_carrier_revenue) duplicate_sim.daily_callback(collect_carrier_revenue_detail); <p>In this example, the duplicate_sim is running the same config as the original, but this would work with a modified config or even a completely different network.</p> <p>Once we have attached all desired callbacks to the simulation we want to run, we can run it as normal.</p> In\u00a0[8]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 0.51 seconds\n</pre> <p>All the usual summary data remains available for review and analysis.</p> In\u00a0[9]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[9]: In\u00a0[10]: Copied! <pre>summary.callback_data\n</pre> summary.callback_data Out[10]: <pre>&lt;passengersim.callbacks.CallbackData from daily, end_sample&gt;</pre> <p>Because we connected a \"daily\" callback, the data we collected is available under the <code>callback_data.daily</code> accessor.</p> In\u00a0[11]: Copied! <pre>summary.callback_data.daily[:5]\n</pre> summary.callback_data.daily[:5] Out[11]: <pre>[{'trial': 0,\n  'sample': 50,\n  'days_prior': 63,\n  'nogo': {'BOS': {'ORD': {'business': 0, 'leisure': 0},\n    'LAX': {'business': 0, 'leisure': 0}},\n   'ORD': {'LAX': {'business': 0, 'leisure': 0}}}},\n {'trial': 0,\n  'sample': 50,\n  'days_prior': 56,\n  'nogo': {'BOS': {'ORD': {'business': 0, 'leisure': 0},\n    'LAX': {'business': 0, 'leisure': 0}},\n   'ORD': {'LAX': {'business': 0, 'leisure': 0}}}},\n {'trial': 0,\n  'sample': 50,\n  'days_prior': 49,\n  'nogo': {'BOS': {'ORD': {'business': 0, 'leisure': 0},\n    'LAX': {'business': 0, 'leisure': 0}},\n   'ORD': {'LAX': {'business': 0, 'leisure': 0}}}},\n {'trial': 0,\n  'sample': 50,\n  'days_prior': 42,\n  'nogo': {'BOS': {'ORD': {'business': 0, 'leisure': 0},\n    'LAX': {'business': 0, 'leisure': 4}},\n   'ORD': {'LAX': {'business': 0, 'leisure': 3}}}},\n {'trial': 0,\n  'sample': 50,\n  'days_prior': 35,\n  'nogo': {'BOS': {'ORD': {'business': 0, 'leisure': 0},\n    'LAX': {'business': 0, 'leisure': 5}},\n   'ORD': {'LAX': {'business': 0, 'leisure': 4}}}}]</pre> <p>As you might expect, the \"begin_sample\" or \"end_sample\" callbacks are available under <code>callback_data.begin_sample</code> or <code>callback_data.end_sample</code>, respectively.</p> In\u00a0[12]: Copied! <pre>summary.callback_data.end_sample[:3]\n</pre> summary.callback_data.end_sample[:3] Out[12]: <pre>[{'trial': 0,\n  'sample': 50,\n  'AL1': 100475.0,\n  'AL2': 103700.0,\n  'psgr_by_airport': {'AL1': {'BOS': 200.0, 'ORD': 240.0},\n   'AL2': {'BOS': 200.0, 'ORD': 240.0}}},\n {'trial': 0,\n  'sample': 51,\n  'AL1': 101475.0,\n  'AL2': 97425.0,\n  'psgr_by_airport': {'AL1': {'BOS': 190.0, 'ORD': 240.0},\n   'AL2': {'BOS': 197.0, 'ORD': 240.0}}},\n {'trial': 0,\n  'sample': 52,\n  'AL1': 108575.0,\n  'AL2': 95000.0,\n  'psgr_by_airport': {'AL1': {'BOS': 191.0, 'ORD': 231.0},\n   'AL2': {'BOS': 162.0, 'ORD': 231.0}}}]</pre> <p>The callback data can include pretty much anything, so it is stored in a very flexible (but inefficient) format: a list of dict's.  If the content of the dicts is fairly simple (numbers, tuples, lists, or nested dictionaries thereof), it can be converted into a pandas DataFrame using the <code>to_dataframe</code> method on the <code>callback_data</code> attribute.  This may make subsequent analysis easier.</p> In\u00a0[13]: Copied! <pre>summary.callback_data.to_dataframe(\"daily\")\n</pre> summary.callback_data.to_dataframe(\"daily\") Out[13]: trial sample days_prior nogo.BOS.ORD.business nogo.BOS.ORD.leisure nogo.BOS.LAX.business nogo.BOS.LAX.leisure nogo.ORD.LAX.business nogo.ORD.LAX.leisure AL1 AL2 0 0 50 63 0.0 0.0 0.0 0.0 0.0 0.0 NaN NaN 1 0 50 56 0.0 0.0 0.0 0.0 0.0 0.0 NaN NaN 2 0 50 49 0.0 0.0 0.0 0.0 0.0 0.0 NaN NaN 3 0 50 42 0.0 0.0 0.0 4.0 0.0 3.0 NaN NaN 4 0 50 35 0.0 0.0 0.0 5.0 0.0 4.0 NaN NaN ... ... ... ... ... ... ... ... ... ... ... ... 1174 0 99 7 0.0 3.0 0.0 8.0 0.0 7.0 NaN NaN 1175 0 99 5 0.0 5.0 0.0 8.0 0.0 10.0 NaN NaN 1176 0 99 3 0.0 7.0 0.0 11.0 0.0 11.0 NaN NaN 1177 0 99 1 0.0 8.0 6.0 14.0 3.0 15.0 NaN NaN 1178 0 99 0 1.0 10.0 7.0 18.0 3.0 17.0 NaN NaN <p>1179 rows \u00d7 11 columns</p> In\u00a0[14]: Copied! <pre>summary.callback_data.to_dataframe(\"end_sample\")\n</pre> summary.callback_data.to_dataframe(\"end_sample\") Out[14]: trial sample AL1 AL2 psgr_by_airport.AL1.BOS psgr_by_airport.AL1.ORD psgr_by_airport.AL2.BOS psgr_by_airport.AL2.ORD 0 0 50 100475.0 103700.0 200.0 240.0 200.0 240.0 1 0 51 101475.0 97425.0 190.0 240.0 197.0 240.0 2 0 52 108575.0 95000.0 191.0 231.0 162.0 231.0 3 0 53 104275.0 98825.0 200.0 240.0 200.0 240.0 4 0 54 101300.0 97000.0 193.0 240.0 188.0 240.0 5 0 55 94600.0 101175.0 169.0 210.0 181.0 225.0 6 0 56 88425.0 87575.0 172.0 227.0 172.0 227.0 7 0 57 63900.0 58975.0 118.0 154.0 105.0 154.0 8 0 58 98400.0 96700.0 200.0 234.0 200.0 223.0 9 0 59 92175.0 92975.0 173.0 232.0 143.0 238.0 10 0 60 100425.0 92625.0 176.0 228.0 163.0 226.0 11 0 61 94125.0 86675.0 200.0 223.0 200.0 185.0 12 0 62 82525.0 83150.0 174.0 212.0 170.0 216.0 13 0 63 88625.0 76525.0 200.0 189.0 200.0 173.0 14 0 64 109900.0 103375.0 200.0 240.0 200.0 240.0 15 0 65 99775.0 108375.0 164.0 197.0 197.0 238.0 16 0 66 96825.0 100375.0 187.0 217.0 200.0 222.0 17 0 67 111275.0 105700.0 200.0 240.0 200.0 240.0 18 0 68 92575.0 86525.0 187.0 193.0 177.0 208.0 19 0 69 91375.0 97400.0 174.0 205.0 195.0 230.0 20 0 70 78400.0 75100.0 121.0 181.0 146.0 201.0 21 0 71 73825.0 69575.0 144.0 154.0 142.0 173.0 22 0 72 96150.0 93325.0 174.0 235.0 176.0 240.0 23 0 73 78000.0 85600.0 118.0 214.0 151.0 229.0 24 0 74 82600.0 81725.0 142.0 179.0 164.0 181.0 25 0 75 101550.0 93050.0 170.0 227.0 155.0 240.0 26 0 76 90600.0 94900.0 126.0 212.0 144.0 238.0 27 0 77 117925.0 104075.0 200.0 240.0 199.0 240.0 28 0 78 80275.0 73975.0 135.0 193.0 149.0 187.0 29 0 79 109225.0 96450.0 193.0 240.0 161.0 240.0 30 0 80 76700.0 86875.0 153.0 200.0 166.0 229.0 31 0 81 74250.0 82575.0 113.0 166.0 161.0 180.0 32 0 82 74950.0 67800.0 104.0 180.0 92.0 190.0 33 0 83 110900.0 98825.0 197.0 240.0 190.0 240.0 34 0 84 110350.0 97450.0 198.0 240.0 198.0 236.0 35 0 85 108625.0 100200.0 200.0 240.0 200.0 240.0 36 0 86 81575.0 82700.0 157.0 198.0 149.0 216.0 37 0 87 86825.0 93675.0 183.0 168.0 193.0 202.0 38 0 88 66575.0 70500.0 105.0 163.0 104.0 186.0 39 0 89 55700.0 59775.0 98.0 135.0 109.0 148.0 40 0 90 92500.0 100600.0 188.0 230.0 182.0 239.0 41 0 91 102450.0 97400.0 193.0 240.0 188.0 240.0 42 0 92 100525.0 108975.0 199.0 237.0 198.0 240.0 43 0 93 85975.0 87025.0 126.0 174.0 144.0 188.0 44 0 94 100175.0 97950.0 180.0 240.0 163.0 240.0 45 0 95 108800.0 104200.0 197.0 240.0 180.0 240.0 46 0 96 103900.0 98475.0 183.0 240.0 171.0 240.0 47 0 97 92250.0 80250.0 167.0 193.0 149.0 191.0 48 0 98 62450.0 73450.0 126.0 161.0 146.0 195.0 49 0 99 90350.0 90275.0 169.0 188.0 150.0 202.0 <p>Users are free to process this callback data now however they like, with typical Python tools: analyze, visualize, interpret, etc.</p> In\u00a0[15]: Copied! <pre># Visualize revenue difference between carriers across booking curve\n\nimport altair as alt\n\nalt.Chart(summary.callback_data.to_dataframe(\"daily\").eval(\"DIFF = AL1 - AL2\")).mark_line().encode(\n    x=alt.X(\"days_prior\", scale=alt.Scale(reverse=True)),\n    y=\"DIFF\",\n    color=\"sample:N\",\n)\n</pre> # Visualize revenue difference between carriers across booking curve  import altair as alt  alt.Chart(summary.callback_data.to_dataframe(\"daily\").eval(\"DIFF = AL1 - AL2\")).mark_line().encode(     x=alt.X(\"days_prior\", scale=alt.Scale(reverse=True)),     y=\"DIFF\",     color=\"sample:N\", ) Out[15]: In\u00a0[16]: Copied! <pre># Visualize \"nogo\" passengers over time, by market and segment\n\nnogo = (\n    summary.callback_data.to_dataframe(\"daily\")\n    .set_index([\"days_prior\", \"sample\"])\n    .drop(columns=[\"trial\", \"AL1\", \"AL2\"])\n)\nnogo.columns = pd.MultiIndex.from_tuples(nogo.columns.str.split(\".\").to_list())\nnogo.columns.names = [\"nogo\", \"orig\", \"dest\", \"segment\"]\nnogo = nogo.stack([1, 2, 3], future_stack=True).dropna().reset_index()\n\nmean_nogo = nogo.groupby([\"days_prior\", \"orig\", \"dest\", \"segment\"]).nogo.mean().reset_index()\nmean_nogo[\"market\"] = mean_nogo.orig + \"-\" + mean_nogo.dest\n\nalt.Chart(mean_nogo).mark_line().encode(\n    x=alt.X(\"days_prior\", scale=alt.Scale(reverse=True)),\n    y=\"nogo\",\n    color=\"segment:N\",\n    strokeWidth=\"market:N\",\n    strokeDash=\"market:N\",\n)\n</pre> # Visualize \"nogo\" passengers over time, by market and segment  nogo = (     summary.callback_data.to_dataframe(\"daily\")     .set_index([\"days_prior\", \"sample\"])     .drop(columns=[\"trial\", \"AL1\", \"AL2\"]) ) nogo.columns = pd.MultiIndex.from_tuples(nogo.columns.str.split(\".\").to_list()) nogo.columns.names = [\"nogo\", \"orig\", \"dest\", \"segment\"] nogo = nogo.stack([1, 2, 3], future_stack=True).dropna().reset_index()  mean_nogo = nogo.groupby([\"days_prior\", \"orig\", \"dest\", \"segment\"]).nogo.mean().reset_index() mean_nogo[\"market\"] = mean_nogo.orig + \"-\" + mean_nogo.dest  alt.Chart(mean_nogo).mark_line().encode(     x=alt.X(\"days_prior\", scale=alt.Scale(reverse=True)),     y=\"nogo\",     color=\"segment:N\",     strokeWidth=\"market:N\",     strokeDash=\"market:N\", ) Out[16]:"}, {"location": "user-guide/processing-outputs/callbacks.nbconvert.html#callbacks", "title": "Callbacks\u00b6", "text": "<p>PassengerSim includes a variety of optimized data collection processes that run automatically during a simulation, but these pre-selected data may not be sufficient for every analysis.  To supplement this, users can choose to additionally collect any other data while running a simulation. This is done by writing a \"callback\" function.  Such a function is invoked regularly while the simulation is running, and can inspect and store almost anything from the Simulation object.</p>"}, {"location": "user-guide/processing-outputs/callbacks.nbconvert.html#types-of-callback-functions", "title": "Types of Callback Functions\u00b6", "text": "<p>To collect data, we can write a function that will interrogate the simulation and grab whatever info we are looking for.  There are three different points where we can attach data collection callback functions:</p> <ul> <li><code>begin_sample</code>, which will trigger data collection at the beginning of each sample, after the RM systems for each carrier are initialized (e.g. with forecasts, etc) but before any customers can arrive.</li> <li><code>end_sample</code>, which will trigger data collection at the end of each sample, after customers have arrive and all bookings have be finalized.</li> <li><code>daily</code>, which will trigger data collection once per day during every sample, just after any DCP or daily RM system updates are run.</li> </ul> <p>The first two callbacks (begin and end sample) are written as a function that accepts one argument (the <code>Simulation</code> object), and either returns nothing (to ignore that event) or returns a dictionary of values to store, where the keys are all strings naming what's being stored and the values can be whatever is of interest. This can be a simple numeric value (i.e., a scalar), or a tuple, an array, a nested dictionary, or any other pickle-able Python object.</p> <p>We can attach each callback to the Simulation by using a Python decorator.</p>"}, {"location": "user-guide/processing-outputs/callbacks.nbconvert.html#example-callback-functions", "title": "Example Callback Functions\u00b6", "text": "<p>For example, here we create a callback to collect carrier revenue at the end of every sample. Note that we skip the burn period by returning nothing for those samples; this is not required by the callback algorithm but is good practice for analysis.</p>"}, {"location": "user-guide/processing-outputs/callbacks.nbconvert.html#re-using-callback-functions", "title": "Re-using Callback Functions\u00b6", "text": "<p>Attaching via the decorators is a convenient way to add callbacks to a single simulation.  The decorators connect the callback function to the simulation, but do not otherwise modify the function itself. It is easy to define callback functions in a seperate module or to re-use callback functions for multiple simulations, by using the decorator as a regular function. For example, we can create a second simulation object, and attach the same callback functions like this:</p>"}, {"location": "user-guide/processing-outputs/callbacks.nbconvert.html#callback-data", "title": "Callback Data\u00b6", "text": "<p>In addition to the usual suspects, the summary object includes the collected callback data from our callback functions.</p>"}, {"location": "user-guide/processing-outputs/tracers.nbconvert.html", "title": "Tracing", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\n\npax.versions()\n</pre> import passengersim as pax  pax.versions() <pre>passengersim 0.58\npassengersim.core 0.59.dev1+g671876c7d\n</pre> <p>Here, we'll run a quick demo using the \"3MKT\" example model.  We'll give AL1 the 'P' RM system to make it interesting.</p> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\"))\n\ncfg.simulation_controls.num_samples = 400\ncfg.simulation_controls.burn_samples = 50\ncfg.simulation_controls.num_trials = 1\ncfg.db = None\ncfg.outputs.reports.clear()\n\ncfg.carriers.AL1.rm_system = \"P\"\n\nsim = pax.Simulation(cfg)\n</pre> cfg = pax.Config.from_yaml(pax.demo_network(\"3MKT\"))  cfg.simulation_controls.num_samples = 400 cfg.simulation_controls.burn_samples = 50 cfg.simulation_controls.num_trials = 1 cfg.db = None cfg.outputs.reports.clear()  cfg.carriers.AL1.rm_system = \"P\"  sim = pax.Simulation(cfg) In\u00a0[3]: Copied! <pre>from passengersim.tracers.forecasts import (\n    PathForecastTracer,\n    fig_path_forecast_dashboard,\n)\n\nf_tracer = PathForecastTracer(path_ids=[1, 9])\nf_tracer.attach(sim)\n</pre> from passengersim.tracers.forecasts import (     PathForecastTracer,     fig_path_forecast_dashboard, )  f_tracer = PathForecastTracer(path_ids=[1, 9]) f_tracer.attach(sim) In\u00a0[4]: Copied! <pre>from passengersim.tracers.bid_price import (\n    LegBidPriceTracer,\n    PathBidPriceTracer,\n    fig_leg_bid_prices,\n    fig_path_bid_prices,\n)\n\nbp_tracer = PathBidPriceTracer(path_ids=[1, 9])\nbp_tracer.attach(sim)\n\nleg_bp_tracer = LegBidPriceTracer(leg_ids=[101, 111])\nleg_bp_tracer.attach(sim)\n</pre> from passengersim.tracers.bid_price import (     LegBidPriceTracer,     PathBidPriceTracer,     fig_leg_bid_prices,     fig_path_bid_prices, )  bp_tracer = PathBidPriceTracer(path_ids=[1, 9]) bp_tracer.attach(sim)  leg_bp_tracer = LegBidPriceTracer(leg_ids=[101, 111]) leg_bp_tracer.attach(sim) <p>Once the tracers have been attached, we run the simulation as normal. The attached tracers will automatically collect and aggregate the relevant data, and attach the tabulated results to the summary outputs.</p> In\u00a0[5]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>Task Completed after 3.17 seconds\n</pre> <p>All the usual summary data remains available for review and analysis.</p> In\u00a0[6]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>fig_path_forecast_dashboard(summary, path_id=1)\n</pre> fig_path_forecast_dashboard(summary, path_id=1) Out[8]: In\u00a0[9]: Copied! <pre>fig_path_forecast_dashboard(summary, path_id=9)\n</pre> fig_path_forecast_dashboard(summary, path_id=9) Out[9]: <p>The dashboards for bid price tracing are less busy than those for the forecasts, as the bid price</p> In\u00a0[10]: Copied! <pre>fig_path_bid_prices(summary)\n</pre> fig_path_bid_prices(summary) Out[10]: In\u00a0[11]: Copied! <pre>fig_leg_bid_prices(summary)\n</pre> fig_leg_bid_prices(summary) Out[11]: In\u00a0[12]: Copied! <pre>summary.callback_data.selected_path_forecasts\n</pre> summary.callback_data.selected_path_forecasts Out[12]: mean_to_departure stdev_to_departure ... history_sold_yieldable history_closure booking_class Y0 Y1 Y2 Y3 Y4 Y5 Y0 Y1 Y2 Y3 ... Y2 Y3 Y4 Y5 Y0 Y1 Y2 Y3 Y4 Y5 path_id days_prior 1 63 2.542146 9.941561 5.584702 1.794732 11.739468 6.291431 1.771631 4.319455 2.861782 1.579957 ... 0.351978 0.069780 2.359121 1.333736 0.000000 0.000000 0.000000 0.000000 0.000000 0.027802 56 2.436102 9.366506 5.232724 1.724952 9.380347 4.931511 1.714093 4.132766 2.724080 1.530989 ... 0.289121 0.038571 1.079451 0.620330 0.000000 0.000000 0.000000 0.000000 0.002857 0.044945 49 2.344673 8.986836 4.943603 1.686380 8.296376 4.267961 1.679260 4.066012 2.619407 1.496378 ... 0.255385 0.038022 1.323297 0.749231 0.000000 0.000000 0.000000 0.000000 0.002857 0.045275 42 2.234673 8.614418 4.688219 1.648358 6.967735 3.478519 1.647875 3.945773 2.504475 1.477896 ... 0.304615 0.051209 1.186264 0.723736 0.000000 0.000000 0.000000 0.000000 0.005714 0.079780 35 2.118300 8.185957 4.383603 1.597149 5.774734 2.682167 1.604271 3.696554 2.417460 1.460541 ... 0.187473 0.024725 0.755495 0.475934 0.000000 0.000000 0.000000 0.000000 0.008901 0.106044 31 2.059618 7.866726 4.196131 1.572424 5.013302 2.128337 1.595658 3.609585 2.374704 1.455211 ... 0.111538 0.024286 0.571099 0.354286 0.000000 0.000000 0.000000 0.000000 0.016484 0.124176 28 2.023465 7.695407 4.084592 1.548138 4.430047 1.697790 1.576588 3.560280 2.331070 1.451886 ... 0.144945 0.022198 1.129670 0.678242 0.000000 0.000000 0.000000 0.000000 0.044725 0.159780 24 1.955772 7.378264 3.939647 1.525941 3.250958 0.865343 1.544081 3.428452 2.314346 1.440032 ... 0.140440 0.045385 1.117473 0.694286 0.000000 0.000000 0.000000 0.011429 0.067692 0.181538 21 1.869728 7.110462 3.799208 1.475321 2.053770 0.000000 1.522651 3.363088 2.267855 1.383390 ... 0.260330 0.072418 0.883297 0.000000 0.000000 0.000000 0.004725 0.043736 0.116154 1.000000 17 1.786871 6.718924 3.537032 1.380092 1.042731 0.000000 1.461959 3.230329 2.197576 1.273061 ... 0.233297 0.057802 0.856484 0.000000 0.000000 0.000000 0.021868 0.093297 0.147582 1.000000 14 1.664893 6.293869 3.290389 1.293480 0.000000 0.000000 1.400177 3.072104 2.020656 1.187915 ... 0.652088 0.611429 0.000000 0.000000 0.000000 0.002857 0.065055 0.178242 1.000000 1.000000 10 1.454454 5.449463 2.583637 0.515139 0.000000 0.000000 1.268630 2.711183 1.764790 0.635040 ... 0.685495 0.375165 0.000000 0.000000 0.000000 0.021868 0.126484 0.200000 1.000000 1.000000 7 1.190937 4.441360 1.778410 0.000000 0.000000 0.000000 1.137997 2.322363 1.379983 0.000000 ... 0.513516 0.000000 0.000000 0.000000 0.008571 0.058571 0.161319 1.000000 1.000000 1.000000 5 0.960961 3.719145 1.123151 0.000000 0.000000 0.000000 1.032368 2.000465 1.069064 0.000000 ... 0.865714 0.000000 0.000000 0.000000 0.052967 0.115714 0.199451 1.000000 1.000000 1.000000 3 0.758311 2.893502 0.000000 0.000000 0.000000 0.000000 0.866083 1.679374 0.000000 0.000000 ... 0.000000 0.000000 0.000000 0.000000 0.179560 0.196703 1.000000 1.000000 1.000000 1.000000 1 0.177835 0.735596 0.000000 0.000000 0.000000 0.000000 0.340493 0.743147 0.000000 0.000000 ... 0.000000 0.000000 0.000000 0.000000 0.202747 0.217033 1.000000 1.000000 1.000000 1.000000 9 63 11.095695 7.052048 6.390467 3.957610 21.942445 11.077824 4.726294 3.652488 3.625659 3.685562 ... 0.287033 0.065055 3.847363 0.900110 0.000000 0.000000 0.000000 0.000000 0.009670 0.695714 56 10.500421 6.765455 6.103434 3.892555 18.076396 9.320925 4.468967 3.498517 3.523963 3.675231 ... 0.230000 0.062967 1.758022 0.435275 0.000000 0.000000 0.000000 0.000000 0.018242 0.637253 49 10.026904 6.520729 5.873434 3.829588 16.291918 8.256781 4.348219 3.353806 3.462947 3.665369 ... 0.205714 0.048571 2.067363 0.581648 0.000000 0.000000 0.000000 0.000000 0.027802 0.647912 42 9.623278 6.294246 5.667720 3.781016 14.182168 6.913298 4.198069 3.266205 3.400609 3.638974 ... 0.230220 0.087692 2.177143 0.639121 0.000000 0.000000 0.000000 0.000000 0.062088 0.606923 35 9.105256 5.950400 5.437500 3.693324 11.882819 5.375649 4.034654 3.145313 3.353641 3.581604 ... 0.130879 0.046593 1.293407 0.495275 0.000000 0.000000 0.000000 0.000000 0.079231 0.591319 31 8.812289 5.790729 5.306621 3.646730 10.478225 4.109598 3.942200 3.118391 3.269516 3.515460 ... 0.068791 0.043846 0.988132 0.348462 0.000000 0.000000 0.000000 0.000000 0.102088 0.540110 28 8.566684 5.690949 5.237830 3.602884 9.349790 3.188522 3.896806 3.066985 3.265444 3.475829 ... 0.161648 0.130769 1.987363 0.779231 0.000000 0.000000 0.000000 0.000000 0.158022 0.500989 24 8.212289 5.521828 5.076181 3.472115 7.015424 1.551609 3.824400 3.013752 3.191924 3.287509 ... 0.148791 0.310220 1.916593 0.809121 0.000000 0.000000 0.000000 0.017143 0.225714 0.485824 21 7.919871 5.343147 4.927390 3.127391 4.601234 0.000000 3.746274 2.962048 3.155510 2.773445 ... 0.208901 0.332637 1.701868 0.000000 0.000000 0.000000 0.000000 0.065934 0.289231 1.000000 17 7.480421 5.143696 4.718489 2.732468 2.248740 0.000000 3.550376 2.926404 3.078314 2.199131 ... 0.330989 0.396484 1.478571 0.000000 0.000000 0.000000 0.005714 0.141099 0.368352 1.000000 14 6.975915 4.869301 4.380354 2.184727 0.000000 0.000000 3.394130 2.837693 2.824929 1.512106 ... 0.816154 1.009780 0.000000 0.000000 0.000000 0.000000 0.042857 0.224835 1.000000 1.000000 10 5.934816 4.322597 3.520753 0.865754 0.000000 0.000000 2.978688 2.600283 2.501777 0.801162 ... 0.897363 0.594615 0.000000 0.000000 0.000000 0.014286 0.129780 0.289560 1.000000 1.000000 7 4.733717 3.613382 2.468508 0.000000 0.000000 0.000000 2.452147 2.283770 1.817399 0.000000 ... 0.811978 0.000000 0.000000 0.000000 0.005714 0.036593 0.182198 1.000000 1.000000 1.000000 5 3.880456 3.003979 1.433578 0.000000 0.000000 0.000000 2.089969 1.930955 1.232235 0.000000 ... 1.078791 0.000000 0.000000 0.000000 0.044835 0.102527 0.247912 1.000000 1.000000 1.000000 3 2.940177 2.384334 0.000000 0.000000 0.000000 0.000000 1.608757 1.583988 0.000000 0.000000 ... 0.000000 0.000000 0.000000 0.000000 0.315824 0.315824 1.000000 1.000000 1.000000 1.000000 1 0.708996 0.712860 0.000000 0.000000 0.000000 0.000000 0.649894 0.749299 0.000000 0.000000 ... 0.000000 0.000000 0.000000 0.000000 0.390330 0.390330 1.000000 1.000000 1.000000 1.000000 <p>32 rows \u00d7 36 columns</p> <p>The bid prices data includes the mean and standard deviation of the leg or path bid price, by days prior.</p> In\u00a0[13]: Copied! <pre>summary.callback_data.leg_bid_prices\n</pre> summary.callback_data.leg_bid_prices Out[13]: leg_id 101 111 statistic days_prior mean 63 52.591280 152.434345 62 52.367467 152.140443 61 53.034745 151.776852 60 52.925320 152.223692 59 52.317152 152.609186 ... ... ... ... std_dev 4 115.335364 171.875792 3 127.414644 180.136785 2 141.228146 163.284747 1 130.021006 161.918451 0 130.021006 161.918451 <p>128 rows \u00d7 2 columns</p> In\u00a0[14]: Copied! <pre>sim1 = pax.Simulation(cfg)\n</pre> sim1 = pax.Simulation(cfg) In\u00a0[15]: Copied! <pre>@sim1.begin_sample_callback\ndef grab_forecasts(sim):\n    if sim.eng.sample not in [300, 375]:\n        return\n    return {f\"path-{p}\": sim.eng.paths.select(path_id=p).get_forecast_data() for p in [1, 9]}\n</pre> @sim1.begin_sample_callback def grab_forecasts(sim):     if sim.eng.sample not in [300, 375]:         return     return {f\"path-{p}\": sim.eng.paths.select(path_id=p).get_forecast_data() for p in [1, 9]} In\u00a0[16]: Copied! <pre>summary1 = sim1.run()\n</pre> summary1 = sim1.run() <pre></pre> <pre>Task Completed after 1.96 seconds\n</pre> <p>When run like this, we capture not the average path forecast over the simulation, but rather the exact path forecast for the selected paths (1 and 9) at sample days 300 and 375.  The data is stored in the <code>callback_data.begin_sample</code> attribute:</p> In\u00a0[17]: Copied! <pre>summary1.callback_data.begin_sample\n</pre> summary1.callback_data.begin_sample Out[17]: <pre>[{'trial': 0,\n  'sample': 300,\n  'path-1': &lt;passengersim_core.forecast_tools.ForecastData at 0x13876eb10&gt;,\n  'path-9': &lt;passengersim_core.forecast_tools.ForecastData at 0x138b8cbf0&gt;},\n {'trial': 0,\n  'sample': 375,\n  'path-1': &lt;passengersim_core.forecast_tools.ForecastData at 0x138bb4bf0&gt;,\n  'path-9': &lt;passengersim_core.forecast_tools.ForecastData at 0x138bb4950&gt;}]</pre> <p>We can review the details of each specific forecast by accessing the dashboard visualization.</p> In\u00a0[18]: Copied! <pre>summary1.callback_data.begin_sample[0][\"path-1\"].dashboard()\n</pre> summary1.callback_data.begin_sample[0][\"path-1\"].dashboard() Out[18]: <p>We can also access individual sub-tables of forecast data as pandas DataFrames, to manipulate or visualize as we like.</p> In\u00a0[19]: Copied! <pre>summary1.callback_data.begin_sample[0][\"path-1\"].history_sold_yieldable\n</pre> summary1.callback_data.begin_sample[0][\"path-1\"].history_sold_yieldable Out[19]: booking_class Y0 Y1 Y2 Y3 Y4 Y5 tf_index 0 0.192308 0.500000 0.307692 0.038462 1.923077 1.307692 1 0.153846 0.538462 0.307692 0.000000 0.576923 0.653846 2 0.076923 0.153846 0.269231 0.000000 1.192308 0.576923 3 0.115385 0.384615 0.153846 0.076923 0.961538 0.692308 4 0.038462 0.346154 0.153846 0.038462 0.692308 0.346154 5 0.038462 0.076923 0.115385 0.076923 0.692308 0.269231 6 0.038462 0.384615 0.230769 0.000000 1.000000 0.615385 7 0.000000 0.192308 0.115385 0.115385 1.307692 0.769231 8 0.230769 0.384615 0.384615 0.000000 0.923077 0.000000 9 0.076923 0.307692 0.269231 0.000000 1.115385 0.000000 10 0.192308 0.923077 0.500000 0.576923 0.000000 0.000000 11 0.230769 0.730769 0.461538 0.153846 0.000000 0.000000 12 0.153846 0.269231 0.576923 0.000000 0.000000 0.000000 13 0.153846 0.576923 0.653846 0.000000 0.000000 0.000000 14 0.269231 0.961538 0.000000 0.000000 0.000000 0.000000 15 0.038462 0.307692 0.000000 0.000000 0.000000 0.000000 In\u00a0[20]: Copied! <pre>summary1.callback_data.begin_sample[0][\"path-1\"].mean_in_timeframe\n</pre> summary1.callback_data.begin_sample[0][\"path-1\"].mean_in_timeframe Out[20]: booking_class Y0 Y1 Y2 Y3 Y4 Y5 tf_index 0 0.192308 0.500000 0.307692 0.038462 1.923077 1.307692 1 0.153846 0.538462 0.307692 0.000000 0.576923 0.653846 2 0.076923 0.153846 0.269231 0.000000 1.192308 0.576923 3 0.115385 0.384615 0.153846 0.076923 0.961538 0.692308 4 0.038462 0.346154 0.153846 0.038462 0.692308 0.346154 5 0.038462 0.076923 0.115385 0.076923 0.692308 0.290420 6 0.038462 0.384615 0.230769 0.000000 1.000000 0.676087 7 0.000000 0.192308 0.115385 0.115385 1.307692 0.855903 8 0.230769 0.384615 0.384615 0.000000 1.048620 0.000000 9 0.076923 0.307692 0.269231 0.000000 1.311751 0.000000 10 0.192308 0.923077 0.544670 0.740127 0.000000 0.000000 11 0.230769 0.730769 0.562779 0.247132 0.000000 0.000000 12 0.153846 0.359422 0.766563 0.000000 0.000000 0.000000 13 0.167882 0.711566 0.847891 0.000000 0.000000 0.000000 14 0.397941 1.222805 0.000000 0.000000 0.000000 0.000000 15 0.084310 0.438919 0.000000 0.000000 0.000000 0.000000"}, {"location": "user-guide/processing-outputs/tracers.nbconvert.html#tracing", "title": "Tracing\u00b6", "text": "<p>In addition to the completely flexible <code>callback</code> data storage system, PassengerSim also includes the ability to \"trace\" certain details of the simulation.  Traces are more aggregate than other callbacks, as they will follow the average values of various measures over many samples.  Unlike other aggregate measures, they allow for the selection of a limited number of micro-level details, e.g. path forecasts for specific paths, or bid prices on specific legs.  This contrasts with the database functionality, which can (relatively) efficiently store this information for all paths or legs. Tracing allows the analyst to probe a simulation for details of interest without becoming bogged down in the recording and storage of massive amounts of data that really isn't needed.</p>"}, {"location": "user-guide/processing-outputs/tracers.nbconvert.html#forecast-tracing", "title": "Forecast Tracing\u00b6", "text": "<p>The path forecast tracing capabilities allows us to record detailed data about a subset of Simulation path forecasts, so we can review them after the simulation.  The tracing will summarize the average forecasts for the specific paths, but will not store the sample-by-sample forecast details, which would be an enormous amount of detail that will require large amounts of memory or disk storage and may not be sufficiently useful for analysis. A similar tracing tool is available for leg forecasts as well.</p>"}, {"location": "user-guide/processing-outputs/tracers.nbconvert.html#bid-price-tracing", "title": "Bid Price Tracing\u00b6", "text": "<p>Similarly, the bid price tracing feature allows us to record detailed data about a subset of Simulation bid prices. We can record bid prices by leg, path, or both if desired.  Each tracer only attaches to the bid prices on a selected subset of individual legs, so as to not overwhelm the simulation with data.</p>"}, {"location": "user-guide/processing-outputs/tracers.nbconvert.html#dashboards", "title": "Dashboards\u00b6", "text": "<p>In addition to the usual summary reports, the output summary also provides the data needed to power detailed dashboard visualizations for each of the traced paths or legs.</p> <p>For the selected paths or legs, we can review a forecast dashboard that shows the forecast mean and std dev for each fare class from each DCP through departure, the mean forecast within each timeframe, as well as history data on yieldable and (if recorded separately) priceable sales, and average closure rates at each DCP.  The displayed data in each dashboard is specific to the selected path or leg, but averaged across all relevant (non-burned) samples in the simulation.</p>"}, {"location": "user-guide/processing-outputs/tracers.nbconvert.html#tracers-in-callback-data", "title": "Tracers in Callback Data\u00b6", "text": "<p>All the underlying data for these reports is stored in the summary's <code>callback_data</code> attribute, if you want to access it to parse or visualize it differently.  The forecast tracers contain selected summary statistics by path or leg, days prior, and fare class. These statistics are aggregated across all relevant (i.e. non-burned) samples.</p>"}, {"location": "user-guide/processing-outputs/tracers.nbconvert.html#relationship-to-callbacks", "title": "Relationship to Callbacks\u00b6", "text": "<p>Unlike other callback data, the tracers are not stored by sample day, as that would generally create an overwhelming amount of data to store, and we are typically not interested in that much detail.  If we are interested in grabbing and storing path forecast data for individual sample days, we can still do that with the regular callback interface.</p>"}, {"location": "user-guide/rm-systems/index.html", "title": "RM Systems", "text": "<p>A revenue management (RM) system is defined by one or more steps. The steps tell the simulation which demand untruncation, demand forecasting, and optimization algorithms to use.  These steps also provide information on the kind of forecast and optimization used (i.e., leg or path) and if path-level information should be aggregated to leg-level information before a step is performed.  Finally, these steps allow the user to specify algorithm-specific parameters, e.g., when using exponential smoothing the user can specify the smoothing constant, alpha.</p> <p>Each carrier should have an RM system that it uses. In PassengerSim, users have the ability to create a single RM system and assign it to all carriers, or to create multiple RM systems and assign different RM systems to different carriers.</p> <p>Below is an example that defines 4 RM systems.  It will be helpful to use these examples to understand the different step_types and options associated with each step_type.</p> <pre><code>rm_systems:\n  fcfs:\n    steps: []\n  rm_no_detruncation:\n    processes:\n      DCP:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: none\n        kind: leg\n      - step_type: forecast\n        name: forecast\n        algorithm: additive_pickup\n        alpha: 0.1\n        kind: leg\n      - step_type: emsr\n        name: optimization\n        algorithm: emsrb\n        kind: leg\n  rm_em:\n    steps:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: none\n        kind: leg\n      - step_type: forecast\n        name: forecast\n        algorithm: additive_pickup\n        alpha: 0.15\n        kind: leg\n      - step_type: fcfs\n        name: optimization\n  rm_probp:\n    steps:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: em\n        kind: path\n      - step_type: forecast\n        name: path_forecast\n        algorithm: exp_smoothing\n        alpha: 0.15\n        kind: path\n      - step_type: probp\n        name: optimization\n      - step_type: aggregation\n        name: aggregate\n      - step_type: emsr\n        name: optimization\n        algorithm: emsrb\n        kind: leg\n</code></pre> <p>The first RM system is based on a first-come, first-serve approach (named <code>fcfs</code>). No steps are defined for <code>fcfs</code> as there is no demand detruncation, demand forecasting, or optimization done with FCFS.  If step_types are defined when <code>fcfs</code> is explicitly specified as the optimization algorithm, they will be ignored.</p> <p>The second RM system, named <code>rm_no_detruncation</code>, is leg-based and uses an <code>additive_pickup</code> forecasting model with EMSRb and no demand detrunction. The alpha parameter that is specified in the forecast <code>step_type</code> will be ignored as it is not used for the additive pick-up model.</p> <p>The third RM system, named <code>rm_em</code>, is using the expectation-maximization (EM) method of detruncation with an exponential smoothing demand forecasting approach that has a smoothing constant of alpha of 0.15 with and EMSRb optimizer. Both the forecasts and optimization are done using leg-level inputs.</p> <p>Finally, the fourth RM system, named <code>rm_probp</code>, is also using the EM method of detruncation with an exponential smoothing dmeand forecasting approach that has a smoothing constant or alpha of 0.15.  Unlike in <code>rm_em</code> however, the untruncation and forecasting steps are done at the path level. The optimization step is based on probp that first finds displacement costs at a path level, then aggregates them to a leg-level in the aggregation step type, and finally calculates protection levels using EMSRb with leg-level demand inputs.</p> <p>Given an overview of how RM systems are constructed, let's now look at each step in detail.</p>"}, {"location": "user-guide/rm-systems/index.html#untruncation", "title": "Untruncation", "text": "<pre><code>- step_type: untruncation\n  name: untruncation\n  algorithm: none, em, naive1, naive2\n  kind: leg, path\n</code></pre> <p>There are three untruncation (also called detruncation) algorithms.  The first, <code>em</code>, is based on the expectation maximization method.  The <code>naive1</code> and <code>naive2</code> methods are based on Shebelov presentation. The untruncation steps can be performed at the path or leg level.</p>"}, {"location": "user-guide/rm-systems/index.html#forecast", "title": "Forecast", "text": "<pre><code>- step_type: 'forecast'\n  algorithm: { additive_pickup, exp_smoothing }\n  alpha: float\n  kind: { leg, path, hybrid }\n</code></pre> <p>There are two forecasting algorithms: exponential smoothing (that uses a smoothing or alpha parameter) and additive pickup model.  The exponential smoothing model does not (currently) incorporate trend or seasonality.</p> <p>The additive pickup model generates a forecast by considering the \"pickup\", or the number of new sales in a booking class, in each time period (DCP).  This model is additive in that the forecast of demand yet to come at given time is computed as the sum of forecast pickups in all future time periods.  This forecasting model does not consider the level of demand already accumulated, only the demand expected in the future.  The forecast is made considering the results from the prior 26 sample days. The additive pickup model ignores the value of the alpha parameter, and it should be omitted when using this algorithm.</p> <p>Either forecast algorithm can be performed based on data collected at either the leg or path level. However, if the forecast is at the leg level then detruncation must also have been performed at the same level.</p>"}, {"location": "user-guide/rm-systems/index.html#emsr-optimization", "title": "EMSR Optimization", "text": "<pre><code>- step_type: emsr\n  name: optimization\n  algorithm: emsra, emsrb\n  kind: leg\n</code></pre> <p>The step_type emsr is used for algorithms based on the expected marginal seat revenue approach and also can be used for fcfs. (although the first RM system defined as fcfs in the example above is a cleaner way to specify the fcfs option).</p>"}, {"location": "user-guide/rm-systems/index.html#probp-optimization", "title": "ProBP Optimization", "text": "<pre><code>- step_type: probp\n  name: optimization\n</code></pre> <p>The step_type probp does just as the name suggests - uses the probabilistic bid price algorithm to determine path-based displacment costs.  After these are found, two more steps are needed - the first is to aggregate path-level information to leg-level information and do the probp proration? and the next is to use the leg-level inputs to find protection levels using emsrb.</p>"}, {"location": "user-guide/rm-systems/emsr.html", "title": "EMSR Optimization", "text": "<p>Optimization is the most fundamental part of revenue management systems, is it is the process used to tailor the set of products being offered to maximize revenue. It typically occurs after untruncation and forecasting.</p> <p>PassengerSim offers several different optimization algorithms. One widely used algorithm is called EMSR (expected marginal seat revenue), which has a few variants, generally labels as \"A\", \"B\", and \"C\".</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b:\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: emsr #(1)!\n        algorithm: b\n        kind: leg\n</code></pre></p> <ol> <li>The <code>step_type</code> for EMSR optimization is <code>emsr</code>, this is how PassengerSim     identifies what to do in this step.</li> </ol>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim._old_rm.EmsrStep", "title": "EmsrStep", "text": "<p>               Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim._old_rm.EmsrStep.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: Literal[\n    \"a\", \"b\", \"emsra\", \"emsrb\", \"emsrc\", \"emsrg\"\n]\n</code></pre> <p>Which variant of the EMSR optimization algorithm should be applied.</p> <p>Currently the \"A\" and \"B\" variants are implemented. EMSRc computes the critical EMSR value as a proxy for displacement or bid price The \"G\" variant is EMSRb using a Gamma distribution (experimental)</p>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim._old_rm.EmsrStep.kind", "title": "kind  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['leg'] = 'leg'\n</code></pre> <p>EMSR (Expected Marginal Seat Revenue) is a leg-based optimization algorithm.</p> <p>The <code>kind</code> parameter is included in the interface for compatability, but setting any value here other than <code>leg</code> will result in an error.</p>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim._old_rm.EmsrStep.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[Any] = []\n</code></pre>"}, {"location": "user-guide/rm-systems/fcfs.html", "title": "FCFS Allocation", "text": "<p>First come first served (FCFS) is a simple method for allocating capacity to customers, and it operates pretty much as you would expect: customers whom arrive first are offered products, no attempt is made to optimize for anything.</p> <p>This process of capacity allocation will also occur if no RM optimization algorithm is applied, but the explicit FCFS step type allow the user to be intentional about selecting this algorithm, and to attach snapshot filters to the simulation if desired.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b:\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: fcfs #(1)!\n</code></pre></p> <ol> <li>The <code>step_type</code> for first come, first served is <code>fcfs</code>.</li> </ol>"}, {"location": "user-guide/rm-systems/fcfs.html#passengersim._old_rm.FcfsStep", "title": "FcfsStep", "text": "<p>               Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/fcfs.html#passengersim._old_rm.FcfsStep.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[Any] = []\n</code></pre>"}, {"location": "user-guide/rm-systems/forecast.html", "title": "Forecasting", "text": "<p>Forecasting is a key part of revenue management systems.  You need to know how many customers of each type you should expect, so you can tailor the set of products being offered to maximize revenue.</p> <p>In PassengerSim, forecasting is included as a step within an RM system, typically within the DCP process, after untruncation and before any optimization.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b:\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast #(1)!\n        algorithm: additive_pickup #(2)!\n        kind: leg #(3)!\n      - step_type: emsr\n        algorithm: b\n        kind: leg\n</code></pre></p> <ol> <li>The <code>step_type</code> for forecasting must be <code>forecast</code>, this is how PassengerSim     identifies what to do in this step.</li> <li>Several different algorithms are available for forecasting, see     below for details.</li> <li>Forecasts can be made at the leg or path level, see     below for details.</li> </ol>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim._old_rm.ForecastStep", "title": "ForecastStep", "text": "<p>               Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim._old_rm.ForecastStep.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: Literal[\n    \"exp_smoothing\",\n    \"additive_pickup\",\n    \"multiplicative_pickup\",\n]\n</code></pre> <p>Forecasting algorithm.</p> <p>There are several available forecasting algorithms:</p> <p><code>exp_smoothing</code>     is an exponential smoothing model.  This model uses the <code>alpha</code> parameter     to control the amount of smoothing applied.  It does not (currently)     incorporate trend effects or seasonality.</p> <p><code>additive_pickup</code>     is an additive pickup model, which generates a forecast by considering the     \"pickup\", or the number of new sales in a booking class, in each time     period (DCP).  This model is additive in that the forecast of demand yet     to come at given time is computed as the sum of forecast pickups in all     future time periods.  This forecasting model does not consider the level     of demand already accumulated, only the demand expected in the future. The     forecast is made considering the results from the prior 26 sample days.     The additive pickup model ignores the value of the alpha parameter, and it     can safely be omitted when using this algorithm.</p> <p><code>multiplicative_pickup</code>     is a multiplicative pickup model.  This model is in development.</p>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim._old_rm.ForecastStep.kind", "title": "kind  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>kind: Literal[\n    \"leg\",\n    \"path\",\n    \"hybrid\",\n    \"conditional\",\n    \"leg-conditional\",\n    \"leg-hybrid\",\n] = \"leg\"\n</code></pre> <p>Level of collected demand data that should be used for forecasting.</p> <p>Hybrid forecasting is primarily a path-based forecast, but it includes EM untruncation of yieldable demand.</p>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim._old_rm.ForecastStep.alpha", "title": "alpha  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>alpha: float = 0.15\n</code></pre> <p>Exponential smoothing factor.</p> <p>This setting is ignored if the forecast algorithm is not \"exp_smoothing\".</p>"}, {"location": "user-guide/rm-systems/probp.html", "title": "ProBP Optimization", "text": "<p>Optimization is the most fundamental part of revenue management systems, is it is the process used to tailor the set of products being offered to maximize revenue. It typically occurs after untruncation and forecasting.</p> <p>PassengerSim offers several different optimization algorithms, including probabilistic bid price (ProBP) optimization.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_probp:\n    availability_control: bp #(2)!\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: probp #(1)!\n</code></pre></p> <ol> <li>The <code>step_type</code> for probabilistic bid price optimization is <code>probp</code>, this is     how PassengerSim identifies what to do in this step.</li> <li>To apply the ProBP optimization results, the <code>rm_system</code> should be set to use     <code>bp</code> (bid price) availability controls.</li> </ol>"}, {"location": "user-guide/rm-systems/probp.html#passengersim._old_rm.ProBpStep", "title": "ProBpStep", "text": "<p>               Bases: <code>RmStep</code></p> <p>Implements ProBP as an RM Step</p>"}, {"location": "user-guide/rm-systems/probp.html#passengersim._old_rm.ProBpStep.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[Any] = []\n</code></pre>"}, {"location": "user-guide/rm-systems/untruncation.html", "title": "Untruncation", "text": "<p>Untruncation is a part of most revenue management systems.  It is a mathematical process whereby we estimate the number of customers there would have been for a particular product, assuming we would have offered the product for sale to all comers.  In the cases where we actually did offer the product to all, then there is nothing for this algorithm to do beyond counting our actual sales.  However, many times our RM systems will limit the number of customers we actually accept, and our actual sales are \"truncated\".  Untruncation is needed to approximate how many customers were lost.</p> <p>In PassengerSim, untruncation is included as a step within an RM system, typically within the DCP process before any forecasting or optimization steps.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b: #(4)!\n    processes:\n      DCP:\n      - step_type: untruncation #(1)!\n        algorithm: em #(2)!\n        kind: leg #(3)!\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: emsr\n        algorithm: b\n        kind: leg\n</code></pre></p> <ol> <li>The <code>step_type</code> must be <code>untruncation</code>, as this is how PassengerSim     identifies what to do in this step.</li> <li>Several different algorithms are available for untruncation, see     below for details.</li> <li>Untruncation can be done at the leg or path level, see     below for details.</li> <li>This is showing that <code>basic_emsr_b</code> is the name of this RM system.     Elsewhere in the configuration (not shown in this example snippet) you will     define carriers, and each will be assigned an RM system using these names.</li> </ol>"}, {"location": "user-guide/rm-systems/untruncation.html#passengersim._old_rm.UntruncationStep", "title": "UntruncationStep", "text": "<p>               Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/untruncation.html#passengersim._old_rm.UntruncationStep.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: Literal[\n    \"em\",\n    \"em_py\",\n    \"none\",\n    \"naive1\",\n    \"naive2\",\n    \"naive3\",\n    \"pd\",\n    \"mfem\",\n]\n</code></pre> <p>Untruncation algorithm.</p> <p>There are several available algorithms:</p> <p><code>none</code>     applies no untruncation, and assumes that demand was the same as sales.     Applying this algorithm is still important even if no detruncation is     desired, as PassengerSim tracks historical demand separately from sales     and without \"none\" the historical demand used in forecasting would be     zero.</p> <p><code>em</code>     is an expectation-maximization model.</p> <p><code>em_py</code>     is an expectation-maximization model implemented in Python.  It is slow     but useful for educational purposes.</p> <p><code>naive1</code>     is not recommended for use.</p> <p><code>naive2</code>     is not recommended for use.</p> <p><code>naive3</code>     is not recommended for use.</p> <p><code>pd</code>     is a projection-detruncation model, based on the method developed by     Hopperstad and described by Weatherford &amp; Polt.</p> <p><code>mfem</code>     Multi-Flight Expectation Maximization.  Takes into account spill and recapture across multiple departures</p>"}, {"location": "user-guide/rm-systems/untruncation.html#passengersim._old_rm.UntruncationStep.kind", "title": "kind  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['leg', 'path', 'hybrid'] = 'leg'\n</code></pre> <p>Level of collected demand data that should be used for untruncation.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html", "title": "Carrier-level Summaries", "text": "Out[1]: <pre>PosixPath('saved-output/simple-sim.20251112-090459.pkl.lz4')</pre> In\u00a0[2]: Copied! <pre>from passengersim import SimulationTables\n\nsummary = SimulationTables.from_pickle(\"saved-output/simple-sim\")\n</pre> from passengersim import SimulationTables  summary = SimulationTables.from_pickle(\"saved-output/simple-sim\") In\u00a0[3]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[3]: In\u00a0[4]: Copied! <pre>summary.fig_carrier_mileage()\n</pre> summary.fig_carrier_mileage() Out[4]: In\u00a0[5]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[5]: <p>Alternatively, this function can also display the average leg load factor, which considers the fraction of capacity sold on each leg, and weights all legs uniformly.</p> In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors(load_measure=\"avg_leg_lf\")\n</pre> summary.fig_carrier_load_factors(load_measure=\"avg_leg_lf\") Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_leg_load_factor_distribution()\n</pre> summary.fig_leg_load_factor_distribution() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_carrier_local_share()\n</pre> summary.fig_carrier_local_share() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_carrier_local_share(\"leg_pax\")\n</pre> summary.fig_carrier_local_share(\"leg_pax\") Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_carrier_yields()\n</pre> summary.fig_carrier_yields() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[11]: In\u00a0[12]: Copied! <pre>from passengersim.contrast import Contrast\n\ncomps = Contrast(\n    Simple=summary,\n    Untruncated=SimulationTables.from_pickle(\"saved-output/untruncated-sim\"),\n)\n</pre> from passengersim.contrast import Contrast  comps = Contrast(     Simple=summary,     Untruncated=SimulationTables.from_pickle(\"saved-output/untruncated-sim\"), ) In\u00a0[13]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_carrier_load_factors(load_measure=\"avg_leg_lf\")\n</pre> comps.fig_carrier_load_factors(load_measure=\"avg_leg_lf\") Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_carrier_yields()\n</pre> comps.fig_carrier_yields() Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[17]:"}, {"location": "user-guide/viz/carriers.nbconvert.html#carrier-level-summaries", "title": "Carrier-level Summaries\u00b6", "text": "<p>This page provides an overview of the carrier-level summary visualizations available in PassengerSim.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#one-simulation-run", "title": "One Simulation Run\u00b6", "text": "<p>The results from a simulation run are stored in a <code>SimulationTables</code> instance, which is returned from <code>Simulation.run</code> or can be loaded from a stored database of results. This object has a number of methods to generate visualizations for the results of the simulation.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#revenues", "title": "Revenues\u00b6", "text": "<p><code>SimulationTables.fig_carrier_revenues</code></p> <p>Display the average revenues by carrier.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#mileage", "title": "Mileage\u00b6", "text": "<p><code>SimulationTables.fig_carrier_mileage</code></p> <p>Display the available seat miles (ASM) and average revenue passenger miles (RPM) by carrier.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#load-factors", "title": "Load Factors\u00b6", "text": "<p><code>SimulationTables.fig_carrier_load_factors</code></p> <p>Display the average system load factors by carrier.  The system load factor is calculated based on ASM and RPM figures for the carrier, which weights larger capacity vehicles and longer distance legs more heavily, to reflect their larger relative importance in evaluating carrier performance.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#load-factor-distributions", "title": "Load Factor Distributions\u00b6", "text": "<p><code>SimulationTables.fig_leg_load_factor_distribution</code></p> <p>Display the distribution of leg load factors.  This can be done for all carriers individually (<code>by_carrier=True</code>, or omitted as this is the default), or across carriers in aggregate (<code>by_carrier=False</code>), for a specific carrier (<code>by_carrier='AL1'</code>).</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#local-passenger-percentages", "title": "Local Passenger Percentages\u00b6", "text": "<p>Display the percentage of local passengers by carrier.  By default, this is the percentage of bookings that are local (i.e. flying on only a single leg). Alternatively, this method accepts a <code>load_measure</code> argument that can be set to 'leg_pax', which will report the percentage of leg passengers who are local -- the numerator of this ratio is the same, but the denominator is larger (assuming there are any connecting passengers in the network).</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#yields", "title": "Yields\u00b6", "text": "<p><code>SimulationTables.fig_carrier_yields</code></p> <p>Display the average yield (revenue per passenger mile) by carrier.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#fare-class-mix", "title": "Fare Class Mix\u00b6", "text": "<p><code>SimulationTables.fig_fare_class_mix</code></p> <p>Display the fare class mix by carrier.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#contrasting-multiple-runs", "title": "Contrasting Multiple Runs\u00b6", "text": "<p>Similar figures are available contrasting the results of multiple runs, by bundling multiple <code>SimulationTables</code> objects in a <code>Contrast</code> instance.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#revenues", "title": "Revenues\u00b6", "text": "<p><code>Contrast.fig_carrier_revenues</code>.</p> <p>Display the average revenues by carrier.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#load-factors", "title": "Load Factors\u00b6", "text": "<p><code>Contrast.fig_carrier_load_factors</code>.</p> <p>Display the average system load factors by carrier.  The system load factor is calculated based on ASM and RPM figures for the carrier, which weights larger capacity vehicles and longer distance legs more heavily, to reflect their larger relative importance in evaluating carrier performance.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#yields", "title": "Yields\u00b6", "text": "<p><code>Contrast.fig_carrier_yields</code>.</p> <p>Display the average yield (revenue per passenger mile) by carrier.</p>"}, {"location": "user-guide/viz/carriers.nbconvert.html#fare-class-mix", "title": "Fare Class Mix\u00b6", "text": "<p><code>Contrast.fig_fare_class_mix</code>.</p> <p>Display the fare class mix by carrier.</p>"}]}