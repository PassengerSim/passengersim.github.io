var __index = {"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "index.html", "title": "Home", "text": ""}, {"location": "API/index.html", "title": "PassengerSim API", "text": "<p>The main <code>passengersim</code> package includes configuration and analysis tools.  It is freely available for use.</p> <p>The <code>passengersim.core</code> sub-package is only available to authorized users.</p>"}, {"location": "API/contrast.html", "title": "Contrasting Results", "text": ""}, {"location": "API/contrast.html#passengersim.contrast.Contrast", "title": "Contrast", "text": "<p>             Bases: <code>dict</code></p> Source code in <code>passengersim/contrast.py</code> <pre><code>class Contrast(dict):\n    def apply(\n        self, func: Callable, axis: int | Literal[\"index\", \"columns\", \"rows\"] = 0\n    ) -&gt; pd.DataFrame | pd.Series:\n        data = {}\n        for k, v in self.items():\n            if v is not None:\n                data[k] = func(v)\n        try:\n            return pd.concat(data, axis=axis, names=[\"source\"])\n        except TypeError:\n            return pd.Series(data).rename_axis(index=\"source\")\n\n    def __getattr__(self, attr):\n        if attr.startswith(\"fig_\"):\n            g = globals()\n            if attr in g:\n                return partial(g[attr], self)\n                # return lambda *a, **k: g[attr](self, *a, **k)\n        raise AttributeError(attr)\n\n    def __dir__(self):\n        x = set(super().__dir__())\n        x |= {g for g in globals() if g.startswith(\"fig_\")}\n        return sorted(x)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.__dir__", "title": "__dir__", "text": "<pre><code>__dir__()\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def __dir__(self):\n    x = set(super().__dir__())\n    x |= {g for g in globals() if g.startswith(\"fig_\")}\n    return sorted(x)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.__getattr__", "title": "__getattr__", "text": "<pre><code>__getattr__(attr)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def __getattr__(self, attr):\n    if attr.startswith(\"fig_\"):\n        g = globals()\n        if attr in g:\n            return partial(g[attr], self)\n            # return lambda *a, **k: g[attr](self, *a, **k)\n    raise AttributeError(attr)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.apply", "title": "apply", "text": "<pre><code>apply(\n    func: Callable,\n    axis: int | Literal[\"index\", \"columns\", \"rows\"] = 0,\n) -&gt; pd.DataFrame | pd.Series\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def apply(\n    self, func: Callable, axis: int | Literal[\"index\", \"columns\", \"rows\"] = 0\n) -&gt; pd.DataFrame | pd.Series:\n    data = {}\n    for k, v in self.items():\n        if v is not None:\n            data[k] = func(v)\n    try:\n        return pd.concat(data, axis=axis, names=[\"source\"])\n    except TypeError:\n        return pd.Series(data).rename_axis(index=\"source\")\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_bid_price_history", "title": "fig_bid_price_history", "text": "<pre><code>fig_bid_price_history(\n    summaries,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_bid_price_history(\n    summaries,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df=False,\n):\n    if cap is None:\n        bp_mean = \"bid_price_mean\"\n    elif cap == \"some\":\n        bp_mean = \"some_cap_bid_price_mean\"\n    elif cap == \"zero\":\n        bp_mean = \"zero_cap_bid_price_mean\"\n    else:\n        raise ValueError(f\"cap={cap!r} not in ['some', 'zero', None]\")\n\n    if not isinstance(by_carrier, str):\n        raise NotImplementedError(\n            \"contrast.fig_bid_price_history requires looking at a single carrier (set `by_carrier`)\"\n        )\n    df = _assemble(\n        summaries,\n        \"bid_price_history\",\n        by_carrier=by_carrier,\n        show_stdev=show_stdev,\n        cap=cap,\n    )\n    if raw_df:\n        return df\n\n    line_encoding = dict(\n        x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"),\n        y=alt.Y(bp_mean, title=\"Bid Price\"),\n        color=\"source:N\",\n    )\n    chart = alt.Chart(df)\n    fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n    if show_stdev:\n        area_encoding = dict(\n            x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"),\n            y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"),\n            y2=alt.Y2(\"bid_price_upper:Q\", title=\"Bid Price\"),\n            color=\"source:N\",\n        )\n        bound = chart.mark_area(\n            opacity=0.1,\n            interpolate=\"step-before\",\n        ).encode(**area_encoding)\n        bound_line = chart.mark_line(\n            opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\"\n        ).encode(\n            x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"),\n            color=\"source:N\",\n        )\n        top_line = bound_line.encode(y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"))\n        bottom_line = bound_line.encode(y=alt.Y(\"bid_price_upper:Q\", title=\"Bid Price\"))\n        fig = fig + bound + top_line + bottom_line\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_bookings_by_timeframe", "title": "fig_bookings_by_timeframe", "text": "<pre><code>fig_bookings_by_timeframe(\n    summaries: dict[str, SummaryTables],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df=False,\n    source_labels: bool = False,\n) -&gt; alt.Chart | pd.DataFrame\n</code></pre> <p>Generate a figure contrasting bookings by timeframe for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>             (<code>dict[str, SummaryTables]</code>)         \u2013          <p>One or more SummaryTables to compare. The keys of this dictionary are the text names used to label the \"source\" for each set of data in the figure.</p> </li> <li> <code>by_carrier</code>             (<code>bool or str</code>, default:                 <code>True</code> )         \u2013          <p>Whether to differentiate carriers by colors (the default) or give the name of a particular carrier as a string to filter the results shown in the figure to only that one carrier.</p> </li> <li> <code>by_class</code>             (<code>bool or str</code>, default:                 <code>False</code> )         \u2013          <p>Whether to differentiate booking class by colors (the default) or give the name of a particular booking class as a string to filter the results shown in the figure to only that one booking class.</p> </li> <li> <code>raw_df</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Set to true to return the raw dataframe used to generate the figure, instead of the figure itself.</p> </li> <li> <code>source_labels</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Write source labels above the columns of the figure. Source labels are also available as tool tips, but if the figure is being shared as an image without tooltips, the source labels may make it easier to interpret.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>report</code>             (<code>Reporter</code>)         \u2013          <p>Giving a reporter for this keyword only argument allow you to automatically append this figure to the report (in addition to returning it for display or other processing).</p> </li> <li> <code>trace</code>             (<code>ExcelWriter or (ExcelWriter, str)</code>)         \u2013          <p>Write the raw dataframe backing this figure to the Excel workbook.</p> </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_bookings_by_timeframe(\n    summaries: dict[str, SummaryTables],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df=False,\n    source_labels: bool = False,\n) -&gt; alt.Chart | pd.DataFrame:\n    \"\"\"\n    Generate a figure contrasting bookings by timeframe for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n        One or more SummaryTables to compare. The keys of this dictionary are the\n        text names used to label the \"source\" for each set of data in the figure.\n    by_carrier : bool or str, default True\n        Whether to differentiate carriers by colors (the default) or give the name\n        of a particular carrier as a string to filter the results shown in the\n        figure to only that one carrier.\n    by_class : bool or str, default False\n        Whether to differentiate booking class by colors (the default) or give the\n        name of a particular booking class as a string to filter the results shown\n        in the figure to only that one booking class.\n    raw_df : bool, default False\n        Set to true to return the raw dataframe used to generate the figure, instead\n        of the figure itself.\n    source_labels : bool, default False\n        Write source labels above the columns of the figure. Source labels are also\n        available as tool tips, but if the figure is being shared as an image without\n        tooltips, the source labels may make it easier to interpret.\n\n    Other Parameters\n    ----------------\n    report : xmle.Reporter, optional\n        Giving a reporter for this keyword only argument allow you to automatically\n        append this figure to the report (in addition to returning it for display\n        or other processing).\n    trace : pd.ExcelWriter or (pd.ExcelWriter, str), optional\n        Write the raw dataframe backing this figure to the Excel workbook.\n    \"\"\"\n    if by_carrier is True and by_class is True:\n        raise NotImplementedError(\"comparing by both class and carrier is messy\")\n    df = _assemble(\n        summaries, \"bookings_by_timeframe\", by_carrier=by_carrier, by_class=by_class\n    )\n    source_order = list(summaries.keys())\n\n    title = \"Bookings by Timeframe\"\n    if by_class is True:\n        title = \"Bookings by Timeframe and Booking Class\"\n    title_annot = []\n    if isinstance(by_carrier, str):\n        title_annot.append(by_carrier)\n    if isinstance(by_class, str):\n        title_annot.append(f\"Class {by_class}\")\n    if title_annot:\n        title = f\"{title} ({', '.join(title_annot)})\"\n\n    if raw_df:\n        df.attrs[\"title\"] = title\n        return df\n\n    if by_class:\n        if isinstance(by_class, str):\n            color = alt.Color(\"source:N\", title=\"Source\", sort=source_order).title(\n                \"Source\"\n            )\n            tooltips = ()\n        else:\n            color = alt.Color(\"booking_class:N\").title(\"Booking Class\")\n            tooltips = (alt.Tooltip(\"booking_class\", title=\"Booking Class\"),)\n        chart = alt.Chart(df.sort_values(\"source\", ascending=False))\n        chart_1 = chart.mark_bar().encode(\n            color=color,\n            x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n            xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n            y=alt.Y(\"sold\", stack=True),\n            tooltip=[\n                alt.Tooltip(\"source:N\", title=\"Source\"),\n                alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                *tooltips,\n                alt.Tooltip(\"rrd\", title=\"DfD\"),\n                alt.Tooltip(\"sold\", format=\".2f\"),\n            ],\n        )\n        chart_2 = chart.mark_text(\n            color=\"#616161\",\n            yOffset=-2,\n            angle=270,\n            fontSize=8,\n            baseline=\"middle\",\n            align=\"left\",\n        ).encode(\n            text=alt.Text(\"source:N\", title=\"Source\"),\n            x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n            xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n            # shape=alt.Shape(\"source:N\", title=\"Source\", sort=source_order),\n            y=alt.Y(\"sum(sold)\", title=None),\n        )\n        return (\n            ((chart_1 + chart_2) if source_labels else chart_1)\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"paxtype:N\", title=\"Passenger Type\"),\n                title=title,\n            )\n            .configure_title(fontSize=18)\n        )\n    elif by_carrier is True:\n        return (\n            alt.Chart(df.sort_values(\"source\", ascending=False))\n            .mark_bar()\n            .encode(\n                color=alt.Color(\"carrier:N\").title(\"Carrier\"),\n                x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n                xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n                y=alt.Y(\"sold\", stack=True),\n                tooltip=[\n                    alt.Tooltip(\"source:N\", title=\"Source\"),\n                    alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\"rrd\", title=\"DfD\"),\n                    alt.Tooltip(\"sold\", format=\".2f\"),\n                ],\n            )\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"paxtype:N\", title=\"Passenger Type\"),\n                title=title,\n            )\n            .configure_title(fontSize=18)\n        )\n    else:\n        return (\n            alt.Chart(df.sort_values(\"source\", ascending=False), title=title)\n            .mark_line()\n            .encode(\n                color=alt.Color(\"source:N\", title=\"Source\", sort=source_order),\n                x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n                y=\"sold\",\n                strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n                strokeWidth=alt.StrokeWidth(\n                    \"source:N\", title=\"Source\", sort=source_order\n                ),\n                tooltip=[\n                    alt.Tooltip(\"source:N\", title=\"Source\"),\n                    alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"rrd\", title=\"DfD\"),\n                    alt.Tooltip(\"sold\", format=\".2f\"),\n                ],\n            )\n            .properties(\n                width=500,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n            .configure_title(fontSize=18)\n        )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_load_factors", "title": "fig_carrier_load_factors", "text": "<pre><code>fig_carrier_load_factors(\n    summaries,\n    raw_df=False,\n    load_measure: Literal[\n        \"sys_lf\", \"avg_leg_lf\"\n    ] = \"sys_lf\",\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = True,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_load_factors(\n    summaries,\n    raw_df=False,\n    load_measure: Literal[\"sys_lf\", \"avg_leg_lf\"] = \"sys_lf\",\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = True,\n):\n    measure_name = {\n        \"sys_lf\": \"System Load Factor\",\n        \"avg_leg_lf\": \"Leg Load factor\",\n    }.get(load_measure, \"Load Factor\")\n    df = _assemble(summaries, \"carrier_load_factors\", load_measure=load_measure)\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = f\"Carrier {measure_name}s\"\n        return df\n    return _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=load_measure,\n        measure_name=measure_name,\n        measure_format=\".2f\",\n        orient=orient,\n        title=f\"Carrier {measure_name}s\",\n        ratio=ratio,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_revenues", "title": "fig_carrier_revenues", "text": "<pre><code>fig_carrier_revenues(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = True,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_revenues(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = True,\n):\n    df = _assemble(summaries, \"carrier_revenues\")\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Revenues\"\n        return df\n    return _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=\"avg_rev\",\n        measure_name=\"Revenue ($)\",\n        measure_format=\"$.4s\",\n        orient=orient,\n        title=\"Carrier Revenues\",\n        ratio=ratio,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_yields", "title": "fig_carrier_yields", "text": "<pre><code>fig_carrier_yields(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = True,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_yields(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = True,\n):\n    df = _assemble(summaries, \"carrier_yields\")\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Yields\"\n        return df\n    return _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=\"yield\",\n        measure_name=\"Yield ($)\",\n        measure_format=\"$.4f\",\n        orient=orient,\n        title=\"Carrier Yields\",\n        ratio=ratio,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_demand_to_come", "title": "fig_demand_to_come", "text": "<pre><code>fig_demand_to_come(\n    summaries: Contrast,\n    func: Literal[\"mean\", \"std\"] = \"mean\",\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_demand_to_come(\n    summaries: Contrast,\n    func: Literal[\"mean\", \"std\"] = \"mean\",\n    raw_df=False,\n):\n    def dtc_seg(s):\n        if s is None:\n            return pd.DataFrame(columns=[\"segment\"])\n        sum_on = []\n        if \"orig\" in s.index.names:\n            sum_on.append(\"orig\")\n        if \"dest\" in s.index.names:\n            sum_on.append(\"dest\")\n        if sum_on:\n            s = s.groupby(s.index.names.difference(sum_on)).sum()\n        return s\n\n    if func == \"mean\":\n        y_title = \"Mean Demand to Come\"\n        demand_to_come_by_segment = summaries.apply(\n            lambda s: dtc_seg(s.demand_to_come)\n            .groupby(\"segment\", observed=False)\n            .mean()\n            .stack(),\n            axis=1,\n        )\n        df = demand_to_come_by_segment.stack().rename(\"dtc\").reset_index()\n    elif func == \"std\":\n        y_title = \"Std Dev Demand to Come\"\n        demand_to_come_by_segment = summaries.apply(\n            lambda s: dtc_seg(s.demand_to_come)\n            .groupby(\"segment\", observed=False)\n            .std()\n            .stack(),\n            axis=1,\n        )\n        df = demand_to_come_by_segment.stack().rename(\"dtc\").reset_index()\n    else:\n        raise ValueError(f\"func must be in [mean, std] not {func}\")\n    if raw_df:\n        return df\n    return (\n        alt.Chart(df)\n        .mark_line()\n        .encode(\n            x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n            y=alt.Y(\"dtc:Q\").title(y_title),\n            color=\"segment:N\",\n            strokeDash=\"source:N\",\n        )\n    )  # .properties(width=500, height=400)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_fare_class_mix", "title": "fig_fare_class_mix", "text": "<pre><code>fig_fare_class_mix(\n    summaries, raw_df=False, label_threshold=0.06\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_fare_class_mix(summaries, raw_df=False, label_threshold=0.06):\n    df = _assemble(summaries, \"fare_class_mix\")\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Fare Class Mix\"\n        return df\n    import altair as alt\n\n    label_threshold_value = (\n        df.groupby([\"carrier\", \"source\"]).avg_sold.sum().max() * label_threshold\n    )\n    chart = alt.Chart(df).transform_calculate(\n        halfsold=\"datum.avg_sold / 2.0\",\n    )\n    bars = chart.mark_bar().encode(\n        x=alt.X(\"source:N\", title=\"Source\", sort=source_order),\n        y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n        color=\"booking_class\",\n        tooltip=[\n            \"source\",\n            \"booking_class\",\n            alt.Tooltip(\"avg_sold\", format=\".2f\"),\n        ],\n    )\n    text = chart.mark_text(dx=0, dy=3, color=\"white\", baseline=\"top\").encode(\n        x=alt.X(\"source:N\", title=\"Source\", sort=source_order),\n        y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n        text=alt.Text(\"avg_sold:Q\", format=\".2f\"),\n        opacity=alt.condition(\n            f\"datum.avg_sold &lt; {label_threshold_value:.3f}\",\n            alt.value(0),\n            alt.value(1),\n        ),\n        order=alt.Order(\"booking_class:N\", sort=\"descending\"),\n    )\n    return (\n        (bars + text)\n        .properties(\n            width=200,\n            height=300,\n        )\n        .facet(\n            column=alt.Column(\"carrier:N\", title=\"Carrier\"),\n            title=\"Carrier Fare Class Mix\",\n        )\n        .configure_title(fontSize=18)\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_leg_forecasts", "title": "fig_leg_forecasts", "text": "<pre><code>fig_leg_forecasts(\n    summaries,\n    raw_df=False,\n    by_flt_no=None,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"]\n    | list[Literal[\"mu\", \"sigma\"]] = \"mu\",\n    agg_booking_classes: bool = False,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_leg_forecasts(\n    summaries,\n    raw_df=False,\n    by_flt_no=None,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"] | list[Literal[\"mu\", \"sigma\"]] = \"mu\",\n    agg_booking_classes: bool = False,\n):\n    if isinstance(of, list):\n        if raw_df:\n            raise NotImplementedError\n        fig = fig_leg_forecasts(\n            summaries,\n            by_flt_no=by_flt_no,\n            by_class=by_class,\n            of=of[0],\n            agg_booking_classes=agg_booking_classes,\n        )\n        for of_ in of[1:]:\n            fig |= fig_leg_forecasts(\n                summaries,\n                by_flt_no=by_flt_no,\n                by_class=by_class,\n                of=of_,\n                agg_booking_classes=agg_booking_classes,\n            )\n        return fig\n    df = _assemble(\n        summaries, \"leg_forecasts\", by_flt_no=by_flt_no, by_class=by_class, of=of\n    )\n    color = \"booking_class:N\"\n    if isinstance(by_class, str):\n        color = \"source:N\"\n    if agg_booking_classes or not by_class:\n        color = \"source:N\"\n        if of == \"mu\":\n            df = (\n                df.groupby([\"source\", \"flt_no\", \"rrd\"])\n                .forecast_mean.sum()\n                .reset_index()\n            )\n        elif of == \"sigma\":\n\n            def sum_sigma(x):\n                return np.sqrt(sum(x**2))\n\n            df = (\n                df.groupby([\"source\", \"flt_no\", \"rrd\"])\n                .forecast_stdev.apply(sum_sigma)\n                .reset_index()\n            )\n    if raw_df:\n        df.attrs[\"title\"] = \"Average Leg Forecasts\"\n        return df\n    return _fig_forecasts(\n        df,\n        facet_on=\"flt_no\" if not isinstance(by_flt_no, int) else None,\n        y=\"forecast_mean\" if of == \"mu\" else \"forecast_stdev\",\n        y_title=\"Mean Demand Forecast\" if of == \"mu\" else \"Std Dev Demand Forecast\",\n        color=color,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_path_forecasts", "title": "fig_path_forecasts", "text": "<pre><code>fig_path_forecasts(\n    summaries,\n    raw_df=False,\n    by_path_id=None,\n    path_names: dict | None = None,\n    agg_booking_classes: bool = False,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\", \"closed\"] = \"mu\",\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_path_forecasts(\n    summaries,\n    raw_df=False,\n    by_path_id=None,\n    path_names: dict | None = None,\n    agg_booking_classes: bool = False,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\", \"closed\"] = \"mu\",\n):\n    if isinstance(of, list):\n        if raw_df:\n            df = {\n                _of: fig_path_forecasts(\n                    summaries,\n                    by_path_id=by_path_id,\n                    path_names=path_names,\n                    by_class=by_class,\n                    of=of[0],\n                    raw_df=raw_df,\n                )\n                for _of in of\n            }\n            return pd.concat(df, axis=0, names=[\"measurement\"]).reset_index(0)\n        fig = fig_path_forecasts(\n            summaries,\n            by_path_id=by_path_id,\n            path_names=path_names,\n            by_class=by_class,\n            of=of[0],\n        )\n        for of_ in of[1:]:\n            fig |= fig_path_forecasts(\n                summaries,\n                by_path_id=by_path_id,\n                path_names=path_names,\n                by_class=by_class,\n                of=of_,\n            )\n        return fig\n    df = _assemble(\n        summaries, \"path_forecasts\", by_path_id=by_path_id, of=of, by_class=by_class\n    )\n    list(summaries.keys())\n    if path_names is not None:\n        df[\"path_id\"] = df[\"path_id\"].apply(lambda x: path_names.get(x, str(x)))\n    color = \"booking_class:N\"\n    if isinstance(by_class, str):\n        color = \"source:N\"\n    if agg_booking_classes:\n        if of == \"mu\":\n            df = (\n                df.groupby([\"source\", \"path_id\", \"rrd\"])\n                .forecast_mean.sum()\n                .reset_index()\n            )\n        elif of == \"sigma\":\n\n            def sum_sigma(x):\n                return np.sqrt(sum(x**2))\n\n            df = (\n                df.groupby([\"source\", \"path_id\", \"rrd\"])\n                .forecast_stdev.apply(sum_sigma)\n                .reset_index()\n            )\n        elif of == \"closed\":\n            df = (\n                df.groupby([\"source\", \"path_id\", \"rrd\"])\n                .forecast_closed_in_tf.mean()\n                .reset_index()\n            )\n    if raw_df:\n        if of == \"mu\":\n            df.attrs[\"title\"] = \"Average Path Forecast Means\"\n        elif of == \"sigma\":\n            df.attrs[\"title\"] = \"Average Path Forecast Standard Deviations\"\n        elif of == \"closed\":\n            df.attrs[\"title\"] = \"Average Path Forecast Closed in Timeframe\"\n        return df\n    if of == \"mu\":\n        y = \"forecast_mean\"\n        y_title = \"Mean Demand Forecast\"\n    elif of == \"sigma\":\n        y = \"forecast_stdev\"\n        y_title = \"Std Dev Demand Forecast\"\n    elif of == \"closed\":\n        y = \"forecast_closed_in_tf\"\n        y_title = \"Mean Time Frame Closed of Demand Forecast\"\n    else:\n        raise NotImplementedError\n\n    # use ordinal data type for DCP labels unless the underlying data is daily, then use Q\n    rrd_ntype = \"O\"\n    if len(df[\"rrd\"].value_counts()) &gt; 30:\n        rrd_ntype = \"Q\"\n    return _fig_forecasts(\n        df,\n        facet_on=\"path_id\" if not isinstance(by_path_id, int) else None,\n        y=y,\n        y_title=y_title,\n        color=color,\n        rrd_ntype=rrd_ntype,\n    )\n</code></pre>"}, {"location": "API/simulation.html", "title": "Simulation", "text": ""}, {"location": "API/simulation.html#passengersim.driver.Simulation", "title": "Simulation", "text": "Source code in <code>passengersim/driver.py</code> <pre><code>class Simulation:\n    @classmethod\n    def from_yaml(\n        cls,\n        filenames: pathlib.Path | list[pathlib.Path],\n        output_dir: pathlib.Path | None = None,\n    ):\n        config = passengersim.config.Config.from_yaml(filenames)\n        return cls(config, output_dir)\n\n    def __init__(\n        self,\n        config: Config,\n        output_dir: pathlib.Path | None = None,\n    ):\n        if output_dir is None:\n            import tempfile\n\n            self._tempdir = tempfile.TemporaryDirectory()\n            output_dir = os.path.join(self._tempdir.name, \"test1\")\n        self.cnx = None\n        if config.simulation_controls.write_raw_files:\n            try:\n                from passengersim_core.utils import FileWriter\n            except ImportError:\n                self.file_writer = None\n            else:\n                self.file_writer = FileWriter.FileWriter(output_dir)\n        else:\n            self.file_writer = None\n        #        self.dcp_list = [63, 24, 17, 10, 5]\n        self.dcp_list = [63, 56, 49, 42, 35, 31, 28, 24, 21, 17, 14, 10, 7, 5, 3, 1, 0]\n        self.classes = []\n        self.fare_sales_by_dcp = defaultdict(int)\n        self.fare_sales_by_airline_dcp = defaultdict(int)\n        self.fare_details_sold = defaultdict(int)\n        self.fare_details_sold_business = defaultdict(int)\n        self.fare_details_revenue = defaultdict(float)\n        self.output_dir = output_dir\n        self.demand_multiplier = 1.0\n        self.airports = []\n        self.choice_models = {}\n        self.frat5curves = {}\n        self.load_factor_curves = {}\n        self.debug = False\n        self.update_frequency = None\n        self.random_generator = passengersim.core.Generator(42)\n        self.sample_done_callback = lambda n, n_total: None\n        self._initialize(config)\n        self.cnx = database.Database(\n            engine=config.db.engine,\n            filename=config.db.filename,\n            pragmas=config.db.pragmas,\n            commit_count_delay=config.db.commit_count_delay,\n        )\n        if self.cnx.is_open:\n            database.tables.create_table_legs(self.cnx._connection, self.sim.legs)\n            database.tables.create_table_path_defs(self.cnx._connection, self.sim.paths)\n            if config.db != \":memory:\":\n                self.cnx.save_configs(config)\n\n    @property\n    def base_time(self) -&gt; int:\n        return self.sim.base_time\n\n    @property\n    def snapshot_filters(self) -&gt; list[SnapshotFilter] | None:\n        try:\n            sim = self.sim\n        except AttributeError:\n            return None\n        return sim.snapshot_filters\n\n    @snapshot_filters.setter\n    def snapshot_filters(self, x: list[SnapshotFilter]):\n        try:\n            sim = self.sim\n        except AttributeError as err:\n            raise ValueError(\n                \"sim not initialized, cannot set snapshot_filters\"\n            ) from err\n        sim.snapshot_filters = x\n\n    def _initialize(self, config: Config):\n        self.sim = passengersim.core.SimulationEngine(name=config.scenario)\n        self.sim.config = config\n        self.sim.random_generator = self.random_generator\n        self.sim.snapshot_filters = config.snapshot_filters\n        for pname, pvalue in config.simulation_controls:\n            if pname == \"demand_multiplier\":\n                self.demand_multiplier = pvalue\n            elif pname == \"write_raw_files\":\n                self.write_raw_files = pvalue\n            elif pname == \"random_seed\":\n                self.random_generator.seed(pvalue)\n            elif pname == \"update_frequency\":\n                self.update_frequency = pvalue\n            elif pname == \"base_date\":\n                pass\n            elif pname == \"dcp_hour\":\n                pass\n            elif pname == \"show_progress_bar\":\n                pass\n            elif pname == \"double_capacity_until\":\n                pass\n            elif pname == \"timeframe_demand_allocation\":\n                pass\n            elif pname == \"tot_z_factor\":\n                pass\n            elif pname == \"simple_k_factor\":\n                pass\n            else:\n                self.sim.set_parm(pname, float(pvalue))\n        for pname, pvalue in config.simulation_controls.model_extra.items():\n            print(f\"extra simulation setting: {pname} = \", float(pvalue))\n            self.sim.set_parm(pname, float(pvalue))\n\n        self.rm_systems = {}\n        from passengersim_core.airline.rm_system import Rm_System\n\n        for rm_name, rm_system in config.rm_systems.items():\n            x = self.rm_systems[rm_name] = Rm_System(rm_name)\n            for process_name, process in rm_system.processes.items():\n                step_list = [s._factory() for s in process]\n                x.add_process(process_name, step_list)\n\n            ### This needs ot be revisited, now that we have DCP and DAILY step lists\n            availability_control = rm_system.availability_control\n            processes = (\n                rm_system.processes[\"dcp\"] if \"dcp\" in rm_system.processes else []\n            )\n            if len(processes) == 0:\n                _inferred_availability_control = \"none\"\n            # elif steps[-1].step_type in (\"probp\", \"udp\"):\n            #    _inferred_availability_control = \"bp\"\n            # else:\n            #    _inferred_availability_control = \"vn\"\n            if availability_control == \"infer\":\n                raise NotImplementedError(\"\")\n            #   availability_control = _inferred_availability_control\n            # else:\n            #   if availability_control != _inferred_availability_control:\n            #     warnings.warn(\n            #         f\"availability_control for this RmSystem should be \"\n            #         f\"{_inferred_availability_control} but it is set to \"\n            #         f\"{availability_control}\"\n            #     )\n            x.availability_control = availability_control\n\n        for cm_name, cm in config.choice_models.items():\n            x = passengersim.core.ChoiceModel(cm_name, cm.kind)\n            for pname, pvalue in cm:\n                if pname in (\"kind\", \"name\"):\n                    continue\n                if pvalue is None:\n                    continue\n                if isinstance(pvalue, list | tuple):\n                    x.add_parm(pname, *pvalue)\n                else:\n                    x.add_parm(pname, pvalue)\n            x.random_generator = self.random_generator\n            self.choice_models[cm_name] = x\n\n        for f5_name, f5_data in config.frat5_curves.items():\n            f5 = Frat5(f5_name)\n            for _dcp, val in f5_data.curve.items():\n                f5.add_vals(val)\n            self.sim.add_frat5(f5)\n            self.frat5curves[f5_name] = f5\n\n        for lf_name, lf_curve in config.load_factor_curves.items():\n            self.load_factor_curves[lf_name] = lf_curve\n\n        for airline_name, airline_config in config.airlines.items():\n            availability_control = self.rm_systems[\n                airline_config.rm_system\n            ].availability_control\n            airline = passengersim.core.Airline(airline_name, availability_control)\n            airline.rm_system = self.rm_systems[airline_config.rm_system]\n            if airline_config.frat5 is not None and airline_config.frat5 != \"\":\n                f5 = self.frat5curves[airline_config.frat5]\n                airline.frat5 = f5\n            if (\n                airline_config.load_factor_curve is not None\n                and airline_config.load_factor_curve != \"\"\n            ):\n                lfc = self.load_factor_curves[airline_config.load_factor_curve]\n                airline.load_factor_curve = lfc\n            self.sim.add_airline(airline)\n\n        self.classes = config.classes\n        self.init_rm = {}  # TODO\n        self.dcps = config.dcps\n\n        self.curves = {}\n        for curve_name, curve_config in config.booking_curves.items():\n            bc = passengersim.core.BookingCurve(curve_name)\n            bc.random_generator = self.random_generator\n            for dcp, pct in curve_config.curve.items():\n                bc.add_dcp(dcp, pct)\n            self.curves[curve_name] = bc\n\n        self.legs = {}\n        for leg_config in config.legs:\n            leg = passengersim.core.Leg(\n                leg_config.carrier,\n                leg_config.fltno,\n                leg_config.orig,\n                leg_config.dest,\n                capacity=leg_config.capacity,\n            )\n            leg.dep_time = leg_config.dep_time\n            leg.arr_time = leg_config.arr_time\n            if leg_config.distance:\n                leg.distance = leg_config.distance\n            elif len(self.airports) &gt; 0:\n                leg.distance = self.get_mileage(leg.orig, leg.dest)\n            if len(self.classes) &gt; 0:\n                self.set_classes(leg)\n            self.sim.add_leg(leg)\n            if self.debug:\n                print(f\"Added leg: {leg}, dist = {leg.distance}\")\n            self.legs[leg.flt_no] = leg\n\n        for dmd_config in config.demands:\n            dmd = passengersim.core.Demand(\n                dmd_config.orig, dmd_config.dest, dmd_config.segment\n            )\n            dmd.base_demand = dmd_config.base_demand * self.demand_multiplier\n            dmd.price = dmd_config.reference_fare\n            dmd.reference_fare = dmd_config.reference_fare\n            if len(self.airports) &gt; 0:\n                dmd.distance = self.get_mileage(dmd.orig, dmd.dest)\n            model_name = dmd_config.choice_model\n            cm = self.choice_models.get(model_name, None)\n            if cm is not None:\n                dmd.add_choice_model(cm)\n            if model_name == \"business\" or dmd_config.segment == \"business\":\n                dmd.business = True\n            if dmd_config.curve:\n                curve_name = str(dmd_config.curve).strip()\n                curve = self.curves[curve_name]\n                dmd.add_curve(curve)\n            self.sim.add_demand(dmd)\n            if self.debug:\n                print(f\"Added demand: {dmd}, base_demand = {dmd.base_demand}\")\n\n        # self.fares = []\n        for fare_config in config.fares:\n            fare = passengersim.core.Fare(\n                fare_config.carrier,\n                fare_config.orig,\n                fare_config.dest,\n                fare_config.booking_class,\n                fare_config.price,\n            )\n            fare.adv_purch = fare_config.advance_purchase\n            for rest_code in fare_config.restrictions:\n                fare.add_restriction(rest_code)\n            self.sim.add_fare(fare)\n            if self.debug:\n                print(f\"Added fare: {fare}\")\n            # self.fares.append(fare)\n\n        for path_config in config.paths:\n            p = passengersim.core.Path(path_config.orig, path_config.dest, 0.0)\n            p.path_quality_index = path_config.path_quality_index\n            leg_index1 = path_config.legs[0]\n            tmp_leg = self.legs[leg_index1]\n            assert (\n                tmp_leg.orig == path_config.orig\n            ), \"Path statement is corrupted, orig doesn't match\"\n            assert tmp_leg.flt_no == leg_index1\n            p.add_leg(tmp_leg)\n            if len(path_config.legs) &gt;= 2:\n                leg_index2 = path_config.legs[1]\n                if leg_index2 &gt; 0:\n                    tmp_leg = self.legs[leg_index2]\n                    p.add_leg(self.legs[leg_index2])\n            assert (\n                tmp_leg.dest == path_config.dest\n            ), \"Path statement is corrupted, dest doesn't match\"\n            self.sim.add_path(p)\n\n        # Go through and make sure things are linked correctly\n        for dmd in self.sim.demands:\n            for fare in self.sim.fares:\n                if fare.orig == dmd.orig and fare.dest == dmd.dest:\n                    # print(\"Joining:\", dmd, fare)\n                    dmd.add_fare(fare)\n\n        for leg in self.sim.legs:\n            for fare in self.sim.fares:\n                if (\n                    fare.carrier == leg.carrier\n                    and fare.orig == leg.orig\n                    and fare.dest == leg.dest\n                ):\n                    leg.set_bucket_decision_fare(fare.booking_class, fare.price)\n                    leg.set_bucket_fcst_revenue(fare.booking_class, fare.price)\n\n        self.sim.base_time = config.simulation_controls.reference_epoch()\n\n    def set_classes(self, _leg, debug=False):\n        cap = float(_leg.capacity)\n        if debug:\n            print(_leg, \"Capacity = \", cap)\n        for bkg_class in self.classes:\n            # Input as a percentage\n            auth = int(cap * self.init_rm.get(bkg_class, 100.0) / 100.0)\n            b = passengersim.core.Bucket(bkg_class, alloc=auth)\n            # print(\"adding bucket\", b)\n            _leg.add_bucket(b)\n            if debug:\n                print(\"    Bucket\", bkg_class, auth)\n\n    def setup_scenario(self):\n        self.cnx.delete_experiment(self.sim.name)\n        logger.debug(\"building connections\")\n        num_paths = self.sim.build_connections()\n        if num_paths and self.cnx.is_open:\n            database.tables.create_table_path_defs(self.cnx._connection, self.sim.paths)\n        logger.debug(f\"Connections done, num_paths = {num_paths}\")\n        self.vn_initial_mapping()\n\n    def vn_initial_mapping(self):\n        vn_airlines = []\n        for airline in self.sim.airlines:\n            if airline.control == \"vn\":\n                vn_airlines.append(airline.name)\n\n        for path in self.sim.paths:\n            if path.get_leg_carrier(0) in vn_airlines:\n                for bc in self.classes:\n                    pc = PathClass(bc)\n                    index = int(bc[1])\n                    pc.set_indexes(index, index)\n                    path.add_path_class(pc)\n\n    def _run_sim(self):\n        update_freq = self.update_frequency\n        logger.debug(\n            f\"run_sim, num_trials = {self.sim.num_trials}, num_samples = {self.sim.num_samples}\"\n        )\n        self.sim.update_db_write_flags()\n        n_samples_total = self.sim.num_trials * self.sim.num_samples\n        n_samples_done = 0\n        self.sample_done_callback(n_samples_done, n_samples_total)\n        if self.sim.config.simulation_controls.show_progress_bar:\n            progress = ProgressBar(total=n_samples_total)\n        else:\n            progress = DummyProgressBar()\n        with progress:\n            for trial in range(self.sim.num_trials):\n                self.sim.trial = trial\n                self.sim.reset_trial_counters()\n                for sample in range(self.sim.num_samples):\n                    if self.sim.config.simulation_controls.double_capacity_until:\n                        # Just trying this, PODS has something similar during the burn phase\n                        if sample == 0:\n                            for leg in self.sim.legs:\n                                leg.capacity = leg.capacity * 2.0\n                        elif (\n                            sample\n                            == self.sim.config.simulation_controls.double_capacity_until\n                        ):\n                            for leg in self.sim.legs:\n                                leg.capacity = leg.capacity / 2.0\n\n                    progress.tick(refresh=(sample == 0))\n                    self.sim.sample = sample\n                    if self.sim.config.simulation_controls.random_seed is not None:\n                        self.reseed(\n                            [\n                                self.sim.config.simulation_controls.random_seed,\n                                trial,\n                                sample,\n                            ]\n                        )\n                    if update_freq is not None and self.sim.sample % update_freq == 0:\n                        total_rev, n = 0.0, 0\n                        airline_info = \"\"\n                        for cxr in self.sim.airlines:\n                            total_rev += cxr.revenue\n                            n += 1\n                            airline_info += (\n                                f\"{', ' if n &gt; 0 else ''}{cxr.name}=${cxr.revenue:8.0f}\"\n                            )\n\n                        dmd_b, dmd_l = 0, 0\n                        for dmd in self.sim.demands:\n                            if dmd.business:\n                                dmd_b += dmd.scenario_demand\n                            else:\n                                dmd_l += dmd.scenario_demand\n                        d_info = f\", {int(dmd_b)}, {int(dmd_l)}\"\n                        logger.info(\n                            f\"Trial={self.sim.trial}, Sample={self.sim.sample}{airline_info}{d_info}\"\n                        )\n                    if self.sim.trial &gt; 0 or self.sim.sample &gt; 0:\n                        self.sim.reset_counters()\n                    self.generate_demands()\n\n                    # Loop on passengers\n                    while True:\n                        event = self.sim.go()\n                        self.run_airline_models(event)\n                        if (\n                            event is None\n                            or str(event) == \"Done\"\n                            or (event[0] == \"Done\")\n                        ):\n                            assert (\n                                self.sim.num_events() == 0\n                            ), f\"Event queue still has {self.sim.num_events()} events\"\n                            break\n                    if self.cnx:\n                        try:\n                            self.cnx.commit()\n                        except AttributeError:\n                            pass\n\n                    n_samples_done += 1\n                    self.sample_done_callback(n_samples_done, n_samples_total)\n                if self.cnx.is_open:\n                    self.cnx.save_final(self.sim)\n\n    def run_airline_models(self, info: Any = None, departed: bool = False, debug=False):\n        event_type = info[0]\n        recording_day = info[\n            1\n        ]  # could in theory also be non-integer for fractional days\n        dcp_index = info[2]\n        if dcp_index == -1:\n            dcp_index = len(self.dcp_list) - 1\n\n        if event_type.lower() in {\"dcp\", \"done\"}:\n            self.sim.last_dcp = recording_day\n            self.capture_dcp_data(dcp_index)\n\n        # This will change once we have \"dcp\" and \"daily\" portions of an RM system in the YAML input file\n        for airline in self.sim.airlines:\n            if event_type.lower() in {\"dcp\", \"done\"}:\n                airline.rm_system.run(\n                    self.sim, airline.name, dcp_index, recording_day, event_type=\"dcp\"\n                )\n            elif event_type.lower() == \"daily\":\n                airline.rm_system.run(\n                    self.sim, airline.name, dcp_index, recording_day, event_type=\"daily\"\n                )\n\n        if event_type.lower() == \"daily\":\n            if (\n                self.cnx.is_open\n                and self.sim.save_timeframe_details\n                and recording_day &gt; 0\n            ):\n                self.sim.write_to_sqlite(\n                    self.cnx._connection,\n                    recording_day,\n                    store_bid_prices=self.sim.config.db.store_leg_bid_prices,\n                    intermediate_day=True,\n                )\n        elif event_type.lower() in {\"dcp\", \"done\"}:\n            if self.cnx.is_open:\n                self.cnx.save_details(self.sim, recording_day)\n            if self.file_writer is not None:\n                self.file_writer.save_details(self.sim, recording_day)\n\n    def capture_dcp_data(self, dcp_index):\n        for leg in self.sim.legs:\n            leg.capture_dcp(dcp_index)\n        for path in self.sim.paths:\n            path.capture_dcp(dcp_index)\n\n    def _accum_by_tf(self, dcp_index):\n        # This is now replaced by C++ native counters ...\n        if dcp_index &gt; 0:\n            prev_dcp = self.dcp_list[dcp_index - 1]\n            for f in self.sim.fares:\n                curr_business = self.fare_sales_by_dcp.get((\"business\", prev_dcp), 0)\n                curr_leisure = self.fare_sales_by_dcp.get((\"leisure\", prev_dcp), 0)\n                inc_leisure = curr_leisure + (f.sold - f.sold_business)\n                inc_business = curr_business + f.sold_business\n                self.fare_sales_by_dcp[(\"business\", prev_dcp)] = inc_business\n                self.fare_sales_by_dcp[(\"leisure\", prev_dcp)] = inc_leisure\n\n                key2 = (f.carrier, prev_dcp)\n                curr_airline = self.fare_sales_by_airline_dcp[key2]\n                self.fare_sales_by_airline_dcp[key2] = curr_airline + f.sold\n\n                key3 = (f.carrier, f.booking_class, prev_dcp)\n                self.fare_details_sold[key3] += f.sold\n                self.fare_details_sold_business[key3] += f.sold_business\n                self.fare_details_revenue[key3] += f.price * f.sold\n\n    def generate_dcp_rm_events(self, debug=False):\n        \"\"\"Pushes an event per reading day (DCP) onto the queue.\n        Also adds events for daily reoptimzation\"\"\"\n        dcp_hour = self.sim.config.simulation_controls.dcp_hour\n        if debug:\n            tmp = datetime.fromtimestamp(self.sim.base_time, tz=timezone.utc)\n            print(f\"Base Time is {tmp.strftime('%Y-%m-%d %H:%M:%S %Z')}\")\n        for dcp_index, dcp in enumerate(self.dcp_list):\n            if dcp == 0:\n                continue\n            event_time = int(self.sim.base_time - dcp * 86400 + 3600 * dcp_hour)\n            if debug:\n                tmp = datetime.fromtimestamp(event_time, tz=timezone.utc)\n                print(f\"Added DCP {dcp} at {tmp.strftime('%Y-%m-%d %H:%M:%S %Z')}\")\n            info = (\"DCP\", dcp, dcp_index)\n            rm_event = Event(info, event_time)\n            self.sim.add_event(rm_event)\n\n        # Now add the events for daily reoptimization\n        max_days_prior = max(self.dcp_list)\n        for days_prior in range(max_days_prior):\n            if days_prior not in self.dcp_list:\n                info = (\"daily\", days_prior, 0)\n                event_time = int(\n                    self.sim.base_time - days_prior * 86400 + 3600 * dcp_hour\n                )\n                rm_event = Event(info, event_time)\n                self.sim.add_event(rm_event)\n\n    def generate_demands(self, system_rn=None, debug=False):\n        \"\"\"Generate demands, following the procedure used in PODS\n        The biggest difference is that we can put all the timeframe (DCP) demands\n        into the event queue before any processing.\n        For large models, I might rewrite this into the C++ core in the future\"\"\"\n        self.generate_dcp_rm_events()\n        total_events = 0\n        system_rn = (\n            self.random_generator.get_normal() if system_rn is None else system_rn\n        )\n\n        # We don't have an O&amp;D object, but we use this to get a market random number per market\n        mrn_ref = {}\n\n        # Need to have leisure / business split for PODS\n        trn_ref = {\n            \"business\": self.random_generator.get_normal(),\n            \"leisure\": self.random_generator.get_normal(),\n        }\n\n        def get_or_make_random(grouping, key):\n            if key not in grouping:\n                grouping[key] = self.random_generator.get_normal()\n            return grouping[key]\n\n        end_time = self.base_time\n\n        for dmd in self.sim.demands:\n            base = dmd.base_demand\n\n            # Get the random numbers we're going to use to perturb demand\n            trn = get_or_make_random(trn_ref, (dmd.orig, dmd.dest, dmd.segment))\n            mrn = get_or_make_random(mrn_ref, (dmd.orig, dmd.dest))\n            if self.sim.config.simulation_controls.simple_k_factor:\n                urn = (\n                    self.random_generator.get_normal()\n                    * self.sim.config.simulation_controls.simple_k_factor\n                )\n            else:\n                urn = 0\n\n            mu = base * (\n                1.0\n                + system_rn * self.sim.sys_k_factor\n                + mrn * self.sim.mkt_k_factor\n                + trn * self.sim.pax_type_k_factor\n                + urn\n            )\n            mu = max(mu, 0.0)\n            sigma = sqrt(\n                mu * self.sim.config.simulation_controls.tot_z_factor\n            )  # Correct?\n            n = mu + sigma * self.random_generator.get_normal()\n            dmd.scenario_demand = max(n, 0)\n\n            if debug:\n                logger.debug(\n                    f\"DMD,{self.sim.sample},{dmd.orig},{dmd.dest},{dmd.segment},{dmd.base_demand},\"\n                    f\"{round(mu,2)},{round(sigma,2)},{round(n,2)}\"\n                )\n\n            # Now we split it up over timeframes and add it to the simulation\n            num_pax = int(dmd.scenario_demand + 0.5)  # rounding\n            if (\n                self.sim.config.simulation_controls.timeframe_demand_allocation\n                == \"pods\"\n            ):\n                num_events_by_tf = self.sim.allocate_demand_to_tf_pods(\n                    dmd, num_pax, self.sim.tf_k_factor, int(end_time)\n                )\n            else:\n                num_events_by_tf = self.sim.allocate_demand_to_tf(\n                    dmd, num_pax, self.sim.tf_k_factor, int(end_time)\n                )\n            num_events = sum(num_events_by_tf)\n            total_events += num_events\n            if num_events != round(num_pax):\n                # print(f\"Generate demand function, num_pax={num_pax}, num_events={num_events}\")\n                raise Exception(\n                    f\"Generate demand function, num_pax={num_pax}, num_events={num_events}\"\n                )\n\n        return total_events\n\n    # def data_by_timeframe(self):\n    #     logger.info(\"----- Demand By DCP -----\")\n    #     dmd_by_tf = defaultdict(float)\n    #     for dmd in self.sim.demands:\n    #         for dcp in self.dcp_list:\n    #             if dcp == 0:\n    #                 continue\n    #             dmd_by_tf[(dmd.curve_number, dcp)] += dmd.get_demand_dcp(dcp)\n    #     for k, v in dmd_by_tf.items():\n    #         logger.info(f\"    {k[0]}, {k[1]}, {v}\")\n    #\n    #     total_samples = self.sim.num_trials * self.sim.num_samples\n    #     logger.info(\n    #         f\"Fare Sales by DCP (dcp, business, tf_business, leisure, tf_leisure), samples = {total_samples}\"\n    #     )\n    #     prev_b, prev_l = 0, 0\n    #     for dcp in self.dcp_list:\n    #         if dcp == 0:\n    #             continue\n    #         business = self.fare_sales_by_dcp[(\"business\", dcp)]\n    #         leisure = self.fare_sales_by_dcp[(\"leisure\", dcp)]\n    #         logger.info(\n    #             f\"    {dcp}, {business}, {business - prev_b}, {leisure}, {leisure - prev_l}\"\n    #         )\n    #         prev_b, prev_l = business, leisure\n    #\n    #     logger.info(\"Fare Sales by DCP &amp; airline (dcp, Al1, AL2, ...etc)\")\n    #     prev = defaultdict(int)\n    #     for dcp in self.dcp_list:\n    #         if dcp == 0:\n    #             continue\n    #         tmp = \"\"\n    #         for a in self.sim.airlines:\n    #             sold = self.fare_sales_by_airline_dcp[(a.name, dcp)]\n    #             inc_sold = sold - prev[a.name]\n    #             tmp += str(inc_sold) if tmp == \"\" else (\", \" + str(inc_sold))\n    #             prev[a.name] = sold\n    #         logger.info(f\"    {dcp}, {tmp}\")\n    #\n    #     logger.info(\n    #         \"Fare Details:  Airline, Class, RRD, Sold, Business, Leisure, AvgPrice\"\n    #     )\n    #     my_keys = self.fare_details_sold.keys()\n    #     my_keys = sorted(my_keys, key=lambda x: (x[0], x[1], 100 - x[2]))\n    #     prev_dcp, prev_sold, prev_business, prev_leisure = 0, 0, 0, 0\n    #     for k in my_keys:\n    #         dcp = k[2]\n    #         if int(dcp) &gt; int(prev_dcp):\n    #             prev_sold, prev_business, prev_leisure = 0, 0, 0\n    #         sold = self.fare_details_sold[k]\n    #         sold_business = self.fare_details_sold_business[k]\n    #         sold_leisure = sold - sold_business\n    #         avg_price = self.fare_details_revenue[k] / sold if sold &gt; 0 else 0.0\n    #         logger.info(\n    #             f\"    {k[0]:4} {k[1]:4} {k[2]:4} \"\n    #             f\"{sold - prev_sold:8} {sold_business - prev_business:8} \"\n    #             f\"{sold_leisure - prev_leisure:8} {avg_price:10.2f}\"\n    #         )\n    #         prev_dcp, prev_sold, prev_business, prev_leisure = (\n    #             dcp,\n    #             sold,\n    #             sold_business,\n    #             sold_leisure,\n    #         )\n\n    def compute_reports(\n        self,\n        sim: SimulationEngine,\n        to_log=True,\n        to_db: bool | database.Database = True,\n        additional=(\n            \"fare_class_mix\",\n            \"load_factors\",\n            \"bookings_by_timeframe\",\n            \"total_demand\",\n        ),\n    ) -&gt; SummaryTables:\n        num_samples = sim.num_trials * (sim.num_samples - sim.burn_samples)\n        if num_samples &lt;= 0:\n            raise ValueError(\n                \"insufficient number of samples outside burn period for reporting\"\n                f\"\\n- num_trials = {sim.num_trials}\"\n                f\"\\n- num_samples = {sim.num_samples}\"\n                f\"\\n- burn_samples = {sim.burn_samples}\"\n            )\n\n        if to_db is True:\n            to_db = self.cnx\n        dmd_df = self.compute_demand_report(sim, to_log, to_db)\n        fare_df = self.compute_fare_report(sim, to_log, to_db)\n        leg_df = self.compute_leg_report(sim, to_log, to_db)\n        path_df = self.compute_path_report(sim, to_log, to_db)\n        path_classes_df = self.compute_path_class_report(sim, to_log, to_db)\n        carrier_df = self.compute_carrier_report(sim, to_log, to_db)\n\n        summary = SummaryTables(\n            demands=dmd_df,\n            fares=fare_df,\n            legs=leg_df,\n            paths=path_df,\n            path_classes=path_classes_df,\n            carriers=carrier_df,\n        )\n        summary.load_additional_tables(self.cnx, sim.name, sim.burn_samples, additional)\n        return summary\n\n    def compute_demand_report(\n        self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n    ):\n        dmd_df = []\n        for m in sim.demands:\n            avg_price = m.revenue / m.sold if m.sold &gt; 0 else 0\n            dmd_df.append(\n                dict(\n                    orig=m.orig,\n                    dest=m.dest,\n                    segment=m.segment,\n                    sold=m.sold,\n                    revenue=m.revenue,\n                    avg_fare=m.revenue / m.sold if m.sold &gt; 0 else 0,\n                    gt_demand=m.gt_demand,\n                    gt_sold=m.gt_sold,\n                    gt_revenue=m.gt_revenue,\n                )\n            )\n            if to_log:\n                logger.info(\n                    f\"   Dmd: {m.orig}-{m.dest}:{m.segment}\"\n                    f\"  Sold = {m.sold},  \"\n                    f\"Rev = {m.revenue}, \"\n                    f\"AvgFare = {avg_price:.2f}\"\n                )\n        dmd_df = pd.DataFrame(dmd_df)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"demand_summary\", dmd_df)\n        return dmd_df\n\n    def compute_fare_report(\n        self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n    ):\n        fare_df = []\n        for f in sim.fares:\n            for dcp_index in range(16):\n                fare_df.append(\n                    dict(\n                        carrier=f.carrier,\n                        orig=f.orig,\n                        dest=f.dest,\n                        booking_class=f.booking_class,\n                        dcp_index=dcp_index,\n                        price=f.price,\n                        sold=f.sold,\n                        gt_sold=f.gt_sold,\n                        avg_adjusted_price=f.get_adjusted_by_dcp(dcp_index),\n                    )\n                )\n                if to_log:\n                    logger.info(\n                        f\"   Fare: {f.carrier} {f.orig}-{f.dest}:{f.booking_class}\"\n                        # f\"AvgAdjFare = {avg_adj_price:.2f},\"\n                        f\"  Sold = {f.sold},  \"\n                        f\"Price = {f.price}\"\n                    )\n        fare_df = pd.DataFrame(fare_df)\n        #        if to_db and to_db.is_open:\n        #            to_db.save_dataframe(\"fare_summary\", fare_df)\n        return fare_df\n\n    def compute_leg_report(\n        self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n    ):\n        num_samples = sim.num_trials * (sim.num_samples - sim.burn_samples)\n        leg_df = []\n        for leg in sim.legs:\n            avg_sold = leg.gt_sold / num_samples\n            avg_rev = leg.gt_revenue / num_samples\n            lf = 100.0 * leg.gt_sold / (leg.capacity * num_samples)\n            if to_log:\n                logger.info(\n                    f\"    Leg: {leg.carrier}:{leg.flt_no} {leg.orig}-{leg.dest}: \"\n                    f\" AvgSold = {avg_sold:6.2f},  AvgRev = ${avg_rev:,.2f}, LF = {lf:,.2f}%\"\n                )\n            leg_df.append(\n                dict(\n                    carrier=leg.carrier,\n                    flt_no=leg.flt_no,\n                    orig=leg.orig,\n                    dest=leg.dest,\n                    avg_sold=avg_sold,\n                    avg_rev=avg_rev,\n                    lf=lf,\n                )\n            )\n        leg_df = pd.DataFrame(leg_df)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"leg_summary\", leg_df)\n        return leg_df\n\n    def compute_path_report(\n        self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n    ):\n        num_samples = sim.num_trials * (sim.num_samples - sim.burn_samples)\n        avg_lf, n = 0.0, 0\n        for leg in sim.legs:\n            lf = 100.0 * leg.gt_sold / (leg.capacity * num_samples)\n            avg_lf += lf\n            n += 1\n\n        tot_rev = 0.0\n        for m in sim.demands:\n            tot_rev += m.revenue\n\n        avg_lf = avg_lf / n if n &gt; 0 else 0\n        if to_log:\n            logger.info(f\"    LF:  {avg_lf:6.2f}%, Total revenue = ${tot_rev:,.2f}\")\n\n        path_df = []\n        for path in sim.paths:\n            avg_sold = path.gt_sold / num_samples\n            avg_sold_priceable = path.gt_sold_priceable / num_samples\n            avg_rev = path.gt_revenue / num_samples\n            if to_log:\n                logger.info(\n                    f\"{path}, avg_sold={avg_sold:6.2f}, avg_rev=${avg_rev:10,.2f}\"\n                )\n            if path.num_legs() == 1:\n                path_df.append(\n                    dict(\n                        orig=path.orig,\n                        dest=path.dest,\n                        carrier1=path.get_leg_carrier(0),\n                        flt_no1=path.get_leg_fltno(0),\n                        carrier2=None,\n                        flt_no2=None,\n                        avg_sold=avg_sold,\n                        avg_sold_priceable=avg_sold_priceable,\n                        avg_rev=avg_rev,\n                    )\n                )\n            elif path.num_legs() == 2:\n                path_df.append(\n                    dict(\n                        orig=path.orig,\n                        dest=path.dest,\n                        carrier1=path.get_leg_carrier(0),\n                        flt_no1=path.get_leg_fltno(0),\n                        carrier2=path.get_leg_carrier(1),\n                        flt_no2=path.get_leg_fltno(1),\n                        avg_sold=avg_sold,\n                        avg_sold_priceable=avg_sold_priceable,\n                        avg_rev=avg_rev,\n                    )\n                )\n            else:\n                raise NotImplementedError(\"path with other than 1 or 2 legs\")\n        path_df = pd.DataFrame(path_df)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"path_summary\", path_df)\n        return path_df\n\n    def compute_path_class_report(\n        self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n    ):\n        num_samples = sim.num_trials * (sim.num_samples - sim.burn_samples)\n        # avg_lf, n = 0.0, 0\n        #        for leg in sim.legs:\n        #            lf = 100.0 * leg.gt_sold / (leg.capacity * num_samples)\n        #            avg_lf += lf\n        #            n += 1\n\n        #        tot_rev = 0.0\n        #        for m in sim.demands:\n        #            tot_rev += m.revenue\n\n        #        avg_lf = avg_lf / n if n &gt; 0 else 0\n        #        if to_log:\n        #            logger.info(f\"    LF:  {avg_lf:6.2f}%, Total revenue = ${tot_rev:,.2f}\")\n\n        path_class_df = []\n        for path in sim.paths:\n            for pc in path.pathclasses:\n                avg_sold = pc.gt_sold / num_samples\n                avg_sold_priceable = pc.gt_sold_priceable / num_samples\n                avg_rev = pc.gt_revenue / num_samples\n                if to_log:\n                    logger.info(\n                        f\"{pc}, avg_sold={avg_sold:6.2f}, avg_rev=${avg_rev:10,.2f}\"\n                    )\n                if path.num_legs() == 1:\n                    path_class_df.append(\n                        dict(\n                            orig=path.orig,\n                            dest=path.dest,\n                            carrier1=path.get_leg_carrier(0),\n                            flt_no1=path.get_leg_fltno(0),\n                            carrier2=None,\n                            flt_no2=None,\n                            booking_class=pc.booking_class,\n                            avg_sold=avg_sold,\n                            avg_sold_priceable=avg_sold_priceable,\n                            avg_rev=avg_rev,\n                        )\n                    )\n                elif path.num_legs() == 2:\n                    path_class_df.append(\n                        dict(\n                            orig=path.orig,\n                            dest=path.dest,\n                            carrier1=path.get_leg_carrier(0),\n                            flt_no1=path.get_leg_fltno(0),\n                            carrier2=path.get_leg_carrier(1),\n                            flt_no2=path.get_leg_fltno(1),\n                            booking_class=pc.booking_class,\n                            avg_sold=avg_sold,\n                            avg_sold_priceable=avg_sold_priceable,\n                            avg_rev=avg_rev,\n                        )\n                    )\n                else:\n                    raise NotImplementedError(\"path with other than 1 or 2 legs\")\n        path_class_df = pd.DataFrame(path_class_df)\n        path_class_df.sort_values(\n            by=[\"orig\", \"dest\", \"carrier1\", \"flt_no1\", \"booking_class\"]\n        )\n        #        if to_db and to_db.is_open:\n        #            to_db.save_dataframe(\"path_class_summary\", path_class_df)\n        return path_class_df\n\n    def compute_carrier_report(\n        self,\n        sim: SimulationEngine,\n        to_log: bool = True,\n        to_db: database.Database | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Compute a carrier summary table.\n\n        The resulting table has one row per simulated carrier, and the following\n        columns:\n\n        - name\n        - avg_sold\n        - load_factor\n        - avg_rev\n        - asm (available seat miles)\n        - rpm (revenue passenger miles)\n        \"\"\"\n        num_samples = sim.num_trials * (sim.num_samples - sim.burn_samples)\n        carrier_df = []\n\n        airline_asm = defaultdict(float)\n        airline_rpm = defaultdict(float)\n        airline_leg_lf = defaultdict(float)\n        airline_leg_count = defaultdict(float)\n        for leg in sim.legs:\n            airline_asm[leg.carrier] += leg.distance * leg.capacity * num_samples\n            airline_rpm[leg.carrier] += leg.distance * leg.gt_sold\n            airline_leg_lf[leg.carrier] += leg.gt_sold / (leg.capacity * num_samples)\n            airline_leg_count[leg.carrier] += 1\n\n        for cxr in sim.airlines:\n            avg_sold = cxr.gt_sold / num_samples\n            avg_rev = cxr.gt_revenue / num_samples\n            asm = airline_asm[cxr.name] / num_samples\n            rpm = airline_rpm[cxr.name] / num_samples\n            # sys_lf = 100.0 * cxr.gt_revenue_passenger_miles / asm if asm &gt; 0 else 0.0\n            denom = airline_asm[cxr.name]\n            sys_lf = (100.0 * airline_rpm[cxr.name] / denom) if denom &gt; 0 else 0\n            if to_log:\n                logger.info(\n                    f\"Airline: {cxr.name}, AvgSold: {round(avg_sold, 2)}, LF {sys_lf:.2f}%,  AvgRev ${avg_rev:10,.2f}\"\n                )\n            carrier_df.append(\n                {\n                    \"carrier\": cxr.name,\n                    \"sold\": round(avg_sold, 2),\n                    \"sys_lf\": round(sys_lf, 3),\n                    \"avg_leg_lf\": round(\n                        100 * airline_leg_lf[cxr.name] / airline_leg_count[cxr.name], 3\n                    ),\n                    \"avg_rev\": (round(avg_rev, 0)),\n                    \"avg_price\": round(avg_rev / avg_sold, 2),\n                    \"asm\": (round(asm, 0)),\n                    \"rpm\": (round(rpm, 0)),\n                    \"yield\": np.nan if rpm == 0 else round(avg_rev / rpm, 4),\n                }\n            )\n            # logger.info(f\"ASM = {airline_asm[cxr.name]:.2f}, RPM = {airline_rpm[cxr.name]:.2f}, LF = {sys_lf:.2f}%\")\n        carrier_df = pd.DataFrame(carrier_df)\n        if to_db and to_db.is_open:\n            to_db.save_dataframe(\"carrier_summary\", carrier_df)\n        return carrier_df\n\n    def reseed(self, seed: int | list[int] | None = 42):\n        logger.debug(\"reseeding random_generator: %s\", seed)\n        self.sim.random_generator.seed(seed)\n\n    def _user_certificate(self, certificate_filename=None):\n        if certificate_filename:\n            from cryptography.x509 import load_pem_x509_certificate\n\n            certificate_filename = pathlib.Path(certificate_filename)\n            with certificate_filename.open(\"rb\") as f:\n                user_cert = load_pem_x509_certificate(f.read())\n        else:\n            user_cert = self.sim.config.license_certificate\n        return user_cert\n\n    def validate_license(self, certificate_filename=None, future: int = 0):\n        user_cert = self._user_certificate(certificate_filename)\n        return self.sim.validate_license(user_cert, future=future)\n\n    def license_info(self, certificate_filename=None):\n        user_cert = self._user_certificate(certificate_filename)\n        return self.sim.license_info(user_cert)\n\n    @property\n    def config(self) -&gt; Config:\n        \"\"\"The configuration used for this Simulation.\"\"\"\n        return self.sim.config\n\n    def run(self, log_reports: bool = False) -&gt; SummaryTables:\n        start_time = time.time()\n        self.setup_scenario()\n        self._run_sim()\n        summary = self.compute_reports(\n            self.sim,\n            to_log=log_reports or self.sim.config.outputs.log_reports,\n            additional=self.sim.config.outputs.reports,\n        )\n        if self.sim.config.outputs.excel:\n            summary.to_xlsx(self.sim.config.outputs.excel)\n        logger.info(\n            f\"Th' th' that's all folks !!!    (Elapsed time = {round(time.time() - start_time, 2)})\"\n        )\n        return summary\n\n    def backup_db(self, dst: pathlib.Path | str | sqlite3.Connection):\n        \"\"\"Back up this database to another copy.\n\n        Parameters\n        ----------\n        dst : Path-like or sqlite3.Connection\n        \"\"\"\n        return self.cnx.backup(dst)\n\n    def path_names(self):\n        result = {}\n        for p in self.sim.paths:\n            result[p.path_id] = str(p)\n        return result\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.airports", "title": "airports  <code>instance-attribute</code>", "text": "<pre><code>airports = []\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.base_time", "title": "base_time  <code>property</code>", "text": "<pre><code>base_time: int\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.choice_models", "title": "choice_models  <code>instance-attribute</code>", "text": "<pre><code>choice_models = {}\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.classes", "title": "classes  <code>instance-attribute</code>", "text": "<pre><code>classes = []\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.cnx", "title": "cnx  <code>instance-attribute</code>", "text": "<pre><code>cnx = database.Database(\n    engine=config.db.engine,\n    filename=config.db.filename,\n    pragmas=config.db.pragmas,\n    commit_count_delay=config.db.commit_count_delay,\n)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.config", "title": "config  <code>property</code>", "text": "<pre><code>config: Config\n</code></pre> <p>The configuration used for this Simulation.</p>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.dcp_list", "title": "dcp_list  <code>instance-attribute</code>", "text": "<pre><code>dcp_list = [\n    63,\n    56,\n    49,\n    42,\n    35,\n    31,\n    28,\n    24,\n    21,\n    17,\n    14,\n    10,\n    7,\n    5,\n    3,\n    1,\n    0,\n]\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.debug", "title": "debug  <code>instance-attribute</code>", "text": "<pre><code>debug = False\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.demand_multiplier", "title": "demand_multiplier  <code>instance-attribute</code>", "text": "<pre><code>demand_multiplier = 1.0\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_details_revenue", "title": "fare_details_revenue  <code>instance-attribute</code>", "text": "<pre><code>fare_details_revenue = defaultdict(float)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_details_sold", "title": "fare_details_sold  <code>instance-attribute</code>", "text": "<pre><code>fare_details_sold = defaultdict(int)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_details_sold_business", "title": "fare_details_sold_business  <code>instance-attribute</code>", "text": "<pre><code>fare_details_sold_business = defaultdict(int)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_sales_by_airline_dcp", "title": "fare_sales_by_airline_dcp  <code>instance-attribute</code>", "text": "<pre><code>fare_sales_by_airline_dcp = defaultdict(int)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.fare_sales_by_dcp", "title": "fare_sales_by_dcp  <code>instance-attribute</code>", "text": "<pre><code>fare_sales_by_dcp = defaultdict(int)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.file_writer", "title": "file_writer  <code>instance-attribute</code>", "text": "<pre><code>file_writer = FileWriter.FileWriter(output_dir)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.frat5curves", "title": "frat5curves  <code>instance-attribute</code>", "text": "<pre><code>frat5curves = {}\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.load_factor_curves", "title": "load_factor_curves  <code>instance-attribute</code>", "text": "<pre><code>load_factor_curves = {}\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.output_dir", "title": "output_dir  <code>instance-attribute</code>", "text": "<pre><code>output_dir = output_dir\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator = passengersim.core.Generator(42)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.sample_done_callback", "title": "sample_done_callback  <code>instance-attribute</code>", "text": "<pre><code>sample_done_callback = lambda , : None\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.snapshot_filters", "title": "snapshot_filters  <code>property</code> <code>writable</code>", "text": "<pre><code>snapshot_filters: list[SnapshotFilter] | None\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.update_frequency", "title": "update_frequency  <code>instance-attribute</code>", "text": "<pre><code>update_frequency = None\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    config: Config, output_dir: pathlib.Path | None = None\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def __init__(\n    self,\n    config: Config,\n    output_dir: pathlib.Path | None = None,\n):\n    if output_dir is None:\n        import tempfile\n\n        self._tempdir = tempfile.TemporaryDirectory()\n        output_dir = os.path.join(self._tempdir.name, \"test1\")\n    self.cnx = None\n    if config.simulation_controls.write_raw_files:\n        try:\n            from passengersim_core.utils import FileWriter\n        except ImportError:\n            self.file_writer = None\n        else:\n            self.file_writer = FileWriter.FileWriter(output_dir)\n    else:\n        self.file_writer = None\n    #        self.dcp_list = [63, 24, 17, 10, 5]\n    self.dcp_list = [63, 56, 49, 42, 35, 31, 28, 24, 21, 17, 14, 10, 7, 5, 3, 1, 0]\n    self.classes = []\n    self.fare_sales_by_dcp = defaultdict(int)\n    self.fare_sales_by_airline_dcp = defaultdict(int)\n    self.fare_details_sold = defaultdict(int)\n    self.fare_details_sold_business = defaultdict(int)\n    self.fare_details_revenue = defaultdict(float)\n    self.output_dir = output_dir\n    self.demand_multiplier = 1.0\n    self.airports = []\n    self.choice_models = {}\n    self.frat5curves = {}\n    self.load_factor_curves = {}\n    self.debug = False\n    self.update_frequency = None\n    self.random_generator = passengersim.core.Generator(42)\n    self.sample_done_callback = lambda n, n_total: None\n    self._initialize(config)\n    self.cnx = database.Database(\n        engine=config.db.engine,\n        filename=config.db.filename,\n        pragmas=config.db.pragmas,\n        commit_count_delay=config.db.commit_count_delay,\n    )\n    if self.cnx.is_open:\n        database.tables.create_table_legs(self.cnx._connection, self.sim.legs)\n        database.tables.create_table_path_defs(self.cnx._connection, self.sim.paths)\n        if config.db != \":memory:\":\n            self.cnx.save_configs(config)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.backup_db", "title": "backup_db", "text": "<pre><code>backup_db(dst: pathlib.Path | str | sqlite3.Connection)\n</code></pre> <p>Back up this database to another copy.</p> <p>Parameters:</p> <ul> <li> <code>dst</code>             (<code>Path - like or Connection</code>)         \u2013          </li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def backup_db(self, dst: pathlib.Path | str | sqlite3.Connection):\n    \"\"\"Back up this database to another copy.\n\n    Parameters\n    ----------\n    dst : Path-like or sqlite3.Connection\n    \"\"\"\n    return self.cnx.backup(dst)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.capture_dcp_data", "title": "capture_dcp_data", "text": "<pre><code>capture_dcp_data(dcp_index)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def capture_dcp_data(self, dcp_index):\n    for leg in self.sim.legs:\n        leg.capture_dcp(dcp_index)\n    for path in self.sim.paths:\n        path.capture_dcp(dcp_index)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_carrier_report", "title": "compute_carrier_report", "text": "<pre><code>compute_carrier_report(\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame\n</code></pre> <p>Compute a carrier summary table.</p> <p>The resulting table has one row per simulated carrier, and the following columns:</p> <ul> <li>name</li> <li>avg_sold</li> <li>load_factor</li> <li>avg_rev</li> <li>asm (available seat miles)</li> <li>rpm (revenue passenger miles)</li> </ul> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_carrier_report(\n    self,\n    sim: SimulationEngine,\n    to_log: bool = True,\n    to_db: database.Database | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute a carrier summary table.\n\n    The resulting table has one row per simulated carrier, and the following\n    columns:\n\n    - name\n    - avg_sold\n    - load_factor\n    - avg_rev\n    - asm (available seat miles)\n    - rpm (revenue passenger miles)\n    \"\"\"\n    num_samples = sim.num_trials * (sim.num_samples - sim.burn_samples)\n    carrier_df = []\n\n    airline_asm = defaultdict(float)\n    airline_rpm = defaultdict(float)\n    airline_leg_lf = defaultdict(float)\n    airline_leg_count = defaultdict(float)\n    for leg in sim.legs:\n        airline_asm[leg.carrier] += leg.distance * leg.capacity * num_samples\n        airline_rpm[leg.carrier] += leg.distance * leg.gt_sold\n        airline_leg_lf[leg.carrier] += leg.gt_sold / (leg.capacity * num_samples)\n        airline_leg_count[leg.carrier] += 1\n\n    for cxr in sim.airlines:\n        avg_sold = cxr.gt_sold / num_samples\n        avg_rev = cxr.gt_revenue / num_samples\n        asm = airline_asm[cxr.name] / num_samples\n        rpm = airline_rpm[cxr.name] / num_samples\n        # sys_lf = 100.0 * cxr.gt_revenue_passenger_miles / asm if asm &gt; 0 else 0.0\n        denom = airline_asm[cxr.name]\n        sys_lf = (100.0 * airline_rpm[cxr.name] / denom) if denom &gt; 0 else 0\n        if to_log:\n            logger.info(\n                f\"Airline: {cxr.name}, AvgSold: {round(avg_sold, 2)}, LF {sys_lf:.2f}%,  AvgRev ${avg_rev:10,.2f}\"\n            )\n        carrier_df.append(\n            {\n                \"carrier\": cxr.name,\n                \"sold\": round(avg_sold, 2),\n                \"sys_lf\": round(sys_lf, 3),\n                \"avg_leg_lf\": round(\n                    100 * airline_leg_lf[cxr.name] / airline_leg_count[cxr.name], 3\n                ),\n                \"avg_rev\": (round(avg_rev, 0)),\n                \"avg_price\": round(avg_rev / avg_sold, 2),\n                \"asm\": (round(asm, 0)),\n                \"rpm\": (round(rpm, 0)),\n                \"yield\": np.nan if rpm == 0 else round(avg_rev / rpm, 4),\n            }\n        )\n        # logger.info(f\"ASM = {airline_asm[cxr.name]:.2f}, RPM = {airline_rpm[cxr.name]:.2f}, LF = {sys_lf:.2f}%\")\n    carrier_df = pd.DataFrame(carrier_df)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"carrier_summary\", carrier_df)\n    return carrier_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_demand_report", "title": "compute_demand_report", "text": "<pre><code>compute_demand_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: database.Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_demand_report(\n    self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n):\n    dmd_df = []\n    for m in sim.demands:\n        avg_price = m.revenue / m.sold if m.sold &gt; 0 else 0\n        dmd_df.append(\n            dict(\n                orig=m.orig,\n                dest=m.dest,\n                segment=m.segment,\n                sold=m.sold,\n                revenue=m.revenue,\n                avg_fare=m.revenue / m.sold if m.sold &gt; 0 else 0,\n                gt_demand=m.gt_demand,\n                gt_sold=m.gt_sold,\n                gt_revenue=m.gt_revenue,\n            )\n        )\n        if to_log:\n            logger.info(\n                f\"   Dmd: {m.orig}-{m.dest}:{m.segment}\"\n                f\"  Sold = {m.sold},  \"\n                f\"Rev = {m.revenue}, \"\n                f\"AvgFare = {avg_price:.2f}\"\n            )\n    dmd_df = pd.DataFrame(dmd_df)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"demand_summary\", dmd_df)\n    return dmd_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_fare_report", "title": "compute_fare_report", "text": "<pre><code>compute_fare_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: database.Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_fare_report(\n    self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n):\n    fare_df = []\n    for f in sim.fares:\n        for dcp_index in range(16):\n            fare_df.append(\n                dict(\n                    carrier=f.carrier,\n                    orig=f.orig,\n                    dest=f.dest,\n                    booking_class=f.booking_class,\n                    dcp_index=dcp_index,\n                    price=f.price,\n                    sold=f.sold,\n                    gt_sold=f.gt_sold,\n                    avg_adjusted_price=f.get_adjusted_by_dcp(dcp_index),\n                )\n            )\n            if to_log:\n                logger.info(\n                    f\"   Fare: {f.carrier} {f.orig}-{f.dest}:{f.booking_class}\"\n                    # f\"AvgAdjFare = {avg_adj_price:.2f},\"\n                    f\"  Sold = {f.sold},  \"\n                    f\"Price = {f.price}\"\n                )\n    fare_df = pd.DataFrame(fare_df)\n    #        if to_db and to_db.is_open:\n    #            to_db.save_dataframe(\"fare_summary\", fare_df)\n    return fare_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_leg_report", "title": "compute_leg_report", "text": "<pre><code>compute_leg_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: database.Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_leg_report(\n    self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n):\n    num_samples = sim.num_trials * (sim.num_samples - sim.burn_samples)\n    leg_df = []\n    for leg in sim.legs:\n        avg_sold = leg.gt_sold / num_samples\n        avg_rev = leg.gt_revenue / num_samples\n        lf = 100.0 * leg.gt_sold / (leg.capacity * num_samples)\n        if to_log:\n            logger.info(\n                f\"    Leg: {leg.carrier}:{leg.flt_no} {leg.orig}-{leg.dest}: \"\n                f\" AvgSold = {avg_sold:6.2f},  AvgRev = ${avg_rev:,.2f}, LF = {lf:,.2f}%\"\n            )\n        leg_df.append(\n            dict(\n                carrier=leg.carrier,\n                flt_no=leg.flt_no,\n                orig=leg.orig,\n                dest=leg.dest,\n                avg_sold=avg_sold,\n                avg_rev=avg_rev,\n                lf=lf,\n            )\n        )\n    leg_df = pd.DataFrame(leg_df)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"leg_summary\", leg_df)\n    return leg_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_path_class_report", "title": "compute_path_class_report", "text": "<pre><code>compute_path_class_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: database.Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_path_class_report(\n    self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n):\n    num_samples = sim.num_trials * (sim.num_samples - sim.burn_samples)\n    # avg_lf, n = 0.0, 0\n    #        for leg in sim.legs:\n    #            lf = 100.0 * leg.gt_sold / (leg.capacity * num_samples)\n    #            avg_lf += lf\n    #            n += 1\n\n    #        tot_rev = 0.0\n    #        for m in sim.demands:\n    #            tot_rev += m.revenue\n\n    #        avg_lf = avg_lf / n if n &gt; 0 else 0\n    #        if to_log:\n    #            logger.info(f\"    LF:  {avg_lf:6.2f}%, Total revenue = ${tot_rev:,.2f}\")\n\n    path_class_df = []\n    for path in sim.paths:\n        for pc in path.pathclasses:\n            avg_sold = pc.gt_sold / num_samples\n            avg_sold_priceable = pc.gt_sold_priceable / num_samples\n            avg_rev = pc.gt_revenue / num_samples\n            if to_log:\n                logger.info(\n                    f\"{pc}, avg_sold={avg_sold:6.2f}, avg_rev=${avg_rev:10,.2f}\"\n                )\n            if path.num_legs() == 1:\n                path_class_df.append(\n                    dict(\n                        orig=path.orig,\n                        dest=path.dest,\n                        carrier1=path.get_leg_carrier(0),\n                        flt_no1=path.get_leg_fltno(0),\n                        carrier2=None,\n                        flt_no2=None,\n                        booking_class=pc.booking_class,\n                        avg_sold=avg_sold,\n                        avg_sold_priceable=avg_sold_priceable,\n                        avg_rev=avg_rev,\n                    )\n                )\n            elif path.num_legs() == 2:\n                path_class_df.append(\n                    dict(\n                        orig=path.orig,\n                        dest=path.dest,\n                        carrier1=path.get_leg_carrier(0),\n                        flt_no1=path.get_leg_fltno(0),\n                        carrier2=path.get_leg_carrier(1),\n                        flt_no2=path.get_leg_fltno(1),\n                        booking_class=pc.booking_class,\n                        avg_sold=avg_sold,\n                        avg_sold_priceable=avg_sold_priceable,\n                        avg_rev=avg_rev,\n                    )\n                )\n            else:\n                raise NotImplementedError(\"path with other than 1 or 2 legs\")\n    path_class_df = pd.DataFrame(path_class_df)\n    path_class_df.sort_values(\n        by=[\"orig\", \"dest\", \"carrier1\", \"flt_no1\", \"booking_class\"]\n    )\n    #        if to_db and to_db.is_open:\n    #            to_db.save_dataframe(\"path_class_summary\", path_class_df)\n    return path_class_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_path_report", "title": "compute_path_report", "text": "<pre><code>compute_path_report(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: database.Database | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_path_report(\n    self, sim: SimulationEngine, to_log=True, to_db: database.Database | None = None\n):\n    num_samples = sim.num_trials * (sim.num_samples - sim.burn_samples)\n    avg_lf, n = 0.0, 0\n    for leg in sim.legs:\n        lf = 100.0 * leg.gt_sold / (leg.capacity * num_samples)\n        avg_lf += lf\n        n += 1\n\n    tot_rev = 0.0\n    for m in sim.demands:\n        tot_rev += m.revenue\n\n    avg_lf = avg_lf / n if n &gt; 0 else 0\n    if to_log:\n        logger.info(f\"    LF:  {avg_lf:6.2f}%, Total revenue = ${tot_rev:,.2f}\")\n\n    path_df = []\n    for path in sim.paths:\n        avg_sold = path.gt_sold / num_samples\n        avg_sold_priceable = path.gt_sold_priceable / num_samples\n        avg_rev = path.gt_revenue / num_samples\n        if to_log:\n            logger.info(\n                f\"{path}, avg_sold={avg_sold:6.2f}, avg_rev=${avg_rev:10,.2f}\"\n            )\n        if path.num_legs() == 1:\n            path_df.append(\n                dict(\n                    orig=path.orig,\n                    dest=path.dest,\n                    carrier1=path.get_leg_carrier(0),\n                    flt_no1=path.get_leg_fltno(0),\n                    carrier2=None,\n                    flt_no2=None,\n                    avg_sold=avg_sold,\n                    avg_sold_priceable=avg_sold_priceable,\n                    avg_rev=avg_rev,\n                )\n            )\n        elif path.num_legs() == 2:\n            path_df.append(\n                dict(\n                    orig=path.orig,\n                    dest=path.dest,\n                    carrier1=path.get_leg_carrier(0),\n                    flt_no1=path.get_leg_fltno(0),\n                    carrier2=path.get_leg_carrier(1),\n                    flt_no2=path.get_leg_fltno(1),\n                    avg_sold=avg_sold,\n                    avg_sold_priceable=avg_sold_priceable,\n                    avg_rev=avg_rev,\n                )\n            )\n        else:\n            raise NotImplementedError(\"path with other than 1 or 2 legs\")\n    path_df = pd.DataFrame(path_df)\n    if to_db and to_db.is_open:\n        to_db.save_dataframe(\"path_summary\", path_df)\n    return path_df\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.compute_reports", "title": "compute_reports", "text": "<pre><code>compute_reports(\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: bool | database.Database = True,\n    additional=(\n        \"fare_class_mix\",\n        \"load_factors\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n    ),\n) -&gt; SummaryTables\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def compute_reports(\n    self,\n    sim: SimulationEngine,\n    to_log=True,\n    to_db: bool | database.Database = True,\n    additional=(\n        \"fare_class_mix\",\n        \"load_factors\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n    ),\n) -&gt; SummaryTables:\n    num_samples = sim.num_trials * (sim.num_samples - sim.burn_samples)\n    if num_samples &lt;= 0:\n        raise ValueError(\n            \"insufficient number of samples outside burn period for reporting\"\n            f\"\\n- num_trials = {sim.num_trials}\"\n            f\"\\n- num_samples = {sim.num_samples}\"\n            f\"\\n- burn_samples = {sim.burn_samples}\"\n        )\n\n    if to_db is True:\n        to_db = self.cnx\n    dmd_df = self.compute_demand_report(sim, to_log, to_db)\n    fare_df = self.compute_fare_report(sim, to_log, to_db)\n    leg_df = self.compute_leg_report(sim, to_log, to_db)\n    path_df = self.compute_path_report(sim, to_log, to_db)\n    path_classes_df = self.compute_path_class_report(sim, to_log, to_db)\n    carrier_df = self.compute_carrier_report(sim, to_log, to_db)\n\n    summary = SummaryTables(\n        demands=dmd_df,\n        fares=fare_df,\n        legs=leg_df,\n        paths=path_df,\n        path_classes=path_classes_df,\n        carriers=carrier_df,\n    )\n    summary.load_additional_tables(self.cnx, sim.name, sim.burn_samples, additional)\n    return summary\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.from_yaml", "title": "from_yaml  <code>classmethod</code>", "text": "<pre><code>from_yaml(\n    filenames: pathlib.Path | list[pathlib.Path],\n    output_dir: pathlib.Path | None = None,\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>@classmethod\ndef from_yaml(\n    cls,\n    filenames: pathlib.Path | list[pathlib.Path],\n    output_dir: pathlib.Path | None = None,\n):\n    config = passengersim.config.Config.from_yaml(filenames)\n    return cls(config, output_dir)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.generate_dcp_rm_events", "title": "generate_dcp_rm_events", "text": "<pre><code>generate_dcp_rm_events(debug=False)\n</code></pre> <p>Pushes an event per reading day (DCP) onto the queue. Also adds events for daily reoptimzation</p> Source code in <code>passengersim/driver.py</code> <pre><code>def generate_dcp_rm_events(self, debug=False):\n    \"\"\"Pushes an event per reading day (DCP) onto the queue.\n    Also adds events for daily reoptimzation\"\"\"\n    dcp_hour = self.sim.config.simulation_controls.dcp_hour\n    if debug:\n        tmp = datetime.fromtimestamp(self.sim.base_time, tz=timezone.utc)\n        print(f\"Base Time is {tmp.strftime('%Y-%m-%d %H:%M:%S %Z')}\")\n    for dcp_index, dcp in enumerate(self.dcp_list):\n        if dcp == 0:\n            continue\n        event_time = int(self.sim.base_time - dcp * 86400 + 3600 * dcp_hour)\n        if debug:\n            tmp = datetime.fromtimestamp(event_time, tz=timezone.utc)\n            print(f\"Added DCP {dcp} at {tmp.strftime('%Y-%m-%d %H:%M:%S %Z')}\")\n        info = (\"DCP\", dcp, dcp_index)\n        rm_event = Event(info, event_time)\n        self.sim.add_event(rm_event)\n\n    # Now add the events for daily reoptimization\n    max_days_prior = max(self.dcp_list)\n    for days_prior in range(max_days_prior):\n        if days_prior not in self.dcp_list:\n            info = (\"daily\", days_prior, 0)\n            event_time = int(\n                self.sim.base_time - days_prior * 86400 + 3600 * dcp_hour\n            )\n            rm_event = Event(info, event_time)\n            self.sim.add_event(rm_event)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.generate_demands", "title": "generate_demands", "text": "<pre><code>generate_demands(system_rn=None, debug=False)\n</code></pre> <p>Generate demands, following the procedure used in PODS The biggest difference is that we can put all the timeframe (DCP) demands into the event queue before any processing. For large models, I might rewrite this into the C++ core in the future</p> Source code in <code>passengersim/driver.py</code> <pre><code>def generate_demands(self, system_rn=None, debug=False):\n    \"\"\"Generate demands, following the procedure used in PODS\n    The biggest difference is that we can put all the timeframe (DCP) demands\n    into the event queue before any processing.\n    For large models, I might rewrite this into the C++ core in the future\"\"\"\n    self.generate_dcp_rm_events()\n    total_events = 0\n    system_rn = (\n        self.random_generator.get_normal() if system_rn is None else system_rn\n    )\n\n    # We don't have an O&amp;D object, but we use this to get a market random number per market\n    mrn_ref = {}\n\n    # Need to have leisure / business split for PODS\n    trn_ref = {\n        \"business\": self.random_generator.get_normal(),\n        \"leisure\": self.random_generator.get_normal(),\n    }\n\n    def get_or_make_random(grouping, key):\n        if key not in grouping:\n            grouping[key] = self.random_generator.get_normal()\n        return grouping[key]\n\n    end_time = self.base_time\n\n    for dmd in self.sim.demands:\n        base = dmd.base_demand\n\n        # Get the random numbers we're going to use to perturb demand\n        trn = get_or_make_random(trn_ref, (dmd.orig, dmd.dest, dmd.segment))\n        mrn = get_or_make_random(mrn_ref, (dmd.orig, dmd.dest))\n        if self.sim.config.simulation_controls.simple_k_factor:\n            urn = (\n                self.random_generator.get_normal()\n                * self.sim.config.simulation_controls.simple_k_factor\n            )\n        else:\n            urn = 0\n\n        mu = base * (\n            1.0\n            + system_rn * self.sim.sys_k_factor\n            + mrn * self.sim.mkt_k_factor\n            + trn * self.sim.pax_type_k_factor\n            + urn\n        )\n        mu = max(mu, 0.0)\n        sigma = sqrt(\n            mu * self.sim.config.simulation_controls.tot_z_factor\n        )  # Correct?\n        n = mu + sigma * self.random_generator.get_normal()\n        dmd.scenario_demand = max(n, 0)\n\n        if debug:\n            logger.debug(\n                f\"DMD,{self.sim.sample},{dmd.orig},{dmd.dest},{dmd.segment},{dmd.base_demand},\"\n                f\"{round(mu,2)},{round(sigma,2)},{round(n,2)}\"\n            )\n\n        # Now we split it up over timeframes and add it to the simulation\n        num_pax = int(dmd.scenario_demand + 0.5)  # rounding\n        if (\n            self.sim.config.simulation_controls.timeframe_demand_allocation\n            == \"pods\"\n        ):\n            num_events_by_tf = self.sim.allocate_demand_to_tf_pods(\n                dmd, num_pax, self.sim.tf_k_factor, int(end_time)\n            )\n        else:\n            num_events_by_tf = self.sim.allocate_demand_to_tf(\n                dmd, num_pax, self.sim.tf_k_factor, int(end_time)\n            )\n        num_events = sum(num_events_by_tf)\n        total_events += num_events\n        if num_events != round(num_pax):\n            # print(f\"Generate demand function, num_pax={num_pax}, num_events={num_events}\")\n            raise Exception(\n                f\"Generate demand function, num_pax={num_pax}, num_events={num_events}\"\n            )\n\n    return total_events\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.license_info", "title": "license_info", "text": "<pre><code>license_info(certificate_filename=None)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def license_info(self, certificate_filename=None):\n    user_cert = self._user_certificate(certificate_filename)\n    return self.sim.license_info(user_cert)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.path_names", "title": "path_names", "text": "<pre><code>path_names()\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def path_names(self):\n    result = {}\n    for p in self.sim.paths:\n        result[p.path_id] = str(p)\n    return result\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.reseed", "title": "reseed", "text": "<pre><code>reseed(seed: int | list[int] | None = 42)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def reseed(self, seed: int | list[int] | None = 42):\n    logger.debug(\"reseeding random_generator: %s\", seed)\n    self.sim.random_generator.seed(seed)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.run", "title": "run", "text": "<pre><code>run(log_reports: bool = False) -&gt; SummaryTables\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def run(self, log_reports: bool = False) -&gt; SummaryTables:\n    start_time = time.time()\n    self.setup_scenario()\n    self._run_sim()\n    summary = self.compute_reports(\n        self.sim,\n        to_log=log_reports or self.sim.config.outputs.log_reports,\n        additional=self.sim.config.outputs.reports,\n    )\n    if self.sim.config.outputs.excel:\n        summary.to_xlsx(self.sim.config.outputs.excel)\n    logger.info(\n        f\"Th' th' that's all folks !!!    (Elapsed time = {round(time.time() - start_time, 2)})\"\n    )\n    return summary\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.run_airline_models", "title": "run_airline_models", "text": "<pre><code>run_airline_models(\n    info: Any = None, departed: bool = False, debug=False\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def run_airline_models(self, info: Any = None, departed: bool = False, debug=False):\n    event_type = info[0]\n    recording_day = info[\n        1\n    ]  # could in theory also be non-integer for fractional days\n    dcp_index = info[2]\n    if dcp_index == -1:\n        dcp_index = len(self.dcp_list) - 1\n\n    if event_type.lower() in {\"dcp\", \"done\"}:\n        self.sim.last_dcp = recording_day\n        self.capture_dcp_data(dcp_index)\n\n    # This will change once we have \"dcp\" and \"daily\" portions of an RM system in the YAML input file\n    for airline in self.sim.airlines:\n        if event_type.lower() in {\"dcp\", \"done\"}:\n            airline.rm_system.run(\n                self.sim, airline.name, dcp_index, recording_day, event_type=\"dcp\"\n            )\n        elif event_type.lower() == \"daily\":\n            airline.rm_system.run(\n                self.sim, airline.name, dcp_index, recording_day, event_type=\"daily\"\n            )\n\n    if event_type.lower() == \"daily\":\n        if (\n            self.cnx.is_open\n            and self.sim.save_timeframe_details\n            and recording_day &gt; 0\n        ):\n            self.sim.write_to_sqlite(\n                self.cnx._connection,\n                recording_day,\n                store_bid_prices=self.sim.config.db.store_leg_bid_prices,\n                intermediate_day=True,\n            )\n    elif event_type.lower() in {\"dcp\", \"done\"}:\n        if self.cnx.is_open:\n            self.cnx.save_details(self.sim, recording_day)\n        if self.file_writer is not None:\n            self.file_writer.save_details(self.sim, recording_day)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.set_classes", "title": "set_classes", "text": "<pre><code>set_classes(_leg, debug=False)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def set_classes(self, _leg, debug=False):\n    cap = float(_leg.capacity)\n    if debug:\n        print(_leg, \"Capacity = \", cap)\n    for bkg_class in self.classes:\n        # Input as a percentage\n        auth = int(cap * self.init_rm.get(bkg_class, 100.0) / 100.0)\n        b = passengersim.core.Bucket(bkg_class, alloc=auth)\n        # print(\"adding bucket\", b)\n        _leg.add_bucket(b)\n        if debug:\n            print(\"    Bucket\", bkg_class, auth)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.setup_scenario", "title": "setup_scenario", "text": "<pre><code>setup_scenario()\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def setup_scenario(self):\n    self.cnx.delete_experiment(self.sim.name)\n    logger.debug(\"building connections\")\n    num_paths = self.sim.build_connections()\n    if num_paths and self.cnx.is_open:\n        database.tables.create_table_path_defs(self.cnx._connection, self.sim.paths)\n    logger.debug(f\"Connections done, num_paths = {num_paths}\")\n    self.vn_initial_mapping()\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.validate_license", "title": "validate_license", "text": "<pre><code>validate_license(\n    certificate_filename=None, future: int = 0\n)\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def validate_license(self, certificate_filename=None, future: int = 0):\n    user_cert = self._user_certificate(certificate_filename)\n    return self.sim.validate_license(user_cert, future=future)\n</code></pre>"}, {"location": "API/simulation.html#passengersim.driver.Simulation.vn_initial_mapping", "title": "vn_initial_mapping", "text": "<pre><code>vn_initial_mapping()\n</code></pre> Source code in <code>passengersim/driver.py</code> <pre><code>def vn_initial_mapping(self):\n    vn_airlines = []\n    for airline in self.sim.airlines:\n        if airline.control == \"vn\":\n            vn_airlines.append(airline.name)\n\n    for path in self.sim.paths:\n        if path.get_leg_carrier(0) in vn_airlines:\n            for bc in self.classes:\n                pc = PathClass(bc)\n                index = int(bc[1])\n                pc.set_indexes(index, index)\n                path.add_path_class(pc)\n</code></pre>"}, {"location": "API/summary.html", "title": "Summary Results", "text": ""}, {"location": "API/summary.html#passengersim.summary.logger", "title": "logger  <code>module-attribute</code>", "text": "<pre><code>logger = logging.getLogger('passengersim.summary')\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables", "title": "SummaryTables", "text": "Source code in <code>passengersim/summary.py</code> <pre><code>class SummaryTables:\n    @classmethod\n    def from_sqlite(\n        cls,\n        filename: str,\n        make_indexes: bool = False,\n        additional: Collection[str | tuple] = (\n            \"fare_class_mix\",\n            \"load_factors\",\n            \"bookings_by_timeframe\",\n            \"total_demand\",\n        ),\n    ):\n        if not os.path.isfile(filename):\n            raise FileNotFoundError(filename)\n        db = database.Database(\n            engine=\"sqlite\",\n            filename=filename,\n        )\n\n        demands = cls.load_basic_table(db, \"demand_summary\")\n        legs = cls.load_basic_table(db, \"leg_summary\")\n        paths = cls.load_basic_table(db, \"path_summary\")\n        carriers = cls.load_basic_table(db, \"carrier_summary\")\n\n        summary = cls(\n            demands=demands,\n            legs=legs,\n            paths=paths,\n            carriers=carriers,\n        )\n\n        if make_indexes:\n            db.add_indexes()\n\n        logger.info(\"loading configs\")\n        config = db.load_configs()\n\n        summary.load_additional_tables(\n            db,\n            scenario=config.scenario,\n            burn_samples=config.simulation_controls.burn_samples,\n            additional=additional,\n        )\n        summary.cnx = db\n        return summary\n\n    @classmethod\n    def load_basic_table(self, db: database.Database, tablename: str):\n        \"\"\"Load a basic table\"\"\"\n        logger.info(\"loading %s\", tablename)\n        return db.dataframe(f\"SELECT * FROM {tablename}\")\n\n    def load_additional_tables(\n        self,\n        db: database.Database,\n        scenario: str,\n        burn_samples: int,\n        additional: Collection[str | tuple] = (\n            \"fare_class_mix\",\n            \"bookings_by_timeframe\",\n            \"total_demand\",\n        ),\n    ) -&gt; None:\n        if \"fare_class_mix\" in additional and db.is_open:\n            logger.info(\"loading fare_class_mix\")\n            self.fare_class_mix = database.common_queries.fare_class_mix(\n                db, scenario, burn_samples=burn_samples\n            )\n            if self.od_fare_class_mix:\n                for orig, dest in list(self.od_fare_class_mix):\n                    self.od_fare_class_mix[\n                        (orig, dest)\n                    ] = database.common_queries.od_fare_class_mix(\n                        db, orig, dest, scenario, burn_samples=burn_samples\n                    )\n\n        for i in additional:\n            if isinstance(i, tuple) and i[0] == \"od_fare_class_mix\" and db.is_open:\n                orig, dest = i[1], i[2]\n                if self.od_fare_class_mix is None:\n                    self.od_fare_class_mix = {}\n                logger.info(f\"loading od_fare_class_mix({orig},{dest})\")\n                self.od_fare_class_mix[\n                    (orig, dest)\n                ] = database.common_queries.od_fare_class_mix(\n                    db, orig, dest, scenario, burn_samples=burn_samples\n                )\n\n        if \"bookings_by_timeframe\" in additional and db.is_open:\n            logger.info(\"loading bookings_by_timeframe\")\n            self.bookings_by_timeframe = database.common_queries.bookings_by_timeframe(\n                db, scenario, burn_samples=burn_samples\n            )\n\n        if \"total_demand\" in additional and db.is_open:\n            logger.info(\"loading total_demand\")\n            self.total_demand = database.common_queries.total_demand(\n                db, scenario, burn_samples\n            )\n\n        if \"leg_forecasts\" in additional and db.is_open:\n            logger.info(\"loading leg_forecasts\")\n            self.leg_forecasts = database.common_queries.leg_forecasts(\n                db, scenario, burn_samples\n            )\n\n        if \"path_forecasts\" in additional and db.is_open:\n            logger.info(\"loading path_forecasts\")\n            self.path_forecasts = database.common_queries.path_forecasts(\n                db, scenario, burn_samples\n            )\n\n        if \"demand_to_come\" in additional and db.is_open:\n            logger.info(\"loading demand_to_come\")\n            self.demand_to_come = database.common_queries.demand_to_come(db, scenario)\n\n        if \"carrier_history\" in additional and db.is_open:\n            logger.info(\"loading carrier_history\")\n            self.carrier_history = database.common_queries.carrier_history(db, scenario)\n\n        if \"bid_price_history\" in additional and db.is_open:\n            logger.info(\"loading bid_price_history\")\n            self.bid_price_history = database.common_queries.bid_price_history(\n                db, scenario, burn_samples\n            )\n\n        if \"local_and_flow_yields\" in additional and db.is_open:\n            logger.info(\"loading local_and_flow_yields\")\n            self.local_and_flow_yields = database.common_queries.local_and_flow_yields(\n                db, scenario, burn_samples\n            )\n\n    def __init__(\n        self,\n        demands: pd.DataFrame | None = None,\n        fares: pd.DataFrame | None = None,\n        legs: pd.DataFrame | None = None,\n        paths: pd.DataFrame | None = None,\n        path_classes: pd.DataFrame | None = None,\n        carriers: pd.DataFrame | None = None,\n        fare_class_mix: pd.DataFrame | None = None,\n        load_factors: pd.DataFrame | None = None,\n        bookings_by_timeframe: pd.DataFrame | None = None,\n        total_demand: float | None = None,\n        od_fare_class_mix: dict[tuple[str, str], pd.DataFrame] | None = None,\n        leg_forecasts: pd.DataFrame | None = None,\n        path_forecasts: pd.DataFrame | None = None,\n        carrier_history: pd.DataFrame | None = None,\n        demand_to_come: pd.DataFrame | None = None,\n        bid_price_history: pd.DataFrame | None = None,\n        local_and_flow_yields: pd.DataFrame | None = None,\n    ):\n        self.demands = demands\n        self.fares = fares\n        self.legs = legs\n        self.paths = paths\n        self.path_classes = path_classes\n        self.carriers = carriers\n        self.fare_class_mix = fare_class_mix\n        self.od_fare_class_mix = od_fare_class_mix\n        self.load_factors = load_factors\n        self.bookings_by_timeframe = bookings_by_timeframe\n        self.total_demand = total_demand\n        self.leg_forecasts = leg_forecasts\n        self.path_forecasts = path_forecasts\n        self.carrier_history = carrier_history\n        self.demand_to_come = demand_to_come\n        self.bid_price_history = bid_price_history\n        self.local_and_flow_yields = local_and_flow_yields\n\n    def to_records(self):\n        return {k: v.to_dict(orient=\"records\") for (k, v) in self.__dict__.items()}\n\n    def to_xlsx(self, filename: str | pathlib.Path) -&gt; None:\n        \"\"\"Write summary tables to excel.\n\n        Parameters\n        ----------\n        filename : Path-like\n            The excel file to write.\n        \"\"\"\n        if isinstance(filename, str):\n            filename = pathlib.Path(filename)\n        filename.parent.mkdir(exist_ok=True, parents=True)\n        with pd.ExcelWriter(filename) as writer:\n            for k, v in self.__dict__.items():\n                if isinstance(v, pd.DataFrame):\n                    v.to_excel(writer, sheet_name=k)\n\n    def aggregate_demand_history(self, by_segment: bool = True) -&gt; pd.Series:\n        \"\"\"\n        Total demand by sample, aggregated over all markets.\n\n        Parameters\n        ----------\n        by_segment : bool, default True\n            Aggregate by segment.  If false, segments are also aggregated.\n\n        Returns\n        -------\n        pandas.Series\n            Total demand, indexed by trial, sample, and segment\n            (business/leisure).\n        \"\"\"\n        groupbys = [\"trial\", \"sample\"]\n        if by_segment:\n            groupbys.append(\"segment\")\n        return self.demand_to_come.iloc[:, 0].groupby(groupbys, observed=False).sum()\n\n    def demand_in_tf(self) -&gt; pd.DataFrame | None:\n        \"\"\"History of demand arriving in each timeframe.\n\n        This dataframe is derived from the `demand_to_come` dataframe\n        by taking the sequential differences.\n        \"\"\"\n        if self.demand_to_come is None:\n            return None\n        return self.demand_to_come.diff(-1, axis=1).iloc[:, :-1]\n\n    def fig_carrier_mileage(self, raw_df: bool = False, report=None):\n        \"\"\"\n        Figure showing ASM, RPM by carrier.\n\n        ASM is available seat miles.  RPM is revenue passenger miles.\n\n        Parameters\n        ----------\n        raw_df : bool, default False\n            Return the raw data for this figure as a pandas DataFrame, instead\n            of generating the figure itself.\n        report : xmle.Reporter, optional\n            Also append this figure to the given report.\n        \"\"\"\n        df = (\n            self.carriers.reset_index()[[\"carrier\", \"asm\", \"rpm\"]]\n            .set_index(\"carrier\")\n            .rename_axis(columns=\"measure\")\n            .unstack()\n            .to_frame(\"value\")\n            .reset_index()\n        )\n        if raw_df:\n            return df\n        import altair as alt\n\n        chart = alt.Chart(df, title=\"Carrier Loads\")\n        bars = chart.mark_bar().encode(\n            x=alt.X(\"carrier:N\", title=\"Carrier\"),\n            y=alt.Y(\"value\", stack=None, title=\"miles\"),\n            color=\"measure\",\n            tooltip=[\"carrier\", \"measure\", alt.Tooltip(\"value\", format=\".4s\")],\n        )\n        text = chart.mark_text(\n            dx=0,\n            dy=5,\n            color=\"white\",\n            baseline=\"top\",\n        ).encode(\n            x=alt.X(\"carrier:N\"),\n            y=alt.Y(\"value\").stack(None),\n            text=alt.Text(\"value:Q\", format=\".4s\"),\n        )\n        fig = (\n            (bars + text)\n            .properties(\n                width=400,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n        if report:\n            report.add_figure(fig)\n        return fig\n\n    def _fig_fare_class_mix(\n        self, df: pd.DataFrame, label_threshold: float = 0.06, title=None\n    ):\n        import altair as alt\n\n        label_threshold_value = (\n            df.groupby(\"carrier\").avg_sold.sum().max() * label_threshold\n        )\n        chart = alt.Chart(\n            df, **({\"title\": title} if title else {})\n        ).transform_calculate(\n            halfsold=\"datum.avg_sold / 2.0\",\n        )\n        bars = chart.mark_bar().encode(\n            x=alt.X(\"carrier:N\", title=\"Carrier\"),\n            y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n            color=\"booking_class\",\n            tooltip=[\n                \"carrier\",\n                \"booking_class\",\n                alt.Tooltip(\"avg_sold\", format=\".2f\"),\n            ],\n        )\n        text = chart.mark_text(dx=0, dy=3, color=\"white\", baseline=\"top\").encode(\n            x=alt.X(\"carrier:N\", title=\"Carrier\"),\n            y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n            text=alt.Text(\"avg_sold:Q\", format=\".2f\"),\n            opacity=alt.condition(\n                f\"datum.avg_sold &lt; {label_threshold_value:.3f}\",\n                alt.value(0),\n                alt.value(1),\n            ),\n            order=alt.Order(\"booking_class:N\", sort=\"descending\"),\n        )\n        return (\n            (bars + text)\n            .properties(\n                width=400,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n\n    @report_figure\n    def fig_fare_class_mix(self, raw_df=False, label_threshold=0.06):\n        df = self.fare_class_mix.reset_index()[[\"carrier\", \"booking_class\", \"avg_sold\"]]\n        if raw_df:\n            return df\n        return self._fig_fare_class_mix(\n            df,\n            label_threshold=label_threshold,\n            title=\"Fare Class Mix\",\n        )\n\n    @report_figure\n    def fig_od_fare_class_mix(\n        self, orig: str, dest: str, raw_df=False, label_threshold=0.06\n    ):\n        df = self.od_fare_class_mix[orig, dest].reset_index()[\n            [\"carrier\", \"booking_class\", \"avg_sold\"]\n        ]\n        if raw_df:\n            return df\n        return self._fig_fare_class_mix(\n            df, label_threshold=label_threshold, title=f\"Fare Class Mix ({orig}-{dest})\"\n        )\n\n    @property\n    def raw_fare_class_mix(self) -&gt; pd.DataFrame:\n        \"\"\"Raw data giving the fare class mix.\n\n        This tidy dataframe contains these columns:\n\n        - carrier (str)\n        - booking_class (str)\n        - avg_sold (float)\n        \"\"\"\n        return self.fig_fare_class_mix(raw_df=True)\n\n    @report_figure\n    def fig_bookings_by_timeframe(\n        self,\n        by_carrier: bool | str = True,\n        by_class: bool | str = False,\n        raw_df: bool = False,\n        errorbands: bool = False,\n        exclude_nogo: bool = True,\n    ):\n        if errorbands:\n            if by_carrier is True:\n                raise NotImplementedError(\"error bands for all airlines is messy\")\n            return self._fig_bookings_by_timeframe_errorband(\n                by_carrier=by_carrier, raw_df=raw_df\n            )\n\n        def differs(x):\n            return x.shift(-1, fill_value=0) - x\n\n        def _summarize(x: pd.DataFrame, c: str):\n            if \"trial\" not in x.columns:\n                x = x.assign(trial=0)\n            if by_class:\n                y = (\n                    x.groupby([\"trial\", \"carrier\", \"booking_class\", \"rrd\"])[f\"avg_{c}\"]\n                    .sum()\n                    .unstack([\"trial\", \"carrier\", \"booking_class\"])\n                    .sort_index(ascending=False)\n                    .apply(differs)\n                    .stack([\"carrier\", \"booking_class\"])\n                    .aggregate([\"mean\", \"sem\"], axis=1)\n                    .assign(\n                        ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                        ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                    )\n                )\n            else:\n                y = (\n                    x.groupby([\"trial\", \"carrier\", \"rrd\"])[f\"avg_{c}\"]\n                    .sum()\n                    .unstack([\"trial\", \"carrier\"])\n                    .sort_index(ascending=False)\n                    .apply(differs)\n                    .stack(\"carrier\")\n                    .aggregate([\"mean\", \"sem\"], axis=1)\n                    .assign(\n                        ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                        ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                    )\n                )\n            return pd.concat({c: y}, names=[\"paxtype\"])\n\n        bookings_by_timeframe = self.bookings_by_timeframe.reset_index()\n        df0 = _summarize(bookings_by_timeframe, \"business\")\n        df1 = _summarize(bookings_by_timeframe, \"leisure\")\n        df = (\n            pd.concat([df0, df1], axis=0)\n            .rename(columns={\"mean\": \"sold\"})\n            .reset_index()\n            .query(\"(rrd&gt;0) &amp; (sold&gt;0)\")\n        )\n        title = \"Bookings by Timeframe\"\n        if by_class is True:\n            title = \"Bookings by Timeframe and Booking Class\"\n        title_annot = []\n        if not by_carrier:\n            g = [\"rrd\", \"paxtype\"]\n            if by_class:\n                g += [\"booking_class\"]\n            df = df.groupby(g)[[\"sold\", \"ci0\", \"ci1\"]].sum().reset_index()\n        if isinstance(by_carrier, str):\n            df = df[df[\"carrier\"] == by_carrier]\n            df = df.drop(columns=[\"carrier\"])\n            title_annot.append(by_carrier)\n            by_carrier = False\n        if isinstance(by_class, str):\n            df = df[df[\"booking_class\"] == by_class]\n            df = df.drop(columns=[\"booking_class\"])\n            title_annot.append(f\"Class {by_class}\")\n            by_class = False\n        if title_annot:\n            title = f\"{title} ({', '.join(title_annot)})\"\n        if exclude_nogo and \"carrier\" in df.columns:\n            df = df[df[\"carrier\"] != \"NONE\"]\n        if raw_df:\n            return df\n\n        import altair as alt\n\n        if by_carrier:\n            color = \"carrier:N\"\n            color_title = \"Carrier\"\n        elif by_class:\n            color = \"class:N\"\n            color_title = \"Booking Class\"\n        else:\n            color = \"paxtype:N\"\n            color_title = \"Passenger Type\"\n\n        if by_class:\n            chart = (\n                alt.Chart(df)\n                .mark_bar()\n                .encode(\n                    color=alt.Color(color).title(color_title),\n                    x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n                    y=alt.Y(\"sold\"),\n                    tooltip=(\n                        [alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else []\n                    )\n                    + [\n                        alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                        alt.Tooltip(\"rrd\", title=\"DfD\"),\n                        alt.Tooltip(\"sold\", format=\".2f\"),\n                    ],\n                )\n                .properties(\n                    width=500,\n                    height=200,\n                )\n                .facet(\n                    row=alt.Row(\"paxtype:N\", title=\"Passenger Type\"),\n                    title=title,\n                )\n                .configure_title(fontSize=18)\n            )\n        else:\n            chart = (\n                alt.Chart(df, title=title)\n                .mark_line()\n                .encode(\n                    color=alt.Color(color).title(color_title),\n                    x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n                    y=alt.Y(\"sold\") if by_class else \"sold\",\n                    strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n                    tooltip=(\n                        [alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else []\n                    )\n                    + [\n                        alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                        alt.Tooltip(\"rrd\", title=\"DfD\"),\n                        alt.Tooltip(\"sold\", format=\".2f\"),\n                    ],\n                )\n                .properties(\n                    width=500,\n                    height=300,\n                )\n                .configure_axis(\n                    labelFontSize=12,\n                    titleFontSize=12,\n                )\n                .configure_legend(\n                    titleFontSize=12,\n                    labelFontSize=15,\n                )\n            )\n        return chart\n\n    def _fig_bookings_by_timeframe_errorband(\n        self, by_carrier: bool | str = True, raw_df=False\n    ):\n        def differs(x):\n            return x.shift(-1, fill_value=0) - x\n\n        b = self.bookings_by_timeframe.reset_index()\n\n        def _summarize(x, c):\n            y = (\n                x.groupby([\"trial\", \"carrier\", \"rrd\"])[f\"avg_{c}\"]\n                .sum()\n                .unstack([\"trial\", \"carrier\"])\n                .sort_index(ascending=False)\n                .apply(differs)\n                .stack(\"carrier\")\n                .aggregate([\"mean\", \"sem\"], axis=1)\n                .assign(\n                    ci0=lambda x: x[\"mean\"] - 1.96 * x[\"sem\"],\n                    ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                )\n            )\n            return pd.concat({c: y}, names=[\"paxtype\"])\n\n        df0 = _summarize(b, \"business\")\n        df1 = _summarize(b, \"leisure\")\n        df = (\n            pd.concat([df0, df1], axis=0)\n            .rename(columns={\"mean\": \"sold\"})\n            .reset_index()\n            .query(\"rrd&gt;0\")\n        )\n        if not by_carrier:\n            df = (\n                df.groupby([\"rrd\", \"paxtype\"])[[\"sold\", \"ci0\", \"ci1\"]]\n                .sum()\n                .reset_index()\n            )\n        if isinstance(by_carrier, str):\n            df = df[df[\"carrier\"] == by_carrier]\n            df = df.drop(columns=[\"carrier\"])\n            by_carrier = False\n        if raw_df:\n            return df\n        import altair as alt\n\n        chart = alt.Chart(df)\n        lines = chart.mark_line().encode(\n            color=alt.Color(\"carrier:N\" if by_carrier else \"paxtype\").title(\n                \"Carrier\" if by_carrier else \"Passenger Type\"\n            ),\n            x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n            y=\"sold\",\n            strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n            tooltip=([alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else [])\n            + [\n                alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                alt.Tooltip(\"rrd\", title=\"DfD\"),\n                alt.Tooltip(\"sold\", format=\".2f\"),\n            ],\n        )\n        bands = chart.mark_errorband().encode(\n            color=alt.Color(\n                \"carrier:N\" if by_carrier else \"paxtype\",\n                title=\"Carrier\" if by_carrier else \"Passenger Type\",\n            ),\n            x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n            y=\"ci0\",\n            y2=\"ci1\",\n            strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n        )\n\n        return (\n            (lines + bands)\n            .properties(\n                width=500,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n\n    def _fig_carrier_load_factors(\n        self,\n        raw_df: bool,\n        load_measure: str,\n        measure_name: str,\n        measure_format: str = \".2f\",\n        orient: Literal[\"h\", \"v\"] = \"h\",\n        title: str | None = None,\n    ):\n        df = self.carriers.reset_index()[[\"carrier\", load_measure]]\n        if raw_df:\n            return df\n        import altair as alt\n\n        chart = alt.Chart(df)\n        if orient == \"v\":\n            bars = chart.mark_bar().encode(\n                x=alt.X(\"carrier:N\", title=\"Carrier\"),\n                y=alt.Y(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                tooltip=[\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\n                        f\"{load_measure}:Q\", title=measure_name, format=measure_format\n                    ),\n                ],\n            )\n            text = chart.mark_text(dx=0, dy=3, color=\"white\", baseline=\"top\").encode(\n                x=alt.X(\"carrier:N\", title=\"Carrier\"),\n                y=alt.Y(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                text=alt.Text(f\"{load_measure}:Q\", format=measure_format),\n            )\n        else:\n            bars = chart.mark_bar().encode(\n                y=alt.Y(\"carrier:N\", title=\"Carrier\"),\n                x=alt.X(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                tooltip=[\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\n                        f\"{load_measure}:Q\", title=measure_name, format=measure_format\n                    ),\n                ],\n            )\n            text = chart.mark_text(\n                dx=-5, dy=0, color=\"white\", baseline=\"middle\", align=\"right\"\n            ).encode(\n                y=alt.Y(\"carrier:N\", title=\"Carrier\"),\n                x=alt.X(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                text=alt.Text(f\"{load_measure}:Q\", format=measure_format),\n            )\n        fig = (\n            (bars + text)\n            .properties(\n                width=500,\n                height=10 + 20 * len(df),\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n        if title:\n            fig.title = title\n        return fig\n\n    @report_figure\n    def fig_carrier_load_factors(\n        self, raw_df=False, load_measure: Literal[\"sys_lf\", \"avg_leg_lf\"] = \"sys_lf\"\n    ):\n        measure_name = (\n            \"System Load Factor\" if load_measure == \"sys_lf\" else \"Leg Load Factor\"\n        )\n        return self._fig_carrier_load_factors(\n            raw_df,\n            load_measure,\n            measure_name,\n            title=f\"Carrier {measure_name}s\",\n        )\n\n    @report_figure\n    def fig_carrier_revenues(self, raw_df=False):\n        return self._fig_carrier_load_factors(\n            raw_df, \"avg_rev\", \"Average Revenue\", \"$.4s\", title=\"Carrier Revenues\"\n        )\n\n    @report_figure\n    def fig_carrier_yields(self, raw_df=False):\n        return self._fig_carrier_load_factors(\n            raw_df, \"yield\", \"Average Yield\", \"$.4f\", title=\"Carrier Yields\"\n        )\n\n    def _fig_forecasts(\n        self, df, facet_on=None, y=\"forecast_mean\", color=\"booking_class:N\"\n    ):\n        import altair as alt\n\n        encoding = dict(\n            x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n            y=alt.Y(f\"{y}:Q\", title=\"Avg Demand Forecast\"),\n        )\n        if color:\n            encoding[\"color\"] = color\n        if not facet_on:\n            return alt.Chart(df).mark_line().encode(**encoding)\n        else:\n            return (\n                alt.Chart(df)\n                .mark_line()\n                .encode(**encoding)\n                .facet(\n                    facet=f\"{facet_on}:N\",\n                    columns=3,\n                )\n            )\n\n    @report_figure\n    def fig_leg_forecasts(\n        self,\n        by_flt_no: bool | int = True,\n        by_class: bool | str = True,\n        of: Literal[\"mu\", \"sigma\"] = \"mu\",\n        raw_df=False,\n    ):\n        y = \"forecast_mean\" if of == \"mu\" else \"forecast_stdev\"\n        columns = [\n            \"carrier\",\n            \"flt_no\",\n            \"booking_class\",\n            \"rrd\",\n            y,\n        ]\n        if self.leg_forecasts is None:\n            raise ValueError(\"the leg_forecasts summary table is not available\")\n        df = self.leg_forecasts.reset_index()[columns]\n        color = \"booking_class:N\"\n        if isinstance(by_flt_no, int) and by_flt_no is not True:\n            df = df[df.flt_no == by_flt_no]\n        if isinstance(by_class, str):\n            df = df[df.booking_class == by_class]\n            color = None\n        if raw_df:\n            return df\n        return self._fig_forecasts(df, facet_on=None, y=y, color=color)\n\n    @report_figure\n    def fig_path_forecasts(\n        self,\n        by_path_id: bool | int = True,\n        by_class: bool | str = True,\n        of: Literal[\"mu\", \"sigma\", \"closed\"] = \"mu\",\n        raw_df=False,\n    ):\n        of_columns = {\n            \"mu\": \"forecast_mean\",\n            \"sigma\": \"forecast_stdev\",\n            \"closed\": \"forecast_closed_in_tf\",\n        }\n        y = of_columns.get(of)\n        columns = [\n            \"path_id\",\n            \"booking_class\",\n            \"rrd\",\n            y,\n        ]\n        df = self.path_forecasts.reset_index()[columns]\n        color = \"booking_class:N\"\n        if isinstance(by_path_id, int) and by_path_id is not True:\n            df = df[df.path_id == by_path_id]\n        if isinstance(by_class, str):\n            df = df[df.booking_class == by_class]\n            color = None\n        if raw_df:\n            return df\n        facet_on = None\n        if by_path_id is True:\n            facet_on = \"path_id\"\n        return self._fig_forecasts(df, facet_on=facet_on, y=y, color=color)\n\n    @report_figure\n    def fig_bid_price_history(\n        self,\n        by_carrier: bool | str = True,\n        show_stdev: float | bool | None = None,\n        cap: Literal[\"some\", \"zero\", None] = None,\n        raw_df=False,\n    ):\n        if cap is None:\n            bp_mean = \"bid_price_mean\"\n        elif cap == \"some\":\n            bp_mean = \"some_cap_bid_price_mean\"\n        elif cap == \"zero\":\n            bp_mean = \"zero_cap_bid_price_mean\"\n        else:\n            raise ValueError(f\"cap={cap!r} not in ['some', 'zero', None]\")\n        df = self.bid_price_history.reset_index()\n        color = None\n        if isinstance(by_carrier, str):\n            df = df[df.carrier == by_carrier]\n        elif by_carrier:\n            color = \"carrier:N\"\n            if show_stdev is None:\n                show_stdev = False\n        if show_stdev:\n            if show_stdev is True:\n                show_stdev = 2\n            df[\"bid_price_upper\"] = df[bp_mean] + show_stdev * df[\"bid_price_stdev\"]\n            df[\"bid_price_lower\"] = (\n                df[bp_mean] - show_stdev * df[\"bid_price_stdev\"]\n            ).clip(0, None)\n        if raw_df:\n            return df\n\n        import altair as alt\n\n        line_encoding = dict(\n            x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"),\n            y=alt.Y(bp_mean, title=\"Bid Price\"),\n        )\n        if color:\n            line_encoding[\"color\"] = color\n        chart = alt.Chart(df)\n        fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n        if show_stdev:\n            area_encoding = dict(\n                x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"),\n                y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"),\n                y2=alt.Y2(\"bid_price_upper:Q\", title=\"Bid Price\"),\n            )\n            bound = chart.mark_area(\n                opacity=0.1,\n                interpolate=\"step-before\",\n            ).encode(**area_encoding)\n            bound_line = chart.mark_line(\n                opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\"\n            ).encode(x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"))\n            top_line = bound_line.encode(\n                y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\")\n            )\n            bottom_line = bound_line.encode(\n                y=alt.Y(\"bid_price_upper:Q\", title=\"Bid Price\")\n            )\n            fig = fig + bound + top_line + bottom_line\n        return fig\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.bid_price_history", "title": "bid_price_history  <code>instance-attribute</code>", "text": "<pre><code>bid_price_history = bid_price_history\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.bookings_by_timeframe", "title": "bookings_by_timeframe  <code>instance-attribute</code>", "text": "<pre><code>bookings_by_timeframe = bookings_by_timeframe\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.carrier_history", "title": "carrier_history  <code>instance-attribute</code>", "text": "<pre><code>carrier_history = carrier_history\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.carriers", "title": "carriers  <code>instance-attribute</code>", "text": "<pre><code>carriers = carriers\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.demand_to_come", "title": "demand_to_come  <code>instance-attribute</code>", "text": "<pre><code>demand_to_come = demand_to_come\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.demands", "title": "demands  <code>instance-attribute</code>", "text": "<pre><code>demands = demands\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fare_class_mix", "title": "fare_class_mix  <code>instance-attribute</code>", "text": "<pre><code>fare_class_mix = fare_class_mix\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fares", "title": "fares  <code>instance-attribute</code>", "text": "<pre><code>fares = fares\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.leg_forecasts", "title": "leg_forecasts  <code>instance-attribute</code>", "text": "<pre><code>leg_forecasts = leg_forecasts\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.legs", "title": "legs  <code>instance-attribute</code>", "text": "<pre><code>legs = legs\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.load_factors", "title": "load_factors  <code>instance-attribute</code>", "text": "<pre><code>load_factors = load_factors\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.local_and_flow_yields", "title": "local_and_flow_yields  <code>instance-attribute</code>", "text": "<pre><code>local_and_flow_yields = local_and_flow_yields\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.od_fare_class_mix", "title": "od_fare_class_mix  <code>instance-attribute</code>", "text": "<pre><code>od_fare_class_mix = od_fare_class_mix\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.path_classes", "title": "path_classes  <code>instance-attribute</code>", "text": "<pre><code>path_classes = path_classes\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.path_forecasts", "title": "path_forecasts  <code>instance-attribute</code>", "text": "<pre><code>path_forecasts = path_forecasts\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.paths", "title": "paths  <code>instance-attribute</code>", "text": "<pre><code>paths = paths\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.raw_fare_class_mix", "title": "raw_fare_class_mix  <code>property</code>", "text": "<pre><code>raw_fare_class_mix: pd.DataFrame\n</code></pre> <p>Raw data giving the fare class mix.</p> <p>This tidy dataframe contains these columns:</p> <ul> <li>carrier (str)</li> <li>booking_class (str)</li> <li>avg_sold (float)</li> </ul>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.total_demand", "title": "total_demand  <code>instance-attribute</code>", "text": "<pre><code>total_demand = total_demand\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    demands: pd.DataFrame | None = None,\n    fares: pd.DataFrame | None = None,\n    legs: pd.DataFrame | None = None,\n    paths: pd.DataFrame | None = None,\n    path_classes: pd.DataFrame | None = None,\n    carriers: pd.DataFrame | None = None,\n    fare_class_mix: pd.DataFrame | None = None,\n    load_factors: pd.DataFrame | None = None,\n    bookings_by_timeframe: pd.DataFrame | None = None,\n    total_demand: float | None = None,\n    od_fare_class_mix: dict[tuple[str, str], pd.DataFrame]\n    | None = None,\n    leg_forecasts: pd.DataFrame | None = None,\n    path_forecasts: pd.DataFrame | None = None,\n    carrier_history: pd.DataFrame | None = None,\n    demand_to_come: pd.DataFrame | None = None,\n    bid_price_history: pd.DataFrame | None = None,\n    local_and_flow_yields: pd.DataFrame | None = None,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>def __init__(\n    self,\n    demands: pd.DataFrame | None = None,\n    fares: pd.DataFrame | None = None,\n    legs: pd.DataFrame | None = None,\n    paths: pd.DataFrame | None = None,\n    path_classes: pd.DataFrame | None = None,\n    carriers: pd.DataFrame | None = None,\n    fare_class_mix: pd.DataFrame | None = None,\n    load_factors: pd.DataFrame | None = None,\n    bookings_by_timeframe: pd.DataFrame | None = None,\n    total_demand: float | None = None,\n    od_fare_class_mix: dict[tuple[str, str], pd.DataFrame] | None = None,\n    leg_forecasts: pd.DataFrame | None = None,\n    path_forecasts: pd.DataFrame | None = None,\n    carrier_history: pd.DataFrame | None = None,\n    demand_to_come: pd.DataFrame | None = None,\n    bid_price_history: pd.DataFrame | None = None,\n    local_and_flow_yields: pd.DataFrame | None = None,\n):\n    self.demands = demands\n    self.fares = fares\n    self.legs = legs\n    self.paths = paths\n    self.path_classes = path_classes\n    self.carriers = carriers\n    self.fare_class_mix = fare_class_mix\n    self.od_fare_class_mix = od_fare_class_mix\n    self.load_factors = load_factors\n    self.bookings_by_timeframe = bookings_by_timeframe\n    self.total_demand = total_demand\n    self.leg_forecasts = leg_forecasts\n    self.path_forecasts = path_forecasts\n    self.carrier_history = carrier_history\n    self.demand_to_come = demand_to_come\n    self.bid_price_history = bid_price_history\n    self.local_and_flow_yields = local_and_flow_yields\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.aggregate_demand_history", "title": "aggregate_demand_history", "text": "<pre><code>aggregate_demand_history(\n    by_segment: bool = True,\n) -&gt; pd.Series\n</code></pre> <p>Total demand by sample, aggregated over all markets.</p> <p>Parameters:</p> <ul> <li> <code>by_segment</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Aggregate by segment.  If false, segments are also aggregated.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>         \u2013          <p>Total demand, indexed by trial, sample, and segment (business/leisure).</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def aggregate_demand_history(self, by_segment: bool = True) -&gt; pd.Series:\n    \"\"\"\n    Total demand by sample, aggregated over all markets.\n\n    Parameters\n    ----------\n    by_segment : bool, default True\n        Aggregate by segment.  If false, segments are also aggregated.\n\n    Returns\n    -------\n    pandas.Series\n        Total demand, indexed by trial, sample, and segment\n        (business/leisure).\n    \"\"\"\n    groupbys = [\"trial\", \"sample\"]\n    if by_segment:\n        groupbys.append(\"segment\")\n    return self.demand_to_come.iloc[:, 0].groupby(groupbys, observed=False).sum()\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.demand_in_tf", "title": "demand_in_tf", "text": "<pre><code>demand_in_tf() -&gt; pd.DataFrame | None\n</code></pre> <p>History of demand arriving in each timeframe.</p> <p>This dataframe is derived from the <code>demand_to_come</code> dataframe by taking the sequential differences.</p> Source code in <code>passengersim/summary.py</code> <pre><code>def demand_in_tf(self) -&gt; pd.DataFrame | None:\n    \"\"\"History of demand arriving in each timeframe.\n\n    This dataframe is derived from the `demand_to_come` dataframe\n    by taking the sequential differences.\n    \"\"\"\n    if self.demand_to_come is None:\n        return None\n    return self.demand_to_come.diff(-1, axis=1).iloc[:, :-1]\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_bid_price_history", "title": "fig_bid_price_history", "text": "<pre><code>fig_bid_price_history(\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_bid_price_history(\n    self,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df=False,\n):\n    if cap is None:\n        bp_mean = \"bid_price_mean\"\n    elif cap == \"some\":\n        bp_mean = \"some_cap_bid_price_mean\"\n    elif cap == \"zero\":\n        bp_mean = \"zero_cap_bid_price_mean\"\n    else:\n        raise ValueError(f\"cap={cap!r} not in ['some', 'zero', None]\")\n    df = self.bid_price_history.reset_index()\n    color = None\n    if isinstance(by_carrier, str):\n        df = df[df.carrier == by_carrier]\n    elif by_carrier:\n        color = \"carrier:N\"\n        if show_stdev is None:\n            show_stdev = False\n    if show_stdev:\n        if show_stdev is True:\n            show_stdev = 2\n        df[\"bid_price_upper\"] = df[bp_mean] + show_stdev * df[\"bid_price_stdev\"]\n        df[\"bid_price_lower\"] = (\n            df[bp_mean] - show_stdev * df[\"bid_price_stdev\"]\n        ).clip(0, None)\n    if raw_df:\n        return df\n\n    import altair as alt\n\n    line_encoding = dict(\n        x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"),\n        y=alt.Y(bp_mean, title=\"Bid Price\"),\n    )\n    if color:\n        line_encoding[\"color\"] = color\n    chart = alt.Chart(df)\n    fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n    if show_stdev:\n        area_encoding = dict(\n            x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"),\n            y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"),\n            y2=alt.Y2(\"bid_price_upper:Q\", title=\"Bid Price\"),\n        )\n        bound = chart.mark_area(\n            opacity=0.1,\n            interpolate=\"step-before\",\n        ).encode(**area_encoding)\n        bound_line = chart.mark_line(\n            opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\"\n        ).encode(x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"))\n        top_line = bound_line.encode(\n            y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\")\n        )\n        bottom_line = bound_line.encode(\n            y=alt.Y(\"bid_price_upper:Q\", title=\"Bid Price\")\n        )\n        fig = fig + bound + top_line + bottom_line\n    return fig\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_bookings_by_timeframe", "title": "fig_bookings_by_timeframe", "text": "<pre><code>fig_bookings_by_timeframe(\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df: bool = False,\n    errorbands: bool = False,\n    exclude_nogo: bool = True,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_bookings_by_timeframe(\n    self,\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df: bool = False,\n    errorbands: bool = False,\n    exclude_nogo: bool = True,\n):\n    if errorbands:\n        if by_carrier is True:\n            raise NotImplementedError(\"error bands for all airlines is messy\")\n        return self._fig_bookings_by_timeframe_errorband(\n            by_carrier=by_carrier, raw_df=raw_df\n        )\n\n    def differs(x):\n        return x.shift(-1, fill_value=0) - x\n\n    def _summarize(x: pd.DataFrame, c: str):\n        if \"trial\" not in x.columns:\n            x = x.assign(trial=0)\n        if by_class:\n            y = (\n                x.groupby([\"trial\", \"carrier\", \"booking_class\", \"rrd\"])[f\"avg_{c}\"]\n                .sum()\n                .unstack([\"trial\", \"carrier\", \"booking_class\"])\n                .sort_index(ascending=False)\n                .apply(differs)\n                .stack([\"carrier\", \"booking_class\"])\n                .aggregate([\"mean\", \"sem\"], axis=1)\n                .assign(\n                    ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                    ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                )\n            )\n        else:\n            y = (\n                x.groupby([\"trial\", \"carrier\", \"rrd\"])[f\"avg_{c}\"]\n                .sum()\n                .unstack([\"trial\", \"carrier\"])\n                .sort_index(ascending=False)\n                .apply(differs)\n                .stack(\"carrier\")\n                .aggregate([\"mean\", \"sem\"], axis=1)\n                .assign(\n                    ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                    ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                )\n            )\n        return pd.concat({c: y}, names=[\"paxtype\"])\n\n    bookings_by_timeframe = self.bookings_by_timeframe.reset_index()\n    df0 = _summarize(bookings_by_timeframe, \"business\")\n    df1 = _summarize(bookings_by_timeframe, \"leisure\")\n    df = (\n        pd.concat([df0, df1], axis=0)\n        .rename(columns={\"mean\": \"sold\"})\n        .reset_index()\n        .query(\"(rrd&gt;0) &amp; (sold&gt;0)\")\n    )\n    title = \"Bookings by Timeframe\"\n    if by_class is True:\n        title = \"Bookings by Timeframe and Booking Class\"\n    title_annot = []\n    if not by_carrier:\n        g = [\"rrd\", \"paxtype\"]\n        if by_class:\n            g += [\"booking_class\"]\n        df = df.groupby(g)[[\"sold\", \"ci0\", \"ci1\"]].sum().reset_index()\n    if isinstance(by_carrier, str):\n        df = df[df[\"carrier\"] == by_carrier]\n        df = df.drop(columns=[\"carrier\"])\n        title_annot.append(by_carrier)\n        by_carrier = False\n    if isinstance(by_class, str):\n        df = df[df[\"booking_class\"] == by_class]\n        df = df.drop(columns=[\"booking_class\"])\n        title_annot.append(f\"Class {by_class}\")\n        by_class = False\n    if title_annot:\n        title = f\"{title} ({', '.join(title_annot)})\"\n    if exclude_nogo and \"carrier\" in df.columns:\n        df = df[df[\"carrier\"] != \"NONE\"]\n    if raw_df:\n        return df\n\n    import altair as alt\n\n    if by_carrier:\n        color = \"carrier:N\"\n        color_title = \"Carrier\"\n    elif by_class:\n        color = \"class:N\"\n        color_title = \"Booking Class\"\n    else:\n        color = \"paxtype:N\"\n        color_title = \"Passenger Type\"\n\n    if by_class:\n        chart = (\n            alt.Chart(df)\n            .mark_bar()\n            .encode(\n                color=alt.Color(color).title(color_title),\n                x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n                y=alt.Y(\"sold\"),\n                tooltip=(\n                    [alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else []\n                )\n                + [\n                    alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"rrd\", title=\"DfD\"),\n                    alt.Tooltip(\"sold\", format=\".2f\"),\n                ],\n            )\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"paxtype:N\", title=\"Passenger Type\"),\n                title=title,\n            )\n            .configure_title(fontSize=18)\n        )\n    else:\n        chart = (\n            alt.Chart(df, title=title)\n            .mark_line()\n            .encode(\n                color=alt.Color(color).title(color_title),\n                x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n                y=alt.Y(\"sold\") if by_class else \"sold\",\n                strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n                tooltip=(\n                    [alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else []\n                )\n                + [\n                    alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"rrd\", title=\"DfD\"),\n                    alt.Tooltip(\"sold\", format=\".2f\"),\n                ],\n            )\n            .properties(\n                width=500,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n    return chart\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_load_factors", "title": "fig_carrier_load_factors", "text": "<pre><code>fig_carrier_load_factors(\n    raw_df=False,\n    load_measure: Literal[\n        \"sys_lf\", \"avg_leg_lf\"\n    ] = \"sys_lf\",\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_carrier_load_factors(\n    self, raw_df=False, load_measure: Literal[\"sys_lf\", \"avg_leg_lf\"] = \"sys_lf\"\n):\n    measure_name = (\n        \"System Load Factor\" if load_measure == \"sys_lf\" else \"Leg Load Factor\"\n    )\n    return self._fig_carrier_load_factors(\n        raw_df,\n        load_measure,\n        measure_name,\n        title=f\"Carrier {measure_name}s\",\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_mileage", "title": "fig_carrier_mileage", "text": "<pre><code>fig_carrier_mileage(raw_df: bool = False, report=None)\n</code></pre> <p>Figure showing ASM, RPM by carrier.</p> <p>ASM is available seat miles.  RPM is revenue passenger miles.</p> <p>Parameters:</p> <ul> <li> <code>raw_df</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Return the raw data for this figure as a pandas DataFrame, instead of generating the figure itself.</p> </li> <li> <code>report</code>             (<code>Reporter</code>, default:                 <code>None</code> )         \u2013          <p>Also append this figure to the given report.</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def fig_carrier_mileage(self, raw_df: bool = False, report=None):\n    \"\"\"\n    Figure showing ASM, RPM by carrier.\n\n    ASM is available seat miles.  RPM is revenue passenger miles.\n\n    Parameters\n    ----------\n    raw_df : bool, default False\n        Return the raw data for this figure as a pandas DataFrame, instead\n        of generating the figure itself.\n    report : xmle.Reporter, optional\n        Also append this figure to the given report.\n    \"\"\"\n    df = (\n        self.carriers.reset_index()[[\"carrier\", \"asm\", \"rpm\"]]\n        .set_index(\"carrier\")\n        .rename_axis(columns=\"measure\")\n        .unstack()\n        .to_frame(\"value\")\n        .reset_index()\n    )\n    if raw_df:\n        return df\n    import altair as alt\n\n    chart = alt.Chart(df, title=\"Carrier Loads\")\n    bars = chart.mark_bar().encode(\n        x=alt.X(\"carrier:N\", title=\"Carrier\"),\n        y=alt.Y(\"value\", stack=None, title=\"miles\"),\n        color=\"measure\",\n        tooltip=[\"carrier\", \"measure\", alt.Tooltip(\"value\", format=\".4s\")],\n    )\n    text = chart.mark_text(\n        dx=0,\n        dy=5,\n        color=\"white\",\n        baseline=\"top\",\n    ).encode(\n        x=alt.X(\"carrier:N\"),\n        y=alt.Y(\"value\").stack(None),\n        text=alt.Text(\"value:Q\", format=\".4s\"),\n    )\n    fig = (\n        (bars + text)\n        .properties(\n            width=400,\n            height=300,\n        )\n        .configure_axis(\n            labelFontSize=12,\n            titleFontSize=12,\n        )\n        .configure_legend(\n            titleFontSize=12,\n            labelFontSize=15,\n        )\n    )\n    if report:\n        report.add_figure(fig)\n    return fig\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_revenues", "title": "fig_carrier_revenues", "text": "<pre><code>fig_carrier_revenues(raw_df=False)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_carrier_revenues(self, raw_df=False):\n    return self._fig_carrier_load_factors(\n        raw_df, \"avg_rev\", \"Average Revenue\", \"$.4s\", title=\"Carrier Revenues\"\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_yields", "title": "fig_carrier_yields", "text": "<pre><code>fig_carrier_yields(raw_df=False)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_carrier_yields(self, raw_df=False):\n    return self._fig_carrier_load_factors(\n        raw_df, \"yield\", \"Average Yield\", \"$.4f\", title=\"Carrier Yields\"\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_fare_class_mix", "title": "fig_fare_class_mix", "text": "<pre><code>fig_fare_class_mix(raw_df=False, label_threshold=0.06)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_fare_class_mix(self, raw_df=False, label_threshold=0.06):\n    df = self.fare_class_mix.reset_index()[[\"carrier\", \"booking_class\", \"avg_sold\"]]\n    if raw_df:\n        return df\n    return self._fig_fare_class_mix(\n        df,\n        label_threshold=label_threshold,\n        title=\"Fare Class Mix\",\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_leg_forecasts", "title": "fig_leg_forecasts", "text": "<pre><code>fig_leg_forecasts(\n    by_flt_no: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"] = \"mu\",\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_leg_forecasts(\n    self,\n    by_flt_no: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"] = \"mu\",\n    raw_df=False,\n):\n    y = \"forecast_mean\" if of == \"mu\" else \"forecast_stdev\"\n    columns = [\n        \"carrier\",\n        \"flt_no\",\n        \"booking_class\",\n        \"rrd\",\n        y,\n    ]\n    if self.leg_forecasts is None:\n        raise ValueError(\"the leg_forecasts summary table is not available\")\n    df = self.leg_forecasts.reset_index()[columns]\n    color = \"booking_class:N\"\n    if isinstance(by_flt_no, int) and by_flt_no is not True:\n        df = df[df.flt_no == by_flt_no]\n    if isinstance(by_class, str):\n        df = df[df.booking_class == by_class]\n        color = None\n    if raw_df:\n        return df\n    return self._fig_forecasts(df, facet_on=None, y=y, color=color)\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_od_fare_class_mix", "title": "fig_od_fare_class_mix", "text": "<pre><code>fig_od_fare_class_mix(\n    orig: str, dest: str, raw_df=False, label_threshold=0.06\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_od_fare_class_mix(\n    self, orig: str, dest: str, raw_df=False, label_threshold=0.06\n):\n    df = self.od_fare_class_mix[orig, dest].reset_index()[\n        [\"carrier\", \"booking_class\", \"avg_sold\"]\n    ]\n    if raw_df:\n        return df\n    return self._fig_fare_class_mix(\n        df, label_threshold=label_threshold, title=f\"Fare Class Mix ({orig}-{dest})\"\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_path_forecasts", "title": "fig_path_forecasts", "text": "<pre><code>fig_path_forecasts(\n    by_path_id: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\", \"closed\"] = \"mu\",\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_path_forecasts(\n    self,\n    by_path_id: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\", \"closed\"] = \"mu\",\n    raw_df=False,\n):\n    of_columns = {\n        \"mu\": \"forecast_mean\",\n        \"sigma\": \"forecast_stdev\",\n        \"closed\": \"forecast_closed_in_tf\",\n    }\n    y = of_columns.get(of)\n    columns = [\n        \"path_id\",\n        \"booking_class\",\n        \"rrd\",\n        y,\n    ]\n    df = self.path_forecasts.reset_index()[columns]\n    color = \"booking_class:N\"\n    if isinstance(by_path_id, int) and by_path_id is not True:\n        df = df[df.path_id == by_path_id]\n    if isinstance(by_class, str):\n        df = df[df.booking_class == by_class]\n        color = None\n    if raw_df:\n        return df\n    facet_on = None\n    if by_path_id is True:\n        facet_on = \"path_id\"\n    return self._fig_forecasts(df, facet_on=facet_on, y=y, color=color)\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.from_sqlite", "title": "from_sqlite  <code>classmethod</code>", "text": "<pre><code>from_sqlite(\n    filename: str,\n    make_indexes: bool = False,\n    additional: Collection[str | tuple] = (\n        \"fare_class_mix\",\n        \"load_factors\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n    ),\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@classmethod\ndef from_sqlite(\n    cls,\n    filename: str,\n    make_indexes: bool = False,\n    additional: Collection[str | tuple] = (\n        \"fare_class_mix\",\n        \"load_factors\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n    ),\n):\n    if not os.path.isfile(filename):\n        raise FileNotFoundError(filename)\n    db = database.Database(\n        engine=\"sqlite\",\n        filename=filename,\n    )\n\n    demands = cls.load_basic_table(db, \"demand_summary\")\n    legs = cls.load_basic_table(db, \"leg_summary\")\n    paths = cls.load_basic_table(db, \"path_summary\")\n    carriers = cls.load_basic_table(db, \"carrier_summary\")\n\n    summary = cls(\n        demands=demands,\n        legs=legs,\n        paths=paths,\n        carriers=carriers,\n    )\n\n    if make_indexes:\n        db.add_indexes()\n\n    logger.info(\"loading configs\")\n    config = db.load_configs()\n\n    summary.load_additional_tables(\n        db,\n        scenario=config.scenario,\n        burn_samples=config.simulation_controls.burn_samples,\n        additional=additional,\n    )\n    summary.cnx = db\n    return summary\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.load_additional_tables", "title": "load_additional_tables", "text": "<pre><code>load_additional_tables(\n    db: database.Database,\n    scenario: str,\n    burn_samples: int,\n    additional: Collection[str | tuple] = (\n        \"fare_class_mix\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n    ),\n) -&gt; None\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>def load_additional_tables(\n    self,\n    db: database.Database,\n    scenario: str,\n    burn_samples: int,\n    additional: Collection[str | tuple] = (\n        \"fare_class_mix\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n    ),\n) -&gt; None:\n    if \"fare_class_mix\" in additional and db.is_open:\n        logger.info(\"loading fare_class_mix\")\n        self.fare_class_mix = database.common_queries.fare_class_mix(\n            db, scenario, burn_samples=burn_samples\n        )\n        if self.od_fare_class_mix:\n            for orig, dest in list(self.od_fare_class_mix):\n                self.od_fare_class_mix[\n                    (orig, dest)\n                ] = database.common_queries.od_fare_class_mix(\n                    db, orig, dest, scenario, burn_samples=burn_samples\n                )\n\n    for i in additional:\n        if isinstance(i, tuple) and i[0] == \"od_fare_class_mix\" and db.is_open:\n            orig, dest = i[1], i[2]\n            if self.od_fare_class_mix is None:\n                self.od_fare_class_mix = {}\n            logger.info(f\"loading od_fare_class_mix({orig},{dest})\")\n            self.od_fare_class_mix[\n                (orig, dest)\n            ] = database.common_queries.od_fare_class_mix(\n                db, orig, dest, scenario, burn_samples=burn_samples\n            )\n\n    if \"bookings_by_timeframe\" in additional and db.is_open:\n        logger.info(\"loading bookings_by_timeframe\")\n        self.bookings_by_timeframe = database.common_queries.bookings_by_timeframe(\n            db, scenario, burn_samples=burn_samples\n        )\n\n    if \"total_demand\" in additional and db.is_open:\n        logger.info(\"loading total_demand\")\n        self.total_demand = database.common_queries.total_demand(\n            db, scenario, burn_samples\n        )\n\n    if \"leg_forecasts\" in additional and db.is_open:\n        logger.info(\"loading leg_forecasts\")\n        self.leg_forecasts = database.common_queries.leg_forecasts(\n            db, scenario, burn_samples\n        )\n\n    if \"path_forecasts\" in additional and db.is_open:\n        logger.info(\"loading path_forecasts\")\n        self.path_forecasts = database.common_queries.path_forecasts(\n            db, scenario, burn_samples\n        )\n\n    if \"demand_to_come\" in additional and db.is_open:\n        logger.info(\"loading demand_to_come\")\n        self.demand_to_come = database.common_queries.demand_to_come(db, scenario)\n\n    if \"carrier_history\" in additional and db.is_open:\n        logger.info(\"loading carrier_history\")\n        self.carrier_history = database.common_queries.carrier_history(db, scenario)\n\n    if \"bid_price_history\" in additional and db.is_open:\n        logger.info(\"loading bid_price_history\")\n        self.bid_price_history = database.common_queries.bid_price_history(\n            db, scenario, burn_samples\n        )\n\n    if \"local_and_flow_yields\" in additional and db.is_open:\n        logger.info(\"loading local_and_flow_yields\")\n        self.local_and_flow_yields = database.common_queries.local_and_flow_yields(\n            db, scenario, burn_samples\n        )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.load_basic_table", "title": "load_basic_table  <code>classmethod</code>", "text": "<pre><code>load_basic_table(db: database.Database, tablename: str)\n</code></pre> <p>Load a basic table</p> Source code in <code>passengersim/summary.py</code> <pre><code>@classmethod\ndef load_basic_table(self, db: database.Database, tablename: str):\n    \"\"\"Load a basic table\"\"\"\n    logger.info(\"loading %s\", tablename)\n    return db.dataframe(f\"SELECT * FROM {tablename}\")\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.to_records", "title": "to_records", "text": "<pre><code>to_records()\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>def to_records(self):\n    return {k: v.to_dict(orient=\"records\") for (k, v) in self.__dict__.items()}\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.to_xlsx", "title": "to_xlsx", "text": "<pre><code>to_xlsx(filename: str | pathlib.Path) -&gt; None\n</code></pre> <p>Write summary tables to excel.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>Path - like</code>)         \u2013          <p>The excel file to write.</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def to_xlsx(self, filename: str | pathlib.Path) -&gt; None:\n    \"\"\"Write summary tables to excel.\n\n    Parameters\n    ----------\n    filename : Path-like\n        The excel file to write.\n    \"\"\"\n    if isinstance(filename, str):\n        filename = pathlib.Path(filename)\n    filename.parent.mkdir(exist_ok=True, parents=True)\n    with pd.ExcelWriter(filename) as writer:\n        for k, v in self.__dict__.items():\n            if isinstance(v, pd.DataFrame):\n                v.to_excel(writer, sheet_name=k)\n</code></pre>"}, {"location": "API/Core/index.html", "title": "PassengerSim.Core API", "text": "<p>While the main <code>passengersim</code> package available as a freely downloadable open source package, the functionality in the <code>passengersim.core</code> sub-package  is only available to authorized users.  The documentation of the API for this  sub-package is provided here. </p>"}, {"location": "API/Core/00-SimulationEngine.html", "title": "Simulation Engine", "text": ""}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine-attributes", "title": "Attributes", "text": ""}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.airlines", "title": "airlines  <code>instance-attribute</code>", "text": "<pre><code>airlines: Iterator[Airline]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.base_time", "title": "base_time  <code>instance-attribute</code>", "text": "<pre><code>base_time: int\n</code></pre> <p>The base time of the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.bucketnames", "title": "bucketnames  <code>instance-attribute</code>", "text": "<pre><code>bucketnames: Iterator[str]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.buckets", "title": "buckets  <code>instance-attribute</code>", "text": "<pre><code>buckets: Iterator[Bucket]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.burn_samples", "title": "burn_samples  <code>instance-attribute</code>", "text": "<pre><code>burn_samples: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.config", "title": "config  <code>instance-attribute</code>", "text": "<pre><code>config: Config | None\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.demands", "title": "demands  <code>instance-attribute</code>", "text": "<pre><code>demands: Iterator[Demand]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.disable_ap", "title": "disable_ap  <code>instance-attribute</code>", "text": "<pre><code>disable_ap: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.dwm_lite", "title": "dwm_lite  <code>instance-attribute</code>", "text": "<pre><code>dwm_lite: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.fares", "title": "fares  <code>instance-attribute</code>", "text": "<pre><code>fares: Iterator[Fare]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.iteration", "title": "iteration  <code>instance-attribute</code>", "text": "<pre><code>iteration: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.last_dcp", "title": "last_dcp  <code>instance-attribute</code>", "text": "<pre><code>last_dcp: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.last_event_time", "title": "last_event_time  <code>instance-attribute</code>", "text": "<pre><code>last_event_time: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.legs", "title": "legs  <code>instance-attribute</code>", "text": "<pre><code>legs: Iterator[Leg]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.manual_paths", "title": "manual_paths  <code>instance-attribute</code>", "text": "<pre><code>manual_paths: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.max_connect_time", "title": "max_connect_time  <code>instance-attribute</code>", "text": "<pre><code>max_connect_time: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.mkt_k_factor", "title": "mkt_k_factor  <code>instance-attribute</code>", "text": "<pre><code>mkt_k_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_samples", "title": "num_samples  <code>instance-attribute</code>", "text": "<pre><code>num_samples: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_trials", "title": "num_trials  <code>instance-attribute</code>", "text": "<pre><code>num_trials: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.pathclasses", "title": "pathclasses  <code>instance-attribute</code>", "text": "<pre><code>pathclasses: Iterator[PathClass]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.paths", "title": "paths  <code>instance-attribute</code>", "text": "<pre><code>paths: Iterator[Path]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.pax_type_k_factor", "title": "pax_type_k_factor  <code>instance-attribute</code>", "text": "<pre><code>pax_type_k_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.prorate_revenue", "title": "prorate_revenue  <code>instance-attribute</code>", "text": "<pre><code>prorate_revenue: bool\n</code></pre> <p>When set to True, O&amp;D revenue is prorated by mileage to the leg level</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator: Generator\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.rm_start_sample", "title": "rm_start_sample  <code>instance-attribute</code>", "text": "<pre><code>rm_start_sample: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.sample", "title": "sample  <code>instance-attribute</code>", "text": "<pre><code>sample: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.save_timeframe_details", "title": "save_timeframe_details  <code>instance-attribute</code>", "text": "<pre><code>save_timeframe_details: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.snapshot_filters", "title": "snapshot_filters  <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[SnapshotFilter] | None\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.sys_k_factor", "title": "sys_k_factor  <code>instance-attribute</code>", "text": "<pre><code>sys_k_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.tf_k_factor", "title": "tf_k_factor  <code>instance-attribute</code>", "text": "<pre><code>tf_k_factor: float\n</code></pre> <p>Timeframe k-factor, controls variance in the passenger arrival curves</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.tf_z_factor", "title": "tf_z_factor  <code>instance-attribute</code>", "text": "<pre><code>tf_z_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.trial", "title": "trial  <code>instance-attribute</code>", "text": "<pre><code>trial: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine-functions", "title": "Functions", "text": ""}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.__init__", "title": "__init__", "text": "<pre><code>__init__(name: str = 'Incognito', random_generator=None)\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_airline", "title": "add_airline", "text": "<pre><code>add_airline(airline: Airline) -&gt; None\n</code></pre> <p>Add an Airline to the simulation</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_demand", "title": "add_demand", "text": "<pre><code>add_demand(dmd: Demand) -&gt; None\n</code></pre> <p>Add a Market Segment demand to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_event", "title": "add_event", "text": "<pre><code>add_event(e: Event) -&gt; None\n</code></pre> <p>Add a user Event to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_fare", "title": "add_fare", "text": "<pre><code>add_fare(fare: Fare) -&gt; None\n</code></pre> <p>Add a Fare to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_frat5", "title": "add_frat5", "text": "<pre><code>add_frat5(frat5: Frat5) -&gt; None\n</code></pre> <p>Add a Frat5 curve to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_leg", "title": "add_leg", "text": "<pre><code>add_leg(leg: Leg) -&gt; None\n</code></pre> <p>Add a Leg to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_path", "title": "add_path", "text": "<pre><code>add_path(path: Path) -&gt; None\n</code></pre> <p>Add a Path to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.allocate_demand_to_tf", "title": "allocate_demand_to_tf", "text": "<pre><code>allocate_demand_to_tf(\n    dmd: Demand,\n    num_pax: int,\n    tf_k_factor: float,\n    endTS: int,\n    debug: bool = False,\n) -&gt; tuple[int]\n</code></pre> <p>Generate events for a single demand</p> <p>Parameters:</p> <ul> <li> <code>dmd</code>             (<code>Demand</code>)         \u2013          </li> <li> <code>num_pax</code>             (<code>int</code>)         \u2013          </li> <li> <code>tf_k_factor</code>             (<code>float</code>)         \u2013          </li> <li> <code>endTS</code>             (<code>int</code>)         \u2013          </li> <li> <code>debug</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p>Number of events allocated.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.allocate_demand_to_tf_pods", "title": "allocate_demand_to_tf_pods", "text": "<pre><code>allocate_demand_to_tf_pods(\n    dmd: Demand,\n    num_pax: int,\n    tf_k_factor: float,\n    endTS: int,\n    debug: bool = False,\n) -&gt; tuple[int]\n</code></pre> <p>Generate events for a single demand (used to simulate PODS processing)</p> <p>Parameters:</p> <ul> <li> <code>dmd</code>             (<code>Demand</code>)         \u2013          </li> <li> <code>num_pax</code>             (<code>int</code>)         \u2013          </li> <li> <code>tf_k_factor</code>             (<code>float</code>)         \u2013          </li> <li> <code>endTS</code>             (<code>int</code>)         \u2013          </li> <li> <code>debug</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int]</code>         \u2013          <p>Number of events allocated by DCP.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.build_connections", "title": "build_connections", "text": "<pre><code>build_connections() -&gt; None\n</code></pre> <p>Build connections for the demands.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.build_expiration", "title": "build_expiration", "text": "<pre><code>build_expiration() -&gt; datetime.datetime\n</code></pre> <p>Get the expiration time for this build.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.final_write_to_sqlite", "title": "final_write_to_sqlite", "text": "<pre><code>final_write_to_sqlite(cnx: sqlite3.Connection)\n</code></pre> <p>Write final summary details to sqlite</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.go", "title": "go", "text": "<pre><code>go() -&gt; Any\n</code></pre> <p>Run the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.license_info", "title": "license_info", "text": "<pre><code>license_info(user_cert=None) -&gt; str\n</code></pre> <p>Access license info as a human-readable string.</p> <p>Parameters:</p> <ul> <li> <code>user_cert</code>             (<code>Certificate</code>, default:                 <code>None</code> )         \u2013          <p>The license.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_events", "title": "num_events", "text": "<pre><code>num_events() -&gt; int\n</code></pre> <p>Return the number of events currently on the event queue.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.path_2_leg", "title": "path_2_leg", "text": "<pre><code>path_2_leg(airline: str) -&gt; None\n</code></pre> <p>Aggregate PathClass forecasts to Leg/Bucket</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.reset_counters", "title": "reset_counters", "text": "<pre><code>reset_counters() -&gt; None\n</code></pre> <p>Reset counters for sold &amp; revenue, for demands and legs.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.set_parm", "title": "set_parm", "text": "<pre><code>set_parm(name: str, value: float) -&gt; None\n</code></pre> <p>Set a simulation parameter by name and value</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.update_db_write_flags", "title": "update_db_write_flags", "text": "<pre><code>update_db_write_flags()\n</code></pre> <p>Update database writing flags based on config.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.validate_license", "title": "validate_license", "text": "<pre><code>validate_license(user_cert=None, future: int = 0) -&gt; None\n</code></pre> <p>Validate a user's license certificate.</p> <p>Parameters:</p> <ul> <li> <code>user_cert</code>             (<code>Certificate</code>, default:                 <code>None</code> )         \u2013          <p>The license.</p> </li> <li> <code>future</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Validate as if it is this many days in the future.  This is primarily used for debugging and testing. This is treated as an unsigned integer internally, so negative values will not go back in time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>           \u2013          <p>If the license certificate is not valid.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.write_to_sqlite", "title": "write_to_sqlite", "text": "<pre><code>write_to_sqlite(\n    cnx: sqlite3.Connection,\n    dcp: int,\n    store_bid_prices: bool = True,\n    intermediate_day: bool = False,\n)\n</code></pre> <p>Write details to sqlite</p>"}, {"location": "API/Core/Airline.html", "title": "Airline", "text": ""}, {"location": "API/Core/Airline.html#passengersim_core.Airline.control", "title": "control  <code>instance-attribute</code>", "text": "<pre><code>control: Literal[\n    \"leg\", \"theft\", \"bp\", \"bp_loose\", \"vn\", \"lft\", \"none\"\n]\n</code></pre> <p>Control method for this carrier.</p>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.frat5", "title": "frat5  <code>instance-attribute</code>", "text": "<pre><code>frat5: Optional[str]\n</code></pre>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.gt_available_seat_miles", "title": "gt_available_seat_miles  <code>instance-attribute</code>", "text": "<pre><code>gt_available_seat_miles: float\n</code></pre> <p>Grand total ASM, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.gt_demand", "title": "gt_demand  <code>instance-attribute</code>", "text": "<pre><code>gt_demand: int\n</code></pre> <p>Grand total generated demand, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre> <p>Grand total revenue, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.gt_revenue_passenger_miles", "title": "gt_revenue_passenger_miles  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue_passenger_miles: float\n</code></pre> <p>Grand total RPM, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre> <p>Grand total sold, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.load_factor_curve", "title": "load_factor_curve  <code>instance-attribute</code>", "text": "<pre><code>load_factor_curve: Optional[Any]\n</code></pre> <p>An instance of RmSystem, called at each DCP to do detruncation / forecasting / optimization</p>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.rm_system", "title": "rm_system  <code>instance-attribute</code>", "text": "<pre><code>rm_system: Any\n</code></pre>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    name: str,\n    control: Literal[\n        \"leg\", \"theft\", \"bp\", \"bp_loose\", \"vn\", \"none\"\n    ] = \"leg\",\n)\n</code></pre>"}, {"location": "API/Core/BookingCurves.html", "title": "Booking Curves", "text": ""}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator: Generator\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.__init__", "title": "__init__", "text": "<pre><code>__init__(name: str)\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.add_dcp", "title": "add_dcp", "text": "<pre><code>add_dcp(dcp: int, pct: float)\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.get_curve", "title": "get_curve", "text": "<pre><code>get_curve() -&gt; dict[int, float]\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.verify_curve", "title": "verify_curve", "text": "<pre><code>verify_curve() -&gt; bool\n</code></pre>"}, {"location": "API/Core/Bucket.html", "title": "Bucket", "text": ""}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.alloc", "title": "alloc  <code>instance-attribute</code>", "text": "<pre><code>alloc: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.fcst_revenue", "title": "fcst_revenue  <code>instance-attribute</code>", "text": "<pre><code>fcst_revenue: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.force_closed", "title": "force_closed  <code>instance-attribute</code>", "text": "<pre><code>force_closed: bool\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.protection", "title": "protection  <code>instance-attribute</code>", "text": "<pre><code>protection: int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.untruncated_demand", "title": "untruncated_demand  <code>instance-attribute</code>", "text": "<pre><code>untruncated_demand: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    name: str,\n    alloc: float = 0,\n    price: float = 0,\n    sold: float = 0,\n    revenue: float = 0,\n    fcst_mean: float = 0,\n    fcst_std_dev: float = 0,\n)\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html", "title": "Choice Model", "text": ""}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.path_quality_alpha", "title": "path_quality_alpha  <code>instance-attribute</code>", "text": "<pre><code>path_quality_alpha: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.path_quality_beta", "title": "path_quality_beta  <code>instance-attribute</code>", "text": "<pre><code>path_quality_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.preferred_airline_alpha", "title": "preferred_airline_alpha  <code>instance-attribute</code>", "text": "<pre><code>preferred_airline_alpha: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.preferred_airline_beta", "title": "preferred_airline_beta  <code>instance-attribute</code>", "text": "<pre><code>preferred_airline_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator: Generator\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.__init__", "title": "__init__", "text": "<pre><code>__init__(name: str, type: Literal['logit', 'pods'])\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.add_parm", "title": "add_parm", "text": "<pre><code>add_parm(\n    name: str, value: float, value2: float = 0\n) -&gt; None\n</code></pre> <p>Add a parameter value to the choice model</p>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.serialize", "title": "serialize", "text": "<pre><code>serialize() -&gt; dict\n</code></pre> <p>Get all parameter values from the choice model.</p>"}, {"location": "API/Core/Demand.html", "title": "Demand", "text": ""}, {"location": "API/Core/Demand.html#passengersim_core.Demand.base_demand", "title": "base_demand  <code>instance-attribute</code>", "text": "<pre><code>base_demand: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.business", "title": "business  <code>instance-attribute</code>", "text": "<pre><code>business: bool\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.distance", "title": "distance  <code>instance-attribute</code>", "text": "<pre><code>distance: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.fares", "title": "fares  <code>instance-attribute</code>", "text": "<pre><code>fares: Iterator[Fare]\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.generated_demand", "title": "generated_demand  <code>instance-attribute</code>", "text": "<pre><code>generated_demand: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_demand", "title": "gt_demand  <code>instance-attribute</code>", "text": "<pre><code>gt_demand: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_eliminated_chose_nothing", "title": "gt_eliminated_chose_nothing  <code>instance-attribute</code>", "text": "<pre><code>gt_eliminated_chose_nothing: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_eliminated_no_offers", "title": "gt_eliminated_no_offers  <code>instance-attribute</code>", "text": "<pre><code>gt_eliminated_no_offers: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_eliminated_wtp", "title": "gt_eliminated_wtp  <code>instance-attribute</code>", "text": "<pre><code>gt_eliminated_wtp: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.reference_fare", "title": "reference_fare  <code>instance-attribute</code>", "text": "<pre><code>reference_fare: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.scenario_demand", "title": "scenario_demand  <code>instance-attribute</code>", "text": "<pre><code>scenario_demand: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.segment", "title": "segment  <code>instance-attribute</code>", "text": "<pre><code>segment: str\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.unsold", "title": "unsold  <code>instance-attribute</code>", "text": "<pre><code>unsold: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    orig: str,\n    dest: str,\n    segment: str = None,\n    base_demand: float = 0,\n    scenario_demand: float = 0,\n)\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_choice_model", "title": "add_choice_model", "text": "<pre><code>add_choice_model(choicemodel: ChoiceModel)\n</code></pre> <p>Add a choice model to this market segment</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_curve", "title": "add_curve", "text": "<pre><code>add_curve(curve: BookingCurve)\n</code></pre> <p>Add a booking curve to this market segment</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_fare", "title": "add_fare", "text": "<pre><code>add_fare(fare: Fare)\n</code></pre> <p>Add a fare to this market segment</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_group_sizes", "title": "add_group_sizes", "text": "<pre><code>add_group_sizes(group_sizes: list[float])\n</code></pre> <p>Group sizes is an array, with proportion for each, i.e [0.5, 0.4, 0.1] has 40% of bookings with 2 passengers</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_path", "title": "add_path", "text": "<pre><code>add_path(path: Path)\n</code></pre> <p>Add an itinerary path to this market segment</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_airline_revenue", "title": "get_airline_revenue", "text": "<pre><code>get_airline_revenue(airline_code: str)\n</code></pre> <p>Get revenue for the specified airline code</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_airline_sold", "title": "get_airline_sold", "text": "<pre><code>get_airline_sold(airline_code: str)\n</code></pre> <p>Get sold for the specified airline code</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_demand_dcp", "title": "get_demand_dcp", "text": "<pre><code>get_demand_dcp(dcp: int)\n</code></pre> <p>Get demand for the specified DCP</p>"}, {"location": "API/Core/Fare.html", "title": "Fare", "text": ""}, {"location": "API/Core/Fare.html#passengersim_core.Fare.adjusted_price", "title": "adjusted_price  <code>instance-attribute</code>", "text": "<pre><code>adjusted_price: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.adv_purch", "title": "adv_purch  <code>instance-attribute</code>", "text": "<pre><code>adv_purch: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.booking_class", "title": "booking_class  <code>instance-attribute</code>", "text": "<pre><code>booking_class: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.sold_business", "title": "sold_business  <code>instance-attribute</code>", "text": "<pre><code>sold_business: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    carrier: str,\n    orig: str,\n    dest: str,\n    booking_class: str,\n    price: float,\n)\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.add_restriction", "title": "add_restriction", "text": "<pre><code>add_restriction(restriction: str) -&gt; None\n</code></pre> <p>Add a restriction code to this Fare.</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.adjust_price", "title": "adjust_price", "text": "<pre><code>adjust_price(dcp_index: int, adjusted_price: float)\n</code></pre> <p>Set the adjusted price.  The dcp_index is only used for tracking and reporting</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_adjusted_by_dcp", "title": "get_adjusted_by_dcp", "text": "<pre><code>get_adjusted_by_dcp(dcp_index: int)\n</code></pre> <p>Return the average adjusted fare for this DCP index.  Will return 0.0 if the DCP index was not found</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_restriction", "title": "get_restriction", "text": "<pre><code>get_restriction(n: int)\n</code></pre> <p>Get the n-th restriction code on this Fare</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_sales_by_dcp", "title": "get_sales_by_dcp", "text": "<pre><code>get_sales_by_dcp(dcp: int)\n</code></pre> <p>Get the sales by specified DCP</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.num_restrictions", "title": "num_restrictions", "text": "<pre><code>num_restrictions(selfself)\n</code></pre> <p>How many restrictions do we have on this fare?</p>"}, {"location": "API/Core/Generator.html", "title": "Generator", "text": ""}, {"location": "API/Core/Generator.html#passengersim_core.Generator.bitgenerator", "title": "bitgenerator  <code>instance-attribute</code>", "text": "<pre><code>bitgenerator: np.random.BitGenerator\n</code></pre>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.bitgenerator_class", "title": "bitgenerator_class  <code>instance-attribute</code>", "text": "<pre><code>bitgenerator_class: type[np.random.BitGenerator]\n</code></pre>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    seed: int | None = None,\n    bitgenerator_class: type[np.random.BitGenerator]\n    | None = None,\n)\n</code></pre> <p>Initialize a random number generator.</p> <p>Parameters:</p> <ul> <li> <code>seed</code>             (<code>int or None</code>, default:                 <code>None</code> )         \u2013          <p>For reproducibility, provide a seed.  If no seed is provided, a random seed is provided by the operating system and generally the results will be different every time you reseed.</p> </li> <li> <code>bitgenerator_class</code>             (<code>type[BitGenerator]</code>, default:                 <code>None</code> )         \u2013          <p>This is the class used to create new BitGenerator objects when the seed is reset.</p> </li> </ul>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.get_normal", "title": "get_normal", "text": "<pre><code>get_normal() -&gt; float\n</code></pre> <p>Return a random draw from a standard normal distribution.</p>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.get_uniform", "title": "get_uniform", "text": "<pre><code>get_uniform() -&gt; float\n</code></pre> <p>Return a random draw standard uniform distribution.</p>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.seed", "title": "seed", "text": "<pre><code>seed(seed: int | list[int] | None) -&gt; None\n</code></pre> <p>Reseed the random bit generator.</p>"}, {"location": "API/Core/Leg.html", "title": "Leg", "text": ""}, {"location": "API/Core/Leg.html#passengersim_core.Leg.arr_time", "title": "arr_time  <code>instance-attribute</code>", "text": "<pre><code>arr_time: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.bid_price", "title": "bid_price  <code>instance-attribute</code>", "text": "<pre><code>bid_price: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.bid_price_gradient", "title": "bid_price_gradient  <code>instance-attribute</code>", "text": "<pre><code>bid_price_gradient: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.buckets", "title": "buckets  <code>instance-attribute</code>", "text": "<pre><code>buckets: Iterator[Bucket]\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.capacity", "title": "capacity  <code>instance-attribute</code>", "text": "<pre><code>capacity: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.dep_time", "title": "dep_time  <code>instance-attribute</code>", "text": "<pre><code>dep_time: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.displacement", "title": "displacement  <code>instance-attribute</code>", "text": "<pre><code>displacement: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.distance", "title": "distance  <code>instance-attribute</code>", "text": "<pre><code>distance: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.duration", "title": "duration  <code>instance-attribute</code>", "text": "<pre><code>duration: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.equipment", "title": "equipment  <code>instance-attribute</code>", "text": "<pre><code>equipment: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.flt_no", "title": "flt_no  <code>instance-attribute</code>", "text": "<pre><code>flt_no: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.gt_capacity", "title": "gt_capacity  <code>instance-attribute</code>", "text": "<pre><code>gt_capacity: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.info", "title": "info  <code>instance-attribute</code>", "text": "<pre><code>info: Any\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.q_demand", "title": "q_demand  <code>instance-attribute</code>", "text": "<pre><code>q_demand: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    carrier: str,\n    flt_no: int,\n    orig: str,\n    dest: str,\n    capacity: int = 0,\n    sold: int = 0,\n    duration: int = 0,\n    equipment: str = None,\n    info: Any = None,\n)\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.add_bucket", "title": "add_bucket", "text": "<pre><code>add_bucket(*args: Bucket)\n</code></pre> <p>Add an inventory control bucket to the Leg.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.bucket_number", "title": "bucket_number", "text": "<pre><code>bucket_number(i: int | str) -&gt; Bucket\n</code></pre> <p>Get the bucket from the leg.</p> <p>Parameters:</p> <ul> <li> <code>i</code>             (<code>int or str</code>)         \u2013          <p>If an integer, returns the bucket at this index position from the list of buckets attached to this Leg.  If given as a str, returns the bucket with the indicated booking class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Bucket</code>         \u2013          </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.capture_dcp", "title": "capture_dcp", "text": "<pre><code>capture_dcp(i: int) -&gt; None\n</code></pre> <p>Grab a snapshot of important variables.</p> <p>Parameters:</p> <ul> <li> <code>i</code>             (<code>int</code>)         \u2013          <p>The index of the DCP to capture.</p> </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.forecast", "title": "forecast", "text": "<pre><code>forecast(\n    dcp_index: int,\n    algorithm: str,\n    snapshot_instruction: \"SnapshotInstruction | None\" = None,\n)\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_auth", "title": "get_bucket_auth", "text": "<pre><code>get_bucket_auth(i: int | str) -&gt; int\n</code></pre> <p>Get the authorization for a bucket attached to this leg.</p> <p>Parameters:</p> <ul> <li> <code>i</code>             (<code>int or str</code>)         \u2013          <p>If an integer, returns the auth of the bucket at this index position from the list of buckets attached to this Leg.  If given as a str, returns the auth of the bucket with the indicated booking class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_decision_fare", "title": "get_bucket_decision_fare", "text": "<pre><code>get_bucket_decision_fare(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the decision fare for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_fcst_mean", "title": "get_bucket_fcst_mean", "text": "<pre><code>get_bucket_fcst_mean(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the forecast demand for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_fcst_revenue", "title": "get_bucket_fcst_revenue", "text": "<pre><code>get_bucket_fcst_revenue(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the forecast revenue for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_fcst_std_dev", "title": "get_bucket_fcst_std_dev", "text": "<pre><code>get_bucket_fcst_std_dev(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the forecast demand std. dev. for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_revenue", "title": "get_bucket_revenue", "text": "<pre><code>get_bucket_revenue(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the revenue for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_sold", "title": "get_bucket_sold", "text": "<pre><code>get_bucket_sold(i: int | str) -&gt; int\n</code></pre> <p>Get the number of seats sold for a bucket attached to this leg.</p> <p>Parameters:</p> <ul> <li> <code>i</code>             (<code>int or str</code>)         \u2013          <p>If an integer, returns the number of seats sold for the bucket at this index position from the list of buckets attached to this Leg.  If given as a str, returns the number of seats sold for the bucket with the indicated booking class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_num_buckets", "title": "get_num_buckets", "text": "<pre><code>get_num_buckets() -&gt; int\n</code></pre> <p>Get the number of buckets attached to this leg.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.littlewood", "title": "littlewood", "text": "<pre><code>littlewood(\n    mu: float,\n    sigma: float,\n    rev_hi: float,\n    rev_lo: float,\n    cv100: float,\n) -&gt; float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.print_bucket_detail", "title": "print_bucket_detail", "text": "<pre><code>print_bucket_detail()\n</code></pre> <p>Print a bunch of debugging info</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.print_bucket_history", "title": "print_bucket_history", "text": "<pre><code>print_bucket_history()\n</code></pre> <p>Print a bunch of debugging info</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_auth", "title": "set_bucket_auth", "text": "<pre><code>set_bucket_auth(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the authorization for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_decision_fare", "title": "set_bucket_decision_fare", "text": "<pre><code>set_bucket_decision_fare(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the decision fare for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_fcst_mean", "title": "set_bucket_fcst_mean", "text": "<pre><code>set_bucket_fcst_mean(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the forecast demand for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_fcst_revenue", "title": "set_bucket_fcst_revenue", "text": "<pre><code>set_bucket_fcst_revenue(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the revenue forecast for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_fcst_std_dev", "title": "set_bucket_fcst_std_dev", "text": "<pre><code>set_bucket_fcst_std_dev(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the forecast demand std. dev. for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_revenue", "title": "set_bucket_revenue", "text": "<pre><code>set_bucket_revenue(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the revenue for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_sold", "title": "set_bucket_sold", "text": "<pre><code>set_bucket_sold(bkt_ref: int | str, sold: int)\n</code></pre> <p>Set the seats sold for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.untruncate_demand", "title": "untruncate_demand", "text": "<pre><code>untruncate_demand(\n    dcp_index: int,\n    algorithm: str,\n    snapshot_instruction: \"SnapshotInstruction | None\" = None,\n)\n</code></pre> <p>Run the demand untruncation models for this leg and its buckets.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.write_to_sqlite", "title": "write_to_sqlite", "text": "<pre><code>write_to_sqlite(\n    sqlite_pointer: sqlite3.Connection,\n    sim: SimulationEngine,\n    dcp: int,\n)\n</code></pre> <p>Write to leg_bucket_detail.</p>"}, {"location": "API/Core/Path.html", "title": "Path", "text": ""}, {"location": "API/Core/Path.html#passengersim_core.Path.adjusted_at", "title": "adjusted_at  <code>instance-attribute</code>", "text": "<pre><code>adjusted_at: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.gt_sold_priceable", "title": "gt_sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>gt_sold_priceable: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.last_fcst_ts", "title": "last_fcst_ts  <code>instance-attribute</code>", "text": "<pre><code>last_fcst_ts: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.path_quality_index", "title": "path_quality_index  <code>instance-attribute</code>", "text": "<pre><code>path_quality_index: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.pathclasses", "title": "pathclasses  <code>instance-attribute</code>", "text": "<pre><code>pathclasses: Iterator[PathClass]\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.raw_fcst_mean", "title": "raw_fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>raw_fcst_mean: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.raw_fcst_std_dev", "title": "raw_fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>raw_fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.sold_priceable", "title": "sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>sold_priceable: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.utility", "title": "utility  <code>instance-attribute</code>", "text": "<pre><code>utility: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.__init__", "title": "__init__", "text": "<pre><code>__init__(orig: str, dest: str, price: float)\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.accumulate_forecasts", "title": "accumulate_forecasts", "text": "<pre><code>accumulate_forecasts()\n</code></pre> <p>Adds the path fcst to each leg / bucket</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.accumulate_forecasts_vn", "title": "accumulate_forecasts_vn", "text": "<pre><code>accumulate_forecasts_vn()\n</code></pre> <p>Adds the path fcst to each leg / bucket, using the Virtual Nesting mapping</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_airline", "title": "add_airline", "text": "<pre><code>add_airline(airline: Airline) -&gt; None\n</code></pre> <p>Add an Airline to this Path.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_booking_class", "title": "add_booking_class", "text": "<pre><code>add_booking_class(booking_class: str)\n</code></pre> <p>Add a booking class to this Path</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_leg", "title": "add_leg", "text": "<pre><code>add_leg(leg: Leg) -&gt; None\n</code></pre> <p>Add a leg to this Path.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_path_class", "title": "add_path_class", "text": "<pre><code>add_path_class(path_class: PathClass)\n</code></pre> <p>Add a path class to this Path</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.adjust_forecasts", "title": "adjust_forecasts", "text": "<pre><code>adjust_forecasts(\n    last_ts: int,\n    current_ts: int,\n    departure_ts: int,\n    snapshot_instruction: \"SnapshotInstruction | None\" = None,\n) -&gt; None\n</code></pre> <p>Adjust the forecast for this path and any path-class items it has, using in daily reoptimization</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.allocate_q_demand", "title": "allocate_q_demand", "text": "<pre><code>allocate_q_demand(\n    frat5: Frat5, dcp_index: int, debug: bool\n) -&gt; float\n</code></pre> <p>First step in Q-forecasting</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.capture_dcp", "title": "capture_dcp", "text": "<pre><code>capture_dcp(dcp_index: int)\n</code></pre> <p>Save relevant information for this DCP</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.check_avail", "title": "check_avail", "text": "<pre><code>check_avail(\n    fare: \"Fare\", num_pax: int, debug: Optional[bool]\n)\n</code></pre> <p>Is this fare available on the Path?  Used for unit testing</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.compute_q_equivalent", "title": "compute_q_equivalent", "text": "<pre><code>compute_q_equivalent(\n    frat5: Frat5,\n    dcp_index: int,\n    max_cap: float = 10.0,\n    snapshot_instruction: \"SnapshotInstruction | None\" = None,\n) -&gt; float\n</code></pre> <p>First step in Q-forecasting</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.forecast", "title": "forecast", "text": "<pre><code>forecast(\n    dcp_index: int,\n    algorithm: str,\n    event_time: int,\n    snapshot_instruction: \"SnapshotInstruction | None\" = None,\n) -&gt; float\n</code></pre> <p>Run the forecast models for this path and any path-class items it has</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_decision_fare", "title": "get_class_decision_fare", "text": "<pre><code>get_class_decision_fare(pc_index: int | str) -&gt; float\n</code></pre> <p>Get the decision fare amount for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_fcst_mean", "title": "get_class_fcst_mean", "text": "<pre><code>get_class_fcst_mean(pc_index: int | str) -&gt; float\n</code></pre> <p>Get the demand forecast for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_sold", "title": "get_class_sold", "text": "<pre><code>get_class_sold(pc_index: int | str) -&gt; int\n</code></pre> <p>Get the number sold for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_std_dev", "title": "get_class_std_dev", "text": "<pre><code>get_class_std_dev(pc_index: int | str) -&gt; float\n</code></pre> <p>Get the demand forecast std. dev. for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_bid_price", "title": "get_leg_bid_price", "text": "<pre><code>get_leg_bid_price(n: int) -&gt; float\n</code></pre> <p>Get the bid price on the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_carrier", "title": "get_leg_carrier", "text": "<pre><code>get_leg_carrier(n: int) -&gt; str\n</code></pre> <p>Get the carrier code for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_dep_time", "title": "get_leg_dep_time", "text": "<pre><code>get_leg_dep_time(n: int) -&gt; int\n</code></pre> <p>Get the departure timestamp code for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_dest", "title": "get_leg_dest", "text": "<pre><code>get_leg_dest(n: int) -&gt; str\n</code></pre> <p>Get the destination airport for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_equipment", "title": "get_leg_equipment", "text": "<pre><code>get_leg_equipment(n: int) -&gt; str\n</code></pre> <p>Get the equipment code for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_fltno", "title": "get_leg_fltno", "text": "<pre><code>get_leg_fltno(n: int) -&gt; int\n</code></pre> <p>Get the flight number for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_orig", "title": "get_leg_orig", "text": "<pre><code>get_leg_orig(n: int) -&gt; str\n</code></pre> <p>Get the origin airport for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_total_bid_price", "title": "get_total_bid_price", "text": "<pre><code>get_total_bid_price() -&gt; float\n</code></pre> <p>Get the total of bid prices on all legs</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_total_distance", "title": "get_total_distance", "text": "<pre><code>get_total_distance() -&gt; float\n</code></pre> <p>Get the total of distances on all legs</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.hybrid_forecast", "title": "hybrid_forecast", "text": "<pre><code>hybrid_forecast(\n    dcp_index: int,\n    algorithm: str,\n    snapshot_instruction: \"SnapshotInstruction | None\",\n    frat5: Frat5,\n    max_cap: float = 10,\n) -&gt; float\n</code></pre> <p>Run the forecast models for this path and any path-class items it has</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.num_classes", "title": "num_classes", "text": "<pre><code>num_classes() -&gt; int\n</code></pre> <p>Return the number of booking classes that are tracked for this Path</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.num_deps", "title": "num_deps", "text": "<pre><code>num_deps() -&gt; int\n</code></pre> <p>How many historical departures are on this path?</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.num_legs", "title": "num_legs", "text": "<pre><code>num_legs() -&gt; int\n</code></pre> <p>How many legs are on this path?</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.print_class_history", "title": "print_class_history", "text": "<pre><code>print_class_history(path_class_index: int) -&gt; str\n</code></pre> <p>Print some historical data to stdout, mostly for debugging</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_decision_fare", "title": "set_class_decision_fare", "text": "<pre><code>set_class_decision_fare(pc_index: int | str, fcst: float)\n</code></pre> <p>Set the decision fare amount for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_fcst_mean", "title": "set_class_fcst_mean", "text": "<pre><code>set_class_fcst_mean(pc_index: int | str, fcst: float)\n</code></pre> <p>Set the demand forecast for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_sold", "title": "set_class_sold", "text": "<pre><code>set_class_sold(pc_index: int | str, sold: int)\n</code></pre> <p>Set the number sold for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_std_dev", "title": "set_class_std_dev", "text": "<pre><code>set_class_std_dev(pc_index: int | str, fcst: float)\n</code></pre> <p>Set the demand forecast std. dev.for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.untruncate_demand", "title": "untruncate_demand", "text": "<pre><code>untruncate_demand(\n    dcp_index: int,\n    algorithm: str,\n    debug: \"SnapshotInstruction | None\" = None,\n)\n</code></pre> <p>Run the demand untruncation models for this path and any path-class items it has</p>"}, {"location": "API/Core/PathClass.html", "title": "Path Class", "text": ""}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.booking_class", "title": "booking_class  <code>instance-attribute</code>", "text": "<pre><code>booking_class: str\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.contribution1", "title": "contribution1  <code>instance-attribute</code>", "text": "<pre><code>contribution1: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.contribution2", "title": "contribution2  <code>instance-attribute</code>", "text": "<pre><code>contribution2: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.decision_fare", "title": "decision_fare  <code>instance-attribute</code>", "text": "<pre><code>decision_fare: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.gt_sold_priceable", "title": "gt_sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>gt_sold_priceable: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.index1", "title": "index1  <code>instance-attribute</code>", "text": "<pre><code>index1: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.index2", "title": "index2  <code>instance-attribute</code>", "text": "<pre><code>index2: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.sold_priceable", "title": "sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>sold_priceable: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.__init__", "title": "__init__", "text": "<pre><code>__init__(booking_class: Any)\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.add_fare", "title": "add_fare", "text": "<pre><code>add_fare(fare: Fare)\n</code></pre> <p>Add a Fare to the PathClass</p>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.set_indexes", "title": "set_indexes", "text": "<pre><code>set_indexes(i1: int, i2: int = 0) -&gt; None\n</code></pre> <p>Set the VN indexes for this PathClass.</p>"}, {"location": "API/config/00-configs.html", "title": "Config", "text": ""}, {"location": "API/config/00-configs.html#passengersim.config.base.Config", "title": "Config", "text": "<p>             Bases: <code>YamlConfig</code></p> Source code in <code>passengersim/config/base.py</code> <pre><code>class Config(YamlConfig, extra=\"forbid\"):\n    scenario: str = Field(default_factory=random_label)\n    \"\"\"Name for this scenario.\n\n    The scenario name is helpful when writing different simulations to the same\n    database so you can uniquely identify and query results for a particular\n    scenario.\"\"\"\n\n    simulation_controls: SimulationSettings = SimulationSettings()\n    \"\"\"\n    Controls that apply broadly to the overall simulation.\n\n    See [SimulationSettings][passengersim.config.SimulationSettings] for detailed\n    documentation.\n    \"\"\"\n\n    db: DatabaseConfig = DatabaseConfig()\n    \"\"\"\n    See [passengersim.config.DatabaseConfig][] for detailed documentation.\n    \"\"\"\n\n    outputs: OutputConfig = OutputConfig()\n    \"\"\"\n    See [passengersim.config.OutputConfig][] for detailed documentation.\n    \"\"\"\n\n    rm_systems: DictOfNamed[RmSystem] = {}\n    \"\"\"\n    The revenue management systems used by the carriers in this simulation.\n\n    See [RM Systems][rm-systems] for details.\n    \"\"\"\n\n    frat5_curves: DictOfNamed[Frat5Curve] = {}\n    \"\"\" FRAT5 curves are used to model sellup rates in Q-forecasting\"\"\"\n\n    load_factor_curves: DictOfNamed[LoadFactorCurve] = {}\n    \"\"\" FRAT5 curves are used to model sellup rates in Q-forecasting\"\"\"\n\n    choice_models: DictOfNamed[ChoiceModel] = {}\n    \"\"\"Several choice models are programmed behind the scenes.\n\n    The choice_models option allows the user to set the parameters used in the\n    utility model for a particular choice model. There are two choice models\n    currently programmed.\n    1. PODS-like\n    2. MNL, using the Lurkin et. al. paper (needs more testing and pdating)\n\n    Need to explaining more here\"\"\"\n\n    airlines: DictOfNamed[Airline] = {}\n    \"\"\"A list of airlines.\n\n    One convention is to use Airline1, Airline2, ... to list the airlines in the\n    network.  Another convention is to use IATA industry-standard two-letter airline\n    codes.  See the\n    [IATA code search](https://www.iata.org/en/publications/directories/code-search/)\n    for more information.\"\"\"\n\n    places: DictOfNamed[Place] = {}\n    \"\"\"A list of places (airports, vertiports, other stations).\"\"\"\n\n    classes: list[str] = []\n    \"\"\"A list of fare classes.\n\n    One convention is to use Y0, Y1, ... to label fare classes from the highest\n    fare (Y0) to the lowest fare (Yn).  You can also use Y, B, M, H,... etc.\n    An example of classes is below.\n\n    Example\n    -------\n    ```{yaml}\n    classes:\n      - Y0\n      - Y1\n      - Y2\n      - Y3\n      - Y4\n      - Y5\n    ```\n    \"\"\"\n\n    dcps: list[int] = []\n    \"\"\"A list of DCPs (data collection points).\n\n    The DCPs are given as integers, which represent the number of days\n    before departure.   An example of data collection points is given below.\n    Note that typically as you get closer to day of departure (DCP=0) the number\n    of days between two consecutive DCP periods decreases.  The DCP intervals are\n    shorter because as you get closer to departure, customer arrival rates tend\n    to increase, and it is advantageous to forecast changes in demand for shorter\n    intervals.\n\n    Example\n    -------\n    ```{yaml}\n    dcps: [63, 56, 49, 42, 35, 31, 28, 24, 21, 17, 14, 10, 7, 5, 3, 1]\n    ```\n    \"\"\"\n\n    booking_curves: DictOfNamed[BookingCurve] = {}\n    \"\"\"Booking curves\n\n    The booking curve points typically line up with the DCPs.\n\n    Example\n    -------\n    ```{yaml}\n    booking_curves:\n      - name: c1\n        curve:\n          63: 0.06\n          56: 0.11\n          49: 0.15\n          42: 0.2\n          35: 0.23\n          31: 0.25\n          28: 0.28\n          24: 0.31\n          21: 0.35\n          17: 0.4\n          14: 0.5\n          10: 0.62\n          7: 0.7\n          5: 0.78\n          3: 0.95\n          1: 1.0\n    \"\"\"\n\n    legs: list[Leg] = []\n    demands: list[Demand] = []\n    fares: list[Fare] = []\n    paths: list[Path] = []\n\n    snapshot_filters: list[SnapshotFilter] = []\n\n    @field_validator(\"snapshot_filters\", mode=\"before\")\n    def _handle_no_snapshot_filters(cls, v):\n        if v is None:\n            v = []\n        return v\n\n    raw_license_certificate: bytes | None = None\n\n    @field_validator(\"raw_license_certificate\", mode=\"before\")\n    def _handle_license_certificate(cls, v):\n        if isinstance(v, str) and v.startswith(\"-----BEGIN CERTIFICATE-----\"):\n            v = v.encode(\"utf8\")\n        return v\n\n    @property\n    def license_certificate(self):\n        from cryptography.x509 import load_pem_x509_certificate\n\n        if isinstance(self.raw_license_certificate, bytes):\n            return load_pem_x509_certificate(self.raw_license_certificate)\n\n    @model_validator(mode=\"after\")\n    def _airlines_have_rm_systems(cls, m: Config):\n        \"\"\"Check that all airlines have RM systems that have been defined.\"\"\"\n        for airline in m.airlines.values():\n            if airline.rm_system not in m.rm_systems:\n                raise ValueError(\n                    f\"Airline {airline.name} has unknown RM system {airline.rm_system}\"\n                )\n        return m\n\n    @model_validator(mode=\"after\")\n    def _booking_curves_match_dcps(cls, m: Config):\n        \"\"\"Check that all booking curves are complete and valid.\"\"\"\n        sorted_dcps = reversed(sorted(m.dcps))\n        for curve in m.booking_curves.values():\n            i = 0\n            for dcp in sorted_dcps:\n                assert (\n                    dcp in curve.curve\n                ), f\"booking curve {curve.name} is missing dcp {dcp}\"\n                assert (\n                    curve.curve[dcp] &gt;= i\n                ), f\"booking curve {curve.name} moves backwards at dcp {dcp}\"\n                i = curve.curve[dcp]\n        return m\n\n    @model_validator(mode=\"after\")\n    def _requested_summaries_have_data(cls, m: Config):\n        \"\"\"Check that requested summary outputs will have the data needed.\"\"\"\n        if \"local_and_flow_yields\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"pathclass_final\", \"pathclass\"}:\n                raise ValueError(\n                    \"the `local_and_flow_yields` report requires recording \"\n                    \"at least `pathclass_final` details in the database\"\n                )\n        if \"bid_price_history\" in m.outputs.reports:\n            if \"leg\" not in m.db.write_items:\n                raise ValueError(\n                    \"the `bid_price_history` report requires recording \"\n                    \"`leg` details in the database\"\n                )\n            if not m.db.store_leg_bid_prices:\n                raise ValueError(\n                    \"the `bid_price_history` report requires recording \"\n                    \"`store_leg_bid_prices` to be True\"\n                )\n        if \"demand_to_come\" in m.outputs.reports:\n            if \"demand\" not in m.db.write_items:\n                raise ValueError(\n                    \"the `demand_to_come` report requires recording \"\n                    \"`demand` details in the database\"\n                )\n        if \"path_forecasts\" in m.outputs.reports:\n            if \"pathclass\" not in m.db.write_items:\n                raise ValueError(\n                    \"the `path_forecasts` report requires recording \"\n                    \"`pathclass` details in the database\"\n                )\n        if \"leg_forecasts\" in m.outputs.reports:\n            if \"bucket\" not in m.db.write_items:\n                raise ValueError(\n                    \"the `leg_forecasts` report requires recording \"\n                    \"`bucket` details in the database\"\n                )\n        if \"bookings_by_timeframe\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"bookings\", \"fare\"}:\n                raise ValueError(\n                    \"the `bookings_by_timeframe` report requires recording \"\n                    \"`fare` or `bookings` details in the database\"\n                )\n        if \"total_demand\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"demand\", \"demand_final\"}:\n                raise ValueError(\n                    \"the `total_demand` report requires recording \"\n                    \"at least `demand_final` details in the database\"\n                )\n        if \"fare_class_mix\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"fare\", \"fare_final\"}:\n                raise ValueError(\n                    \"the `fare_class_mix` report requires recording \"\n                    \"at least `fare_final` details in the database\"\n                )\n        return m\n\n    @classmethod\n    def model_validate(\n        cls,\n        *args,\n        **kwargs,\n    ) -&gt; typing.Any:\n        \"\"\"Validate the passengersim Config inputs.\n\n        This method reloads the Config class to ensure all imported\n        RmSteps are properly registered before validation.\n\n        Parameters\n        ----------\n        obj\n            The object to validate.\n        strict : bool\n            Whether to raise an exception on invalid fields.\n        from_attributes\n            Whether to extract data from object attributes.\n        context\n            Additional context to pass to the validator.\n\n        Raises\n        ------\n        ValidationError\n            If the object could not be validated.\n\n        Returns\n        -------\n        Config\n            The validated model instance.\n        \"\"\"\n        # reload these to refresh for any newly defined RmSteps\n        module_parent = \".\".join(__name__.split(\".\")[:-1])\n        importlib.reload(sys.modules.get(f\"{module_parent}.rm_systems\"))\n        importlib.reload(sys.modules.get(__name__))\n        module = importlib.reload(sys.modules.get(module_parent))\n        reloaded_class = getattr(module, cls.__name__)\n        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n        __tracebackhide__ = True\n        return reloaded_class.__pydantic_validator__.validate_python(*args, **kwargs)\n\n    def add_output_prefix(\n        self, prefix: pathlib.Path, spool_format: str = \"%Y%m%d-%H%M\"\n    ):\n        \"\"\"\n        Add a prefix directory to all simulation output files.\n        \"\"\"\n        if not isinstance(prefix, pathlib.Path):\n            prefix = pathlib.Path(prefix)\n        if spool_format:\n            proposal = prefix.joinpath(time.strftime(spool_format))\n            n = 0\n            while proposal.exists():\n                n += 1\n                proposal = prefix.joinpath(time.strftime(spool_format) + f\".{n}\")\n            prefix = proposal\n        prefix.mkdir(parents=True)\n\n        if self.db.filename:\n            self.db.filename = prefix.joinpath(self.db.filename)\n        if self.outputs.excel:\n            self.outputs.excel = prefix.joinpath(self.outputs.excel)\n        for sf in self.snapshot_filters:\n            if sf.directory:\n                sf.directory = prefix.joinpath(sf.directory)\n        return prefix\n\n    @model_validator(mode=\"after\")\n    def _attach_distance_to_legs_without_it(self):\n        \"\"\"Attach distance in nautical miles to legs that are missing distance.\"\"\"\n        for leg in self.legs:\n            if leg.distance is None:\n                place_o = self.places.get(leg.orig, None)\n                place_d = self.places.get(leg.dest, None)\n                if place_o is not None and place_d is not None:\n                    leg.distance = great_circle(place_o, place_d)\n                if place_o is None:\n                    warnings.warn(f\"No defined place for {leg.orig}\", stacklevel=2)\n                if place_d is None:\n                    warnings.warn(f\"No defined place for {leg.dest}\", stacklevel=2)\n        return self\n\n    def __repr__(self):\n        indent = 2\n        x = []\n        i = \" \" * indent\n        for k, v in self:\n            if k in {\"legs\", \"paths\", \"fares\", \"demands\"}:\n                val = f\"&lt;list of {len(v)} {k}&gt;\"\n            elif k in {\"booking_curves\"}:\n                val = f\"&lt;dict of {len(v)} {k}&gt;\"\n            elif isinstance(v, dict):\n                val = repr_dict_with_indent(v, indent)\n            else:\n                try:\n                    val = v.__repr_with_indent__(indent)\n                except AttributeError:\n                    val = repr(v)\n            if \"\\n\" in val:\n                val_lines = val.split(\"\\n\")\n                val = \"\\n  \" + \"\\n  \".join(val_lines)\n            x.append(f\"{i}{k}: {val}\")\n        return \"passengersim.Config:\\n\" + \"\\n\".join(x)\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.airlines", "title": "airlines  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>airlines: DictOfNamed[Airline] = {}\n</code></pre> <p>A list of airlines.</p> <p>One convention is to use Airline1, Airline2, ... to list the airlines in the network.  Another convention is to use IATA industry-standard two-letter airline codes.  See the IATA code search for more information.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.booking_curves", "title": "booking_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>booking_curves: DictOfNamed[BookingCurve] = {}\n</code></pre> <p>Booking curves</p> <p>The booking curve points typically line up with the DCPs.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.booking_curves--example", "title": "Example", "text": "<p>```{yaml} booking_curves:   - name: c1     curve:       63: 0.06       56: 0.11       49: 0.15       42: 0.2       35: 0.23       31: 0.25       28: 0.28       24: 0.31       21: 0.35       17: 0.4       14: 0.5       10: 0.62       7: 0.7       5: 0.78       3: 0.95       1: 1.0</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.choice_models", "title": "choice_models  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>choice_models: DictOfNamed[ChoiceModel] = {}\n</code></pre> <p>Several choice models are programmed behind the scenes.</p> <p>The choice_models option allows the user to set the parameters used in the utility model for a particular choice model. There are two choice models currently programmed. 1. PODS-like 2. MNL, using the Lurkin et. al. paper (needs more testing and pdating)</p> <p>Need to explaining more here</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.classes", "title": "classes  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>classes: list[str] = []\n</code></pre> <p>A list of fare classes.</p> <p>One convention is to use Y0, Y1, ... to label fare classes from the highest fare (Y0) to the lowest fare (Yn).  You can also use Y, B, M, H,... etc. An example of classes is below.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.classes--example", "title": "Example", "text": "<pre><code>classes:\n  - Y0\n  - Y1\n  - Y2\n  - Y3\n  - Y4\n  - Y5\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.db", "title": "db  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>db: DatabaseConfig = DatabaseConfig()\n</code></pre> <p>See passengersim.config.DatabaseConfig for detailed documentation.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.dcps", "title": "dcps  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcps: list[int] = []\n</code></pre> <p>A list of DCPs (data collection points).</p> <p>The DCPs are given as integers, which represent the number of days before departure.   An example of data collection points is given below. Note that typically as you get closer to day of departure (DCP=0) the number of days between two consecutive DCP periods decreases.  The DCP intervals are shorter because as you get closer to departure, customer arrival rates tend to increase, and it is advantageous to forecast changes in demand for shorter intervals.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.dcps--example", "title": "Example", "text": "<pre><code>dcps: [63, 56, 49, 42, 35, 31, 28, 24, 21, 17, 14, 10, 7, 5, 3, 1]\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.demands", "title": "demands  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>demands: list[Demand] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.fares", "title": "fares  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>fares: list[Fare] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.frat5_curves", "title": "frat5_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frat5_curves: DictOfNamed[Frat5Curve] = {}\n</code></pre> <p>FRAT5 curves are used to model sellup rates in Q-forecasting</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.legs", "title": "legs  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>legs: list[Leg] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.license_certificate", "title": "license_certificate  <code>property</code>", "text": "<pre><code>license_certificate\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.load_factor_curves", "title": "load_factor_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>load_factor_curves: DictOfNamed[LoadFactorCurve] = {}\n</code></pre> <p>FRAT5 curves are used to model sellup rates in Q-forecasting</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.outputs", "title": "outputs  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>outputs: OutputConfig = OutputConfig()\n</code></pre> <p>See passengersim.config.OutputConfig for detailed documentation.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.paths", "title": "paths  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>paths: list[Path] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.places", "title": "places  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>places: DictOfNamed[Place] = {}\n</code></pre> <p>A list of places (airports, vertiports, other stations).</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.raw_license_certificate", "title": "raw_license_certificate  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>raw_license_certificate: bytes | None = None\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.rm_systems", "title": "rm_systems  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>rm_systems: DictOfNamed[RmSystem] = {}\n</code></pre> <p>The revenue management systems used by the carriers in this simulation.</p> <p>See RM Systems for details.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.scenario", "title": "scenario  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>scenario: str = Field(default_factory=random_label)\n</code></pre> <p>Name for this scenario.</p> <p>The scenario name is helpful when writing different simulations to the same database so you can uniquely identify and query results for a particular scenario.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.simulation_controls", "title": "simulation_controls  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>simulation_controls: SimulationSettings = (\n    SimulationSettings()\n)\n</code></pre> <p>Controls that apply broadly to the overall simulation.</p> <p>See SimulationSettings for detailed documentation.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[SnapshotFilter] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.__repr__", "title": "__repr__", "text": "<pre><code>__repr__()\n</code></pre> Source code in <code>passengersim/config/base.py</code> <pre><code>def __repr__(self):\n    indent = 2\n    x = []\n    i = \" \" * indent\n    for k, v in self:\n        if k in {\"legs\", \"paths\", \"fares\", \"demands\"}:\n            val = f\"&lt;list of {len(v)} {k}&gt;\"\n        elif k in {\"booking_curves\"}:\n            val = f\"&lt;dict of {len(v)} {k}&gt;\"\n        elif isinstance(v, dict):\n            val = repr_dict_with_indent(v, indent)\n        else:\n            try:\n                val = v.__repr_with_indent__(indent)\n            except AttributeError:\n                val = repr(v)\n        if \"\\n\" in val:\n            val_lines = val.split(\"\\n\")\n            val = \"\\n  \" + \"\\n  \".join(val_lines)\n        x.append(f\"{i}{k}: {val}\")\n    return \"passengersim.Config:\\n\" + \"\\n\".join(x)\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.add_output_prefix", "title": "add_output_prefix", "text": "<pre><code>add_output_prefix(\n    prefix: pathlib.Path, spool_format: str = \"%Y%m%d-%H%M\"\n)\n</code></pre> <p>Add a prefix directory to all simulation output files.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>def add_output_prefix(\n    self, prefix: pathlib.Path, spool_format: str = \"%Y%m%d-%H%M\"\n):\n    \"\"\"\n    Add a prefix directory to all simulation output files.\n    \"\"\"\n    if not isinstance(prefix, pathlib.Path):\n        prefix = pathlib.Path(prefix)\n    if spool_format:\n        proposal = prefix.joinpath(time.strftime(spool_format))\n        n = 0\n        while proposal.exists():\n            n += 1\n            proposal = prefix.joinpath(time.strftime(spool_format) + f\".{n}\")\n        prefix = proposal\n    prefix.mkdir(parents=True)\n\n    if self.db.filename:\n        self.db.filename = prefix.joinpath(self.db.filename)\n    if self.outputs.excel:\n        self.outputs.excel = prefix.joinpath(self.outputs.excel)\n    for sf in self.snapshot_filters:\n        if sf.directory:\n            sf.directory = prefix.joinpath(sf.directory)\n    return prefix\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.model_validate", "title": "model_validate  <code>classmethod</code>", "text": "<pre><code>model_validate(*args, **kwargs) -&gt; typing.Any\n</code></pre> <p>Validate the passengersim Config inputs.</p> <p>This method reloads the Config class to ensure all imported RmSteps are properly registered before validation.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>         \u2013          <p>The object to validate.</p> </li> <li> <code>strict</code>             (<code>bool</code>)         \u2013          <p>Whether to raise an exception on invalid fields.</p> </li> <li> <code>from_attributes</code>         \u2013          <p>Whether to extract data from object attributes.</p> </li> <li> <code>context</code>         \u2013          <p>Additional context to pass to the validator.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValidationError</code>           \u2013          <p>If the object could not be validated.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config</code>         \u2013          <p>The validated model instance.</p> </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    *args,\n    **kwargs,\n) -&gt; typing.Any:\n    \"\"\"Validate the passengersim Config inputs.\n\n    This method reloads the Config class to ensure all imported\n    RmSteps are properly registered before validation.\n\n    Parameters\n    ----------\n    obj\n        The object to validate.\n    strict : bool\n        Whether to raise an exception on invalid fields.\n    from_attributes\n        Whether to extract data from object attributes.\n    context\n        Additional context to pass to the validator.\n\n    Raises\n    ------\n    ValidationError\n        If the object could not be validated.\n\n    Returns\n    -------\n    Config\n        The validated model instance.\n    \"\"\"\n    # reload these to refresh for any newly defined RmSteps\n    module_parent = \".\".join(__name__.split(\".\")[:-1])\n    importlib.reload(sys.modules.get(f\"{module_parent}.rm_systems\"))\n    importlib.reload(sys.modules.get(__name__))\n    module = importlib.reload(sys.modules.get(module_parent))\n    reloaded_class = getattr(module, cls.__name__)\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    return reloaded_class.__pydantic_validator__.validate_python(*args, **kwargs)\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig", "title": "YamlConfig", "text": "<p>             Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/base.py</code> <pre><code>class YamlConfig(PrettyModel):\n    @classmethod\n    def _load_unformatted_yaml(\n        cls: type[TConfig],\n        filenames: str | pathlib.Path | list[str] | list[pathlib.Path],\n    ) -&gt; addicty.Dict:\n        \"\"\"\n        Read from YAML to an unvalidated addicty.Dict.\n\n        Parameters\n        ----------\n        filenames : path-like or list[path-like]\n            If multiple filenames are provided, they are loaded in order\n            and values with matching keys defined in later files will overwrite\n            the ones found in earlier files.\n\n        Returns\n        -------\n        addicty.Dict\n        \"\"\"\n        if isinstance(filenames, str | pathlib.Path):\n            filenames = [filenames]\n        raw_config = addicty.Dict()\n        for filename in filenames:\n            if isinstance(filename, str) and \"\\n\" in filename:\n                # explicit YAML content cannot have include statements\n                content = addicty.Dict.load(filename, freeze=False)\n                raw_config.update(content)\n                continue\n            filename = pathlib.Path(filename)\n            if filename.suffix in (\".pem\", \".crt\", \".cert\"):\n                # license certificate\n                with open(filename, \"rb\") as f:\n                    raw_config.raw_license_certificate = f.read()\n            else:\n                opener = gzip.open if filename.suffix == \".gz\" else open\n                if filename.parts[0] in {\"https:\", \"http:\", \"s3:\"}:\n                    opener = web_opener\n                    if filename.suffix == \".gz\":\n                        raise NotImplementedError(\n                            \"cannot load compressed files from web yet\"\n                        )\n                with opener(filename) as f:\n                    content = addicty.Dict.load(f, freeze=False)\n                    include = content.pop(\"include\", None)\n                    if include is not None:\n                        if isinstance(include, str):\n                            filename.parent.joinpath(include)\n                            inclusions = [filename.parent.joinpath(include)]\n                        else:\n                            inclusions = [filename.parent.joinpath(i) for i in include]\n                        raw_config.update(cls._load_unformatted_yaml(inclusions))\n                    raw_config.update(content)\n            logger.info(\"loaded config from %s\", filename)\n        return raw_config\n\n    @classmethod\n    def from_yaml(\n        cls: type[TConfig],\n        filenames: pathlib.Path | list[pathlib.Path],\n    ) -&gt; TConfig:\n        \"\"\"\n        Read from YAML to an unvalidated addicty.Dict.\n\n        Parameters\n        ----------\n        filenames : path-like or list[path-like]\n            If multiple filenames are provided, they are loaded in order\n            and values with matching keys defined in later files will overwrite\n            the ones found in earlier files.\n\n        Returns\n        -------\n        Config\n        \"\"\"\n        raw_config = cls._load_unformatted_yaml(filenames)\n        return cls.model_validate(raw_config.to_dict())\n\n    def to_yaml(self, stream: os.PathLike | io.FileIO | None = None) -&gt; None | bytes:\n        \"\"\"\n        Write a config to YAML format.\n\n        Parameters\n        ----------\n        stream : Path-like or File-like, optional\n            Write the results here.  If given as a path, a new file is written\n            at this location, or give a File-like object open for writing.\n\n        Returns\n        -------\n        bytes or None\n            When no stream is given, the YAML content is returned as bytes,\n            otherwise this method returns nothing.\n        \"\"\"\n\n        def path_to_str(x):\n            if isinstance(x, dict):\n                return {k: path_to_str(v) for k, v in x.items()}\n            if isinstance(x, list):\n                return list(path_to_str(i) for i in x)\n            if isinstance(x, tuple):\n                return list(path_to_str(i) for i in x)\n            if isinstance(x, pathlib.Path):\n                return str(x)\n            else:\n                return x\n\n        y = path_to_str(self.model_dump())\n        b = yaml.dump(y, encoding=\"utf8\", Dumper=yaml.SafeDumper)\n        if isinstance(stream, str):\n            stream = pathlib.Path(stream)\n        if isinstance(stream, pathlib.Path):\n            stream.write_bytes(b)\n        elif isinstance(stream, io.RawIOBase):\n            stream.write(b)\n        elif isinstance(stream, io.TextIOBase):\n            stream.write(b.decode())\n        else:\n            return b\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig.from_yaml", "title": "from_yaml  <code>classmethod</code>", "text": "<pre><code>from_yaml(\n    filenames: pathlib.Path | list[pathlib.Path],\n) -&gt; TConfig\n</code></pre> <p>Read from YAML to an unvalidated addicty.Dict.</p> <p>Parameters:</p> <ul> <li> <code>filenames</code>             (<code>path - like or list[path - like]</code>)         \u2013          <p>If multiple filenames are provided, they are loaded in order and values with matching keys defined in later files will overwrite the ones found in earlier files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config</code>         \u2013          </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>@classmethod\ndef from_yaml(\n    cls: type[TConfig],\n    filenames: pathlib.Path | list[pathlib.Path],\n) -&gt; TConfig:\n    \"\"\"\n    Read from YAML to an unvalidated addicty.Dict.\n\n    Parameters\n    ----------\n    filenames : path-like or list[path-like]\n        If multiple filenames are provided, they are loaded in order\n        and values with matching keys defined in later files will overwrite\n        the ones found in earlier files.\n\n    Returns\n    -------\n    Config\n    \"\"\"\n    raw_config = cls._load_unformatted_yaml(filenames)\n    return cls.model_validate(raw_config.to_dict())\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig.to_yaml", "title": "to_yaml", "text": "<pre><code>to_yaml(\n    stream: os.PathLike | io.FileIO | None = None,\n) -&gt; None | bytes\n</code></pre> <p>Write a config to YAML format.</p> <p>Parameters:</p> <ul> <li> <code>stream</code>             (<code>Path - like or File - like</code>, default:                 <code>None</code> )         \u2013          <p>Write the results here.  If given as a path, a new file is written at this location, or give a File-like object open for writing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes or None</code>         \u2013          <p>When no stream is given, the YAML content is returned as bytes, otherwise this method returns nothing.</p> </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>def to_yaml(self, stream: os.PathLike | io.FileIO | None = None) -&gt; None | bytes:\n    \"\"\"\n    Write a config to YAML format.\n\n    Parameters\n    ----------\n    stream : Path-like or File-like, optional\n        Write the results here.  If given as a path, a new file is written\n        at this location, or give a File-like object open for writing.\n\n    Returns\n    -------\n    bytes or None\n        When no stream is given, the YAML content is returned as bytes,\n        otherwise this method returns nothing.\n    \"\"\"\n\n    def path_to_str(x):\n        if isinstance(x, dict):\n            return {k: path_to_str(v) for k, v in x.items()}\n        if isinstance(x, list):\n            return list(path_to_str(i) for i in x)\n        if isinstance(x, tuple):\n            return list(path_to_str(i) for i in x)\n        if isinstance(x, pathlib.Path):\n            return str(x)\n        else:\n            return x\n\n    y = path_to_str(self.model_dump())\n    b = yaml.dump(y, encoding=\"utf8\", Dumper=yaml.SafeDumper)\n    if isinstance(stream, str):\n        stream = pathlib.Path(stream)\n    if isinstance(stream, pathlib.Path):\n        stream.write_bytes(b)\n    elif isinstance(stream, io.RawIOBase):\n        stream.write(b)\n    elif isinstance(stream, io.TextIOBase):\n        stream.write(b.decode())\n    else:\n        return b\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html", "title": "Simulation Controls", "text": ""}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings", "title": "SimulationSettings", "text": "<p>             Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/simulation_controls.py</code> <pre><code>class SimulationSettings(PrettyModel, extra=\"allow\", validate_assignment=True):\n    num_trials: conint(ge=1, le=1000) = 1\n    \"\"\"The overall number of trials to run.\n\n    Each trial is a complete simulation, including burn-in training time as well\n    as study time.  It will have a number of sequentially developed samples, each of\n    which represents one \"typical\" day of travel.\n\n    See [Counting Simulations][counting-simulations] for more details.\n    \"\"\"\n\n    num_samples: conint(ge=1, le=10000) = 600\n    \"\"\"The number of samples to run within each trial.\n\n    Each sample represents one \"typical\" day of travel.\n    See [Counting Simulations][counting-simulations] for more details.\n    \"\"\"\n\n    burn_samples: conint(ge=1, le=10000) = 100\n    \"\"\"The number of samples to burn when starting each trial.\n\n    Burned samples are used to populate a stable history of data to support\n    forecasting and optimization algorithms, but are not used to evaluate\n    performance results.\n\n    See [Counting Simulations][counting-simulations] for more details.\n    \"\"\"\n\n    double_capacity_until: int | None = None\n    \"\"\"\n    Double the capacity on all legs until this sample.\n\n    The extra capacity may reduce the statistical noise of untruncation\n    within the burn period and allow the simulation to achieve a stable\n    steady state faster.  If used, this should be set to a value at least\n    26 below the `burn_samples` value to avoid polluting the results.\n    \"\"\"\n\n    @field_validator(\"double_capacity_until\")\n    @classmethod\n    def _avoid_capacity_pollution(cls, v: int | None, info: ValidationInfo):\n        if v and v &gt;= info.data[\"burn_samples\"] - 25:\n            raise ValueError(\"doubled capacity will pollute results\")\n        return v\n\n    sys_k_factor: confloat(ge=0, le=5.0) = 0.10\n    \"\"\"\n    System-level randomness factor.\n\n    This factor controls the level of correlation in demand levels across the\n    entire system.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    mkt_k_factor: confloat(ge=0, le=5.0) = 0.20\n    \"\"\"\n    Market-level randomness factor.\n\n    This factor controls the level of correlation in demand levels across origin-\n    destination markets.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    pax_type_k_factor: confloat(ge=0, le=5.0) = 0.0\n    \"\"\"\n    Passenger-type randomness factor.\n\n    This factor controls the level of correlation in demand levels across passenger\n    types.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    simple_k_factor: confloat(ge=0, le=5.0) = 0.40\n    \"\"\"\n    Passenger-type randomness factor.\n\n    This factor add uncorrelated variance to every demand.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    tf_k_factor: confloat(ge=0) = 0.1\n    \"\"\"\n    Time frame randomness factor.\n\n    This factor controls the dispersion of bookings over time, given a previously\n    identified level of total demand. See [k-factors]() for more details.\n    \"\"\"\n\n    tot_z_factor: confloat(ge=0, le=100.0) = 2.0\n    \"\"\"\n    Base level demand variance control.\n\n    This factor scales the variance in the amount of total demand for any given\n    market segment.\n\n    See [k-factors][demand-generation-k-factors] for more details.\n    \"\"\"\n\n    tf_z_factor: confloat(ge=0, le=100.0) = 2.0\n    \"\"\"\n    Timeframe demand variance control.\n\n    This factor scales the variance in the allocation of total demand to the\n    various arrival timeframes.\n\n    See [k-factors][demand-generation-k-factors] for more details.\n    \"\"\"\n\n    prorate_revenue: bool = True\n\n    dwm_lite: bool = True\n    \"\"\"\n    Use the \"lite\" decision window model.\n\n    The structure of this model is the same as that use by Boeing.\n    \"\"\"\n\n    max_connect_time: conint(ge=0) = 240\n    \"\"\"\n    Maximum connection time for automatically generated paths.\n\n    Any generated path that has a connection time greater than this value (expressed\n    in minutes) is invalidated.\n    \"\"\"\n\n    disable_ap: bool = False\n    \"\"\"\n    Remove all advance purchase settings used in the simulation.\n\n    This applies to all airlines and all fare products.\n    \"\"\"\n\n    demand_multiplier: confloat(gt=0) = 1.0\n    \"\"\"\n    Scale all demand by this value.\n\n    Setting to a value other than 1.0 will increase or decrease all demand inputs\n    uniformly by the same multiplicative amount. This is helpful when exploring how\n    simulation results vary when you have \"low demand\" scenarios (e.g,\n    demand_multiplier = 0.8), or \"high demand\" scenarios (e.g., demand multiplier = 1.1).\n    \"\"\"\n\n    manual_paths: bool = True\n    \"\"\"\n    The user has provided explicit paths and connections.\n\n    If set to False, the automatic path generation algorithm is applied.\n    \"\"\"\n\n    write_raw_files: bool = False\n\n    random_seed: int | None = None\n    \"\"\"\n    Integer used to control the reproducibility of simulation results.\n\n    A seed is base value used by a pseudo-random generator to generate random\n    numbers. A fixed random seed is used to ensure the same randomness pattern\n    is reproducible and does not change between simulation runs, i.e. allows\n    subsequent runs to be conducted with the same randomness pattern as a\n    previous one. Any value set here will allow results to be repeated.\n\n    The random number generator is re-seeded at the beginning of every sample\n    in every trial with a fixed tuple of three values: this \"global\" random seed,\n    plus the sample number and trial number.  This ensures that partial results\n    are also reproducible: the simulation of sample 234 in trial 2 will be the\n    same regardless of how many samples are in trial 1.\n    \"\"\"\n\n    update_frequency: int | None = None\n\n    controller_time_zone: int | float = -21600\n    \"\"\"\n    The reference time zone for the controller (seconds relative to UTC).\n\n    Data collection points will be trigger at approximately midnight in this time zone.\n\n    This value can be input in hours instead of seconds, any absolute value less\n    than or equal to 12 will be assumed to be hours and scaled to seconds.\n\n    The default value is -6 hours, or US Central Standard Time.\n    \"\"\"\n\n    base_date: str = \"2020-03-01\"\n    \"\"\"\n    The default date used to compute relative times for travel.\n\n    Future enhancements may include multi-day modeling.\n    \"\"\"\n\n    dcp_hour: float = 0.0\n    \"\"\"\n    The hour of the day that the RM recalculation events are triggered.\n\n    If set to zero, the events happen at midnight.  Other values can\n    delay the recalculation into later in the night (or the next day).\n    \"\"\"\n\n    show_progress_bar: bool = True\n    \"\"\"\n    Show a progress bar while running.\n\n    The progress display requires `rich` is installed.\n    \"\"\"\n\n    @field_validator(\"controller_time_zone\", mode=\"before\")\n    def _time_zone_convert_hours_to_seconds(cls, v):\n        if -12 &lt;= v &lt;= 12:\n            v *= 3600\n        return v\n\n    def reference_epoch(self) -&gt; int:\n        \"\"\"Get the reference travel datetime in unix time.\"\"\"\n        return iso_to_unix(self.base_date) - self.controller_time_zone\n\n    timeframe_demand_allocation: Literal[\"v2\", \"pods\"] = \"v2\"\n    \"\"\"\n    Which algorithm to use for time frame demand allocation.\n    \"\"\"\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.base_date", "title": "base_date  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>base_date: str = '2020-03-01'\n</code></pre> <p>The default date used to compute relative times for travel.</p> <p>Future enhancements may include multi-day modeling.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.burn_samples", "title": "burn_samples  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>burn_samples: conint(ge=1, le=10000) = 100\n</code></pre> <p>The number of samples to burn when starting each trial.</p> <p>Burned samples are used to populate a stable history of data to support forecasting and optimization algorithms, but are not used to evaluate performance results.</p> <p>See Counting Simulations for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.controller_time_zone", "title": "controller_time_zone  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>controller_time_zone: int | float = -21600\n</code></pre> <p>The reference time zone for the controller (seconds relative to UTC).</p> <p>Data collection points will be trigger at approximately midnight in this time zone.</p> <p>This value can be input in hours instead of seconds, any absolute value less than or equal to 12 will be assumed to be hours and scaled to seconds.</p> <p>The default value is -6 hours, or US Central Standard Time.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.dcp_hour", "title": "dcp_hour  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcp_hour: float = 0.0\n</code></pre> <p>The hour of the day that the RM recalculation events are triggered.</p> <p>If set to zero, the events happen at midnight.  Other values can delay the recalculation into later in the night (or the next day).</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.demand_multiplier", "title": "demand_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>demand_multiplier: confloat(gt=0) = 1.0\n</code></pre> <p>Scale all demand by this value.</p> <p>Setting to a value other than 1.0 will increase or decrease all demand inputs uniformly by the same multiplicative amount. This is helpful when exploring how simulation results vary when you have \"low demand\" scenarios (e.g, demand_multiplier = 0.8), or \"high demand\" scenarios (e.g., demand multiplier = 1.1).</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.disable_ap", "title": "disable_ap  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>disable_ap: bool = False\n</code></pre> <p>Remove all advance purchase settings used in the simulation.</p> <p>This applies to all airlines and all fare products.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.double_capacity_until", "title": "double_capacity_until  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>double_capacity_until: int | None = None\n</code></pre> <p>Double the capacity on all legs until this sample.</p> <p>The extra capacity may reduce the statistical noise of untruncation within the burn period and allow the simulation to achieve a stable steady state faster.  If used, this should be set to a value at least 26 below the <code>burn_samples</code> value to avoid polluting the results.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.dwm_lite", "title": "dwm_lite  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dwm_lite: bool = True\n</code></pre> <p>Use the \"lite\" decision window model.</p> <p>The structure of this model is the same as that use by Boeing.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.manual_paths", "title": "manual_paths  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>manual_paths: bool = True\n</code></pre> <p>The user has provided explicit paths and connections.</p> <p>If set to False, the automatic path generation algorithm is applied.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.max_connect_time", "title": "max_connect_time  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>max_connect_time: conint(ge=0) = 240\n</code></pre> <p>Maximum connection time for automatically generated paths.</p> <p>Any generated path that has a connection time greater than this value (expressed in minutes) is invalidated.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.mkt_k_factor", "title": "mkt_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>mkt_k_factor: confloat(ge=0, le=5.0) = 0.2\n</code></pre> <p>Market-level randomness factor.</p> <p>This factor controls the level of correlation in demand levels across origin- destination markets.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.num_samples", "title": "num_samples  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>num_samples: conint(ge=1, le=10000) = 600\n</code></pre> <p>The number of samples to run within each trial.</p> <p>Each sample represents one \"typical\" day of travel. See Counting Simulations for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.num_trials", "title": "num_trials  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>num_trials: conint(ge=1, le=1000) = 1\n</code></pre> <p>The overall number of trials to run.</p> <p>Each trial is a complete simulation, including burn-in training time as well as study time.  It will have a number of sequentially developed samples, each of which represents one \"typical\" day of travel.</p> <p>See Counting Simulations for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.pax_type_k_factor", "title": "pax_type_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>pax_type_k_factor: confloat(ge=0, le=5.0) = 0.0\n</code></pre> <p>Passenger-type randomness factor.</p> <p>This factor controls the level of correlation in demand levels across passenger types.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.prorate_revenue", "title": "prorate_revenue  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>prorate_revenue: bool = True\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.random_seed", "title": "random_seed  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>random_seed: int | None = None\n</code></pre> <p>Integer used to control the reproducibility of simulation results.</p> <p>A seed is base value used by a pseudo-random generator to generate random numbers. A fixed random seed is used to ensure the same randomness pattern is reproducible and does not change between simulation runs, i.e. allows subsequent runs to be conducted with the same randomness pattern as a previous one. Any value set here will allow results to be repeated.</p> <p>The random number generator is re-seeded at the beginning of every sample in every trial with a fixed tuple of three values: this \"global\" random seed, plus the sample number and trial number.  This ensures that partial results are also reproducible: the simulation of sample 234 in trial 2 will be the same regardless of how many samples are in trial 1.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.show_progress_bar", "title": "show_progress_bar  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>show_progress_bar: bool = True\n</code></pre> <p>Show a progress bar while running.</p> <p>The progress display requires <code>rich</code> is installed.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.simple_k_factor", "title": "simple_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>simple_k_factor: confloat(ge=0, le=5.0) = 0.4\n</code></pre> <p>Passenger-type randomness factor.</p> <p>This factor add uncorrelated variance to every demand.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.sys_k_factor", "title": "sys_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>sys_k_factor: confloat(ge=0, le=5.0) = 0.1\n</code></pre> <p>System-level randomness factor.</p> <p>This factor controls the level of correlation in demand levels across the entire system.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.tf_k_factor", "title": "tf_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tf_k_factor: confloat(ge=0) = 0.1\n</code></pre> <p>Time frame randomness factor.</p> <p>This factor controls the dispersion of bookings over time, given a previously identified level of total demand. See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.tf_z_factor", "title": "tf_z_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tf_z_factor: confloat(ge=0, le=100.0) = 2.0\n</code></pre> <p>Timeframe demand variance control.</p> <p>This factor scales the variance in the allocation of total demand to the various arrival timeframes.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.timeframe_demand_allocation", "title": "timeframe_demand_allocation  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>timeframe_demand_allocation: Literal['v2', 'pods'] = 'v2'\n</code></pre> <p>Which algorithm to use for time frame demand allocation.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.tot_z_factor", "title": "tot_z_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tot_z_factor: confloat(ge=0, le=100.0) = 2.0\n</code></pre> <p>Base level demand variance control.</p> <p>This factor scales the variance in the amount of total demand for any given market segment.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.update_frequency", "title": "update_frequency  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>update_frequency: int | None = None\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.write_raw_files", "title": "write_raw_files  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>write_raw_files: bool = False\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.reference_epoch", "title": "reference_epoch", "text": "<pre><code>reference_epoch() -&gt; int\n</code></pre> <p>Get the reference travel datetime in unix time.</p> Source code in <code>passengersim/config/simulation_controls.py</code> <pre><code>def reference_epoch(self) -&gt; int:\n    \"\"\"Get the reference travel datetime in unix time.\"\"\"\n    return iso_to_unix(self.base_date) - self.controller_time_zone\n</code></pre>"}, {"location": "API/config/airlines.html", "title": "Airlines", "text": ""}, {"location": "API/config/airlines.html#passengersim.config.airlines.Airline", "title": "Airline", "text": "<p>             Bases: <code>Named</code></p> <p>Configuration for passengersim.Airline object.</p> Source code in <code>passengersim/config/airlines.py</code> <pre><code>class Airline(Named, extra=\"forbid\"):\n    \"\"\"Configuration for passengersim.Airline object.\"\"\"\n\n    rm_system: str\n    \"\"\"Name of the revenue management system used by this airline.\"\"\"\n\n    control: str = \"\"\n    \"\"\"Deprecated.  No effect\"\"\"\n\n    frat5: Optional[str] = \"\"\n    \"\"\"Named FRAT5 curve.  \n    This is the default that will be applied if not found at a more detailed level\n    \"\"\"\n\n    load_factor_curve: Optional[Any] = None\n    \"\"\"Named FRAT5 curve.  \n    This is the default that will be applied if not found at a more detailed level\n    \"\"\"\n</code></pre>"}, {"location": "API/config/airlines.html#passengersim.config.airlines.Airline.control", "title": "control  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>control: str = ''\n</code></pre> <p>Deprecated.  No effect</p>"}, {"location": "API/config/airlines.html#passengersim.config.airlines.Airline.frat5", "title": "frat5  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frat5: Optional[str] = ''\n</code></pre> <p>Named FRAT5 curve. This is the default that will be applied if not found at a more detailed level</p>"}, {"location": "API/config/airlines.html#passengersim.config.airlines.Airline.load_factor_curve", "title": "load_factor_curve  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>load_factor_curve: Optional[Any] = None\n</code></pre> <p>Named FRAT5 curve. This is the default that will be applied if not found at a more detailed level</p>"}, {"location": "API/config/airlines.html#passengersim.config.airlines.Airline.rm_system", "title": "rm_system  <code>instance-attribute</code>", "text": "<pre><code>rm_system: str\n</code></pre> <p>Name of the revenue management system used by this airline.</p>"}, {"location": "API/config/booking_curves.html", "title": "Booking Curves", "text": ""}, {"location": "API/config/booking_curves.html#passengersim.config.booking_curves.BookingCurve", "title": "BookingCurve", "text": "<p>             Bases: <code>Named</code></p> <p>A mathematical description of the relative arrival rate of customers over time.</p> Source code in <code>passengersim/config/booking_curves.py</code> <pre><code>class BookingCurve(Named, extra=\"forbid\"):\n    \"\"\"\n    A mathematical description of the relative arrival rate of customers over time.\n    \"\"\"\n\n    curve: dict[int, float]\n    \"\"\"Define a booking curve.\n\n    For a given customer type, the booking curve gives the cumulative fraction\n    of those customers who are expected to have already \"arrived\" at any given\n    data collection point (DCP).  An \"arriving\" customer is one who is interested\n    in booking, but may or may not actually purchase a travel product from one\n    of the carriers, depending on the availability of products at the time of their\n    arrival.\n\n    The values (cumulative fraction of customers arriving) should increase\n    monotonically as the keys (DCPs, e.g. days to departure) decrease.\n\n    Example\n    -------\n    ```{yaml}\n    - name: business\n      curve:\n        63: 0.01\n        56: 0.02\n        49: 0.05\n        42: 0.13\n        35: 0.19\n        31: 0.23\n        28: 0.29\n        24: 0.35\n        21: 0.45\n        17: 0.54\n        14: 0.67\n        10: 0.79\n        7: 0.86\n        5: 0.91\n        3: 0.96\n        1: 1.0\n    ```\n    \"\"\"\n\n    @field_validator(\"curve\")\n    def _booking_curves_accumulate(cls, v: dict[int, float], info: ValidationInfo):\n        \"\"\"Check that all curve values do not decrease as DCP keys decrease.\"\"\"\n        sorted_dcps = reversed(sorted(v.keys()))\n        i = 0\n        for dcp in sorted_dcps:\n            assert (\n                v[dcp] &gt;= i\n            ), f\"booking curve {info.data['name']} moves backwards at dcp {dcp}\"\n            i = v[dcp]\n        return v\n</code></pre>"}, {"location": "API/config/booking_curves.html#passengersim.config.booking_curves.BookingCurve.curve", "title": "curve  <code>instance-attribute</code>", "text": "<pre><code>curve: dict[int, float]\n</code></pre> <p>Define a booking curve.</p> <p>For a given customer type, the booking curve gives the cumulative fraction of those customers who are expected to have already \"arrived\" at any given data collection point (DCP).  An \"arriving\" customer is one who is interested in booking, but may or may not actually purchase a travel product from one of the carriers, depending on the availability of products at the time of their arrival.</p> <p>The values (cumulative fraction of customers arriving) should increase monotonically as the keys (DCPs, e.g. days to departure) decrease.</p>"}, {"location": "API/config/booking_curves.html#passengersim.config.booking_curves.BookingCurve.curve--example", "title": "Example", "text": "<pre><code>- name: business\n  curve:\n    63: 0.01\n    56: 0.02\n    49: 0.05\n    42: 0.13\n    35: 0.19\n    31: 0.23\n    28: 0.29\n    24: 0.35\n    21: 0.45\n    17: 0.54\n    14: 0.67\n    10: 0.79\n    7: 0.86\n    5: 0.91\n    3: 0.96\n    1: 1.0\n</code></pre>"}, {"location": "API/config/choice_model.html", "title": "Choice Models", "text": ""}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.ChoiceModel", "title": "ChoiceModel  <code>module-attribute</code>", "text": "<pre><code>ChoiceModel = Annotated[\n    PodsChoiceModel | LogitChoiceModel,\n    Field(discriminator=\"kind\"),\n]\n</code></pre> <p>Two types of choice models are available in PassengerSim.</p> <p>Use the <code>kind</code> key to select which kind of choice model you wish to parameterize.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel", "title": "LogitChoiceModel", "text": "<p>             Bases: <code>Named</code></p> Source code in <code>passengersim/config/choice_model.py</code> <pre><code>class LogitChoiceModel(Named, extra=\"forbid\"):\n    kind: Literal[\"logit\"]\n\n    intercept: float = 0\n    \"\"\"This is the alternative specific constant for the no-purchase alternative.\"\"\"\n\n    nonstop: float = 0\n    duration: float = 0\n    price: float = 0\n    \"\"\"This is the parameter for the price of each alternative.\"\"\"\n\n    tod_sin2p: float = 0\n    r\"\"\"Schedule parameter.\n\n    If $t$ is departure time (in minutes after midnight local time) divided\n    by 1440, this parameter is multiplied by $sin( 2 \\pi t)$ and the result is\n    added to the utility of the particular alternative.\"\"\"\n\n    tod_sin4p: float = 0\n    r\"\"\"Schedule parameter.\n\n    If $t$ is departure time (in minutes after midnight local time) divided\n    by 1440, this parameter is multiplied by $sin( 4 \\pi t)$ and the result is\n    added to the utility of the particular alternative.\"\"\"\n\n    tod_sin6p: float = 0\n    tod_cos2p: float = 0\n    tod_cos4p: float = 0\n    tod_cos6p: float = 0\n    free_bag: float = 0\n    early_boarding: float = 0\n    same_day_change: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.duration", "title": "duration  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>duration: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.early_boarding", "title": "early_boarding  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>early_boarding: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.free_bag", "title": "free_bag  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>free_bag: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.intercept", "title": "intercept  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>intercept: float = 0\n</code></pre> <p>This is the alternative specific constant for the no-purchase alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.kind", "title": "kind  <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['logit']\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.nonstop", "title": "nonstop  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>nonstop: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.price", "title": "price  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>price: float = 0\n</code></pre> <p>This is the parameter for the price of each alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.same_day_change", "title": "same_day_change  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>same_day_change: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_cos2p", "title": "tod_cos2p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_cos2p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_cos4p", "title": "tod_cos4p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_cos4p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_cos6p", "title": "tod_cos6p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_cos6p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_sin2p", "title": "tod_sin2p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_sin2p: float = 0\n</code></pre> <p>Schedule parameter.</p> <p>If \\(t\\) is departure time (in minutes after midnight local time) divided by 1440, this parameter is multiplied by \\(sin( 2 \\pi t)\\) and the result is added to the utility of the particular alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_sin4p", "title": "tod_sin4p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_sin4p: float = 0\n</code></pre> <p>Schedule parameter.</p> <p>If \\(t\\) is departure time (in minutes after midnight local time) divided by 1440, this parameter is multiplied by \\(sin( 4 \\pi t)\\) and the result is added to the utility of the particular alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_sin6p", "title": "tod_sin6p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_sin6p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel", "title": "PodsChoiceModel", "text": "<p>             Bases: <code>Named</code></p> Source code in <code>passengersim/config/choice_model.py</code> <pre><code>class PodsChoiceModel(Named, extra=\"forbid\"):\n    kind: Literal[\"pods\"]\n\n    emult: float | None = None\n\n    basefare_mult: float | None = None\n    connect_disutility: float | None = None\n    path_quality: tuple[float, float] | None = None\n    preferred_airline: tuple[float, float] | None = None\n    r1: float | None = None\n    r2: float | None = None\n    r3: float | None = None\n    r4: float | None = None\n    tolerance: float | None = None\n    non_stop_multiplier: float | None = None\n    connection_multiplier: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.basefare_mult", "title": "basefare_mult  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>basefare_mult: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.connect_disutility", "title": "connect_disutility  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>connect_disutility: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.connection_multiplier", "title": "connection_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>connection_multiplier: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.emult", "title": "emult  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>emult: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.kind", "title": "kind  <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['pods']\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.non_stop_multiplier", "title": "non_stop_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>non_stop_multiplier: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.path_quality", "title": "path_quality  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>path_quality: tuple[float, float] | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.preferred_airline", "title": "preferred_airline  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>preferred_airline: tuple[float, float] | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.r1", "title": "r1  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>r1: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.r2", "title": "r2  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>r2: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.r3", "title": "r3  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>r3: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.r4", "title": "r4  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>r4: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.tolerance", "title": "tolerance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tolerance: float | None = None\n</code></pre>"}, {"location": "API/config/database.html", "title": "Database", "text": ""}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig", "title": "DatabaseConfig", "text": "<p>             Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/database.py</code> <pre><code>class DatabaseConfig(PrettyModel, extra=\"forbid\", validate_assignment=True):\n    engine: Literal[\"sqlite\", \"mysql\", None] = \"sqlite\"\n    \"\"\"Database engine to use.\n\n    Currently only `sqlite` is fully implemented.\"\"\"\n\n    filename: pathlib.Path | None = \"airsim-output.sqlite\"\n    \"\"\"Name of file for SQLite output.\"\"\"\n\n    fast: bool = False\n    \"\"\"Whether to use pre-compiled SQL write instructions.\"\"\"\n\n    pragmas: list[str] = []\n    \"\"\"A list of PRAGMA commands to execute upon opening a database connection.\"\"\"\n\n    commit_count_delay: int | None = 250\n    \"\"\"Commit transactions to the database will only be honored this frequently.\n\n    By setting this number greater than 1, the transaction frequency will be reduced,\n    improving overall runtime performance by storing more data in RAM and writing to\n    persistent storage less frequently.\n    \"\"\"\n\n    write_items: set[\n        Literal[\n            \"leg\",\n            \"bucket\",\n            \"fare\",\n            \"demand\",\n            \"leg_daily\",\n            \"leg_final\",\n            \"bucket_final\",\n            \"fare_final\",\n            \"demand_final\",\n            \"bookings\",\n            \"pathclass\",\n            \"pathclass_daily\",\n            \"pathclass_final\",\n        ]\n    ] = {\"leg_final\", \"fare_final\", \"demand_final\", \"bookings\"}\n    \"\"\"Which items should be written to the database.\n\n    The following values can be provided in this set:\n\n    - *leg*: write every leg to the `leg_detail` table at every DCP.\n    - *leg_final*: write every leg to the `leg_detail` table only at DCP 0.\n    - *bucket*: write every leg bucket to the `leg_bucket_detail` table at every DCP.\n    - *bucket_final*: write every leg bucket to the `leg_bucket_detail` table only\n        at DCP 0.\n    - *fare*: write every fare to the `fare_detail` table at every DCP.\n    - *fare_final*: write every fare to the `fare_detail` table only at DCP 0.\n    - *demand*: write every demand to the `demand_detail` table at every DCP.\n    - *bookings*: store booking summary data at every DCP and write an aggregate\n        summary of bookings by DCP to the `bookings_by_timeframe` table at the end\n        of the simulation.\n    \"\"\"\n\n    dcp_write_hooks: list[Callable] = []\n    \"\"\"Additional callable functions that write to the database at each DCP.\n\n    Each should have a signature matching `f(db, sim, dcp)`.\n    \"\"\"\n\n    @field_validator(\"engine\", mode=\"before\")\n    def _interpret_none(cls, v):\n        \"\"\"Allow engine to be \"none\".\"\"\"\n        if isinstance(v, str) and v.lower() == \"none\":\n            v = None\n        return v\n\n    store_leg_bid_prices: bool = True\n    \"\"\"Should leg bid prices be stored in the database.\"\"\"\n</code></pre>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.commit_count_delay", "title": "commit_count_delay  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>commit_count_delay: int | None = 250\n</code></pre> <p>Commit transactions to the database will only be honored this frequently.</p> <p>By setting this number greater than 1, the transaction frequency will be reduced, improving overall runtime performance by storing more data in RAM and writing to persistent storage less frequently.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.dcp_write_hooks", "title": "dcp_write_hooks  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcp_write_hooks: list[Callable] = []\n</code></pre> <p>Additional callable functions that write to the database at each DCP.</p> <p>Each should have a signature matching <code>f(db, sim, dcp)</code>.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.engine", "title": "engine  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>engine: Literal['sqlite', 'mysql', None] = 'sqlite'\n</code></pre> <p>Database engine to use.</p> <p>Currently only <code>sqlite</code> is fully implemented.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.fast", "title": "fast  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>fast: bool = False\n</code></pre> <p>Whether to use pre-compiled SQL write instructions.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.filename", "title": "filename  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>filename: pathlib.Path | None = 'airsim-output.sqlite'\n</code></pre> <p>Name of file for SQLite output.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.pragmas", "title": "pragmas  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>pragmas: list[str] = []\n</code></pre> <p>A list of PRAGMA commands to execute upon opening a database connection.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.store_leg_bid_prices", "title": "store_leg_bid_prices  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>store_leg_bid_prices: bool = True\n</code></pre> <p>Should leg bid prices be stored in the database.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.write_items", "title": "write_items  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>write_items: set[\n    Literal[\n        \"leg\",\n        \"bucket\",\n        \"fare\",\n        \"demand\",\n        \"leg_daily\",\n        \"leg_final\",\n        \"bucket_final\",\n        \"fare_final\",\n        \"demand_final\",\n        \"bookings\",\n        \"pathclass\",\n        \"pathclass_daily\",\n        \"pathclass_final\",\n    ]\n] = {\"leg_final\", \"fare_final\", \"demand_final\", \"bookings\"}\n</code></pre> <p>Which items should be written to the database.</p> <p>The following values can be provided in this set:</p> <ul> <li>leg: write every leg to the <code>leg_detail</code> table at every DCP.</li> <li>leg_final: write every leg to the <code>leg_detail</code> table only at DCP 0.</li> <li>bucket: write every leg bucket to the <code>leg_bucket_detail</code> table at every DCP.</li> <li>bucket_final: write every leg bucket to the <code>leg_bucket_detail</code> table only     at DCP 0.</li> <li>fare: write every fare to the <code>fare_detail</code> table at every DCP.</li> <li>fare_final: write every fare to the <code>fare_detail</code> table only at DCP 0.</li> <li>demand: write every demand to the <code>demand_detail</code> table at every DCP.</li> <li>bookings: store booking summary data at every DCP and write an aggregate     summary of bookings by DCP to the <code>bookings_by_timeframe</code> table at the end     of the simulation.</li> </ul>"}, {"location": "API/config/demands.html", "title": "Demands", "text": ""}, {"location": "API/config/demands.html#passengersim.config.demands.Demand", "title": "Demand", "text": "<p>             Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/demands.py</code> <pre><code>class Demand(BaseModel, extra=\"forbid\"):\n    orig: str\n    dest: str\n    segment: str\n    base_demand: float\n    reference_fare: float\n    distance: float | None = 0.0\n    choice_model: str | None = None\n    \"\"\"The name of the choice model that is applied for this demand.\"\"\"\n\n    curve: str | None = None\n    \"\"\"The name of the booking curve that is applied for this demand.\n\n    Each demand is attached to a booking curve that describes the temporal\n    distribution of customer arrivals.\"\"\"\n\n    @property\n    def choice_model_(self):\n        \"\"\"Choice model, falling back to segment name if not set explicitly.\"\"\"\n        return self.choice_model or self.segment\n\n    @field_validator(\"curve\", mode=\"before\")\n    def curve_integer_name(cls, v):\n        \"\"\"Booking curves can have integer names, treat as string.\"\"\"\n        if isinstance(v, int):\n            v = str(v)\n        return v\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.base_demand", "title": "base_demand  <code>instance-attribute</code>", "text": "<pre><code>base_demand: float\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.choice_model", "title": "choice_model  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>choice_model: str | None = None\n</code></pre> <p>The name of the choice model that is applied for this demand.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.choice_model_", "title": "choice_model_  <code>property</code>", "text": "<pre><code>choice_model_\n</code></pre> <p>Choice model, falling back to segment name if not set explicitly.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.curve", "title": "curve  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>curve: str | None = None\n</code></pre> <p>The name of the booking curve that is applied for this demand.</p> <p>Each demand is attached to a booking curve that describes the temporal distribution of customer arrivals.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.distance", "title": "distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>distance: float | None = 0.0\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.reference_fare", "title": "reference_fare  <code>instance-attribute</code>", "text": "<pre><code>reference_fare: float\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.segment", "title": "segment  <code>instance-attribute</code>", "text": "<pre><code>segment: str\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.curve_integer_name", "title": "curve_integer_name", "text": "<pre><code>curve_integer_name(v)\n</code></pre> <p>Booking curves can have integer names, treat as string.</p> Source code in <code>passengersim/config/demands.py</code> <pre><code>@field_validator(\"curve\", mode=\"before\")\ndef curve_integer_name(cls, v):\n    \"\"\"Booking curves can have integer names, treat as string.\"\"\"\n    if isinstance(v, int):\n        v = str(v)\n    return v\n</code></pre>"}, {"location": "API/config/fares.html", "title": "Fares", "text": ""}, {"location": "API/config/fares.html#passengersim.config.fares.Fare", "title": "Fare", "text": "<p>             Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/fares.py</code> <pre><code>class Fare(BaseModel, extra=\"forbid\"):\n    carrier: str\n    orig: str\n    dest: str\n    booking_class: str\n    price: float\n    advance_purchase: int\n    restrictions: list[str] = []\n\n    @field_validator(\"restrictions\", mode=\"before\")\n    def allow_unrestricted(cls, v):\n        \"\"\"Allow restrictions to be None or missing.\"\"\"\n        if v is None:\n            v = []\n        return v\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.advance_purchase", "title": "advance_purchase  <code>instance-attribute</code>", "text": "<pre><code>advance_purchase: int\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.booking_class", "title": "booking_class  <code>instance-attribute</code>", "text": "<pre><code>booking_class: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.restrictions", "title": "restrictions  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>restrictions: list[str] = []\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.allow_unrestricted", "title": "allow_unrestricted", "text": "<pre><code>allow_unrestricted(v)\n</code></pre> <p>Allow restrictions to be None or missing.</p> Source code in <code>passengersim/config/fares.py</code> <pre><code>@field_validator(\"restrictions\", mode=\"before\")\ndef allow_unrestricted(cls, v):\n    \"\"\"Allow restrictions to be None or missing.\"\"\"\n    if v is None:\n        v = []\n    return v\n</code></pre>"}, {"location": "API/config/frat5_curves.html", "title": "Frat5 Curves", "text": ""}, {"location": "API/config/frat5_curves.html#passengersim.config.frat5_curves.Frat5Curve", "title": "Frat5Curve", "text": "<p>             Bases: <code>Named</code></p> <p>FRAT5 = Fare Ratio at which 50% of customers will buy up to the higher fare.</p> Source code in <code>passengersim/config/frat5_curves.py</code> <pre><code>class Frat5Curve(Named, extra=\"forbid\"):\n    \"\"\"\n    FRAT5 = Fare Ratio at which 50% of customers will buy up to the higher fare.\n    \"\"\"\n\n    curve: dict[int, float]\n    \"\"\"Define a Frat5 curve.\n\n\n    The values (cumulative fraction of customers arriving) should increase\n    monotonically as the keys (DCPs, e.g. days to departure) decrease.\n\n    Example\n    -------\n    ```{yaml}\n    - name: curve_C\n      curve:\n        63: 1.4\n        56: 1.4\n        49: 1.5\n        42: 1.5\n        35: 1.6\n        31: 1.7\n        28: 1.8\n        24: 1.9\n        21: 2.3\n        17: 2.7\n        14: 3.2\n        10: 3.3\n        7: 3.4\n        5: 3.4\n        3: 3.5\n        1: 3.5\n    ```\n    \"\"\"\n\n    @field_validator(\"curve\")\n    def _frat5_curves_accumulate(cls, v: dict[int, float], info: ValidationInfo):\n        \"\"\"Check that all curve values do not decrease as DCP keys decrease.\"\"\"\n        sorted_dcps = reversed(sorted(v.keys()))\n        i = 0\n        for dcp in sorted_dcps:\n            assert (\n                v[dcp] &gt;= i\n            ), f\"frat5 curve {info.data['name']} moves backwards at dcp {dcp}\"\n            i = v[dcp]\n        return v\n</code></pre>"}, {"location": "API/config/frat5_curves.html#passengersim.config.frat5_curves.Frat5Curve.curve", "title": "curve  <code>instance-attribute</code>", "text": "<pre><code>curve: dict[int, float]\n</code></pre> <p>Define a Frat5 curve.</p> <p>The values (cumulative fraction of customers arriving) should increase monotonically as the keys (DCPs, e.g. days to departure) decrease.</p>"}, {"location": "API/config/frat5_curves.html#passengersim.config.frat5_curves.Frat5Curve.curve--example", "title": "Example", "text": "<pre><code>- name: curve_C\n  curve:\n    63: 1.4\n    56: 1.4\n    49: 1.5\n    42: 1.5\n    35: 1.6\n    31: 1.7\n    28: 1.8\n    24: 1.9\n    21: 2.3\n    17: 2.7\n    14: 3.2\n    10: 3.3\n    7: 3.4\n    5: 3.4\n    3: 3.5\n    1: 3.5\n</code></pre>"}, {"location": "API/config/legs.html", "title": "Legs", "text": ""}, {"location": "API/config/legs.html#passengersim.config.legs.Leg", "title": "Leg", "text": "<p>             Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/legs.py</code> <pre><code>class Leg(BaseModel, extra=\"forbid\"):\n    carrier: str\n    fltno: int\n    \"\"\"A unique identifier for this leg.\n\n    Each leg in a network should have a globally unique identifier (i.e. even\n    if the carrier is different, `fltno` values should be unique.\n    \"\"\"\n\n    orig: str\n    \"\"\"Origination location for this leg.\"\"\"\n\n    dest: str\n    \"\"\"Destination location for this leg.\"\"\"\n\n    date: datetime = datetime.fromisoformat(\"2020-03-01\")\n    \"\"\"Date for this leg.\"\"\"\n\n    dep_time: int\n    \"\"\"Departure time for this leg in Unix time.\n\n    In input files, this can be specified as a string in the format \"HH:MM\",\n    with the hour in 24-hour format.\n\n    Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.\"\"\"\n\n    arr_time: int\n    \"\"\"Arrival time for this leg in Unix time.\n\n    In input files, this can be specified as a string in the format \"HH:MM\",\n    with the hour in 24-hour format.\n\n    Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.\"\"\"\n\n    capacity: int\n    distance: float | None = None\n\n    @field_validator(\"date\", mode=\"before\")\n    def _date_from_string(cls, v):\n        if isinstance(v, str):\n            v = datetime.fromisoformat(v)\n        return v\n\n    @field_validator(\"dep_time\", \"arr_time\", mode=\"before\")\n    def _timestring_to_int(cls, v, info: ValidationInfo):\n        if isinstance(v, str) and \":\" in v:\n            dep_time_str = v.split(\":\")\n            hh, mm = int(dep_time_str[0]), int(dep_time_str[1])\n            v = create_timestamp(info.data[\"date\"], 0, hh, mm)\n        if info.field_name == \"arr_time\":\n            if v &lt; info.data[\"dep_time\"]:\n                v += 86400  # add a day (in seconds) as arr time is next day\n        return v\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.arr_time", "title": "arr_time  <code>instance-attribute</code>", "text": "<pre><code>arr_time: int\n</code></pre> <p>Arrival time for this leg in Unix time.</p> <p>In input files, this can be specified as a string in the format \"HH:MM\", with the hour in 24-hour format.</p> <p>Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.capacity", "title": "capacity  <code>instance-attribute</code>", "text": "<pre><code>capacity: int\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: str\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.date", "title": "date  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>date: datetime = datetime.fromisoformat('2020-03-01')\n</code></pre> <p>Date for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.dep_time", "title": "dep_time  <code>instance-attribute</code>", "text": "<pre><code>dep_time: int\n</code></pre> <p>Departure time for this leg in Unix time.</p> <p>In input files, this can be specified as a string in the format \"HH:MM\", with the hour in 24-hour format.</p> <p>Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre> <p>Destination location for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.distance", "title": "distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>distance: float | None = None\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.fltno", "title": "fltno  <code>instance-attribute</code>", "text": "<pre><code>fltno: int\n</code></pre> <p>A unique identifier for this leg.</p> <p>Each leg in a network should have a globally unique identifier (i.e. even if the carrier is different, <code>fltno</code> values should be unique.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre> <p>Origination location for this leg.</p>"}, {"location": "API/config/load_factor_curves.html", "title": "Load Factor Curves", "text": ""}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve", "title": "LoadFactorCurve", "text": "<p>             Bases: <code>Named</code></p> <p>LF Curve specifies the load factor at which to close a booking class. This is designed to simulate a naive LCC that really doesn't have automated RM</p> Source code in <code>passengersim/config/load_factor_curves.py</code> <pre><code>class LoadFactorCurve(Named, extra=\"forbid\"):\n    \"\"\"\n    LF Curve specifies the load factor at which to close a booking class.\n    This is designed to simulate a naive LCC that really doesn't have automated RM\n    \"\"\"\n\n    algorithm: str\n    min_accordion: float\n    max_accordion: float\n    target_load_factor: float\n    convergence_constant: float\n    curve: dict[str, float]\n    \"\"\"Define a Load Factor curve.\n\n    Example\n    -------\n    ```{yaml}\n    - name: lf_curve_1\n      curve:\n        Y0: 1.0\n        Y1: 0.85\n        Y2: 0.75\n    ```\n    \"\"\"\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: str\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.convergence_constant", "title": "convergence_constant  <code>instance-attribute</code>", "text": "<pre><code>convergence_constant: float\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.curve", "title": "curve  <code>instance-attribute</code>", "text": "<pre><code>curve: dict[str, float]\n</code></pre> <p>Define a Load Factor curve.</p>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.curve--example", "title": "Example", "text": "<pre><code>- name: lf_curve_1\n  curve:\n    Y0: 1.0\n    Y1: 0.85\n    Y2: 0.75\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.max_accordion", "title": "max_accordion  <code>instance-attribute</code>", "text": "<pre><code>max_accordion: float\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.min_accordion", "title": "min_accordion  <code>instance-attribute</code>", "text": "<pre><code>min_accordion: float\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.target_load_factor", "title": "target_load_factor  <code>instance-attribute</code>", "text": "<pre><code>target_load_factor: float\n</code></pre>"}, {"location": "API/config/named.html", "title": "Named", "text": "<p>This module contains utilities for managing named objects.</p>"}, {"location": "API/config/named.html#passengersim.config.named.DictOfNamed", "title": "DictOfNamed  <code>module-attribute</code>", "text": "<pre><code>DictOfNamed = Annotated[\n    dict[str, T], BeforeValidator(enforce_name)\n]\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.Named", "title": "Named", "text": "<p>             Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/named.py</code> <pre><code>class Named(PrettyModel):\n    name: str\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.Named.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.enforce_name", "title": "enforce_name", "text": "<pre><code>enforce_name(x: dict[str, T] | list[T]) -&gt; dict[str, T]\n</code></pre> <p>Enforce that each item has a unique name.</p> <p>If you provide a list, this will ensure that each item in the list has a name. If you provide a dict, the names are given by the keys of the dictionary, and this will ensure that for each value, if it also has an explicitly defined name, that name matches its key-derived name.</p> Source code in <code>passengersim/config/named.py</code> <pre><code>def enforce_name(x: dict[str, T] | list[T]) -&gt; dict[str, T]:\n    \"\"\"Enforce that each item has a unique name.\n\n    If you provide a list, this will ensure that each item in the list has a name.\n    If you provide a dict, the names are given by the keys of the dictionary, and\n    this will ensure that for each value, if it also has an explicitly defined name,\n    that name matches its key-derived name.\n    \"\"\"\n    if isinstance(x, list):\n        x_ = {}\n        for n, i in enumerate(x):\n            k = i.get(\"name\")\n            if k is None:\n                raise ValueError(f\"missing name in position {n}\")\n            x_[k] = i\n        x = x_\n    for k, v in x.items():\n        if \"name\" not in v or not v[\"name\"]:\n            v[\"name\"] = k\n        if v[\"name\"] != k:\n            raise ValueError(\"explict name does not match key\")\n    return x\n</code></pre>"}, {"location": "API/config/outputs.html", "title": "Outputs", "text": ""}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig", "title": "OutputConfig", "text": "<p>             Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/outputs.py</code> <pre><code>class OutputConfig(PrettyModel, extra=\"forbid\", validate_assignment=True):\n    log_reports: bool = False\n    \"\"\"Write basic reports directly to the run log.\"\"\"\n\n    excel: pathlib.Path | None = None\n    \"\"\"Write excel outputs to this file after a run.\"\"\"\n\n    reports: set[str | tuple[str, ...]] = {\n        \"fare_class_mix\",\n        \"load_factors\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n    }\n    \"\"\"Reports to include.\"\"\"\n</code></pre>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.excel", "title": "excel  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>excel: pathlib.Path | None = None\n</code></pre> <p>Write excel outputs to this file after a run.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.log_reports", "title": "log_reports  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>log_reports: bool = False\n</code></pre> <p>Write basic reports directly to the run log.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.reports", "title": "reports  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>reports: set[str | tuple[str, ...]] = {\n    \"fare_class_mix\",\n    \"load_factors\",\n    \"bookings_by_timeframe\",\n    \"total_demand\",\n}\n</code></pre> <p>Reports to include.</p>"}, {"location": "API/config/paths.html", "title": "Paths", "text": ""}, {"location": "API/config/paths.html#passengersim.config.paths.Path", "title": "Path", "text": "<p>             Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/paths.py</code> <pre><code>class Path(BaseModel, extra=\"forbid\"):\n    path_id: int | None = None\n    orig: str\n    dest: str\n    path_quality_index: float\n\n    legs: list[int]\n    \"\"\"Flight numbers of legs comprising the path.\"\"\"\n\n    @field_validator(\"legs\", mode=\"before\")\n    def allow_single_leg(cls, v):\n        \"\"\"Allow a single leg path to be just an int not a list of one int.\"\"\"\n        if isinstance(v, int):\n            v = [v]\n        return v\n\n    @field_validator(\"legs\")\n    def at_least_one_leg(cls, v):\n        \"\"\"There must be at least one leg.\"\"\"\n        if len(v) &lt; 1:\n            raise ValueError(\"path must have at least one leg\")\n        return v\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.legs", "title": "legs  <code>instance-attribute</code>", "text": "<pre><code>legs: list[int]\n</code></pre> <p>Flight numbers of legs comprising the path.</p>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.path_id", "title": "path_id  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>path_id: int | None = None\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.path_quality_index", "title": "path_quality_index  <code>instance-attribute</code>", "text": "<pre><code>path_quality_index: float\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.allow_single_leg", "title": "allow_single_leg", "text": "<pre><code>allow_single_leg(v)\n</code></pre> <p>Allow a single leg path to be just an int not a list of one int.</p> Source code in <code>passengersim/config/paths.py</code> <pre><code>@field_validator(\"legs\", mode=\"before\")\ndef allow_single_leg(cls, v):\n    \"\"\"Allow a single leg path to be just an int not a list of one int.\"\"\"\n    if isinstance(v, int):\n        v = [v]\n    return v\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.at_least_one_leg", "title": "at_least_one_leg", "text": "<pre><code>at_least_one_leg(v)\n</code></pre> <p>There must be at least one leg.</p> Source code in <code>passengersim/config/paths.py</code> <pre><code>@field_validator(\"legs\")\ndef at_least_one_leg(cls, v):\n    \"\"\"There must be at least one leg.\"\"\"\n    if len(v) &lt; 1:\n        raise ValueError(\"path must have at least one leg\")\n    return v\n</code></pre>"}, {"location": "API/config/places.html", "title": "Places", "text": ""}, {"location": "API/config/places.html#passengersim.config.places.Place", "title": "Place", "text": "<p>             Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/places.py</code> <pre><code>class Place(BaseModel, extra=\"forbid\", validate_assignment=True):\n    name: str\n    \"\"\"Identifying code for this place.\n\n    For airports, typically the three letter code.\"\"\"\n\n    label: str\n    \"\"\"A descriptive label for this place.\"\"\"\n\n    lat: float | None = None\n    \"\"\"Latitude in degrees.\"\"\"\n\n    lon: float | None = None\n    \"\"\"Longitude in degrees.\"\"\"\n\n    time_zone: str | None = None\n    \"\"\"\n    The time zone for this location.\n    \"\"\"\n\n    @field_validator(\"time_zone\")\n    def _valid_time_zone(cls, v: str):\n        \"\"\"Check for valid time zones.\"\"\"\n        if isinstance(v, str):\n            ZoneInfo(v)\n        return v\n\n    @property\n    def time_zone_info(self):\n        return ZoneInfo(self.time_zone)\n</code></pre>"}, {"location": "API/config/places.html#passengersim.config.places.Place.label", "title": "label  <code>instance-attribute</code>", "text": "<pre><code>label: str\n</code></pre> <p>A descriptive label for this place.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.lat", "title": "lat  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>lat: float | None = None\n</code></pre> <p>Latitude in degrees.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.lon", "title": "lon  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>lon: float | None = None\n</code></pre> <p>Longitude in degrees.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre> <p>Identifying code for this place.</p> <p>For airports, typically the three letter code.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.time_zone", "title": "time_zone  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>time_zone: str | None = None\n</code></pre> <p>The time zone for this location.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.time_zone_info", "title": "time_zone_info  <code>property</code>", "text": "<pre><code>time_zone_info\n</code></pre>"}, {"location": "API/config/places.html#passengersim.config.places.great_circle", "title": "great_circle", "text": "<pre><code>great_circle(place1: Place, place2: Place)\n</code></pre> <p>Using Haversine formula, to get distance between points in miles.</p> Source code in <code>passengersim/config/places.py</code> <pre><code>def great_circle(place1: Place, place2: Place):\n    \"\"\"Using Haversine formula, to get distance between points in miles.\"\"\"\n    lon1 = math.radians(place1.lon)\n    lat1 = math.radians(place1.lat)\n    lon2 = math.radians(place2.lon)\n    lat2 = math.radians(place2.lat)\n    lon_diff = lon2 - lon1\n    lat_diff = lat2 - lat1\n    a = math.sin((lat_diff) / 2.0) ** 2.0 + (\n        math.cos(lat1) * math.cos(lat2) * (math.sin((lon_diff) / 2.0) ** 2.0)\n    )\n    angle2 = 2.0 * math.asin(min(1.0, math.sqrt(a)))\n    # Convert back to degrees.\n    angle2 = math.degrees(angle2)\n    # Each degree on a great circle of Earth is 69.0468 miles. ( 60 nautical miles )\n    distance2 = 69.0468 * angle2\n    return distance2\n</code></pre>"}, {"location": "API/config/pretty.html", "title": "Pretty", "text": ""}, {"location": "API/config/pretty.html#passengersim.config.pretty.PrettyModel", "title": "PrettyModel", "text": "<p>             Bases: <code>BaseModel</code></p> <p>Pretty-print as YAML style outputs.</p> Source code in <code>passengersim/config/pretty.py</code> <pre><code>class PrettyModel(BaseModel):\n    \"\"\"Pretty-print as YAML style outputs.\"\"\"\n\n    def __repr_with_indent__(self, indent=0):\n        x = []\n        i = \" \" * indent\n        for k, v in self:\n            try:\n                val = v.__repr_with_indent__(0)\n            except AttributeError:\n                if isinstance(v, dict):\n                    val = repr_dict_with_indent(v, indent)\n                else:\n                    val = repr(v)\n                    if isinstance(v, list) and len(val) &gt; 70:\n                        val = \"- \" + \"\\n- \".join(repr(j) for j in v)\n            if \"\\n\" in val:\n                val_lines = val.split(\"\\n\")\n                val = \"\\n  \" + \"\\n  \".join(val_lines)\n            x.append(f\"{i}{k}: {val}\")\n        return \"\\n\".join(x)\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}:\\n\" + self.__repr_with_indent__(2)\n</code></pre>"}, {"location": "API/config/pretty.html#passengersim.config.pretty.PrettyModel.__repr__", "title": "__repr__", "text": "<pre><code>__repr__()\n</code></pre> Source code in <code>passengersim/config/pretty.py</code> <pre><code>def __repr__(self):\n    return f\"{self.__class__.__name__}:\\n\" + self.__repr_with_indent__(2)\n</code></pre>"}, {"location": "API/config/pretty.html#passengersim.config.pretty.PrettyModel.__repr_with_indent__", "title": "__repr_with_indent__", "text": "<pre><code>__repr_with_indent__(indent=0)\n</code></pre> Source code in <code>passengersim/config/pretty.py</code> <pre><code>def __repr_with_indent__(self, indent=0):\n    x = []\n    i = \" \" * indent\n    for k, v in self:\n        try:\n            val = v.__repr_with_indent__(0)\n        except AttributeError:\n            if isinstance(v, dict):\n                val = repr_dict_with_indent(v, indent)\n            else:\n                val = repr(v)\n                if isinstance(v, list) and len(val) &gt; 70:\n                    val = \"- \" + \"\\n- \".join(repr(j) for j in v)\n        if \"\\n\" in val:\n            val_lines = val.split(\"\\n\")\n            val = \"\\n  \" + \"\\n  \".join(val_lines)\n        x.append(f\"{i}{k}: {val}\")\n    return \"\\n\".join(x)\n</code></pre>"}, {"location": "API/config/pretty.html#passengersim.config.pretty.repr_dict_with_indent", "title": "repr_dict_with_indent", "text": "<pre><code>repr_dict_with_indent(d: dict[str, Any], indent=0)\n</code></pre> Source code in <code>passengersim/config/pretty.py</code> <pre><code>def repr_dict_with_indent(d: dict[str, Any], indent=0):\n    x = []\n    i = \" \" * indent\n    for k, v in d.items():\n        try:\n            val = v.__repr_with_indent__(indent)\n        except AttributeError:\n            if isinstance(v, dict):\n                val = repr_dict_with_indent(v, indent)\n            else:\n                val = repr(v)\n                if isinstance(v, list) and len(val) &gt; 70:\n                    val = \"- \" + \"\\n- \".join(repr(j) for j in v)\n        if \"\\n\" in val:\n            val_lines = val.split(\"\\n\")\n            val = \"\\n  \" + \"\\n  \".join(val_lines)\n        x.append(f\"{i}{k}: {val}\")\n    return \"\\n\".join(x)\n</code></pre>"}, {"location": "API/config/rm_steps.html", "title": "RM Steps", "text": ""}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.DummyStep", "title": "DummyStep", "text": "<p>             Bases: <code>RmStepBase</code></p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>class DummyStep(RmStepBase):\n    step_type: Literal[\"dummy\"]\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.DummyStep.step_type", "title": "step_type  <code>instance-attribute</code>", "text": "<pre><code>step_type: Literal['dummy']\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase", "title": "RmStepBase", "text": "<p>             Bases: <code>BaseModel</code></p> <p>Base class for RmSteps.</p> <p>Every non-abstract derived class must have a <code>step_type</code> class attribute, annotated with a <code>Literal</code> value type.</p> <p>See <code>DummyStep</code> below for an example.</p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>class RmStepBase(BaseModel, extra=\"forbid\"):\n    \"\"\"\n    Base class for RmSteps.\n\n    Every non-abstract derived class must have a `step_type` class attribute,\n    annotated with a `Literal` value type.\n\n    See `DummyStep` below for an example.\n    \"\"\"\n\n    __subclasses: ClassVar[set[type[RmStepBase]]] = set()\n\n    def __init_subclass__(cls, **kwargs):\n        \"\"\"Capture a list of all concrete subclasses, including nested levels\"\"\"\n        super().__init_subclass__(**kwargs)\n\n        if inspect.isabstract(cls):\n            return  # do not consider intermediate abstract base classes\n\n        annotations = inspect.get_annotations(cls, eval_str=True)\n        assert \"step_type\" in annotations, \"step_type not in annotations\"\n        annotation_step_type = typing.get_origin(annotations[\"step_type\"])\n        assert annotation_step_type == Literal, (\n            f\"annotation {annotations['step_type']} for `{cls.__name__}.step_type` \"\n            f\"is not Literal but {annotation_step_type}\"\n        )\n        found_step_type = typing.get_args(annotations[\"step_type\"])[0]\n        if cls.__name__.lower().endswith(\"step\"):\n            assert found_step_type == cls.__name__.lower()[:-4], (\n                f\"annotation Literal value {found_step_type!r} \"\n                f\"for `{cls.__name__}.step_type` is not the same as the class name \"\n                f\"(omitting 'step' suffix)\"\n            )\n        else:\n            assert found_step_type == cls.__name__.lower(), (\n                f\"annotation Literal value {found_step_type!r} \"\n                f\"for `{cls.__name__}.step_type` is not the same as the class name\"\n            )\n        cls.__subclasses.add(cls)\n\n    @classmethod\n    def as_pydantic_field(cls):\n        \"\"\"Pydantic field type as a union of all subclasses, discriminated on step_type.\"\"\"\n        if len(cls.__subclasses) &gt; 1:\n            return Annotated[\n                reduce(operator.__or__, cls.__subclasses),\n                Field(discriminator=\"step_type\"),\n            ]\n        else:  # only the DummyStep\n            return Annotated[reduce(operator.__or__, cls.__subclasses), Field()]\n\n    def _factory(self):\n        \"\"\"Generate a deep copy of this RmStep.\"\"\"\n        return self.model_copy(deep=True)\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase.__subclasses", "title": "__subclasses  <code>class-attribute</code>", "text": "<pre><code>__subclasses: set[type[RmStepBase]] = set()\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase.__init_subclass__", "title": "__init_subclass__", "text": "<pre><code>__init_subclass__(**kwargs)\n</code></pre> <p>Capture a list of all concrete subclasses, including nested levels</p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>def __init_subclass__(cls, **kwargs):\n    \"\"\"Capture a list of all concrete subclasses, including nested levels\"\"\"\n    super().__init_subclass__(**kwargs)\n\n    if inspect.isabstract(cls):\n        return  # do not consider intermediate abstract base classes\n\n    annotations = inspect.get_annotations(cls, eval_str=True)\n    assert \"step_type\" in annotations, \"step_type not in annotations\"\n    annotation_step_type = typing.get_origin(annotations[\"step_type\"])\n    assert annotation_step_type == Literal, (\n        f\"annotation {annotations['step_type']} for `{cls.__name__}.step_type` \"\n        f\"is not Literal but {annotation_step_type}\"\n    )\n    found_step_type = typing.get_args(annotations[\"step_type\"])[0]\n    if cls.__name__.lower().endswith(\"step\"):\n        assert found_step_type == cls.__name__.lower()[:-4], (\n            f\"annotation Literal value {found_step_type!r} \"\n            f\"for `{cls.__name__}.step_type` is not the same as the class name \"\n            f\"(omitting 'step' suffix)\"\n        )\n    else:\n        assert found_step_type == cls.__name__.lower(), (\n            f\"annotation Literal value {found_step_type!r} \"\n            f\"for `{cls.__name__}.step_type` is not the same as the class name\"\n        )\n    cls.__subclasses.add(cls)\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase.as_pydantic_field", "title": "as_pydantic_field  <code>classmethod</code>", "text": "<pre><code>as_pydantic_field()\n</code></pre> <p>Pydantic field type as a union of all subclasses, discriminated on step_type.</p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>@classmethod\ndef as_pydantic_field(cls):\n    \"\"\"Pydantic field type as a union of all subclasses, discriminated on step_type.\"\"\"\n    if len(cls.__subclasses) &gt; 1:\n        return Annotated[\n            reduce(operator.__or__, cls.__subclasses),\n            Field(discriminator=\"step_type\"),\n        ]\n    else:  # only the DummyStep\n        return Annotated[reduce(operator.__or__, cls.__subclasses), Field()]\n</code></pre>"}, {"location": "API/config/rm_systems.html", "title": "RM Systems", "text": ""}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmProcess", "title": "RmProcess  <code>module-attribute</code>", "text": "<pre><code>RmProcess = list[RmStep]\n</code></pre>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmStep", "title": "RmStep  <code>module-attribute</code>", "text": "<pre><code>RmStep = RmStepBase.as_pydantic_field()\n</code></pre>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem", "title": "RmSystem", "text": "<p>             Bases: <code>Named</code></p> Source code in <code>passengersim/config/rm_systems.py</code> <pre><code>class RmSystem(Named, extra=\"forbid\"):\n    processes: dict[str, RmProcess]\n\n    availability_control: Literal[\n        \"infer\", \"leg\", \"theft\", \"bp\", \"bp_loose\", \"vn\", \"none\"\n    ] = \"infer\"\n    \"\"\"Fare class availability algorithm for carriers using this RmSystem.\n\n    The default value will infer the appropriate control based on the steps in the DCP process\n    (This is pending implementation).\n\n    Allowed values include:\n    - \"leg\" (default): Uses leg-based controls.\n    - \"bp\": Bid price controls with strict resolution (fare must be strictly greater than bid price).\n    - \"bp_loose\": Bid price controls with non-strict resolution (fare must be greater than *or equal to* bid price).\n    - \"vn\": Virtual nesting.\n    - \"none\": No controls.\n    \"\"\"\n\n    @field_validator(\"processes\")\n    @classmethod\n    def _require_dcp_process(cls, value: dict[str, RmProcess]):\n        \"\"\"Ensure that every RmSystem is either empty or has a DCP process.\n\n        This validator also converts all keys to lowercase.\n        \"\"\"\n        lower_value = {k.lower(): v for (k, v) in value.items()}\n        if len(lower_value) and \"dcp\" not in lower_value:\n            raise ValueError(\"Non-empty RmSystem missing a `dcp` process.\")\n        return lower_value\n</code></pre>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem.availability_control", "title": "availability_control  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>availability_control: Literal[\n    \"infer\", \"leg\", \"theft\", \"bp\", \"bp_loose\", \"vn\", \"none\"\n] = \"infer\"\n</code></pre> <p>Fare class availability algorithm for carriers using this RmSystem.</p> <p>The default value will infer the appropriate control based on the steps in the DCP process (This is pending implementation).</p> <p>Allowed values include: - \"leg\" (default): Uses leg-based controls. - \"bp\": Bid price controls with strict resolution (fare must be strictly greater than bid price). - \"bp_loose\": Bid price controls with non-strict resolution (fare must be greater than or equal to bid price). - \"vn\": Virtual nesting. - \"none\": No controls.</p>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem.processes", "title": "processes  <code>instance-attribute</code>", "text": "<pre><code>processes: dict[str, RmProcess]\n</code></pre>"}, {"location": "API/config/snapshot_filter.html", "title": "Snapshot filter", "text": ""}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter", "title": "SnapshotFilter", "text": "<p>             Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>class SnapshotFilter(BaseModel, validate_assignment=True):\n    type: Literal[\n        \"forecast\",\n        \"leg_untruncation\",\n        \"path_untruncation\",\n        \"rm\",\n        \"pro_bp\",\n        \"forecast_adj\",\n        None,\n    ] = None\n    title: str = \"\"\n    airline: str = \"\"\n    trial: list[int] = []\n    sample: list[int] = []\n    dcp: list[int] = []\n    orig: list[str] = []\n    dest: list[str] = []\n    flt_no: list[int] = []\n    logger: str | None = None\n    directory: pathlib.Path | None = None\n\n    @field_validator(\"trial\", \"sample\", \"dcp\", \"orig\", \"dest\", \"flt_no\", mode=\"before\")\n    def _allow_singletons(cls, v):\n        \"\"\"Allow a singleton value that is converted to a list of one item.\"\"\"\n        if not isinstance(v, list | tuple):\n            v = [v]\n        return v\n\n    def filepath(self, sim, leg=None, path=None) -&gt; pathlib.Path | None:\n        if self.directory is None:\n            return None\n        pth = self.directory\n        if leg is not None:\n            pth = pth.joinpath(f\"carrier-{leg.carrier}\")\n        pth = pth.joinpath(f\"dpc-{sim.last_dcp}\")\n        if leg is not None:\n            pth = pth.joinpath(f\"orig-{leg.orig}\")\n        elif path is not None:\n            pth = pth.joinpath(f\"orig-{path.orig}\")\n        if leg is not None:\n            pth = pth.joinpath(f\"dest-{leg.dest}\")\n        elif path is not None:\n            pth = pth.joinpath(f\"dest-{path.dest}\")\n        if leg is not None:\n            pth = pth.joinpath(f\"fltno-{leg.flt_no}\")\n        elif path is not None:\n            pth = pth.joinpath(f\"fltno-{path.get_leg_fltno(0)}\")\n        if sim.num_trials &gt; 1:\n            pth = pth.joinpath(f\"trial-{sim.trial}\")\n        pth = pth.joinpath(f\"sample-{sim.sample}\")\n        pth.parent.mkdir(parents=True, exist_ok=True)\n        return pth.with_suffix(\".log\")\n\n    def run(\n        self, sim, leg=None, path=None, carrier=None, why=False\n    ) -&gt; SnapshotInstruction:\n        # Check the filter conditions\n        info = \"\"\n\n        if len(self.trial) &gt; 0 and sim.trial not in self.trial and sim.num_trials &gt; 1:\n            return SnapshotInstruction(False, why=f\"cause {sim.trial=}\")\n        info += f\"  trial={sim.trial}\"\n\n        if len(self.sample) &gt; 0 and sim.sample not in self.sample:\n            return SnapshotInstruction(False, why=f\"cause {sim.sample=}\")\n        info += f\"  sample={sim.sample}\"\n\n        if len(self.dcp) &gt; 0 and sim.last_dcp not in self.dcp:\n            return SnapshotInstruction(False, why=f\"cause {sim.last_dcp=}\")\n        info += f\"  dcp={sim.last_dcp}\"\n\n        if leg is not None:\n            if self.airline and leg.carrier != self.airline:\n                return SnapshotInstruction(False, why=f\"cause {leg.carrier=}\")\n            info += f\"  carrier={leg.carrier}\"\n\n            if len(self.orig) &gt; 0 and leg.orig not in self.orig:\n                return SnapshotInstruction(False, why=f\"cause {leg.orig=}\")\n            info += f\"  orig={leg.orig}\"\n\n            if len(self.dest) &gt; 0 and leg.dest not in self.dest:\n                return SnapshotInstruction(False, why=f\"cause {leg.dest=}\")\n            info += f\"  dest={leg.dest}\"\n\n            if len(self.flt_no) &gt; 0 and leg.flt_no not in self.flt_no:\n                return SnapshotInstruction(False, why=f\"cause {leg.flt_no=}\")\n            info += f\"  flt_no={leg.flt_no}\"\n\n        if path is not None:\n            if len(self.orig) &gt; 0 and path.orig not in self.orig:\n                return SnapshotInstruction(False, why=f\"cause {path.orig=}\")\n            info += f\"  orig={path.orig}\"\n\n            if len(self.dest) &gt; 0 and path.dest not in self.dest:\n                return SnapshotInstruction(False, why=f\"cause {path.dest=}\")\n            info += f\"  dest={path.dest}\"\n\n            if len(self.flt_no) &gt; 0 and path.get_leg_fltno(0) not in self.flt_no:\n                return SnapshotInstruction(False, why=f\"cause {path.get_leg_fltno(0)=}\")\n            info += f\"  flt_no={path.get_leg_fltno(0)}\"\n\n        if carrier is not None:\n            if self.airline and carrier != self.airline:\n                return SnapshotInstruction(False, why=f\"cause {carrier=}\")\n            info += f\"  carrier={carrier}\"\n\n        # Now do something\n        snapshot_file = self.filepath(sim, leg, path)\n        title = f\"{self.title}:{info}\\n{time.strftime('Snapshot created %Y-%m-%d %A %I:%M:%S %p')}\\n\"\n        if len(self.title) &gt; 0 and not snapshot_file:\n            print(f\"{self.title}:{info}\", flush=True)\n\n        self._last_run_info = info\n\n        if self.type in [\"leg_untruncation\", \"path_untruncation\"]:\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type in (\"forecast\", \"forecast_adj\"):\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type == \"rm\":\n            bucket_detail = leg.print_bucket_detail()\n            snapshot_file = self.filepath(sim, leg, path)\n            if snapshot_file:\n                with snapshot_file.open(mode=\"a\") as f:\n                    f.write(title)\n                    f.write(bucket_detail)\n            else:\n                print(bucket_detail)\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type == \"pro_bp\":\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n\n        raise ValueError(\"unknown snapshot filter type\")\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.airline", "title": "airline  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>airline: str = ''\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.dcp", "title": "dcp  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcp: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.dest", "title": "dest  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dest: list[str] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.directory", "title": "directory  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>directory: pathlib.Path | None = None\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.flt_no", "title": "flt_no  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>flt_no: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.orig", "title": "orig  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>orig: list[str] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.sample", "title": "sample  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>sample: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.title", "title": "title  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>title: str = ''\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.trial", "title": "trial  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>trial: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.type", "title": "type  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>type: Literal[\n    \"forecast\",\n    \"leg_untruncation\",\n    \"path_untruncation\",\n    \"rm\",\n    \"pro_bp\",\n    \"forecast_adj\",\n    None,\n] = None\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.filepath", "title": "filepath", "text": "<pre><code>filepath(sim, leg=None, path=None) -&gt; pathlib.Path | None\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def filepath(self, sim, leg=None, path=None) -&gt; pathlib.Path | None:\n    if self.directory is None:\n        return None\n    pth = self.directory\n    if leg is not None:\n        pth = pth.joinpath(f\"carrier-{leg.carrier}\")\n    pth = pth.joinpath(f\"dpc-{sim.last_dcp}\")\n    if leg is not None:\n        pth = pth.joinpath(f\"orig-{leg.orig}\")\n    elif path is not None:\n        pth = pth.joinpath(f\"orig-{path.orig}\")\n    if leg is not None:\n        pth = pth.joinpath(f\"dest-{leg.dest}\")\n    elif path is not None:\n        pth = pth.joinpath(f\"dest-{path.dest}\")\n    if leg is not None:\n        pth = pth.joinpath(f\"fltno-{leg.flt_no}\")\n    elif path is not None:\n        pth = pth.joinpath(f\"fltno-{path.get_leg_fltno(0)}\")\n    if sim.num_trials &gt; 1:\n        pth = pth.joinpath(f\"trial-{sim.trial}\")\n    pth = pth.joinpath(f\"sample-{sim.sample}\")\n    pth.parent.mkdir(parents=True, exist_ok=True)\n    return pth.with_suffix(\".log\")\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.run", "title": "run", "text": "<pre><code>run(\n    sim, leg=None, path=None, carrier=None, why=False\n) -&gt; SnapshotInstruction\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def run(\n    self, sim, leg=None, path=None, carrier=None, why=False\n) -&gt; SnapshotInstruction:\n    # Check the filter conditions\n    info = \"\"\n\n    if len(self.trial) &gt; 0 and sim.trial not in self.trial and sim.num_trials &gt; 1:\n        return SnapshotInstruction(False, why=f\"cause {sim.trial=}\")\n    info += f\"  trial={sim.trial}\"\n\n    if len(self.sample) &gt; 0 and sim.sample not in self.sample:\n        return SnapshotInstruction(False, why=f\"cause {sim.sample=}\")\n    info += f\"  sample={sim.sample}\"\n\n    if len(self.dcp) &gt; 0 and sim.last_dcp not in self.dcp:\n        return SnapshotInstruction(False, why=f\"cause {sim.last_dcp=}\")\n    info += f\"  dcp={sim.last_dcp}\"\n\n    if leg is not None:\n        if self.airline and leg.carrier != self.airline:\n            return SnapshotInstruction(False, why=f\"cause {leg.carrier=}\")\n        info += f\"  carrier={leg.carrier}\"\n\n        if len(self.orig) &gt; 0 and leg.orig not in self.orig:\n            return SnapshotInstruction(False, why=f\"cause {leg.orig=}\")\n        info += f\"  orig={leg.orig}\"\n\n        if len(self.dest) &gt; 0 and leg.dest not in self.dest:\n            return SnapshotInstruction(False, why=f\"cause {leg.dest=}\")\n        info += f\"  dest={leg.dest}\"\n\n        if len(self.flt_no) &gt; 0 and leg.flt_no not in self.flt_no:\n            return SnapshotInstruction(False, why=f\"cause {leg.flt_no=}\")\n        info += f\"  flt_no={leg.flt_no}\"\n\n    if path is not None:\n        if len(self.orig) &gt; 0 and path.orig not in self.orig:\n            return SnapshotInstruction(False, why=f\"cause {path.orig=}\")\n        info += f\"  orig={path.orig}\"\n\n        if len(self.dest) &gt; 0 and path.dest not in self.dest:\n            return SnapshotInstruction(False, why=f\"cause {path.dest=}\")\n        info += f\"  dest={path.dest}\"\n\n        if len(self.flt_no) &gt; 0 and path.get_leg_fltno(0) not in self.flt_no:\n            return SnapshotInstruction(False, why=f\"cause {path.get_leg_fltno(0)=}\")\n        info += f\"  flt_no={path.get_leg_fltno(0)}\"\n\n    if carrier is not None:\n        if self.airline and carrier != self.airline:\n            return SnapshotInstruction(False, why=f\"cause {carrier=}\")\n        info += f\"  carrier={carrier}\"\n\n    # Now do something\n    snapshot_file = self.filepath(sim, leg, path)\n    title = f\"{self.title}:{info}\\n{time.strftime('Snapshot created %Y-%m-%d %A %I:%M:%S %p')}\\n\"\n    if len(self.title) &gt; 0 and not snapshot_file:\n        print(f\"{self.title}:{info}\", flush=True)\n\n    self._last_run_info = info\n\n    if self.type in [\"leg_untruncation\", \"path_untruncation\"]:\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type in (\"forecast\", \"forecast_adj\"):\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type == \"rm\":\n        bucket_detail = leg.print_bucket_detail()\n        snapshot_file = self.filepath(sim, leg, path)\n        if snapshot_file:\n            with snapshot_file.open(mode=\"a\") as f:\n                f.write(title)\n                f.write(bucket_detail)\n        else:\n            print(bucket_detail)\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type == \"pro_bp\":\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n\n    raise ValueError(\"unknown snapshot filter type\")\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction", "title": "SnapshotInstruction", "text": "Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>class SnapshotInstruction:\n    def __init__(\n        self,\n        trigger: bool = False,\n        filepath: pathlib.Path | None = None,\n        why: str | None = None,\n        filter: SnapshotFilter | None = None,\n        mode: Literal[\"w\", \"a\"] = \"w\",\n    ):\n        self.trigger = bool(trigger)\n        \"\"\"Has this snapshot been triggered.\"\"\"\n        self.why = why\n        \"\"\"Explanation of why snapshot is (or is not) triggered.\"\"\"\n        self.filepath = filepath\n        \"\"\"Where to save snapshot content.\"\"\"\n        self.filter = filter\n        \"\"\"A reference to the filter that spawned this instruction.\"\"\"\n        self.mode = mode\n        \"\"\"Write mode for new content, `w` overwrites existing file, `a` appends.\"\"\"\n\n    def __bool__(self) -&gt; bool:\n        return self.trigger\n\n    def write(self, content: str = \"\"):\n        \"\"\"Write snapshot content to a file, or just print it\"\"\"\n        if not content:\n            return\n        if self.filepath:\n            with self.filepath.open(mode=self.mode) as f:\n                f.write(self.why)\n                f.write(\"\\n\")\n                if isinstance(content, bytes):\n                    content = content.decode(\"utf-8\")\n                elif not isinstance(content, str):\n                    content = str(content)\n                f.write(content)\n                if content[-1] != \"\\n\":\n                    f.write(\"\\n\")\n        else:\n            if self.why:\n                print(self.why)\n            print(content)\n\n    def write_more(self, content: str = \"\"):\n        \"\"\"Write additional snapshot content to a file, or just print it\"\"\"\n        if not content:\n            return\n        if self.filepath:\n            with self.filepath.open(mode=\"a\") as f:\n                if isinstance(content, bytes):\n                    content = content.decode(\"utf-8\")\n                elif not isinstance(content, str):\n                    content = str(content)\n                f.write(content)\n                if content[-1] != \"\\n\":\n                    f.write(\"\\n\")\n        else:\n            print(content)\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.filepath", "title": "filepath  <code>instance-attribute</code>", "text": "<pre><code>filepath = filepath\n</code></pre> <p>Where to save snapshot content.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.filter", "title": "filter  <code>instance-attribute</code>", "text": "<pre><code>filter = filter\n</code></pre> <p>A reference to the filter that spawned this instruction.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.mode", "title": "mode  <code>instance-attribute</code>", "text": "<pre><code>mode = mode\n</code></pre> <p>Write mode for new content, <code>w</code> overwrites existing file, <code>a</code> appends.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.trigger", "title": "trigger  <code>instance-attribute</code>", "text": "<pre><code>trigger = bool(trigger)\n</code></pre> <p>Has this snapshot been triggered.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.why", "title": "why  <code>instance-attribute</code>", "text": "<pre><code>why = why\n</code></pre> <p>Explanation of why snapshot is (or is not) triggered.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.__bool__", "title": "__bool__", "text": "<pre><code>__bool__() -&gt; bool\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    return self.trigger\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    trigger: bool = False,\n    filepath: pathlib.Path | None = None,\n    why: str | None = None,\n    filter: SnapshotFilter | None = None,\n    mode: Literal[\"w\", \"a\"] = \"w\",\n)\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def __init__(\n    self,\n    trigger: bool = False,\n    filepath: pathlib.Path | None = None,\n    why: str | None = None,\n    filter: SnapshotFilter | None = None,\n    mode: Literal[\"w\", \"a\"] = \"w\",\n):\n    self.trigger = bool(trigger)\n    \"\"\"Has this snapshot been triggered.\"\"\"\n    self.why = why\n    \"\"\"Explanation of why snapshot is (or is not) triggered.\"\"\"\n    self.filepath = filepath\n    \"\"\"Where to save snapshot content.\"\"\"\n    self.filter = filter\n    \"\"\"A reference to the filter that spawned this instruction.\"\"\"\n    self.mode = mode\n    \"\"\"Write mode for new content, `w` overwrites existing file, `a` appends.\"\"\"\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.write", "title": "write", "text": "<pre><code>write(content: str = '')\n</code></pre> <p>Write snapshot content to a file, or just print it</p> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def write(self, content: str = \"\"):\n    \"\"\"Write snapshot content to a file, or just print it\"\"\"\n    if not content:\n        return\n    if self.filepath:\n        with self.filepath.open(mode=self.mode) as f:\n            f.write(self.why)\n            f.write(\"\\n\")\n            if isinstance(content, bytes):\n                content = content.decode(\"utf-8\")\n            elif not isinstance(content, str):\n                content = str(content)\n            f.write(content)\n            if content[-1] != \"\\n\":\n                f.write(\"\\n\")\n    else:\n        if self.why:\n            print(self.why)\n        print(content)\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.write_more", "title": "write_more", "text": "<pre><code>write_more(content: str = '')\n</code></pre> <p>Write additional snapshot content to a file, or just print it</p> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def write_more(self, content: str = \"\"):\n    \"\"\"Write additional snapshot content to a file, or just print it\"\"\"\n    if not content:\n        return\n    if self.filepath:\n        with self.filepath.open(mode=\"a\") as f:\n            if isinstance(content, bytes):\n                content = content.decode(\"utf-8\")\n            elif not isinstance(content, str):\n                content = str(content)\n            f.write(content)\n            if content[-1] != \"\\n\":\n                f.write(\"\\n\")\n    else:\n        print(content)\n</code></pre>"}, {"location": "API/database/index.html", "title": "Database", "text": ""}, {"location": "API/database/index.html#passengersim.database.database.leg_bucket_sql", "title": "leg_bucket_sql  <code>module-attribute</code>", "text": "<pre><code>leg_bucket_sql = {}\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.n_commit", "title": "n_commit  <code>module-attribute</code>", "text": "<pre><code>n_commit = 0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database", "title": "Database", "text": "<p>A wrapper to manage transactions for PassengerSim on SQLite.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>class Database:\n    \"\"\"A wrapper to manage transactions for PassengerSim on SQLite.\"\"\"\n\n    def __init__(\n        self,\n        engine: Literal[\"sqlite\", None] = \"sqlite\",\n        filename=None,\n        pragmas: Iterable[str] = (),\n        commit_count_delay: int | None = 250,\n    ):\n        self._connection = None\n        self.engine = engine\n        self.filename = filename\n        self.pragmas = pragmas\n        self._counter = 0\n        self._commit_count_delay = commit_count_delay\n        if self._commit_count_delay is not None:\n            self.commit = self._commit_by_count\n        else:\n            self.commit = self._commit_raw\n        self.open()\n\n    def __getattr__(self, item):\n        return getattr(self._connection, item)\n\n    def open(self, filename: str | None = None):\n        \"\"\"Open the connection if it is not already open.\"\"\"\n        if self._connection is not None:\n            raise ConnectionError(\"the connection is already open\")\n        self.filename = filename or self.filename\n        if self.engine is None:\n            self._connection = None\n        elif self.engine == \"sqlite\" and self.filename is None:\n            self._connection = None\n        elif self.engine == \"sqlite\":\n            if self.filename != \":memory:\":\n                Path(self.filename).parent.mkdir(exist_ok=True, parents=True)\n            logger.info(f\"connecting to sqlite database: {self.filename}\")\n            self._connection = sqlite3.Connection(self.filename)\n            self._connection.create_aggregate(\"VARIANCE\", 1, _VarianceFunc)\n            self._connection.create_aggregate(\"STDEV\", 1, _StdevFunc)\n            for pragma in self.pragmas:\n                self._connection.execute(f\"PRAGMA {pragma};\")\n            self._connection.execute(\"BEGIN TRANSACTION;\")\n            logger.debug(\"initializing sqlite tables\")\n            from .tables import create_tables\n\n            create_tables(self)\n        else:\n            raise NotImplementedError(f\"unknown engine {self.engine!r}\")\n\n    def close(self):\n        \"\"\"Flush pending operations and close the connection.\"\"\"\n        if self._connection:\n            if self._connection.in_transaction:\n                self._connection.execute(\"COMMIT;\")\n            self._connection.close()\n            self._connection = None\n\n    def _commit_by_count(self):\n        self._counter += 1\n        if self._counter &gt;= self._commit_count_delay:\n            self._commit_raw()\n            self._counter = 0\n\n    def _commit_raw(self):\n        if self._connection:\n            if self._connection.in_transaction:\n                self._connection.execute(\"COMMIT;\")\n            self._connection.execute(\"BEGIN TRANSACTION;\")\n\n    def __enter__(self):\n        if self._connection:\n            return self._connection.__enter__()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self._connection:\n            return self._connection.__exit__(exc_type, exc_val, exc_tb)\n\n    @property\n    def is_open(self) -&gt; bool:\n        return self._connection is not None\n\n    def sql_placeholders(self, n: int):\n        \"\"\"A parenthesis enclosed set of `n` placeholders for the selected engine.\"\"\"\n        if self.engine == \"sqlite\":\n            x = \"?\"\n        else:\n            x = \"%s\"\n        return \"(\" + \", \".join(x for _ in range(n)) + \")\"\n\n    def delete_experiment(self, name: str):\n        if self.is_open:\n            logger.debug(f\"deleting existing scenario {name!r} from database\")\n            self.execute(\"DELETE FROM leg_detail WHERE scenario = ?\", (name,))\n            self.execute(\"DELETE FROM leg_bucket_detail WHERE scenario = ?\", (name,))\n            self.execute(\"DELETE FROM demand_detail WHERE scenario = ?\", (name,))\n            self.execute(\"DELETE FROM fare_detail WHERE scenario = ?\", (name,))\n            self._commit_raw()\n        else:\n            logger.debug(f\"database not open, cannot delete {name!r}\")\n\n    def save_configs(self, cfg: Config) -&gt; None:\n        \"\"\"Save configs into the database.\"\"\"\n        from passengersim import __version__\n\n        self.execute(\n            \"\"\"\n        INSERT OR REPLACE INTO runtime_configs(\n            scenario, pxsim_version, configs\n        ) VALUES (?1, ?2, ?3)\n        \"\"\",\n            (\n                cfg.scenario,\n                str(__version__),\n                cfg.model_dump_json(\n                    exclude={\"db\": \"dcp_write_hooks\", \"raw_license_certificate\": True}\n                ),\n            ),\n        )\n\n    def load_configs(self, scenario=None) -&gt; Config:\n        import json\n\n        if scenario:\n            rawjson = next(\n                self.execute(\n                    \"SELECT configs, max(updated_at) FROM runtime_configs WHERE scenario = ?1\",\n                    (scenario,),\n                )\n            )[0]\n        else:\n            rawjson = next(\n                self.execute(\"SELECT configs, max(updated_at) FROM runtime_configs\")\n            )[0]\n        return Config.model_validate(json.loads(rawjson))\n\n    def save_details(self: Database, sim: SimulationEngine, dcp: int):\n        \"\"\"\n        Save details, can be done at each RRD/DCP and at the end of the run\n        \"\"\"\n        if not sim.save_timeframe_details and dcp &gt; 0:\n            return\n        if sim.config.db.fast and isinstance(self._connection, sqlite3.Connection):\n            sim.write_to_sqlite(\n                self._connection,\n                dcp,\n                store_bid_prices=sim.config.db.store_leg_bid_prices,\n            )\n        else:\n            for leg in sim.legs:\n                if \"leg\" in sim.config.db.write_items:\n                    save_leg(self, sim, leg, dcp)\n                if \"bucket\" in sim.config.db.write_items:\n                    save_leg_bucket_multi(self, sim, leg, dcp)\n            if \"fare\" in sim.config.db.write_items:\n                save_fare_multi(self, sim, dcp)\n            if \"demand\" in sim.config.db.write_items:\n                save_demand_multi(self, sim, dcp)\n        # hooks for custom writers written in Python, may be slow\n        for f in sim.config.db.dcp_write_hooks:\n            f(self, sim, dcp)\n        self.commit()\n\n    def save_final(self: Database, sim: SimulationEngine):\n        sim.final_write_to_sqlite(self._connection)\n\n    def dataframe(\n        self, query: str, params: list | tuple | dict | None = None, dtype=None\n    ):\n        \"\"\"Run a SQL query and return the results as a pandas DataFrame.\"\"\"\n        if not self.is_open:\n            raise ValueError(\"database is not open\")\n        import pandas as pd\n\n        return pd.read_sql_query(query, self._connection, params=params, dtype=dtype)\n\n    def save_dataframe(\n        self,\n        name: str,\n        df: pd.DataFrame,\n        if_exists: Literal[\"fail\", \"replace\", \"append\"] = \"replace\",\n    ):\n        \"\"\"Save a dataframe as a table in this database.\"\"\"\n        df.to_sql(name, self._connection, if_exists=if_exists)\n\n    def table_names(self) -&gt; list[str]:\n        \"\"\"List of all tables in the database.\"\"\"\n        qry = \"SELECT name FROM sqlite_master WHERE type=='table'\"\n        return [i[0] for i in self._connection.execute(qry)]\n\n    def table_info(self, table_name: str) -&gt; pd.DataFrame:\n        \"\"\"Get info about a table\"\"\"\n        df = self.dataframe(f\"PRAGMA table_info({table_name})\")\n        return df.set_index(\"cid\")\n\n    def index_names(self, table_name) -&gt; list[str]:\n        \"\"\"List of all named indexes on a given table.\"\"\"\n        qry = \"SELECT name FROM sqlite_master WHERE type=='index' AND tbl_name==?1\"\n        return [i[0] for i in self._connection.execute(qry, (table_name,))]\n\n    def add_indexes(self, fare_detail=True):\n        any_work = False\n        if fare_detail and \"fare_detail_idx_2\" not in self.index_names(\"fare_detail\"):\n            logger.info(\"adding index on fare_detail\")\n            idx = \"\"\"\n            CREATE INDEX fare_detail_idx_2\n            ON fare_detail (scenario, trial, sample, rrd, carrier, booking_class);\n            \"\"\"\n            self._connection.execute(idx)\n            self._connection.commit()\n            self._connection.execute(\"BEGIN TRANSACTION;\")\n            any_work = True\n\n        if any_work:\n            logger.info(\"completed adding indexes\")\n\n    def backup(self, dst: Path | str | sqlite3.Connection, show_progress: bool = True):\n        \"\"\"Back up this database to another copy.\"\"\"\n        if self.engine != \"sqlite\":\n            raise NotImplementedError(f\"no backup available for engine={self.engine!r}\")\n        if not self.is_open:\n            raise OSError(\"database connection is not open\")\n\n        def _progress(status, remaining, total):\n            if remaining:\n                print(f\"Copied {total - remaining} of {total} pages...\")\n            else:\n                print(f\"Copied all {total} pages.\")\n\n        if not isinstance(dst, sqlite3.Connection):\n            dst = sqlite3.connect(dst)\n        if self._connection.in_transaction:\n            self._connection.execute(\"COMMIT;\")\n        with dst:\n            self._connection.backup(\n                dst, pages=10000, progress=_progress if show_progress else None\n            )\n        self._connection.execute(\"BEGIN TRANSACTION;\")\n        dst.close()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._commit_count_delay", "title": "_commit_count_delay  <code>instance-attribute</code>", "text": "<pre><code>_commit_count_delay = commit_count_delay\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._connection", "title": "_connection  <code>instance-attribute</code>", "text": "<pre><code>_connection = None\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._counter", "title": "_counter  <code>instance-attribute</code>", "text": "<pre><code>_counter = 0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.commit", "title": "commit  <code>instance-attribute</code>", "text": "<pre><code>commit = self._commit_by_count\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.engine", "title": "engine  <code>instance-attribute</code>", "text": "<pre><code>engine = engine\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.filename", "title": "filename  <code>instance-attribute</code>", "text": "<pre><code>filename = filename\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.is_open", "title": "is_open  <code>property</code>", "text": "<pre><code>is_open: bool\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.pragmas", "title": "pragmas  <code>instance-attribute</code>", "text": "<pre><code>pragmas = pragmas\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.__enter__", "title": "__enter__", "text": "<pre><code>__enter__()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __enter__(self):\n    if self._connection:\n        return self._connection.__enter__()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.__exit__", "title": "__exit__", "text": "<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    if self._connection:\n        return self._connection.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.__getattr__", "title": "__getattr__", "text": "<pre><code>__getattr__(item)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __getattr__(self, item):\n    return getattr(self._connection, item)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    engine: Literal[\"sqlite\", None] = \"sqlite\",\n    filename=None,\n    pragmas: Iterable[str] = (),\n    commit_count_delay: int | None = 250,\n)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __init__(\n    self,\n    engine: Literal[\"sqlite\", None] = \"sqlite\",\n    filename=None,\n    pragmas: Iterable[str] = (),\n    commit_count_delay: int | None = 250,\n):\n    self._connection = None\n    self.engine = engine\n    self.filename = filename\n    self.pragmas = pragmas\n    self._counter = 0\n    self._commit_count_delay = commit_count_delay\n    if self._commit_count_delay is not None:\n        self.commit = self._commit_by_count\n    else:\n        self.commit = self._commit_raw\n    self.open()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._commit_by_count", "title": "_commit_by_count", "text": "<pre><code>_commit_by_count()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def _commit_by_count(self):\n    self._counter += 1\n    if self._counter &gt;= self._commit_count_delay:\n        self._commit_raw()\n        self._counter = 0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database._commit_raw", "title": "_commit_raw", "text": "<pre><code>_commit_raw()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def _commit_raw(self):\n    if self._connection:\n        if self._connection.in_transaction:\n            self._connection.execute(\"COMMIT;\")\n        self._connection.execute(\"BEGIN TRANSACTION;\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.add_indexes", "title": "add_indexes", "text": "<pre><code>add_indexes(fare_detail=True)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def add_indexes(self, fare_detail=True):\n    any_work = False\n    if fare_detail and \"fare_detail_idx_2\" not in self.index_names(\"fare_detail\"):\n        logger.info(\"adding index on fare_detail\")\n        idx = \"\"\"\n        CREATE INDEX fare_detail_idx_2\n        ON fare_detail (scenario, trial, sample, rrd, carrier, booking_class);\n        \"\"\"\n        self._connection.execute(idx)\n        self._connection.commit()\n        self._connection.execute(\"BEGIN TRANSACTION;\")\n        any_work = True\n\n    if any_work:\n        logger.info(\"completed adding indexes\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.backup", "title": "backup", "text": "<pre><code>backup(\n    dst: Path | str | sqlite3.Connection,\n    show_progress: bool = True,\n)\n</code></pre> <p>Back up this database to another copy.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def backup(self, dst: Path | str | sqlite3.Connection, show_progress: bool = True):\n    \"\"\"Back up this database to another copy.\"\"\"\n    if self.engine != \"sqlite\":\n        raise NotImplementedError(f\"no backup available for engine={self.engine!r}\")\n    if not self.is_open:\n        raise OSError(\"database connection is not open\")\n\n    def _progress(status, remaining, total):\n        if remaining:\n            print(f\"Copied {total - remaining} of {total} pages...\")\n        else:\n            print(f\"Copied all {total} pages.\")\n\n    if not isinstance(dst, sqlite3.Connection):\n        dst = sqlite3.connect(dst)\n    if self._connection.in_transaction:\n        self._connection.execute(\"COMMIT;\")\n    with dst:\n        self._connection.backup(\n            dst, pages=10000, progress=_progress if show_progress else None\n        )\n    self._connection.execute(\"BEGIN TRANSACTION;\")\n    dst.close()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.close", "title": "close", "text": "<pre><code>close()\n</code></pre> <p>Flush pending operations and close the connection.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def close(self):\n    \"\"\"Flush pending operations and close the connection.\"\"\"\n    if self._connection:\n        if self._connection.in_transaction:\n            self._connection.execute(\"COMMIT;\")\n        self._connection.close()\n        self._connection = None\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.dataframe", "title": "dataframe", "text": "<pre><code>dataframe(\n    query: str,\n    params: list | tuple | dict | None = None,\n    dtype=None,\n)\n</code></pre> <p>Run a SQL query and return the results as a pandas DataFrame.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def dataframe(\n    self, query: str, params: list | tuple | dict | None = None, dtype=None\n):\n    \"\"\"Run a SQL query and return the results as a pandas DataFrame.\"\"\"\n    if not self.is_open:\n        raise ValueError(\"database is not open\")\n    import pandas as pd\n\n    return pd.read_sql_query(query, self._connection, params=params, dtype=dtype)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.delete_experiment", "title": "delete_experiment", "text": "<pre><code>delete_experiment(name: str)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def delete_experiment(self, name: str):\n    if self.is_open:\n        logger.debug(f\"deleting existing scenario {name!r} from database\")\n        self.execute(\"DELETE FROM leg_detail WHERE scenario = ?\", (name,))\n        self.execute(\"DELETE FROM leg_bucket_detail WHERE scenario = ?\", (name,))\n        self.execute(\"DELETE FROM demand_detail WHERE scenario = ?\", (name,))\n        self.execute(\"DELETE FROM fare_detail WHERE scenario = ?\", (name,))\n        self._commit_raw()\n    else:\n        logger.debug(f\"database not open, cannot delete {name!r}\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.index_names", "title": "index_names", "text": "<pre><code>index_names(table_name) -&gt; list[str]\n</code></pre> <p>List of all named indexes on a given table.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def index_names(self, table_name) -&gt; list[str]:\n    \"\"\"List of all named indexes on a given table.\"\"\"\n    qry = \"SELECT name FROM sqlite_master WHERE type=='index' AND tbl_name==?1\"\n    return [i[0] for i in self._connection.execute(qry, (table_name,))]\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.load_configs", "title": "load_configs", "text": "<pre><code>load_configs(scenario=None) -&gt; Config\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def load_configs(self, scenario=None) -&gt; Config:\n    import json\n\n    if scenario:\n        rawjson = next(\n            self.execute(\n                \"SELECT configs, max(updated_at) FROM runtime_configs WHERE scenario = ?1\",\n                (scenario,),\n            )\n        )[0]\n    else:\n        rawjson = next(\n            self.execute(\"SELECT configs, max(updated_at) FROM runtime_configs\")\n        )[0]\n    return Config.model_validate(json.loads(rawjson))\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.open", "title": "open", "text": "<pre><code>open(filename: str | None = None)\n</code></pre> <p>Open the connection if it is not already open.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def open(self, filename: str | None = None):\n    \"\"\"Open the connection if it is not already open.\"\"\"\n    if self._connection is not None:\n        raise ConnectionError(\"the connection is already open\")\n    self.filename = filename or self.filename\n    if self.engine is None:\n        self._connection = None\n    elif self.engine == \"sqlite\" and self.filename is None:\n        self._connection = None\n    elif self.engine == \"sqlite\":\n        if self.filename != \":memory:\":\n            Path(self.filename).parent.mkdir(exist_ok=True, parents=True)\n        logger.info(f\"connecting to sqlite database: {self.filename}\")\n        self._connection = sqlite3.Connection(self.filename)\n        self._connection.create_aggregate(\"VARIANCE\", 1, _VarianceFunc)\n        self._connection.create_aggregate(\"STDEV\", 1, _StdevFunc)\n        for pragma in self.pragmas:\n            self._connection.execute(f\"PRAGMA {pragma};\")\n        self._connection.execute(\"BEGIN TRANSACTION;\")\n        logger.debug(\"initializing sqlite tables\")\n        from .tables import create_tables\n\n        create_tables(self)\n    else:\n        raise NotImplementedError(f\"unknown engine {self.engine!r}\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.save_configs", "title": "save_configs", "text": "<pre><code>save_configs(cfg: Config) -&gt; None\n</code></pre> <p>Save configs into the database.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_configs(self, cfg: Config) -&gt; None:\n    \"\"\"Save configs into the database.\"\"\"\n    from passengersim import __version__\n\n    self.execute(\n        \"\"\"\n    INSERT OR REPLACE INTO runtime_configs(\n        scenario, pxsim_version, configs\n    ) VALUES (?1, ?2, ?3)\n    \"\"\",\n        (\n            cfg.scenario,\n            str(__version__),\n            cfg.model_dump_json(\n                exclude={\"db\": \"dcp_write_hooks\", \"raw_license_certificate\": True}\n            ),\n        ),\n    )\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.save_dataframe", "title": "save_dataframe", "text": "<pre><code>save_dataframe(\n    name: str,\n    df: pd.DataFrame,\n    if_exists: Literal[\n        \"fail\", \"replace\", \"append\"\n    ] = \"replace\",\n)\n</code></pre> <p>Save a dataframe as a table in this database.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_dataframe(\n    self,\n    name: str,\n    df: pd.DataFrame,\n    if_exists: Literal[\"fail\", \"replace\", \"append\"] = \"replace\",\n):\n    \"\"\"Save a dataframe as a table in this database.\"\"\"\n    df.to_sql(name, self._connection, if_exists=if_exists)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.save_details", "title": "save_details", "text": "<pre><code>save_details(sim: SimulationEngine, dcp: int)\n</code></pre> <p>Save details, can be done at each RRD/DCP and at the end of the run</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_details(self: Database, sim: SimulationEngine, dcp: int):\n    \"\"\"\n    Save details, can be done at each RRD/DCP and at the end of the run\n    \"\"\"\n    if not sim.save_timeframe_details and dcp &gt; 0:\n        return\n    if sim.config.db.fast and isinstance(self._connection, sqlite3.Connection):\n        sim.write_to_sqlite(\n            self._connection,\n            dcp,\n            store_bid_prices=sim.config.db.store_leg_bid_prices,\n        )\n    else:\n        for leg in sim.legs:\n            if \"leg\" in sim.config.db.write_items:\n                save_leg(self, sim, leg, dcp)\n            if \"bucket\" in sim.config.db.write_items:\n                save_leg_bucket_multi(self, sim, leg, dcp)\n        if \"fare\" in sim.config.db.write_items:\n            save_fare_multi(self, sim, dcp)\n        if \"demand\" in sim.config.db.write_items:\n            save_demand_multi(self, sim, dcp)\n    # hooks for custom writers written in Python, may be slow\n    for f in sim.config.db.dcp_write_hooks:\n        f(self, sim, dcp)\n    self.commit()\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.save_final", "title": "save_final", "text": "<pre><code>save_final(sim: SimulationEngine)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_final(self: Database, sim: SimulationEngine):\n    sim.final_write_to_sqlite(self._connection)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.sql_placeholders", "title": "sql_placeholders", "text": "<pre><code>sql_placeholders(n: int)\n</code></pre> <p>A parenthesis enclosed set of <code>n</code> placeholders for the selected engine.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def sql_placeholders(self, n: int):\n    \"\"\"A parenthesis enclosed set of `n` placeholders for the selected engine.\"\"\"\n    if self.engine == \"sqlite\":\n        x = \"?\"\n    else:\n        x = \"%s\"\n    return \"(\" + \", \".join(x for _ in range(n)) + \")\"\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.table_info", "title": "table_info", "text": "<pre><code>table_info(table_name: str) -&gt; pd.DataFrame\n</code></pre> <p>Get info about a table</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def table_info(self, table_name: str) -&gt; pd.DataFrame:\n    \"\"\"Get info about a table\"\"\"\n    df = self.dataframe(f\"PRAGMA table_info({table_name})\")\n    return df.set_index(\"cid\")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.Database.table_names", "title": "table_names", "text": "<pre><code>table_names() -&gt; list[str]\n</code></pre> <p>List of all tables in the database.</p> Source code in <code>passengersim/database/database.py</code> <pre><code>def table_names(self) -&gt; list[str]:\n    \"\"\"List of all tables in the database.\"\"\"\n    qry = \"SELECT name FROM sqlite_master WHERE type=='table'\"\n    return [i[0] for i in self._connection.execute(qry)]\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._StdevFunc", "title": "_StdevFunc", "text": "<p>             Bases: <code>_VarianceFunc</code></p> Source code in <code>passengersim/database/database.py</code> <pre><code>class _StdevFunc(_VarianceFunc):\n    def finalize(self):\n        if self.k &lt; 3:\n            return None\n        return math.sqrt(self.S / (self.k - 2))\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._StdevFunc.finalize", "title": "finalize", "text": "<pre><code>finalize()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def finalize(self):\n    if self.k &lt; 3:\n        return None\n    return math.sqrt(self.S / (self.k - 2))\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc", "title": "_VarianceFunc", "text": "Source code in <code>passengersim/database/database.py</code> <pre><code>class _VarianceFunc:\n    def __init__(self):\n        self.M = 0.0\n        self.S = 0.0\n        self.k = 1\n\n    def step(self, value):\n        if value is None:\n            return\n        tM = self.M\n        self.M += (value - tM) / self.k\n        self.S += (value - tM) * (value - self.M)\n        self.k += 1\n\n    def finalize(self):\n        if self.k &lt; 3:\n            return None\n        return self.S / (self.k - 2)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.M", "title": "M  <code>instance-attribute</code>", "text": "<pre><code>M = 0.0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.S", "title": "S  <code>instance-attribute</code>", "text": "<pre><code>S = 0.0\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.k", "title": "k  <code>instance-attribute</code>", "text": "<pre><code>k = 1\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.__init__", "title": "__init__", "text": "<pre><code>__init__()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def __init__(self):\n    self.M = 0.0\n    self.S = 0.0\n    self.k = 1\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.finalize", "title": "finalize", "text": "<pre><code>finalize()\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def finalize(self):\n    if self.k &lt; 3:\n        return None\n    return self.S / (self.k - 2)\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database._VarianceFunc.step", "title": "step", "text": "<pre><code>step(value)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def step(self, value):\n    if value is None:\n        return\n    tM = self.M\n    self.M += (value - tM) / self.k\n    self.S += (value - tM) * (value - self.M)\n    self.k += 1\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.compute_rrd", "title": "compute_rrd", "text": "<pre><code>compute_rrd(sim: SimulationEngine, dep_time: float)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def compute_rrd(sim: SimulationEngine, dep_time: float):\n    tmp = int(dep_time / 86400) * 86400\n    rrd = int((tmp - sim.last_event_time) / 86400)\n    if sim.num_events() == 0:\n        rrd = 0\n    return rrd\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.delete_experiment", "title": "delete_experiment", "text": "<pre><code>delete_experiment(cnx: Database, name)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def delete_experiment(cnx: Database, name):\n    with cnx:\n        logger.info(f\"deleting existing scenario {name!r} from database\")\n        cnx.execute(f\"DELETE FROM leg_detail WHERE scenario = '{name}' \")\n        cnx.execute(f\"DELETE FROM leg_bucket_detail WHERE scenario = '{name}' \")\n        cnx.execute(f\"DELETE FROM demand_detail WHERE scenario = '{name}' \")\n        cnx.execute(f\"DELETE FROM fare_detail WHERE scenario = '{name}' \")\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.get_database_connection", "title": "get_database_connection", "text": "<pre><code>get_database_connection(\n    engine: Literal[\"sqlite\", None] = \"sqlite\",\n    filename: Path = None,\n    pragmas: Iterable[str] = (),\n    commit_count_delay: int | None = 250,\n)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def get_database_connection(\n    engine: Literal[\"sqlite\", None] = \"sqlite\",\n    filename: Path = None,\n    pragmas: Iterable[str] = (),\n    commit_count_delay: int | None = 250,\n):\n    return Database(\n        engine=engine,\n        filename=filename,\n        pragmas=pragmas,\n        commit_count_delay=commit_count_delay,\n    )\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.save_demand_multi", "title": "save_demand_multi", "text": "<pre><code>save_demand_multi(\n    cnx: Database, sim: SimulationEngine, dcp\n) -&gt; string\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_demand_multi(cnx: Database, sim: SimulationEngine, dcp) -&gt; string:\n    data_list = []\n    for dmd in sim.demands:\n        data_list.append(\n            (\n                sim.name,\n                sim.iteration,\n                sim.trial,\n                sim.sample,\n                dcp,\n                dmd.orig,\n                dmd.dest,\n                dmd.segment,\n                dmd.scenario_demand,\n                dmd.sold,\n                dmd.revenue,\n            )\n        )\n        # if dmd.sold &gt; dmd.scenario_demand:\n        #     print(f\"{dmd.orig=}, {dmd.dest=}, {dmd.segment}, {dmd.sold}, {dmd.scenario_demand}\")\n\n    try:\n        cursor = cnx.cursor()\n        sql = f\"\"\"INSERT INTO demand_detail\n                (scenario, iteration, trial, sample, rrd, orig, dest, segment, sample_demand, sold, revenue)\n                VALUES ({sql_placeholders(cnx, 11)})\"\"\"\n        cursor.executemany(sql, data_list)\n        return True\n    except Exception as err:\n        print(f\"Doh !!! demand_detail: {err}\")\n        return False\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.save_fare_multi", "title": "save_fare_multi", "text": "<pre><code>save_fare_multi(\n    cnx: Database, sim: SimulationEngine, dcp\n) -&gt; string\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_fare_multi(cnx: Database, sim: SimulationEngine, dcp) -&gt; string:\n    data_list = []\n    for fare in sim.fares:\n        data_list.append(\n            (\n                sim.name,\n                sim.iteration,\n                sim.trial,\n                sim.sample,\n                dcp,\n                fare.carrier,\n                fare.orig,\n                fare.dest,\n                fare.booking_class,\n                fare.sold,\n                fare.sold_business,\n                fare.price,\n            )\n        )\n    try:\n        cursor = cnx.cursor()\n        sql = f\"\"\"INSERT INTO fare_detail\n                (scenario, iteration, trial, sample, rrd, carrier,\n                 orig, dest, booking_class, sold, sold_business, price)\n                VALUES ({sql_placeholders(cnx, 12)})\"\"\"\n        cursor.executemany(sql, data_list)\n        return True\n    except Exception as err:\n        print(f\"Doh !!! fare: {err}\")\n        return False\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.save_leg", "title": "save_leg", "text": "<pre><code>save_leg(cnx, sim, leg, dcp) -&gt; string\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_leg(cnx, sim, leg, dcp) -&gt; string:\n    _dep_time = datetime.utcfromtimestamp(leg.dep_time).strftime(\"%Y-%m-%d %H:%M:%S\")\n    try:\n        cursor = cnx.cursor()\n        sql = f\"\"\"INSERT INTO leg_detail\n                (scenario, iteration, trial, sample, rrd, flt_no, sold, revenue)\n                VALUES ({sql_placeholders(cnx, 8)})\"\"\"\n        cursor.execute(\n            sql,\n            (\n                sim.name,\n                sim.iteration,\n                sim.trial,\n                sim.sample,\n                dcp,\n                leg.flt_no,\n                leg.sold,\n                leg.revenue,\n            ),\n        )\n        return True\n    except Exception as err:\n        print(f\"Doh !!! leg_detail: {err}\")\n        return False\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.save_leg_bucket_multi", "title": "save_leg_bucket_multi", "text": "<pre><code>save_leg_bucket_multi(\n    cnx: Database,\n    sim: SimulationEngine,\n    leg,\n    dcp,\n    commit=False,\n) -&gt; string\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def save_leg_bucket_multi(\n    cnx: Database, sim: SimulationEngine, leg, dcp, commit=False\n) -&gt; string:\n    dep_time = datetime.utcfromtimestamp(leg.dep_time).strftime(\"%Y-%m-%d %H:%M:%S\")\n    # print(\"dep_time = \", dep_time)\n    try:\n        cursor = cnx.cursor()\n        cnx_type = type(cnx).__name__\n        if cnx_type not in leg_bucket_sql:\n            sql = leg_bucket_sql[\n                cnx_type\n            ] = f\"\"\"INSERT INTO leg_bucket_detail\n                (scenario, iteration, trial, sample, rrd, carrier, orig, dest, flt_no,\n                dep_date, bucket_number, name, auth, revenue, sold, untruncated_demand,\n                forecast_mean) VALUES ({sql_placeholders(cnx, 17)})\"\"\"\n        else:\n            sql = leg_bucket_sql.get(cnx_type)\n        data_list = []\n        for n, bkt in enumerate(leg.buckets):\n            data = (\n                sim.name,\n                sim.iteration,\n                sim.trial,\n                sim.sample,\n                dcp,\n                leg.carrier,\n                leg.orig,\n                leg.dest,\n                leg.flt_no,\n                dep_time,\n                n,\n                bkt.name,\n                bkt.alloc,\n                bkt.revenue,\n                bkt.sold,\n                bkt.untruncated_demand,\n                bkt.fcst_mean,\n            )\n            data_list.append(data)\n\n        cursor.executemany(sql, data_list)\n        if commit:\n            cnx.commit()\n        cursor.close()\n        return True\n    except Exception as err:\n        print(f\"Doh !!! leg_bucket_detail: {err}\")\n        return False\n</code></pre>"}, {"location": "API/database/index.html#passengersim.database.database.sql_placeholders", "title": "sql_placeholders", "text": "<pre><code>sql_placeholders(cnx, n: int)\n</code></pre> Source code in <code>passengersim/database/database.py</code> <pre><code>def sql_placeholders(cnx, n: int):\n    if isinstance(cnx, Database):\n        return sql_placeholders(cnx._connection, n)\n    elif isinstance(cnx, sqlite3.Connection):\n        x = \"?\"\n    else:\n        x = \"%s\"\n    return \", \".join(x for _ in range(n))\n</code></pre>"}, {"location": "API/database/common-queries.html", "title": "Common Queries", "text": ""}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.bid_price_history", "title": "bid_price_history", "text": "<pre><code>bid_price_history(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame\n</code></pre> <p>Compute average bid price history over all legs for each carrier.</p> <p>This query requires that the simulation was run while recording leg details (i.e. with the <code>leg</code> flag set on <code>Config.db.write_items</code>), including bid prices.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>             (<code>Database</code>)         \u2013          </li> <li> <code>scenario</code>             (<code>str</code>)         \u2013          </li> <li> <code>burn_samples</code>             (<code>int</code>, default:                 <code>100</code> )         \u2013          <p>The bid prices will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>The resulting dataframe is indexed by <code>carrier</code> and <code>rrd</code>, and has these columns:</p> <ul> <li><code>bid_price_mean</code>: Average bid price across all samples and all legs</li> <li><code>bid_price_stdev</code>: Sample standard deviation of bid prices across all     samples and all legs</li> <li><code>fraction_some_cap</code>: Fraction of all legs across all samples that have     non-zero capacity available for sale.</li> <li><code>fraction_zero_cap</code>: Fraction of all legs across all samples that have     zero capacity available for sale.  Bid prices are computed for these     legs but are not really meaningful.</li> <li><code>some_cap_bid_price_mean</code>: Average bid price across all samples and     all legs conditional on the leg having non-zero capacity.</li> <li><code>some_cap_bid_price_stdev</code>: Sample standard deviation of bid prices     across all samples and all legs conditional on the leg having     non-zero capacity.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def bid_price_history(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute average bid price history over all legs for each carrier.\n\n    This query requires that the simulation was run while recording leg\n    details (i.e. with the `leg` flag set on `Config.db.write_items`),\n    including bid prices.\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The bid prices will be analyzed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `carrier` and `rrd`, and has\n        these columns:\n\n        - `bid_price_mean`: Average bid price across all samples and all legs\n        - `bid_price_stdev`: Sample standard deviation of bid prices across all\n            samples and all legs\n        - `fraction_some_cap`: Fraction of all legs across all samples that have\n            non-zero capacity available for sale.\n        - `fraction_zero_cap`: Fraction of all legs across all samples that have\n            zero capacity available for sale.  Bid prices are computed for these\n            legs but are not really meaningful.\n        - `some_cap_bid_price_mean`: Average bid price across all samples and\n            all legs conditional on the leg having non-zero capacity.\n        - `some_cap_bid_price_stdev`: Sample standard deviation of bid prices\n            across all samples and all legs conditional on the leg having\n            non-zero capacity.\n\n    \"\"\"\n    qry = \"\"\"\n    SELECT\n        carrier,\n        rrd,\n        avg(bid_price) as bid_price_mean,\n        stdev(bid_price) as bid_price_stdev,\n        avg(CASE WHEN leg_detail.sold &lt; leg_defs.capacity THEN 1.0 ELSE 0.0 END) as fraction_some_cap,\n        avg(CASE WHEN leg_detail.sold &lt; leg_defs.capacity THEN 0.0 ELSE 1.0 END) as fraction_zero_cap\n    FROM leg_detail\n        LEFT JOIN leg_defs ON leg_detail.flt_no = leg_defs.flt_no\n    WHERE\n        scenario == ?1\n        AND sample &gt;= ?2\n    GROUP BY\n        carrier, rrd\n    \"\"\"\n    bph = cnx.dataframe(\n        qry,\n        (\n            scenario,\n            burn_samples,\n        ),\n    )\n    qry2 = \"\"\"\n    SELECT\n        carrier,\n        rrd,\n        avg(bid_price) as some_cap_bid_price_mean,\n        stdev(bid_price) as some_cap_bid_price_stdev\n    FROM leg_detail\n        LEFT JOIN leg_defs ON leg_detail.flt_no = leg_defs.flt_no\n    WHERE\n        scenario == ?1\n        AND sample &gt;= ?2\n        AND leg_detail.sold &lt; leg_defs.capacity\n    GROUP BY\n        carrier, rrd\n    \"\"\"\n    bph_some_cap = cnx.dataframe(\n        qry2,\n        (\n            scenario,\n            burn_samples,\n        ),\n    ).set_index([\"carrier\", \"rrd\"])\n    bph = bph.set_index([\"carrier\", \"rrd\"]).join(bph_some_cap)\n    bph = bph.sort_index(ascending=(True, False))\n    return bph\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.bookings_by_timeframe", "title": "bookings_by_timeframe", "text": "<pre><code>bookings_by_timeframe(\n    cnx: Database,\n    scenario: str,\n    from_fare_detail: bool = False,\n    burn_samples: int = 100,\n) -&gt; pd.DataFrame\n</code></pre> <p>Average bookings and revenue by carrier, booking class, and timeframe.</p> <p>This query requires that the simulation was run while recording supporting details (i.e. with the <code>bookings</code> or <code>fare</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>             (<code>Database</code>)         \u2013          </li> <li> <code>scenario</code>             (<code>str</code>)         \u2013          </li> <li> <code>from_fare_detail</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Reconstruct this table from the <code>fare_detail</code> table.  This is generally slower than accessing the <code>bookings</code> table directly, and also requires substantially more data to have been saved into the database by setting the <code>fare</code> flag on <code>Config.db.write_items</code></p> </li> <li> <code>burn_samples</code>             (<code>int</code>, default:                 <code>100</code> )         \u2013          <p>The bookings will be computed ignoring this many samples from the beginning of each trial. This argument is nominally ignored by this query unless <code>from_fare_detail</code> is true, although the simulator will have already ignored the burned samples when storing the data in the bookings table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>The resulting dataframe is indexed by <code>trial</code>, <code>carrier</code>, <code>class</code>, and <code>rrd</code>, and has these columns:</p> <ul> <li><code>avg_sold</code>: Average number of sales.</li> <li><code>avg_business</code>: Average number of sales to passengers in the business segment.</li> <li><code>avg_leisure</code>: Average number of sales to leisure passengers.</li> <li><code>avg_revenue</code>: Average total revenue earned from customers booking in this booking     class in this time period.</li> <li><code>avg_price</code>: Average price per ticket from customers booking in this booking     class in this time period</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def bookings_by_timeframe(\n    cnx: Database,\n    scenario: str,\n    from_fare_detail: bool = False,\n    burn_samples: int = 100,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Average bookings and revenue by carrier, booking class, and timeframe.\n\n    This query requires that the simulation was run while recording supporting\n    details (i.e. with the `bookings` or `fare` flags set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    from_fare_detail : bool, default False\n        Reconstruct this table from the `fare_detail` table.  This is generally\n        slower than accessing the `bookings` table directly, and also requires\n        substantially more data to have been saved into the database by setting\n        the `fare` flag on `Config.db.write_items`\n    burn_samples : int, default 100\n        The bookings will be computed ignoring this many samples from the\n        beginning of each trial. This argument is nominally ignored by this query\n        unless `from_fare_detail` is true, although the simulator will have already\n        ignored the burned samples when storing the data in the bookings table.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `trial`, `carrier`, `class`,\n        and `rrd`, and has these columns:\n\n        - `avg_sold`: Average number of sales.\n        - `avg_business`: Average number of sales to passengers in the business segment.\n        - `avg_leisure`: Average number of sales to leisure passengers.\n        - `avg_revenue`: Average total revenue earned from customers booking in this booking\n            class in this time period.\n        - `avg_price`: Average price per ticket from customers booking in this booking\n            class in this time period\n    \"\"\"\n    qry_fare = \"\"\"\n    SELECT trial, carrier, booking_class, rrd,\n           (AVG(sold)) AS avg_sold,\n           (AVG(sold_business)) AS avg_business,\n           (AVG(sold_leisure)) AS avg_leisure,\n           (AVG(revenue)) AS avg_revenue,\n           (AVG(revenue) / AVG(sold)) AS avg_price,\n           (SUM(sold)) AS tot_sold\n    FROM (SELECT trial, scenario, carrier, booking_class, rrd,\n                 SUM(sold) AS sold,\n                 SUM(sold_business) AS sold_business,\n                 SUM(sold - sold_business) AS sold_leisure,\n                 SUM(sold * price) AS revenue\n          FROM fare_detail\n          WHERE\n                sample &gt;= ?2\n                AND scenario = ?1\n          GROUP BY trial, sample, carrier, booking_class, rrd) a\n    GROUP BY carrier, booking_class, rrd, trial\n    ORDER BY carrier, booking_class, rrd, trial;\n    \"\"\"\n\n    if from_fare_detail:\n        return cnx.dataframe(qry_fare, (scenario, burn_samples)).set_index(\n            [\"trial\", \"carrier\", \"booking_class\", \"rrd\"]\n        )\n\n    qry_bookings = \"\"\"\n    SELECT\n        trial,\n        carrier,\n        booking_class,\n        rrd,\n        avg_sold,\n        avg_business,\n        avg_leisure,\n        avg_revenue,\n        avg_price\n    FROM\n        bookings_by_timeframe\n    WHERE\n        scenario = ?1\n    GROUP BY\n        carrier, booking_class, rrd, trial\n    ORDER BY\n        carrier, booking_class, rrd, trial;\n    \"\"\"\n    return cnx.dataframe(qry_bookings, (scenario,)).set_index(\n        [\"trial\", \"carrier\", \"booking_class\", \"rrd\"]\n    )\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.carrier_history", "title": "carrier_history", "text": "<pre><code>carrier_history(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame\n</code></pre> <p>Sample-level details of carrier-level measures.</p> <p>This query delivers sample-by-sample aggregated summary results for the various carriers in the simulation. It requires that the simulation was run while recording leg bucket details (i.e. with the <code>bucket</code> flag set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>             (<code>Database</code>)         \u2013          </li> <li> <code>scenario</code>             (<code>str</code>)         \u2013          </li> <li> <code>burn_samples</code>             (<code>int</code>, default:                 <code>100</code> )         \u2013          <p>The history will be returned ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>The resulting dataframe is indexed by <code>iteration</code>, <code>trial</code> and <code>sample</code>, and columns defined with a two-level MultiIndex.  The second level of the columns MultiIndex represents the carriers, while the top level includes these columns:</p> <ul> <li><code>forecast_mean</code>: Forecast mean (mu) at the beginning of the booking     curve, summed over all this carrier's legs in this sample.</li> <li><code>forecast_stdev</code>: Forecast standard deviation (sigma) at the beginning     of the booking curve, aggregated over all this carrier's legs in this     sample.</li> <li><code>sold</code>: Total bookings accepted by this carrier in this sample.</li> <li><code>revenue</code>: Total revenue for this carrier in this sample.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def carrier_history(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Sample-level details of carrier-level measures.\n\n    This query delivers sample-by-sample aggregated summary results for the\n    various carriers in the simulation. It requires that the simulation was\n    run while recording leg bucket details (i.e. with the `bucket` flag set\n    on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The history will be returned ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `iteration`, `trial` and `sample`,\n        and columns defined with a two-level MultiIndex.  The second level of\n        the columns MultiIndex represents the carriers, while the top level\n        includes these columns:\n\n        - `forecast_mean`: Forecast mean (mu) at the beginning of the booking\n            curve, summed over all this carrier's legs in this sample.\n        - `forecast_stdev`: Forecast standard deviation (sigma) at the beginning\n            of the booking curve, aggregated over all this carrier's legs in this\n            sample.\n        - `sold`: Total bookings accepted by this carrier in this sample.\n        - `revenue`: Total revenue for this carrier in this sample.\n    \"\"\"\n    # Provides content similar to PODS *.HST output file.\n    max_rrd = int(\n        cnx.dataframe(\n            \"\"\"\n            SELECT max(rrd) FROM leg_bucket_detail WHERE scenario == ?1\n            \"\"\",\n            (scenario,),\n        ).iloc[0, 0]\n    )\n    bd1 = cnx.dataframe(\n        \"\"\"\n        SELECT\n            iteration, trial, sample, carrier,\n            sum(forecast_mean) as forecast_mean,\n            sqrt(sum(forecast_stdev*forecast_stdev)) as forecast_stdev\n        FROM leg_bucket_detail\n        WHERE rrd == ?2 AND scenario == ?1 AND sample &gt;= ?3\n        GROUP BY iteration, trial, sample, carrier\n        \"\"\",\n        (scenario, max_rrd, burn_samples),\n    ).set_index([\"iteration\", \"trial\", \"sample\", \"carrier\"])\n    bd2 = cnx.dataframe(\n        \"\"\"\n        SELECT\n            iteration, trial, sample, carrier,\n            sum(sold) as sold,\n            sum(revenue) as revenue\n        FROM leg_bucket_detail\n        WHERE rrd == 0 AND scenario == ?1 AND sample &gt;= ?2\n        GROUP BY iteration, trial, sample, carrier\n        \"\"\",\n        (scenario, burn_samples),\n    ).set_index([\"iteration\", \"trial\", \"sample\", \"carrier\"])\n    return pd.concat([bd1, bd2], axis=1).unstack(\"carrier\")\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.demand_to_come", "title": "demand_to_come", "text": "<pre><code>demand_to_come(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame\n</code></pre> <p>Demand by market and timeframe across each sample.</p> <p>This query delivers sample-by-sample timeframe demand results for the various markets (origin, destination, passenger type) in the simulation. It requires that the simulation was run while recording demand details (i.e. with the <code>demand</code> flag set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>             (<code>Database</code>)         \u2013          </li> <li> <code>scenario</code>             (<code>str</code>)         \u2013          </li> <li> <code>burn_samples</code>             (<code>int</code>, default:                 <code>100</code> )         \u2013          <p>The demand will be returned ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>The resulting dataframe is indexed by <code>iteration</code>, <code>trial</code>, <code>sample</code>, <code>segment</code>, <code>orig</code>, and <code>dest</code>; and has columns defined by the DCPs. The values stored are the total remaining demand to come at each DCP.</p> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def demand_to_come(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Demand by market and timeframe across each sample.\n\n    This query delivers sample-by-sample timeframe demand results for the\n    various markets (origin, destination, passenger type) in the simulation.\n    It requires that the simulation was run while recording demand details\n    (i.e. with the `demand` flag set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The demand will be returned ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `iteration`, `trial`, `sample`,\n        `segment`, `orig`, and `dest`; and has columns defined by the DCPs.\n        The values stored are the total remaining demand to come at each DCP.\n    \"\"\"\n    # Provides content similar to PODS *.DHS output file, but with market level detail\n    qry = \"\"\"\n    SELECT\n        iteration, trial, sample, segment, orig, dest, rrd, sold, no_go,\n        (round(sample_demand) - sold - no_go) AS future_demand\n    FROM\n        demand_detail\n    WHERE\n        scenario = ?1\n        AND sample &gt;= ?2\n    \"\"\"\n    dmd = cnx.dataframe(\n        qry, (scenario, burn_samples), dtype={\"future_demand\": np.int32}\n    )\n    # dmd[\"future_demand\"] = dmd.sample_demand.round().astype(int) - dmd.sold - dmd.no_go\n    dhs = (\n        dmd.set_index(\n            [\"iteration\", \"trial\", \"sample\", \"segment\", \"orig\", \"dest\", \"rrd\"]\n        )[\"future_demand\"]\n        .unstack(\"rrd\")\n        .sort_values(by=\"rrd\", axis=1, ascending=False)\n    )\n    return dhs\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.fare_class_mix", "title": "fare_class_mix", "text": "<pre><code>fare_class_mix(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame\n</code></pre> <p>Fare class mix by carrier.</p> <p>This query requires that the simulation was run while recording final fare details (i.e. with the <code>fare</code> or <code>fare_final</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>             (<code>Database</code>)         \u2013          </li> <li> <code>scenario</code>             (<code>str</code>)         \u2013          </li> <li> <code>burn_samples</code>             (<code>int</code>, default:                 <code>100</code> )         \u2013          <p>The average total demand will be computed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>The resulting dataframe is indexed by <code>carrier</code> and <code>booking_class</code>, and has these columns:</p> <ul> <li><code>avg_sold</code>: Average number of sales in this booking class.</li> <li><code>avg_revenue</code>: Average total revenue earned from customers booking in     this booking class.</li> <li><code>avg_price</code>: Average price per ticket from customers booking in this     booking class.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def fare_class_mix(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fare class mix by carrier.\n\n    This query requires that the simulation was run while recording final fare\n    details (i.e. with the `fare` or `fare_final` flags set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The average total demand will be computed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `carrier` and `booking_class`, and\n        has these columns:\n\n        - `avg_sold`: Average number of sales in this booking class.\n        - `avg_revenue`: Average total revenue earned from customers booking in\n            this booking class.\n        - `avg_price`: Average price per ticket from customers booking in this\n            booking class.\n    \"\"\"\n    qry = \"\"\"\n    SELECT carrier, booking_class,\n           (AVG(sold)) AS avg_sold,\n           (AVG(revenue)) AS avg_revenue,\n           (AVG(revenue) / AVG(sold)) AS avg_price\n    FROM (\n            SELECT\n                trial, scenario, carrier, booking_class,\n                SUM(sold) AS sold,\n                SUM(sold * price) AS revenue,\n                COUNT(*) AS nobs\n            FROM\n                fare_detail\n            WHERE\n                rrd = 0\n                AND sample &gt;= ?2\n                AND scenario = ?1\n            GROUP BY\n                trial, sample, carrier, booking_class\n    ) tmp\n    GROUP BY carrier, booking_class\n    ORDER BY carrier, booking_class;\n    \"\"\"\n    return cnx.dataframe(qry, (scenario, burn_samples)).set_index(\n        [\"carrier\", \"booking_class\"]\n    )\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.leg_forecasts", "title": "leg_forecasts", "text": "<pre><code>leg_forecasts(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame\n</code></pre> <p>Average forecasts of demand by leg, bucket, and days to departure.</p> <p>This query requires that the simulation was run while recording path-class details (i.e. with the <code>pathclass</code> flag set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>             (<code>Database</code>)         \u2013          </li> <li> <code>scenario</code>             (<code>str</code>)         \u2013          </li> <li> <code>burn_samples</code>             (<code>int</code>, default:                 <code>100</code> )         \u2013          <p>The forecasts will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>The resulting dataframe is indexed by <code>carrier</code>, <code>flt_no</code>, <code>bucket_number</code>, <code>booking_class</code> and <code>rrd</code>, and has these columns:</p> <ul> <li><code>forecast_mean</code>: Average forecast mean (mu).</li> <li><code>forecast_stdev</code>: Average forecast standard deviation (sigma).</li> <li><code>forecast_closed_in_tf</code>: Average fraction of time the timeframe was     closed in the data used to make a forecast.</li> <li><code>forecast_closed_in_tf</code>: Average fraction of time any future timeframe     was closed in the data used to make a forecast.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def leg_forecasts(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Average forecasts of demand by leg, bucket, and days to departure.\n\n    This query requires that the simulation was run while recording path-class\n    details (i.e. with the `pathclass` flag set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The forecasts will be analyzed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `carrier`, `flt_no`,\n        `bucket_number`, `booking_class` and `rrd`, and has these columns:\n\n        - `forecast_mean`: Average forecast mean (mu).\n        - `forecast_stdev`: Average forecast standard deviation (sigma).\n        - `forecast_closed_in_tf`: Average fraction of time the timeframe was\n            closed in the data used to make a forecast.\n        - `forecast_closed_in_tf`: Average fraction of time any future timeframe\n            was closed in the data used to make a forecast.\n    \"\"\"\n    qry = \"\"\"\n    SELECT\n        carrier,\n        flt_no,\n        bucket_number,\n        name as booking_class,\n        rrd,\n        AVG(forecast_mean) as forecast_mean,\n        AVG(forecast_stdev) as forecast_stdev,\n        AVG(forecast_closed_in_tf) as forecast_closed_in_tf,\n        AVG(forecast_closed_in_future) as forecast_closed_in_future\n    FROM\n        leg_bucket_detail\n    WHERE\n        scenario = ?1\n        AND sample &gt;= ?2\n    GROUP BY\n        carrier, flt_no, bucket_number, name, rrd\n    \"\"\"\n    return cnx.dataframe(\n        qry,\n        (\n            scenario,\n            burn_samples,\n        ),\n    ).set_index([\"carrier\", \"flt_no\", \"bucket_number\", \"booking_class\", \"rrd\"])\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.load_factors", "title": "load_factors", "text": "<pre><code>load_factors(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame\n</code></pre> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def load_factors(cnx: Database, scenario: str, burn_samples: int = 100) -&gt; pd.DataFrame:\n    qry = \"\"\"\n    SELECT carrier,\n           ROUND(AVG(sold)) AS avg_legs_sold,\n           ROUND(AVG(100.0 * sold / cap), 2) AS avg_leg_lf,\n           ROUND(AVG(100.0 * rpm / asm), 2) AS sys_lf,\n           ROUND(AVG(revenue), 2) AS avg_rev,\n           ROUND(AVG(revenue / asm), 3) AS yield,\n           ROUND(AVG(revenue) / AVG(sold)) AS avg_leg_price,\n           COUNT(*) AS n_obs\n    FROM (SELECT trial, sample, carrier,\n                 SUM(sold) AS sold,\n                 SUM(capacity) AS cap,\n                 SUM(sold * distance) AS rpm,\n                 SUM(capacity * distance) AS asm,\n                 SUM(revenue) AS revenue\n          FROM leg_detail\n                   JOIN leg_defs USING (flt_no)\n          WHERE rrd = 0\n            AND sample &gt;= ?2\n            AND scenario = ?1\n          GROUP BY trial, sample, carrier\n         ) tmp\n    GROUP BY carrier\n    \"\"\"\n    return cnx.dataframe(qry, (scenario, burn_samples))\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.local_and_flow_yields", "title": "local_and_flow_yields", "text": "<pre><code>local_and_flow_yields(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame\n</code></pre> <p>Compute yields for local (nonstop) and flow (connecting) passengers.</p> <p>This query requires that the simulation was run while recording path class details (i.e. with the <code>pathclass</code> or <code>pathclass_final</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>             (<code>Database</code>)         \u2013          </li> <li> <code>scenario</code>             (<code>str</code>)         \u2013          </li> <li> <code>burn_samples</code>             (<code>int</code>, default:                 <code>100</code> )         \u2013          <p>The yields will be computed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def local_and_flow_yields(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute yields for local (nonstop) and flow (connecting) passengers.\n\n    This query requires that the simulation was run while recording path class\n    details (i.e. with the `pathclass` or `pathclass_final` flags set on\n    `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The yields will be computed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n    \"\"\"\n    qry = \"\"\"\n    WITH path_yields AS (\n        SELECT\n            iteration, trial, sample, path_id, leg1, leg2,\n            SUM(sold) as total_sold,\n            SUM(revenue) as total_revenue,\n            distance,\n            SUM(revenue) / (SUM(sold) * distance) AS yield,\n            leg2 IS NULL AS local\n        FROM\n            path_class_detail\n            LEFT JOIN path_defs USING (path_id)\n        WHERE\n            rrd == 0\n            AND scenario == ?1\n            AND sample &gt;= ?2\n        GROUP BY\n            path_id\n    )\n    SELECT\n        flt_no, carrier, orig, dest, capacity, leg_defs.distance,\n        yield AS local_yield,\n        CAST(total_sold AS REAL) /\n            (total_sold + IFNULL(f1.flow_sold, 0) + IFNULL(f2.flow_sold, 0))\n            AS local_fraction,\n        (IFNULL(f1.flow_revenue, 0) + IFNULL(f2.flow_revenue, 0))\n            / (IFNULL(f1.flow_rpm, 0) + IFNULL(f2.flow_rpm, 0))\n            AS flow_yield\n    FROM\n        leg_defs\n        LEFT JOIN path_yields locals\n        ON locals.leg1 == flt_no AND locals.leg2 IS NULL\n        LEFT JOIN (\n            SELECT\n                leg1,\n                SUM(total_sold) AS flow_sold,\n                SUM(total_revenue) AS flow_revenue,\n                SUM(total_sold * distance) AS flow_rpm\n            FROM\n                path_yields\n            WHERE\n                leg2 IS NOT NULL\n            GROUP BY leg1\n        ) f1 ON f1.leg1 == leg_defs.flt_no\n        LEFT JOIN (\n            SELECT\n                leg2,\n                SUM(total_sold) AS flow_sold,\n                SUM(total_revenue) AS flow_revenue,\n                SUM(total_sold * distance) AS flow_rpm\n            FROM\n                path_yields\n            GROUP BY leg2\n        ) f2 ON f2.leg2 == leg_defs.flt_no\n    \"\"\"\n    df = cnx.dataframe(\n        qry,\n        (\n            scenario,\n            burn_samples,\n        ),\n    )\n    return df\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.od_fare_class_mix", "title": "od_fare_class_mix", "text": "<pre><code>od_fare_class_mix(\n    cnx: Database,\n    orig: str,\n    dest: str,\n    scenario: str,\n    burn_samples: int = 100,\n) -&gt; pd.DataFrame\n</code></pre> <p>Fare class mix by carrier for a particular origin-destination market.</p> <p>This query requires that the simulation was run while recording final fare details (i.e. with the <code>fare</code> or <code>fare_final</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>             (<code>Database</code>)         \u2013          </li> <li> <code>orig</code>             (<code>str</code>)         \u2013          <p>Origin and destination to query.</p> </li> <li> <code>dest</code>             (<code>str</code>)         \u2013          <p>Origin and destination to query.</p> </li> <li> <code>scenario</code>             (<code>str</code>)         \u2013          </li> <li> <code>burn_samples</code>             (<code>int</code>, default:                 <code>100</code> )         \u2013          <p>The average total demand will be computed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>The resulting dataframe is indexed by <code>carrier</code> and <code>booking_class</code>, and has these columns:</p> <ul> <li><code>avg_sold</code>: Average number of sales in this booking class.</li> <li><code>avg_revenue</code>: Average total revenue earned from customers booking in     this booking class.</li> <li><code>avg_price</code>: Average price per ticket from customers booking in this     booking class.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def od_fare_class_mix(\n    cnx: Database, orig: str, dest: str, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fare class mix by carrier for a particular origin-destination market.\n\n    This query requires that the simulation was run while recording final fare\n    details (i.e. with the `fare` or `fare_final` flags set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    orig, dest : str\n        Origin and destination to query.\n    scenario : str\n    burn_samples : int, default 100\n        The average total demand will be computed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `carrier` and `booking_class`, and\n        has these columns:\n\n        - `avg_sold`: Average number of sales in this booking class.\n        - `avg_revenue`: Average total revenue earned from customers booking in\n            this booking class.\n        - `avg_price`: Average price per ticket from customers booking in this\n            booking class.\n    \"\"\"\n\n    qry = \"\"\"\n    SELECT carrier, booking_class,\n           (AVG(sold)) AS avg_sold,\n           (AVG(revenue)) AS avg_revenue,\n           (AVG(revenue) / AVG(sold)) AS avg_price\n    FROM (\n            SELECT\n                trial, scenario, carrier, booking_class,\n                SUM(sold) AS sold,\n                SUM(sold * price) AS revenue,\n                COUNT(*) AS nobs\n            FROM\n                fare_detail\n            WHERE\n                rrd = 0\n                AND sample &gt;= ?2\n                AND scenario = ?1\n                AND orig = ?3\n                AND dest = ?4\n            GROUP BY\n                trial, sample, carrier, booking_class\n    ) tmp\n    GROUP BY carrier, booking_class\n    ORDER BY carrier, booking_class;\n    \"\"\"\n    return cnx.dataframe(qry, (scenario, burn_samples, orig, dest)).set_index(\n        [\"carrier\", \"booking_class\"]\n    )\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.path_forecasts", "title": "path_forecasts", "text": "<pre><code>path_forecasts(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame\n</code></pre> <p>Average forecasts of demand by path, class, and days to departure.</p> <p>This query requires that the simulation was run while recording path-class details (i.e. with the <code>pathclass</code> flag set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>             (<code>Database</code>)         \u2013          </li> <li> <code>scenario</code>             (<code>str</code>)         \u2013          </li> <li> <code>burn_samples</code>             (<code>int</code>, default:                 <code>100</code> )         \u2013          <p>The forecasts will be analyzed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>The resulting dataframe is indexed by <code>path_id</code>, <code>booking_class</code> and <code>rrd</code>, and has these columns:</p> <ul> <li><code>forecast_mean</code>: Average forecast mean (mu).</li> <li><code>forecast_stdev</code>: Average forecast standard deviation (sigma).</li> <li><code>forecast_closed_in_tf</code>: Average fraction of time the timeframe was     closed in the data used to make a forecast.</li> <li><code>forecast_closed_in_tf</code>: Average fraction of time any future timeframe     was closed in the data used to make a forecast.</li> </ul> </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def path_forecasts(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Average forecasts of demand by path, class, and days to departure.\n\n    This query requires that the simulation was run while recording path-class\n    details (i.e. with the `pathclass` flag set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The forecasts will be analyzed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The resulting dataframe is indexed by `path_id`, `booking_class` and\n        `rrd`, and has these columns:\n\n        - `forecast_mean`: Average forecast mean (mu).\n        - `forecast_stdev`: Average forecast standard deviation (sigma).\n        - `forecast_closed_in_tf`: Average fraction of time the timeframe was\n            closed in the data used to make a forecast.\n        - `forecast_closed_in_tf`: Average fraction of time any future timeframe\n            was closed in the data used to make a forecast.\n    \"\"\"\n    qry = \"\"\"\n    SELECT\n        path_id,\n        booking_class,\n        rrd,\n        AVG(forecast_mean) as forecast_mean,\n        AVG(forecast_stdev) as forecast_stdev,\n        AVG(forecast_closed_in_tf) as forecast_closed_in_tf,\n        AVG(forecast_closed_in_future) as forecast_closed_in_future\n    FROM\n        path_class_detail\n    WHERE\n        scenario = ?1\n        AND sample &gt;= ?2\n    GROUP BY\n        path_id, booking_class, rrd\n    \"\"\"\n    return cnx.dataframe(\n        qry,\n        (\n            scenario,\n            burn_samples,\n        ),\n    ).set_index([\"path_id\", \"booking_class\", \"rrd\"])\n</code></pre>"}, {"location": "API/database/common-queries.html#passengersim.database.common_queries.total_demand", "title": "total_demand", "text": "<pre><code>total_demand(\n    cnx: Database, scenario: str, burn_samples: int = 100\n) -&gt; float\n</code></pre> <p>Average total demand.</p> <p>This query requires that the simulation was run while recording final demand details (i.e. with the <code>demand</code> or <code>demand_final</code> flags set on <code>Config.db.write_items</code>).</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>             (<code>Database</code>)         \u2013          </li> <li> <code>scenario</code>             (<code>str</code>)         \u2013          </li> <li> <code>burn_samples</code>             (<code>int</code>, default:                 <code>100</code> )         \u2013          <p>The average total demand will be computed ignoring this many samples from the beginning of each trial.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>         \u2013          </li> </ul> Source code in <code>passengersim/database/common_queries.py</code> <pre><code>def total_demand(cnx: Database, scenario: str, burn_samples: int = 100) -&gt; float:\n    \"\"\"\n    Average total demand.\n\n    This query requires that the simulation was run while recording final demand\n    details (i.e. with the `demand` or `demand_final` flags set on `Config.db.write_items`).\n\n    Parameters\n    ----------\n    cnx : Database\n    scenario : str\n    burn_samples : int, default 100\n        The average total demand will be computed ignoring this many samples from the\n        beginning of each trial.\n\n    Returns\n    -------\n    float\n    \"\"\"\n    qry = \"\"\"\n    SELECT AVG(sample_demand)\n    FROM (\n        SELECT\n            trial, sample, SUM(sample_demand) AS sample_demand\n        FROM\n            demand_detail\n        WHERE\n            rrd = 0\n            AND sample &gt;= ?2\n            AND scenario = ?1\n        GROUP BY\n            trial, sample) tmp;\n    \"\"\"\n    return cnx.dataframe(qry, (scenario, burn_samples)).iloc[0, 0]\n</code></pre>"}, {"location": "API/database/tables.html", "title": "Tables", "text": ""}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_booking_curve", "title": "create_table_booking_curve", "text": "<pre><code>create_table_booking_curve(\n    cnx: Database, primary_key: bool = True\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_booking_curve(cnx: Database, primary_key: bool = True):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS booking_curve (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        carrier\t\t\tVARCHAR(10) NOT NULL,\n        orig\t\t\tVARCHAR(10) NOT NULL,\n        dest\t\t\tVARCHAR(10) NOT NULL,\n        flt_no\t\t\tINT NOT NULL,\n        rrd         \tINT NOT NULL,\n        ratio           FLOAT NOT NULL\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, carrier, orig, dest, flt_no, rrd)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_bookings_by_timeframe", "title": "create_table_bookings_by_timeframe", "text": "<pre><code>create_table_bookings_by_timeframe(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_bookings_by_timeframe(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS bookings_by_timeframe\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        trial       \tINT NOT NULL,\n        carrier\t\t\tVARCHAR(10) NOT NULL,\n        booking_class   VARCHAR(10) NOT NULL,\n        rrd       \t\tINT NOT NULL,\n        tot_sold\t\tFLOAT,\n        avg_sold\t\tFLOAT,\n        avg_business\tFLOAT,\n        avg_leisure     FLOAT,\n        avg_revenue     FLOAT,\n        avg_price       FLOAT,\n        updated_at\t\tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, carrier, booking_class, rrd)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_configs", "title": "create_table_configs", "text": "<pre><code>create_table_configs(cnx: Database)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_configs(cnx: Database):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS runtime_configs (\n        scenario\t\tTEXT PRIMARY KEY,\n        pxsim_version   TEXT,\n        configs         TEXT,\n        updated_at\t    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n    );\n    \"\"\"\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_demand_detail", "title": "create_table_demand_detail", "text": "<pre><code>create_table_demand_detail(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_demand_detail(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS demand_detail\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        iteration\t\tINT NOT NULL,\n        trial\t    \tINT NOT NULL,\n        sample  \t\tINT NOT NULL,\n        rrd     \t    INT NOT NULL,\n        segment\t\t\tVARCHAR(10) NOT NULL,\n        orig\t\t\tVARCHAR(10) NOT NULL,\n        dest\t\t\tVARCHAR(10) NOT NULL,\n        updated_at\t\tDATETIME NOT NULL DEFAuLT CURRENT_TIMESTAMP,\n        sample_demand   FLOAT,\n        sold\t\t\tINT,\n        no_go\t\t\tINT,\n        revenue\t\t\tFLOAT\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, rrd, segment, orig, dest)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_distance", "title": "create_table_distance", "text": "<pre><code>create_table_distance(\n    cnx: Database, primary_key: bool = True\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_distance(cnx: Database, primary_key: bool = True):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS distance (\n        orig\t\t\tVARCHAR(10) NOT NULL,\n        dest\t\t\tVARCHAR(10) NOT NULL,\n        miles           FLOAT\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(primary_key=\", PRIMARY KEY(orig, dest)\")\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_fare_detail", "title": "create_table_fare_detail", "text": "<pre><code>create_table_fare_detail(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_fare_detail(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS fare_detail\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        iteration\t\tINT NOT NULL,\n        trial\t    \tINT NOT NULL,\n        sample  \t\tINT NOT NULL,\n        rrd       \t\tINT NOT NULL,\n        carrier\t\t\tVARCHAR(10) NOT NULL,\n        orig\t\t\tVARCHAR(10) NOT NULL,\n        dest\t\t\tVARCHAR(10) NOT NULL,\n        booking_class   VARCHAR(10) NOT NULL,\n        sold\t\t\tINT,\n        sold_business\tINT,\n        price           FLOAT,\n        updated_at\t\tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, rrd, carrier, orig, dest, booking_class)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_leg_bucket_detail", "title": "create_table_leg_bucket_detail", "text": "<pre><code>create_table_leg_bucket_detail(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_leg_bucket_detail(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS leg_bucket_detail\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        iteration\t\tINT NOT NULL,\n        trial\t    \tINT NOT NULL,\n        sample  \t\tINT NOT NULL,\n        rrd         \tINT NOT NULL,\n        carrier\t\t\tVARCHAR(10) NOT NULL,\n        orig\t\t\tVARCHAR(10) NOT NULL,\n        dest\t\t\tVARCHAR(10) NOT NULL,\n        flt_no\t\t\tINT NOT NULL,\n        dep_date\t\tDATETIME NOT NULL,\n        bucket_number   INT NOT NULL,\n        name            VARCHAR(10) NOT NULL,\n        auth    \t\tINT,\n        revenue    \t\tFLOAT,\n        sold\t\t\tINT,\n        untruncated_demand     FLOAT,\n        forecast_mean   FLOAT,\n        forecast_stdev  FLOAT,\n        forecast_closed_in_tf FLOAT,\n        forecast_closed_in_future FLOAT,\n        updated_at\t\tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, rrd, \"\n            \"carrier, orig, dest, flt_no, dep_date, bucket_number)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_leg_detail", "title": "create_table_leg_detail", "text": "<pre><code>create_table_leg_detail(\n    cnx: Database, primary_key: bool = False\n) -&gt; None\n</code></pre> <p>Create the <code>leg_detail</code> table in the database.</p> <p>Parameters:</p> <ul> <li> <code>cnx</code>             (<code>Database</code>)         \u2013          </li> <li> <code>primary_key</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          </li> </ul> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_leg_detail(cnx: Database, primary_key: bool = False) -&gt; None:\n    \"\"\"\n    Create the `leg_detail` table in the database.\n\n    Parameters\n    ----------\n    cnx : Database\n    primary_key : bool, default False\n    \"\"\"\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS leg_detail\n    (\n        scenario\t    \tVARCHAR(20) NOT NULL,\n        iteration\t    \tINT NOT NULL,\n        trial\t        \tINT NOT NULL,\n        sample  \t    \tINT NOT NULL,\n        rrd             \tINT NOT NULL,\n        flt_no\t\t    \tINT NOT NULL,\n        updated_at\t    \tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        sold\t    \t\tINT,\n        revenue             FLOAT,\n        q_demand            FLOAT,\n        untruncated_demand  FLOAT,\n        forecast_mean       FLOAT,\n        bid_price           FLOAT\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, carrier, orig, dest, flt_no, rrd, dep_date)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_legs", "title": "create_table_legs", "text": "<pre><code>create_table_legs(\n    cnx: Database, legs: Iterable | None = None\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_legs(cnx: Database, legs: Iterable | None = None):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS leg_defs\n    (\n        flt_no INTEGER PRIMARY KEY,\n        carrier TEXT,\n        orig TEXT,\n        dest TEXT,\n        dep_time INTEGER,\n        arr_time INTEGER,\n        capacity INTEGER,\n        distance FLOAT\n    );\n    \"\"\"\n    cnx.execute(sql)\n    for leg in legs:\n        cnx.execute(\n            \"\"\"\n            INSERT OR REPLACE INTO leg_defs(\n                flt_no,\n                carrier,\n                orig,\n                dest,\n                dep_time,\n                arr_time,\n                capacity,\n                distance\n            ) VALUES (\n                ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8\n            )\n            \"\"\",\n            (\n                leg.flt_no,\n                leg.carrier,\n                leg.orig,\n                leg.dest,\n                leg.dep_time,\n                leg.arr_time,\n                leg.capacity,\n                leg.distance,\n            ),\n        )\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_path_class_detail", "title": "create_table_path_class_detail", "text": "<pre><code>create_table_path_class_detail(\n    cnx: Database, primary_key: bool = False\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_path_class_detail(cnx: Database, primary_key: bool = False):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS path_class_detail\n    (\n        scenario\t\tVARCHAR(20) NOT NULL,\n        iteration\t\tINT NOT NULL,\n        trial\t    \tINT NOT NULL,\n        sample  \t\tINT NOT NULL,\n        rrd         \tINT NOT NULL,\n        path_id\t\t\tINT NOT NULL,\n        booking_class   VARCHAR(10) NOT NULL,\n        sold\t\t\tINT,\n        revenue         FLOAT,\n        forecast_mean   FLOAT,\n        forecast_stdev  FLOAT,\n        forecast_closed_in_tf FLOAT,\n        forecast_closed_in_future FLOAT,\n        updated_at\t\tDATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n        {primary_key}\n    );\n    \"\"\"\n    if primary_key is True:\n        sql = sql.format(\n            primary_key=\", PRIMARY KEY(scenario, iteration, trial, sample, rrd, \"\n            \"path_id, booking_class)\"\n        )\n    else:\n        sql = sql.format(primary_key=\"\")\n    cnx.execute(sql)\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_table_path_defs", "title": "create_table_path_defs", "text": "<pre><code>create_table_path_defs(\n    cnx: Database, paths: Iterable | None = None\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_table_path_defs(cnx: Database, paths: Iterable | None = None):\n    sql = \"\"\"\n    CREATE TABLE IF NOT EXISTS path_defs\n    (\n        path_id INTEGER PRIMARY KEY,\n        carrier TEXT,\n        orig TEXT,\n        stop1 TEXT,\n        dest TEXT,\n        leg1 INTEGER,\n        leg2 INTEGER,\n        distance FLOAT\n    );\n    \"\"\"\n    cnx.execute(sql)\n    for pth in paths:\n        connects = pth.num_legs() &gt; 1\n        cnx.execute(\n            \"\"\"\n            INSERT OR REPLACE INTO path_defs(\n                path_id,\n                carrier,\n                orig,\n                stop1,\n                dest,\n                leg1,\n                leg2,\n                distance\n            ) VALUES (\n                ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8\n            )\n            \"\"\",\n            (\n                pth.path_id,\n                pth.get_leg_carrier(0),\n                pth.orig,\n                pth.get_leg_dest(0) if connects else None,\n                pth.dest,\n                pth.get_leg_fltno(0),\n                pth.get_leg_fltno(1) if connects else None,\n                pth.get_total_distance(),\n            ),\n        )\n</code></pre>"}, {"location": "API/database/tables.html#passengersim.database.tables.create_tables", "title": "create_tables", "text": "<pre><code>create_tables(\n    cnx: Database,\n    primary_keys: dict[str, bool] | None = None,\n)\n</code></pre> Source code in <code>passengersim/database/tables.py</code> <pre><code>def create_tables(cnx: Database, primary_keys: dict[str, bool] | None = None):\n    pk = dict(\n        leg=False,\n        leg_bucket=False,\n        demand=False,\n        fare=False,\n        booking_curve=True,\n        distance=True,\n        bookings=False,\n        path_class=False,\n    )\n    if primary_keys is not None:\n        pk.update(primary_keys)\n    create_table_configs(cnx)\n    create_table_leg_detail(cnx, pk[\"leg\"])\n    create_table_leg_bucket_detail(cnx, pk[\"leg_bucket\"])\n    create_table_demand_detail(cnx, pk[\"demand\"])\n    create_table_fare_detail(cnx, pk[\"fare\"])\n    create_table_bookings_by_timeframe(cnx, pk[\"bookings\"])\n    create_table_booking_curve(cnx, pk[\"booking_curve\"])\n    create_table_path_class_detail(cnx, pk[\"path_class\"])\n    create_table_distance(cnx, pk[\"distance\"])\n    cnx._commit_raw()\n</code></pre>"}, {"location": "Tutorials/index.html", "title": "Tutorials", "text": "<p>This section includes some tutorials to demonstrate some of the capabilities of PassengerSim.  These examples are built upon a very simple three market network with two airlines.  Each airline offers a pair of flights from BOS to ORD, and another pair from ORD to LAX.  Passenger demands are constructed for each single-leg market, as well as for the connecting market BOS-LAX.</p>"}, {"location": "Tutorials/index.html#3mkt-al1", "title": "3MKT AL1", "text": "<pre><code>graph LR\n    BOS--&gt;|101| ORD;\n    BOS--&gt;|102| ORD;\n    ORD--&gt;|111| LAX;\n    ORD--&gt;|112| LAX;</code></pre>"}, {"location": "Tutorials/index.html#3mkt-al2", "title": "3MKT AL2", "text": "<pre><code>graph LR\n    BOS--&gt;|201| ORD;\n    BOS--&gt;|202| ORD;\n    ORD--&gt;|211| LAX;\n    ORD--&gt;|212| LAX;</code></pre>"}, {"location": "Tutorials/3MKT/3mkt-01.nbconvert.html", "title": "Simple FCFS", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.17.0\npassengersim.core 0.17.0\n</pre> <p>This example uses network/01-base.yaml configuration file. Within a Jupyter notebook, we can directly initialize a PassengerSim <code>Simulation</code> instance from this file using the <code>from_yaml</code> class constructor:</p> In\u00a0[2]: Copied! <pre>sim = pax.Simulation.from_yaml(\"network/01-base.yaml\")\n</pre> sim = pax.Simulation.from_yaml(\"network/01-base.yaml\") <p>Running the simulation is as simple as calling the <code>run</code> command, which runs the simulation and returns a summary output object.</p> In\u00a0[3]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 19.73 seconds\n</pre> <p>The contents of the final summary is controlled by <code>Config.outputs.reports</code>, which allows the user to add reports for more detail, or drop some unneccessary reports to improve runtime (sometimes substantially).</p> In\u00a0[4]: Copied! <pre>sim.config.outputs.reports\n</pre> sim.config.outputs.reports Out[4]: <pre>{'bookings_by_timeframe',\n 'carrier_history',\n 'demand_to_come',\n 'fare_class_mix',\n 'leg_forecasts',\n 'load_factors',\n 'total_demand'}</pre> <p>For this example, several default reports are included, which allows us to access a number of pre-packaged visualizations for the results.</p> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_carrier_mileage()\n</pre> summary.fig_carrier_mileage() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[8]: <p>All demand is in the lowest fare class, because the simulation has no restrictions against customers simply buying the least expensive fare.</p> In\u00a0[9]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[9]: <p>We are not limited to the pre-packaged visualizations. The various summary tables available in the <code>summary</code> object are all just regular pandas DataFrames, so we can use all the usual Python and Pandas tools for analysis. For example, the <code>demand_to_come</code> table summarizes the total demand to come at each timeframe for every simulation sample.</p> In\u00a0[10]: Copied! <pre>summary.demand_to_come\n</pre> summary.demand_to_come Out[10]: rrd 63 56 49 42 35 31 28 24 21 17 14 10 7 5 3 1 0 iteration trial sample segment orig dest 0 0 100 business BOS LAX 65 61 57 55 51 51 49 48 42 39 39 31 25 19 14 4 0 ORD 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ORD LAX 68 63 59 59 54 52 50 48 47 44 36 32 25 20 16 4 0 leisure BOS LAX 71 58 56 49 43 39 35 30 28 21 16 12 7 7 4 1 0 ORD 49 43 39 34 32 31 27 24 19 15 13 11 11 10 6 1 0 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 9 499 business BOS ORD 66 62 55 52 50 48 46 44 42 39 36 26 21 17 9 3 0 ORD LAX 129 115 106 101 97 96 92 88 83 78 70 60 43 32 22 8 0 leisure BOS LAX 131 107 97 84 71 67 63 50 42 32 24 16 12 9 5 0 0 ORD 96 87 85 76 63 52 47 39 35 29 22 16 13 10 5 4 0 ORD LAX 156 128 117 105 85 75 72 57 46 33 28 20 15 11 6 3 0 <p>24000 rows \u00d7 17 columns</p> <p>With this data, we can do whatever analysis we like.  Here we'll compute the correlation between total demands (from the beginning of the booking curve at DCP 63 all the way to the end) of different passenger types in different markets.</p> In\u00a0[11]: Copied! <pre>summary.demand_to_come[63].unstack([\"segment\", \"orig\", \"dest\"]).corr()\n</pre> summary.demand_to_come[63].unstack([\"segment\", \"orig\", \"dest\"]).corr() Out[11]: segment business leisure orig BOS ORD BOS ORD dest LAX ORD LAX LAX ORD LAX segment orig dest business BOS LAX 1.000000 0.111814 0.146455 0.363078 0.122181 0.107158 ORD 0.111814 1.000000 0.102067 0.106161 0.327514 0.104558 ORD LAX 0.146455 0.102067 1.000000 0.144507 0.115454 0.352284 leisure BOS LAX 0.363078 0.106161 0.144507 1.000000 0.125014 0.105721 ORD 0.122181 0.327514 0.115454 0.125014 1.000000 0.103329 ORD LAX 0.107158 0.104558 0.352284 0.105721 0.103329 1.000000 <p>The <code>summary</code> object also has a command to dump all the summary tables to an Excel workbook, if you prefer to analyze the results there instead of in Jupyter.</p> In\u00a0[12]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-01.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-01.xlsx\") <p>Download 3mkt-01.xlsx</p> In\u00a0[13]: Copied! <pre>import targets\n\ntarget = targets.load(1, sim.config)\n</pre> import targets  target = targets.load(1, sim.config) In\u00a0[14]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[15]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=False, by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=False, by_class=True) Out[17]: <p>We can look at carrier forecasts of demand on individual legs.</p> In\u00a0[18]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=111, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=111, of=[\"mu\", \"sigma\"]) Out[18]: <p>We can compare the mean and standard deviation of demand to come.</p> In\u00a0[19]: Copied! <pre>comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\") Out[19]: <p>We can even take arbitrary functions that apply pandas tools, and have them run automatically against multiple summary objects. For example, we can look at the variance-covariance matrix of aggregate demand by passenger type, and compare those matrices for both the simulation and the target.</p> In\u00a0[20]: Copied! <pre>comps.apply(lambda s: s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov())\n</pre> comps.apply(lambda s: s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov()) Out[20]: segment business leisure source segment simulation business 3279.856113 1981.353347 leisure 1981.353347 5382.230033 target business 3249.598992 1955.419868 leisure 1955.419868 5359.555328"}, {"location": "Tutorials/3MKT/3mkt-01.nbconvert.html#simple-fcfs", "title": "Simple FCFS\u00b6", "text": "<p>This is a very simple network, with only 3 markets, used to demonstrate some features of PassengerSim.</p>"}, {"location": "Tutorials/3MKT/3mkt-01.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": "<p>In addition to summary reports for a single run, we can also use PassengerSim's <code>contrast</code> package to compare simulation runs to each other, or against exogenously defined target results.</p>"}, {"location": "Tutorials/3MKT/3mkt-02.nbconvert.html", "title": "FCFS with Product Restrictions", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.17.0\npassengersim.core 0.17.0\n</pre> <p>This example adds the network/02-buyup.yaml configuration file, to enable the product restrictions.</p> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml([\"network/01-base.yaml\", \"network/02-buyup.yaml\"])\n</pre> cfg = pax.Config.from_yaml([\"network/01-base.yaml\", \"network/02-buyup.yaml\"]) <p>The configuration can be manipulated in Python after loading.  This allows for a more interactive experience, where individual input values can readily be altered for a given analysis.</p> In\u00a0[3]: Copied! <pre>cfg.simulation_controls.num_trials = 4\n</pre> cfg.simulation_controls.num_trials = 4 <p>After all the desired changes have been completed, we use the <code>Config</code> to initialize the <code>Simulation</code>.</p> In\u00a0[4]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[5]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 9.59 seconds\n</pre> In\u00a0[6]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[9]: In\u00a0[10]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-02.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-02.xlsx\") <p>Download 3mkt-02.xlsx</p> In\u00a0[11]: Copied! <pre>import targets\n\ntarget = targets.load(2, cfg)\n</pre> import targets  target = targets.load(2, cfg) In\u00a0[12]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[13]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=111)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=111) Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=111, agg_booking_classes=True)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=111, agg_booking_classes=True) Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=101)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=101) Out[19]:"}, {"location": "Tutorials/3MKT/3mkt-02.nbconvert.html#fcfs-with-product-restrictions", "title": "FCFS with Product Restrictions\u00b6", "text": "<p>In this example, we add product restrictions to the simulation.  These restrictions will cause some passengers to \"buy up\" to a fare product other than the lowest price.</p>"}, {"location": "Tutorials/3MKT/3mkt-02.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-03.nbconvert.html", "title": "FCFS with AP and Product Restrictions", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.17.0\npassengersim.core 0.17.0\n</pre> <p>In prior examples, the configuration were given in one or more external file, passed to the <code>from_yaml</code> constructor as arguments.  We can also craft multi-line yaml content directly in a Python string, and pass that directly to the same contructor.  Here, we will turn the <code>disable_ap</code> switch off, and add a snapshot filter.</p> In\u00a0[2]: Copied! <pre>with_AP = \"\"\"\nsimulation_controls:\n  disable_ap: false\n\nsnapshot_filters:\n- type: leg_untruncation\n  airline: AL1\n  sample: 400\n  flt_no: 101\n  directory: snapshots/em\n\"\"\"\n</pre> with_AP = \"\"\" simulation_controls:   disable_ap: false  snapshot_filters: - type: leg_untruncation   airline: AL1   sample: 400   flt_no: 101   directory: snapshots/em \"\"\" <p>Snapshot filters can be triggered at limited specific points within a large simulation, and they will write out details intermediate results for that specific point.  The example snapshot filter here will provide extra output into the leg untruncation for a single flight on a single sample in the simulation.  Storing this level of detail for every flight for every sample would generally be gratuitous, slowing the simulation significantly and writing out excessively large files, but the snapshots give the ability to see and explore details from deep inside the simulation.</p> In\u00a0[3]: Copied! <pre>cfg = pax.Config.from_yaml([\n    \"network/01-base.yaml\", \n    \"network/02-buyup.yaml\", \n    with_AP\n])\n</pre> cfg = pax.Config.from_yaml([     \"network/01-base.yaml\",      \"network/02-buyup.yaml\",      with_AP ]) In\u00a0[4]: Copied! <pre>cfg.simulation_controls.num_trials = 4\n</pre> cfg.simulation_controls.num_trials = 4 In\u00a0[5]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[6]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 8.82 seconds\n</pre> In\u00a0[7]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[10]: In\u00a0[11]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-03.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-03.xlsx\") <p>Download 3mkt-03.xlsx</p> In\u00a0[12]: Copied! <pre>import targets\n\ntarget = targets.load(3, cfg)\n</pre> import targets  target = targets.load(3, cfg) In\u00a0[13]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[14]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=101)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=101) Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=111)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=111) Out[19]: In\u00a0[20]: Copied! <pre>contrast.fig_leg_forecasts(comps, of=[\"mu\", \"sigma\"], by_flt_no=101, agg_booking_classes=True)\n</pre> contrast.fig_leg_forecasts(comps, of=[\"mu\", \"sigma\"], by_flt_no=101, agg_booking_classes=True) Out[20]:"}, {"location": "Tutorials/3MKT/3mkt-03.nbconvert.html#fcfs-with-ap-and-product-restrictions", "title": "FCFS with AP and Product Restrictions\u00b6", "text": "<p>In this example, on top of product restrictions we also add advance purchase (AP) restrictions to the simulation.  These restrictions close lower priced fare class products as the day of departure approaches.</p> <p>In this example, we will also demostrate adding yaml configuration content in a Jupyter notebook before loading configs, and adding a snapshot filter to the simulation.</p>"}, {"location": "Tutorials/3MKT/3mkt-03.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-04.nbconvert.html", "title": "EMSR-B with Low Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.17.0\npassengersim.core 0.17.0\n</pre> <p>The yaml file for this example contains an explicit <code>include</code> instruction directly in the file. This emulates calling multiple file names in the <code>from_yaml</code> command, but the other file references are written directly into the code, so that groups of configurations can be managed together easily, without necessarily needing the user to carefully assemble the correct set of filenames every time they run the simulation.</p> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\nshow_file(\"network/04-emsrb-low-demand.yaml\")\n</pre> from passengersim.utils.codeview import show_file show_file(\"network/04-emsrb-low-demand.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 0.5\n\nairlines:\n  - name: AL1\n    rm_system: rm_no_detruncation\n  - name: AL2\n    rm_system: rm_no_detruncation\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml([\n    \"network/04-emsrb-low-demand.yaml\",\n])\n</pre> sim = pax.Simulation.from_yaml([     \"network/04-emsrb-low-demand.yaml\", ]) In\u00a0[4]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 17.74 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-04.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-04.xlsx\") <p>Download 3mkt-04.xlsx</p> In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(4, sim.config)\n</pre> import targets  target = targets.load(4, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[12]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[12]: In\u00a0[13]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[15]:"}, {"location": "Tutorials/3MKT/3mkt-04.nbconvert.html#emsr-b-with-low-demand", "title": "EMSR-B with Low Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Demand is simulated at a level 50% lower than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-04.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-05.nbconvert.html", "title": "EMSR-B", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.17.0\npassengersim.core 0.17.0\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\nshow_file(\"network/05-emsrb.yaml\")\n</pre> from passengersim.utils.codeview import show_file show_file(\"network/05-emsrb.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.0\n\nairlines:\n  - name: AL1\n    rm_system: rm_no_detruncation\n  - name: AL2\n    rm_system: rm_no_detruncation\n\ndb:\n  write_items:\n    - leg_final\n    - fare_final\n    - demand_final\n    - bookings\n    - bucket\n\noutputs:\n  reports:\n    - leg_forecasts\n    - fare_class_mix\n    - load_factors\n    - bookings_by_timeframe\n    - total_demand\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml([\n    \"network/05-emsrb.yaml\",\n])\n</pre> sim = pax.Simulation.from_yaml([     \"network/05-emsrb.yaml\", ]) In\u00a0[4]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 14.88 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-05.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-05.xlsx\") In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(5, sim.config)\n</pre> import targets  target = targets.load(5, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[12]: Copied! <pre>contrast.fig_carrier_revenues(comps)\n</pre> contrast.fig_carrier_revenues(comps) Out[12]: In\u00a0[13]: Copied! <pre>contrast.fig_carrier_load_factors(comps)\n</pre> contrast.fig_carrier_load_factors(comps) Out[13]: In\u00a0[14]: Copied! <pre>contrast.fig_fare_class_mix(comps)\n</pre> contrast.fig_fare_class_mix(comps) Out[14]: In\u00a0[15]: Copied! <pre>contrast.fig_leg_forecasts(comps, by_flt_no=101)\n</pre> contrast.fig_leg_forecasts(comps, by_flt_no=101) Out[15]: In\u00a0[16]: Copied! <pre>contrast.fig_leg_forecasts(comps, by_flt_no=111, of=[\"mu\", \"sigma\"])\n</pre> contrast.fig_leg_forecasts(comps, by_flt_no=111, of=[\"mu\", \"sigma\"]) Out[16]: In\u00a0[17]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_class=True, by_carrier=\"AL1\")\n</pre> contrast.fig_bookings_by_timeframe(comps, by_class=True, by_carrier=\"AL1\") Out[17]:"}, {"location": "Tutorials/3MKT/3mkt-05.nbconvert.html#emsr-b", "title": "EMSR-B\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Demand is simulated at normal levels.</p>"}, {"location": "Tutorials/3MKT/3mkt-05.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-06.nbconvert.html", "title": "EMSR-B with High Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.17.0\npassengersim.core 0.17.0\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\nshow_file(\"network/06-emsrb-high-demand.yaml\")\n</pre> from passengersim.utils.codeview import show_file show_file(\"network/06-emsrb-high-demand.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.1\n\nairlines:\n  - name: AL1\n    rm_system: rm_no_detruncation\n  - name: AL2\n    rm_system: rm_no_detruncation\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml([\n    \"network/06-emsrb-high-demand.yaml\",\n])\n</pre> sim = pax.Simulation.from_yaml([     \"network/06-emsrb-high-demand.yaml\", ]) In\u00a0[4]: Copied! <pre>summary = sim.run(log_reports=False)\n</pre> summary = sim.run(log_reports=False) <pre></pre> <pre>\n</pre> <pre>Task Completed after 20.53 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-06.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-06.xlsx\") In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(6, sim.config)\n</pre> import targets  target = targets.load(6, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[12]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[12]: In\u00a0[13]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"]) Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=211, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=211, of=[\"mu\", \"sigma\"]) Out[17]:"}, {"location": "Tutorials/3MKT/3mkt-06.nbconvert.html#emsr-b-with-high-demand", "title": "EMSR-B with High Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Demand is simulated at a level 10% higher than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-06.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-07.nbconvert.html", "title": "EM Untruncation with Low Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.17.0\npassengersim.core 0.17.0\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\nshow_file(\"network/07-untrunc-em-low-demand.yaml\")\n</pre> from passengersim.utils.codeview import show_file show_file(\"network/07-untrunc-em-low-demand.yaml\") <pre>include:\n  - 08-untrunc-em.yaml\n\nsimulation_controls:\n  demand_multiplier: 0.5\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml([\n    \"network/07-untrunc-em-low-demand.yaml\",\n])\n</pre> sim = pax.Simulation.from_yaml([     \"network/07-untrunc-em-low-demand.yaml\", ]) In\u00a0[4]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 18.60 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-07.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-07.xlsx\") In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(7, sim.config)\n</pre> import targets  target = targets.load(7, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[12]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\")\n</pre> contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\") Out[12]: In\u00a0[13]: Copied! <pre>contrast.fig_carrier_revenues(comps)\n</pre> contrast.fig_carrier_revenues(comps) Out[13]: In\u00a0[14]: Copied! <pre>contrast.fig_fare_class_mix(comps)\n</pre> contrast.fig_fare_class_mix(comps) Out[14]: In\u00a0[15]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\", by_class=True)\n</pre> contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\", by_class=True) Out[15]:"}, {"location": "Tutorials/3MKT/3mkt-07.nbconvert.html#em-untruncation-with-low-demand", "title": "EM Untruncation with Low Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Additionally, the EM algorithm is employed to detruncate censored demand. Demand is simulated at a level 50% lower than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-07.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-08.nbconvert.html", "title": "EM Untruncation", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.17.0\npassengersim.core 0.17.0\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/08-untrunc-em.yaml\")\n</pre> show_file(\"network/08-untrunc-em.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.0\n\nrm_systems:\n  rm_test1:\n    availability_control: leg\n    processes:\n      DCP:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        name: forecast\n        algorithm: additive_pickup\n        alpha: 0.15\n        kind: leg\n      - step_type: emsr\n        name: optimization\n        algorithm: emsrb\n        kind: leg\n\nairlines:\n  - name: AL1\n    rm_system: rm_test1\n  - name: AL2\n    rm_system: rm_test1\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml([\n    \"network/08-untrunc-em.yaml\",\n])\n</pre> cfg = pax.Config.from_yaml([     \"network/08-untrunc-em.yaml\", ]) In\u00a0[5]: Copied! <pre>cfg.simulation_controls.num_trials = 6\n</pre> cfg.simulation_controls.num_trials = 6 In\u00a0[6]: Copied! <pre>cfg.outputs.reports.add(\"local_and_flow_yields\")\n</pre> cfg.outputs.reports.add(\"local_and_flow_yields\") In\u00a0[7]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[8]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 13.33 seconds\n</pre> In\u00a0[9]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[11]: In\u00a0[12]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[12]: In\u00a0[13]: Copied! <pre>summary.local_and_flow_yields\n</pre> summary.local_and_flow_yields Out[13]: flt_no carrier orig dest capacity distance local_yield local_fraction flow_yield 0 101 AL1 BOS ORD 100 863.753282 0.228001 0.420964 0.160534 1 102 AL1 BOS ORD 100 863.753282 0.228167 0.418236 0.161452 2 111 AL1 ORD LAX 120 1739.799337 0.176072 0.547242 0.160534 3 112 AL1 ORD LAX 120 1739.799337 0.175771 0.546325 0.161452 4 201 AL2 BOS ORD 100 863.753282 0.228358 0.419200 0.161371 5 202 AL2 BOS ORD 100 863.753282 0.227649 0.418352 0.160918 6 211 AL2 ORD LAX 120 1739.799337 0.176223 0.545831 0.161371 7 212 AL2 ORD LAX 120 1739.799337 0.176275 0.546105 0.160918 In\u00a0[14]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-08.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-08.xlsx\") In\u00a0[15]: Copied! <pre>import targets\ntarget = targets.load(8, cfg)\n</pre> import targets target = targets.load(8, cfg) In\u00a0[16]: Copied! <pre>from passengersim import contrast\n</pre> from passengersim import contrast In\u00a0[17]: Copied! <pre>comps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[18]: Copied! <pre>comps.fig_demand_to_come(\"mean\")\n</pre> comps.fig_demand_to_come(\"mean\") Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"std\") Out[19]: In\u00a0[20]: Copied! <pre>comps.apply(\n    lambda s: (\n        s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov()\n    )\n)\n</pre> comps.apply(     lambda s: (         s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov()     ) ) Out[20]: segment business leisure source segment simulation business 3263.099012 1976.758878 leisure 1976.758878 5291.913397 target business 3249.598992 1955.419868 leisure 1955.419868 5359.555328 In\u00a0[21]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\",  by_class=True)\n</pre> contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\",  by_class=True) Out[21]: In\u00a0[22]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[22]: In\u00a0[23]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[23]: In\u00a0[24]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[24]: In\u00a0[25]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[25]: In\u00a0[26]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"]) Out[26]: In\u00a0[27]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"]) Out[27]: In\u00a0[28]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=111, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=111, of=[\"mu\", \"sigma\"]) Out[28]:"}, {"location": "Tutorials/3MKT/3mkt-08.nbconvert.html#em-untruncation", "title": "EM Untruncation\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Additionally, the EM algorithm is employed to detruncate censored demand. Demand is simulated at normal levels.</p>"}, {"location": "Tutorials/3MKT/3mkt-08.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-09.nbconvert.html", "title": "EM Untruncation with High Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.17.0\npassengersim.core 0.17.0\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/09-untrunc-em-high-demand.yaml\")\n</pre> show_file(\"network/09-untrunc-em-high-demand.yaml\") <pre>include:\n  - 08-untrunc-em.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.1\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml([\n    \"network/09-untrunc-em-high-demand.yaml\",\n])\n</pre> cfg = pax.Config.from_yaml([     \"network/09-untrunc-em-high-demand.yaml\", ]) In\u00a0[5]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[6]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 23.08 seconds\n</pre> In\u00a0[7]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[10]: In\u00a0[11]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-09.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-09.xlsx\") In\u00a0[12]: Copied! <pre>import targets\n\ntarget = targets.load(9, cfg)\n</pre> import targets  target = targets.load(9, cfg) In\u00a0[13]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[14]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=False, by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=False, by_class=True) Out[19]: In\u00a0[20]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"]) Out[20]: In\u00a0[21]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=111, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=111, of=[\"mu\", \"sigma\"]) Out[21]: In\u00a0[22]: Copied! <pre>from passengersim.utils.targets import computed_targets\n\nc_targets = computed_targets(cfg)\n</pre> from passengersim.utils.targets import computed_targets  c_targets = computed_targets(cfg) In\u00a0[23]: Copied! <pre>contrast.fig_bookings_by_timeframe({\n    \"c_targets\": c_targets,\n    \"simulation\": summary,\n    \"target\": target,\n}, by_carrier=False, by_class=True)\n</pre> contrast.fig_bookings_by_timeframe({     \"c_targets\": c_targets,     \"simulation\": summary,     \"target\": target, }, by_carrier=False, by_class=True) Out[23]:"}, {"location": "Tutorials/3MKT/3mkt-09.nbconvert.html#em-untruncation-with-high-demand", "title": "EM Untruncation with High Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Additionally, the EM algorithm is employed to detruncate censored demand. Demand is simulated at a level 10% higher than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-09.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-10.nbconvert.html", "title": "ProBP", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.17.0\npassengersim.core 0.17.0\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/10-probp.yaml\")\n</pre> show_file(\"network/10-probp.yaml\") <pre>include:\n  - 08-untrunc-em.yaml\n\nscenario: 3MKTproBP\n\ndb:\n  write_items:\n    - leg_final\n    - fare_final\n    - demand_final\n    - bookings\n    - bucket\n    - pathclass\n    - leg\n    - demand\n\nsimulation_controls:\n  num_trials: 4 # 10\n  show_progress_bar: false\n\nrm_systems:\n  rm_probp:\n    availability_control: bp\n    processes:\n      DCP:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: em\n        kind: path\n      - step_type: forecast\n        name: path_forecast\n        algorithm: additive_pickup\n        kind: path\n      - step_type: probp\n        name: optimization\n      - step_type: aggregation  # not needed for algorithm, but gives leg forecast data for output\n        name: aggregate\n\nairlines:\n  - name: AL1\n    rm_system: rm_probp\n  - name: AL2\n    rm_system: rm_probp\n\nsnapshot_filters:\n   - type: pro_bp\n     title: ProBP Snapshot\n     sample: [120, 290, 499]\n     dcp: [63, 56, 21]\n     flt_no: 111\n     airline: AL1\n     directory: snapshots/probp\n\noutputs:\n  reports:\n    - fare_class_mix\n    - load_factors\n    - bookings_by_timeframe\n    - total_demand\n    - leg_forecasts\n    - path_forecasts\n    - [od_fare_class_mix, BOS, ORD]\n    - [od_fare_class_mix, BOS, LAX]\n    - [od_fare_class_mix, ORD, LAX]\n    - demand_to_come\n    - carrier_history\n    - bid_price_history\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml([\n    \"network/10-probp.yaml\",\n])\n</pre> cfg = pax.Config.from_yaml([     \"network/10-probp.yaml\", ]) In\u00a0[5]: Copied! <pre>cfg.simulation_controls.num_trials = 6\n</pre> cfg.simulation_controls.num_trials = 6 In\u00a0[6]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[7]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() In\u00a0[8]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[11]: In\u00a0[12]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-10.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-10.xlsx\") In\u00a0[13]: Copied! <pre>import targets\n\ntarget = targets.load(10, cfg)\n</pre> import targets  target = targets.load(10, cfg) In\u00a0[14]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[15]: Copied! <pre>comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\") Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[19]: In\u00a0[20]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True, source_labels=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True, source_labels=True) Out[20]: In\u00a0[21]: Copied! <pre>print(sim.path_names()[1])\ncomps.fig_path_forecasts(by_path_id=1, of=['mu', 'sigma', 'closed'])\n</pre> print(sim.path_names()[1]) comps.fig_path_forecasts(by_path_id=1, of=['mu', 'sigma', 'closed']) <pre>Path: BOS ORD (AL1:101 BOS-ORD)\n</pre> Out[21]: In\u00a0[22]: Copied! <pre>print(sim.path_names()[5])\ncomps.fig_path_forecasts(by_path_id=5, of=['mu', 'sigma', 'closed'])\n</pre> print(sim.path_names()[5]) comps.fig_path_forecasts(by_path_id=5, of=['mu', 'sigma', 'closed']) <pre>Path: ORD LAX (AL1:111 ORD-LAX)\n</pre> Out[22]: In\u00a0[23]: Copied! <pre>print(sim.path_names()[9])\ncomps.fig_path_forecasts(by_path_id=9, of=['mu', 'sigma', 'closed'])\n</pre> print(sim.path_names()[9]) comps.fig_path_forecasts(by_path_id=9, of=['mu', 'sigma', 'closed']) <pre>Path: BOS LAX (AL1:101 BOS-ORD, AL1:111 ORD-LAX)\n</pre> Out[23]: In\u00a0[24]: Copied! <pre>comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\")\n</pre> comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\") Out[24]: In\u00a0[25]: Copied! <pre>comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\", show_stdev=1)\n</pre> comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\", show_stdev=1) Out[25]: In\u00a0[26]: Copied! <pre>from passengersim.extra.forecast_viz import fig_forecasts_and_bid_prices\n</pre> from passengersim.extra.forecast_viz import fig_forecasts_and_bid_prices In\u00a0[27]: Copied! <pre>fig_forecasts_and_bid_prices(\n    sim,\n    trial = 0,\n    rrd = 63,\n    flt_no = 111,\n)\n</pre> fig_forecasts_and_bid_prices(     sim,     trial = 0,     rrd = 63,     flt_no = 111, ) Out[27]: In\u00a0[28]: Copied! <pre>fig_forecasts_and_bid_prices(\n    sim,\n    trial = 0,\n    rrd = 63,\n    flt_no = 101,\n)\n</pre> fig_forecasts_and_bid_prices(     sim,     trial = 0,     rrd = 63,     flt_no = 101, ) Out[28]:"}, {"location": "Tutorials/3MKT/3mkt-10.nbconvert.html#probp", "title": "ProBP\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-10.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-98.nbconvert.html", "title": "Retrospective Analysis", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.17.0\npassengersim.core 0.17.0\n</pre> <p>We can load in <code>SummaryTables</code> objects directly from the database created during a simulation run (assuming it was saved to disk).  For this demo, we have created two small such databases by running two different models with on-disk database files, and then discarding the results (for now). We can then load summary tables of results from these two simulations by using the <code>SummaryTables.from_sqlite</code> constructor.  This command will run queries against the database to reconstruct the same summary table objects we would have gotten as the output from running the simulation.</p> In\u00a0[3]: Copied! <pre>simple = pax.SummaryTables.from_sqlite(\"simple.sqlite\")\nuntrunc = pax.SummaryTables.from_sqlite(\"untruncated.sqlite\")\n</pre> simple = pax.SummaryTables.from_sqlite(\"simple.sqlite\") untrunc = pax.SummaryTables.from_sqlite(\"untruncated.sqlite\") In\u00a0[4]: Copied! <pre>from passengersim.contrast import Contrast\n\ncomps = Contrast(\n    Simple=simple, Untruncated=untrunc\n)\n</pre> from passengersim.contrast import Contrast  comps = Contrast(     Simple=simple, Untruncated=untrunc ) <p>All the same visualizations available in our prior demonstrations are also available for use with the pre-computed results. Since we are not actually running the simulation again, this analysis can even be done by users who don't have (or need) access to the PassengerSim core simulation code.</p> In\u00a0[5]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True, source_labels=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True, source_labels=True) Out[8]: <p>The results of the simulation are stored in database tables.  We can write queries using typical SQLite syntax against the database directly if we like. For convenience, the SQLite database connection used to populate the summary tables is available as the <code>cnx</code> attribute of the SummaryTables object, and we can use its <code>dataframe</code> method to run arbitrary queries and get the results as a pandas DataFrame.</p> In\u00a0[9]: Copied! <pre>simple.cnx.dataframe(\"\"\"\nSELECT\n  sample, auth, sold, forecast_mean, forecast_stdev\nFROM \n  leg_bucket_detail \nWHERE\n  flt_no = 101\n  AND rrd = 21\n  AND name = 'Y2'\n  AND sample &gt;= 100\nLIMIT 10\n\"\"\")\n</pre> simple.cnx.dataframe(\"\"\" SELECT   sample, auth, sold, forecast_mean, forecast_stdev FROM    leg_bucket_detail  WHERE   flt_no = 101   AND rrd = 21   AND name = 'Y2'   AND sample &gt;= 100 LIMIT 10 \"\"\") Out[9]: sample auth sold forecast_mean forecast_stdev 0 100 53 2 7.230769 2.804392 1 101 53 2 6.961538 3.052616 2 102 25 1 6.807692 3.098635 3 103 14 2 7.038462 3.255528 4 104 28 6 6.730769 3.244166 5 105 29 3 6.884615 3.253637 6 106 14 1 6.653846 3.309892 7 107 44 3 6.769231 3.191334 8 108 39 3 6.807692 3.212715 9 109 37 2 7.115385 3.409715"}, {"location": "Tutorials/3MKT/3mkt-98.nbconvert.html#retrospective-analysis", "title": "Retrospective Analysis\u00b6", "text": "<p>In this example, we will demonstrate some analysis that is reading back results of prior completed simulation run.  This is possible because PassengerSim can be configured to write out quite a bit of data to a SQLite database while running.  Much of this output is optional, as writing out intermediate results can create very large database files and impose a significant runtime penalty on the simulation, but having the ability to do so is advantageous for research and development purposes.</p>"}, {"location": "user-guide/cli.html", "title": "Command Line Interface", "text": "<p>AirSim Command Line Interface</p> <p>Usage:</p> <pre><code>$ python -m AirSim [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>info</code></li> <li><code>run</code></li> </ul>"}, {"location": "user-guide/cli.html#python-m-airsim-info", "title": "<code>python -m AirSim info</code>", "text": "<p>Usage:</p> <pre><code>$ python -m AirSim info [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul>"}, {"location": "user-guide/cli.html#python-m-airsim-run", "title": "<code>python -m AirSim run</code>", "text": "<p>Usage:</p> <pre><code>$ python -m AirSim run [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>-n, --network-file PATH</code>: A file that defines the network and various simulation options.  [required]</li> <li><code>-a, --airports-file PATH</code>: A file that defines the airports used in the simulation.</li> <li><code>-o, --out-dir PATH</code>: Out files are written to this directory.</li> <li><code>--db-engine TEXT</code>: [default: sqlite]</li> <li><code>--db-filename TEXT</code>: Use this filename for the output database file. Applies to the the SQLite engine only.  [default: airsim-output.sqlite]</li> <li><code>--fast / --slow</code>: For the SQLite engine only, running in 'fast' mode will store everything in an in-memory first, and dump the entire database to disk only when the simulation is complete.  This can be quite advantageous when the write speed of the disk is slow.  [default: slow]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"}, {"location": "user-guide/how-it-works.html", "title": "How PassengerSim Works", "text": "<p>PasengerSim is a tool that simulates several aspects of passenger travel, including airline revenue management operations, market level passenger demand, and individual  customer choice processes.</p>"}, {"location": "user-guide/how-it-works.html#counting-simulations", "title": "Counting Simulations", "text": "<p>A simulation run consists of a number of independent trials, and each trial is  made up of a sequence of dependent samples -- earlier samples in a trial are used to develop forecasts and train optimization algorithms used by carriers in later samples of the same trial.</p> <p>The number of trials is set by the  <code>num_trials</code> configuration, and the number of samples in each trial is set by <code>num_samples</code>. Both values can be found in the <code>simulation_controls</code> configuration inputs.</p> <p>We can think of a sample as a \"typical\" departure day.  When generating results,  the first X samples from each trial as these are during a \"burn period\" when the  simulation is getting started and sufficient history is being generated to use  for forecasts and other steps.  The nuber of samples in the burn period is set by the <code>burn_samples</code>  configuration value.</p>"}, {"location": "user-guide/how-it-works.html#simulation-randomness", "title": "Simulation Randomness", "text": ""}, {"location": "user-guide/how-it-works.html#demand-generation-k-factors", "title": "Demand Generation K-Factors", "text": "<p>There are multiple sources of variability that is introduced in the simulation. Variability in the level of demand by passenger type on any given day for any origin-destination pair is controlled by a number of k-factors, which are used  to create some correlation across various dimensions of demand.</p> <p>Three k-factors are used to introduce correlation in demand across all markets in  the system and between business/leisure demand within a market. The equation to  generate the mean demand for a given market and passenger type  is given as: </p> <p>\\(\\mu'_{OD-Biz} = \\mu_{OD-Biz} + (SRN \\times k_{sys}) + (MRN \\times k_{mkt}) + (PRN \\times k_{paxtype})\\) </p> <p>where SRN, MRN, and PRN are random numbers associated with the system, market,  and passenger k-factors, respectively.</p> <p>The intuition behind using three k-factors is that even across a \"typical\" departure  day (like Wednesdays) we may have high demand days across the system and low demand  days across the system.  Likewise, if business demand is above average, we expect  that leisure demand may also be above average. Intuitively, when generating demands,  for a given sample (or departure day in the simulation), we add the term  (SRN x <code>sys_k_factor</code>) to every single market and passenger in the system for that  departure day, we add a unique (MRN x <code>mkt_k_factor</code>) to each origin-destination  market in the sample, and we add a unique (PRN x <code>pax_type_k_factor</code>) for each  passenger type within the market. The addition of the (SRN x <code>sys_k_factor</code>) to  \"everything\" in the sample creates a system-level correlation (i.e., demand on  a given departure date or sample could be \"high\" across the system or \"low\"  compared to average).  </p> <p>The addition of the (MRN x <code>mkt_k_factor</code>) to a market creates a market-level  correlation (i.e., if business demand is running higher than average in the  market, we expect leisure demand will run higher than average in general as  well).  </p> <p>The use of the (PRN x <code>pax_type_k_factor</code>) ensures that there is some random  component that is independent between business and leisure passengers in a  given market.</p> <p>In addition to the k-factors that are used to introduce correlation, we have a z-factor. We assume that actual demand, given mean demand, will vary across samples (or  departure dates) according to a constant z-factor given as \\(\\mu\\) divided by \\(\\sigma^2\\). </p> <p>Given different levels of aggregation, we expect that <code>sys_k_factor</code> &lt; <code>mkt_k_factor</code> &lt; <code>pax_type_k_factor</code>.</p> <p>Once we generate the means and std dev for correlated demands by OD and pax type  using the methodology described above, we use these to generate the \u201cactual\u201d demands  for a sample using the equation</p> <p>\\(\\mu'_{OD-Biz} + NRV x \\sigma'_{OD-Biz}\\), </p> <p>where NRV is a normal random variable.</p>"}, {"location": "user-guide/how-it-works.html#demand-allocation-to-time-periods", "title": "Demand Allocation to Time Periods", "text": "<p>The demand generation above is used to find the total demand for each passenger type in each market on each travel day.  This total value is subsequently distributed  over the booking time periods.</p> <p>While the methodology for this is not (yet) explained here, note that the <code>tf_k_factor</code>  is used to generate variability in how demand is allocated to the different time  frames (also using the booking curves as a key input).</p>"}, {"location": "user-guide/installation.html", "title": "Installation", "text": "<p>Install instructions will be here.</p>"}, {"location": "user-guide/installation.html#docker-quick-start", "title": "Docker Quick-start", "text": "<p>Do you have a link to a <code>sky</code> docker image file? If not, these are not the install instructions you are looking for. If you do have a link, go ahead and download the file.  If you are installing on Windows or an Intel-based Mac, you want the amd64 image.  For installing on more recent Apple Silicon-based Macs, use an arm64 image.</p> <p>In addition to the image file, you'll want to download and install Docker Desktop for your computer.  Once it's installed, make sure it's running (you should be able to open and see Docker's dashboard).</p> <p>Then, open a console terminal and change to the directory where the docker image <code>sky.tar</code> file has been saved.  It might be named something slightly different from <code>sky.tar</code>, in which case change the filename in the commands you type to match the filename of the image file you have.  The first step is to run</p> <pre><code>docker load --input sky.tar\n</code></pre> <p>This command may take a few moments to complete, as the content of the downloaded image file will be imported into docker.  You'll need several free gigabytes of hard disk space to complete this step, so if you encounter unexplained EOF errors here that may be the problem.</p> <p>After the docker image is loaded, you should see a <code>sky</code> image in the docker desktop dashboard.  If you can see it, you should then be able to start a container with this image using the following command:</p> Mac/LinuxWindows <pre><code>docker run -p 8899:8899 --rm --volume \"$(pwd)\":/tmp/workplace/work sky:latest\n</code></pre> <pre><code>docker run -p 8899:8899 --rm --volume \"%cd%\":/tmp/workplace/work sky:latest\n</code></pre> <p>Within this command, we have:</p> <ul> <li><code>-p 8899:8899</code> tells docker to expose the container's port 8899 (which has been   configured to be the port served by Jupyter Lab) to localhost.</li> <li><code>--rm</code> means to remove the container when it exits, so there isn't an   extraneous container image file left on your file system.</li> <li><code>--volume \"...\":/tmp/workplace/work</code> makes the current working directory   available inside Jupyter Lab in a directory named <code>work</code> (the container has   been configured with <code>/tmp/workplace</code> as the base location for Jupyter).</li> <li><code>sky:latest</code> tells Docker to use the latest version of the user image   that was installed in the <code>docker load</code> step above.  If your installed   docker image (as shown in the Docker Dashboard) has a different name than   <code>sky</code> then change the command to give the corrent image name.</li> </ul>"}, {"location": "user-guide/untruncation.html", "title": "Untruncation", "text": "<p>Write a description of this concept here.</p>"}, {"location": "user-guide/writing-configs.html", "title": "Config Files", "text": "<p>Most control of the simulation is done via configuration files written in YAML format.</p>"}, {"location": "user-guide/writing-configs.html#simulation-controls", "title": "Simulation Controls", "text": "<pre><code>scenario: Three Market Test Network\nsimulation_controls:\n  random_seed: 42\n  num_trials: 1\n  num_samples: 300\n  sys_k_factor: 0.1\n  mkt_k_factor: 0.2\n  pax_type_k_factor: 0.4\n  tf_k_factor: 0.1\n  tot_z_factor: 2.0\n  tf_z_factor: 2.0\n  prorate_revenue: true\n  dwm_lite: false\n  max_connect_time: 120\n  disable_ap: false\n  demand_multiplier: 1.0\n  manual_paths: true\n</code></pre>"}, {"location": "user-guide/writing-configs.html#rm-systems", "title": "RM Systems", "text": "<p>The <code>rm_systems</code> key allows the user to define one or more revenue management systems that may be used by carriers.</p> <p>These systems can either be defined as a list, where each item in the list defines both a name and steps, or you can write the same instruction as a nested mapping, with the names as keys and the values giving the other attributes of each RM system, (for now, just a list of steps) like this:</p> as listas dict <p><pre><code>rm_systems:\n- name: rm_test1\n  steps:\n  - step_type: untruncation  #(1)!\n    name: untruncation\n    algorithm: em\n    kind: leg\n  - step_type: forecast\n    name: forecast\n    algorithm: exp_smoothing\n    alpha: 0.1\n    kind: leg\n  - step_type: optimization\n    name: optimization\n    algorithm: emsrb  #(2)!\n    kind: leg\n</code></pre></p> <ol> <li> Untruncation allows us to figure out how much demand was censored.</li> <li>If you define different RM systems, you can attach different optimization algorithms, such as     ProBP.</li> </ol> <p><pre><code>rm_systems:\n  rm_test1:\n    steps:\n    - step_type: untruncation  #(1)!\n      name: untruncation\n      algorithm: em\n      kind: leg\n    - step_type: forecast\n      name: forecast\n      algorithm: exp_smoothing\n      alpha: 0.1\n      kind: leg\n    - step_type: optimization\n      name: optimization\n      algorithm: emsrb  #(2)!\n      kind: leg\n</code></pre></p> <ol> <li> Untruncation allows us to figure out how much demand was censored.</li> <li>If you define different RM systems, you can attach different optimization algorithms, such as     ProBP.</li> </ol>"}, {"location": "user-guide/writing-configs.html#passenger-choice-models", "title": "Passenger Choice Models", "text": "<pre><code>choice_models:\n  business:\n    kind: pods\n    emult: 1.6\n    basefare_mult: 2.5\n    path_quality:  [38.30,  0.10]\n    preferred_airline:  [-12.29,  0.17]\n    tolerance: 2.0\n    r1: 0.30\n    r2: 0.10\n    r3: 0.20\n    r4: 0.15\n  leisure:\n    kind: pods\n    emult: 1.5\n    basefare_mult: 1.0\n    path_quality:  [2.02, 0.12]\n    preferred_airline:  [-1.98, 0.11]\n    tolerance: 5.0\n    r1: 0.30\n    r2: 0.15\n    r3: 0.25\n    r4: 0.20\n</code></pre>"}, {"location": "user-guide/writing-configs.html#define-carriers", "title": "Define Carriers", "text": "<pre><code>airlines:\n- name: AL1\n  rm_system: rm_test1\n- name: AL2\n  rm_system: rm_test1\n- name: AL3\n  rm_system: rm_test1\n- name: AL4\n  rm_system: rm_test1\n</code></pre>"}, {"location": "user-guide/writing-configs.html#define-booking-classes", "title": "Define Booking Classes", "text": "<pre><code>classes:\n- Y0\n- Y1\n- Y2\n- Y3\n- Y4\n- Y5\n- Y6\n- Y7\n- Y8\n- Y9\n</code></pre>"}, {"location": "user-guide/writing-configs.html#data-collection-points-dcps", "title": "Data Collection Points (DCPs)", "text": "<pre><code>dcps:\n- 63\n- 56\n- 49\n- 42\n- 35\n- 31\n- 28\n- 24\n- 21\n- 17\n- 14\n- 10\n- 7\n- 5\n- 3\n- 1\n</code></pre>"}, {"location": "user-guide/writing-configs.html#booking-curves", "title": "Booking Curves", "text": "<pre><code>booking_curves:\n- name: '1'\n  curve:\n    63: 0.01\n    56: 0.02\n    49: 0.05\n    42: 0.13\n    35: 0.19\n    31: 0.23\n    28: 0.29\n    24: 0.35\n    21: 0.45\n    17: 0.54\n    14: 0.67\n    10: 0.79\n    7: 0.86\n    5: 0.91\n    3: 0.96\n    1: 1.0\n- name: '2'\n  curve:\n    63: 0.13\n    56: 0.22\n    49: 0.37\n    42: 0.52\n    35: 0.64\n    31: 0.7\n    28: 0.75\n    24: 0.78\n    21: 0.83\n    17: 0.87\n    14: 0.91\n    10: 0.94\n    7: 0.96\n    5: 0.98\n    3: 0.99\n    1: 1.0\n- name: '3'\n  curve:\n    63: 0.04\n    56: 0.06\n    49: 0.12\n    42: 0.26\n    35: 0.35\n    31: 0.41\n    28: 0.48\n    24: 0.54\n    21: 0.63\n    17: 0.7\n    14: 0.81\n    10: 0.88\n    7: 0.93\n    5: 0.96\n    3: 0.98\n    1: 1.0\n- name: '4'\n  curve:\n    63: 0.21\n    56: 0.35\n    49: 0.53\n    42: 0.67\n    35: 0.76\n    31: 0.8\n    28: 0.83\n    24: 0.85\n    21: 0.88\n    17: 0.91\n    14: 0.94\n    10: 0.96\n    7: 0.97\n    5: 0.98\n    3: 0.99\n    1: 1.0\n</code></pre>"}, {"location": "user-guide/writing-configs.html#legs", "title": "Legs", "text": "<pre><code>legs:\n- carrier: AL1\n  fltno: 1\n  orig: BOS\n  dest: SFO\n  date: '2020-01-01'\n  dep_time: 08:00\n  arr_time: '10:00'\n  capacity: 100\n  distance: 867.0\n- carrier: AL2\n  fltno: 2\n  orig: BOS\n  dest: SFO\n  date: '2020-01-01'\n  dep_time: '14:00'\n  arr_time: '16:00'\n  capacity: 100\n  distance: 867.0\n...\n</code></pre>"}, {"location": "user-guide/writing-configs.html#paths", "title": "Paths", "text": "<pre><code>paths:\n- orig: BOS\n  dest: SFO\n  path_quality_index: 1.0\n  legs:\n  - 1\n- orig: BOS\n  dest: SFO\n  path_quality_index: 1.0\n  legs:\n  - 2\n- orig: BOS\n  dest: ORD\n  path_quality_index: 1.0\n  legs:\n  - 3\n...\n</code></pre>"}, {"location": "user-guide/database/index.html", "title": "Database", "text": "<p>The default data storage solution for PassengerSim is a SQLite database file.</p>"}, {"location": "user-guide/database/index.html#database-tables", "title": "Database Tables", "text": "<p>The following tables are created when running a simulation:</p> Table Description leg_defs Static data about network legs leg_detail Simulation data at the leg level leg_bucket_detail Simulation data at the leg-bucket level path_class_detail Simulation data at the path-class level demand_detail Simulation data at the demand level fare_detail Simulation data at the fare level bookings_by_timeframe Aggregate summary simulation data on bookings by timeframe and bookings class"}, {"location": "user-guide/database/index.html#common-queries", "title": "Common Queries", "text": "<p>PassengerSim has a number of pre-packaged functions that query the database of results to provide useful summary tables.</p> Query Description <code>bid_price_history</code> Compute average bid price history over all legs for each carrier <code>bookings_by_timeframe</code> Average bookings and revenue by carrier, booking class, and timeframe <code>carrier_history</code> Sample-level details of carrier-level measures <code>demand_to_come</code> Demand by market and timeframe across each sample <code>fare_class_mix</code> Fare class mix by carrier <code>leg_forecasts</code> Average forecasts of demand by leg, bucket, and days to departure <code>local_and_flow_yields</code> Yields for local (nonstop) and flow (connecting) passengers by leg <code>od_fare_class_mix</code> Fare class mix by carrier for a particular origin-destination market <code>path_forecasts</code> Average forecasts of demand by path, class, and days to departure <code>total_demand</code> Average total demand"}, {"location": "user-guide/database/bookings_by_timeframe.html", "title": "Bookings by Timeframe", "text": "<p>The <code>bookings_by_timeframe</code> database table stores aggregate summary information about simulated bookings by timeframe, carrier, booking class, and passenger segment. Unlike various other \"detail\" tables, it does not store the results from any single sample, but instead has information aggregated over all samples in each trial.</p> <p>The table is created by the <code>create_table_bookings_by_timeframe</code> function, and (potentially) populated during a simulation run.  To be populated with data, the \"bookings\" flag must be set on <code>Config.db.write_items</code>.</p>"}, {"location": "user-guide/database/bookings_by_timeframe.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> trial INT NOT NULL carrier VARCHAR(10) NOT NULL Carrier name booking_class VARCHAR(10) NOT NULL rrd INT NOT NULL Days before departure tot_sold FLOAT Total sales for the carrier and booking class, through this timeframe avg_sold FLOAT Average number of sales (per sample) avg_business FLOAT Average number of sales to business customers avg_leisure FLOAT Average number of sales to leisure customers avg_revenue FLOAT Average revenue from sales avg_price FLOAT Average price sold updated_at DATETIME NOT NULL Time each row was written to the database <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/demand_detail.html", "title": "Demand Detail", "text": "<p>The <code>demand_detail</code> database table stores details about the results of the simulation at the demand level.</p> <p>The table is created by the <code>create_table_demand_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"demand\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"demand_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> </ul>"}, {"location": "user-guide/database/demand_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial rrd INT NOT NULL Days before departure segment VARCHAR(10) NOT NULL Customer segment, typically business or leisure orig VARCHAR(10) NOT NULL Origin (typically an airport code or similar) dest VARCHAR(10) NOT NULL Destination (typically an airport code or similar) updated_at DATETIME NOT NULL Time each row was written to the database sample_demand FLOAT sold INT Number of customers in this demand bucket who bought something no_go INT Number of customers in this demand bucket who bought nothing revenue FLOAT Revenue attributable to these customers <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/distance.html", "title": "Distance", "text": "<p>The <code>distance</code> database table stores the distance between locations (airports and/or other travel nodes). It contains static data not dependent on running the simulation. The table is created by the <code>create_table_distance</code> function.</p>"}, {"location": "user-guide/database/distance.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description orig VARCHAR(10) NOT NULL Origin (typically an airport code or similar) dest VARCHAR(10) NOT NULL Destination (typically an airport code or similar) miles FLOAT Distance between nodes in miles"}, {"location": "user-guide/database/fare_detail.html", "title": "Fare Detail", "text": "<p>The <code>fare_detail</code> database table stores details about the results of the simulation at the fare level.</p> <p>The table is created by the <code>create_table_fare_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"fare\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"fare_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> </ul>"}, {"location": "user-guide/database/fare_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial rrd INT NOT NULL Days before departure carrier VARCHAR(10) NOT NULL Carrier name orig VARCHAR(10) NOT NULL Origin (typically an airport code or similar) dest VARCHAR(10) NOT NULL Destination (typically an airport code or similar) booking_class VARCHAR(10) NOT NULL sold INT Number of customers buying this fare product sold_business INT Number of businss customers buying this fare product price FLOAT Price of this fare updated_at DATETIME NOT NULL Time each row was written to the database <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/leg_bucket_detail.html", "title": "Leg Bucket Detail", "text": "<p>The <code>leg_bucket_detail</code> database table stores details about the results of the simulation at the leg-bucket level.</p> <p>The table is created by the <code>create_table_leg_bucket_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"bucket\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"bucket_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> </ul>"}, {"location": "user-guide/database/leg_bucket_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial rrd INT NOT NULL Days before departure flt_no INT NOT NULL Unique identifier for a given leg <sup>2</sup> bucket_number INT NOT NULL Bucket number (sequential from 0) name VARCHAR(10) NOT NULL Bucket name auth INT Number of seats in this bucket (or higher) available to be sold revenue FLOAT Revenue attributed to this bucket from seats sold sold INT Number of seats sold at this point in time untruncated_demand FLOAT forecast_mean FLOAT forecast_stdev FLOAT forecast_closed_in_tf FLOAT forecast_closed_in_future FLOAT updated_at DATETIME NOT NULL Time each row was written to the database <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> <li> <p>In the \"real world\" the limitations of current technology make it such that flight numbers are not necessary unique by leg, as a single carrier may have multiple segments sharing the same flight number, and multiple carriers will have completely unrelated flights with the same flight number.  To simplify data processing, PassengerSim uses a unique id for every travel segment. Networks in PassengerSim that are derived from realistic sources will require some modest preprocessing to create unique flight numbers for every leg.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/leg_defs.html", "title": "Leg Definitions", "text": "<p>The <code>leg_defs</code> database table stores static details about the legs in the simulation.  Simulation results at the leg level are stored in the <code>leg_details</code> table instead.</p> <p>The <code>leg_defs</code> table is created by the create_table_legs function, which is called in the Simulation initialization step, so it should be available and populated for every simulation run.</p>"}, {"location": "user-guide/database/leg_defs.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description flt_no INTEGER PRIMARY KEY Unique identifier for a given leg <sup>1</sup> carrier TEXT Name of carrier for this leg orig TEXT Origin (typically an airport code or similar) dest TEXT Destination (typically an airport code or similar) dep_time INTEGER arr_time INTEGER capacity INTEGER Number of seats on this leg distance FLOAT Distance from <code>orig</code> to <code>dest</code> in miles. <ol> <li> <p>In the \"real world\" the limitations of current technology make it such that flight numbers are not necessary unique by leg, as a single carrier may have multiple segments sharing the same flight number, and multiple carriers will have completely unrelated flights with the same flight number.  To simplify data processing, PassengerSim uses a unique id for every travel segment. Networks in PassengerSim that are derived from realistic sources will require some modest preprocessing to create unique flight numbers for every leg.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/leg_detail.html", "title": "Leg Detail", "text": "<p>The <code>leg_detail</code> database table stores details about the results of the simulation at the leg level.  Facts about the leg which are not dependent on the simulation are stored in the <code>leg_defs</code> table instead.</p> <p>The table is created by the <code>create_table_leg_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"leg\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"leg_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> <li> <p>\"leg_daily\": The table will be populated at the end of each day during the simulation. Note this will produce a lot of output, and is probably not desirable for most simulation exercises.</p> </li> </ul>"}, {"location": "user-guide/database/leg_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial rrd INT NOT NULL Days before departure flt_no INT NOT NULL Unique identifier for a given leg <sup>3</sup> updated_at DATETIME NOT NULL Time each row was written to the database sold INT Number of seats sold at this point in time revenue FLOAT Revenue attributed to this leg from seats sold q_demand FLOAT untruncated_demand FLOAT forecast_mean FLOAT Forecast of mean demand to come before departure bid_price FLOAT Computed bid price for this leg at this time <sup>2</sup> <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> <li> <p>Bid prices are only computed if there is a RM that provides an instruction to do the computation.  If there is no calculated bid price, this column will be blank.\u00a0\u21a9</p> </li> <li> <p>In the \"real world\" the limitations of current technology make it such that flight numbers are not necessary unique by leg, as a single carrier may have multiple segments sharing the same flight number, and multiple carriers will have completely unrelated flights with the same flight number.  To simplify data processing, PassengerSim uses a unique id for every travel segment. Networks in PassengerSim that are derived from realistic sources will require some modest preprocessing to create unique flight numbers for every leg.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/database/path_class_detail.html", "title": "Path Class Detail", "text": "<p>The <code>path_class_detail</code> database table stores details about the results of the simulation at the path-class level.</p> <p>The table is created by the <code>create_table_path_class_detail</code> function, and (potentially) populated during a simulation run.  To be populated with data, one of the follow flags must be set on <code>Config.db.write_items</code>:</p> <ul> <li> <p>\"pathclass\": The table will be populated at each DCP during the simulation.</p> </li> <li> <p>\"pathclass_final\": The table will be populated only at the end of each sample (i.e. DCP 0) during the simulation</p> </li> </ul>"}, {"location": "user-guide/database/path_class_detail.html#table-schema", "title": "Table Schema", "text": "Column Data Type Description scenario VARCHAR(20) NOT NULL Scenario name <sup>1</sup> iteration INT NOT NULL trial INT NOT NULL sample INT NOT NULL Sample number within trial rrd INT NOT NULL Days before departure path_id INT NOT NULL Unique identifier for a given path booking_class VARCHAR(10) NOT NULL Booking class name sold INT Number of seats sold at this point in time revenue FLOAT Revenue attributed to this bucket from seats sold untruncated_demand FLOAT forecast_mean FLOAT forecast_stdev FLOAT forecast_closed_in_tf FLOAT forecast_closed_in_future FLOAT updated_at DATETIME NOT NULL Time each row was written to the database <ol> <li> <p>The scenario name should be a string, and a unique name should be used for each unique scenario, which allows multiple scenarios to be saved in the same database.  When using SQLite (the default database engine) it is preferred to simply create a new database file for each unique scenario, but this database schema is designed to accommodate other database engines where that may be inconvenient.\u00a0\u21a9</p> </li> </ol>"}, {"location": "user-guide/rm-systems/index.html", "title": "RM Systems", "text": "<p>A revenue management (RM) system is defined by one or more steps. The steps tell the simulation which demand untruncation, demand forecasting, and optimization algorithms to use.  These steps also provide information on the kind of forecast and optimization used (i.e., leg or path) and if path-level information should be aggregated to leg-level information before a step is performed.  Finally, these steps allow the user to specify algorithm-specific parameters, e.g., when using exponential smoothing the user can specify the smoothing constant, alpha.</p> <p>Each carrier should have an RM system that it uses. In PassengerSim, users have the ability to create a single RM system and assign it to all carriers, or to create multiple RM systems and assign different RM systems to different carriers.</p> <p>Below is an example that defines 4 RM systems.  It will be helpful to use these examples to understand the different step_types and options associated with each step_type.</p> <pre><code>rm_systems:\n  fcfs:\n    steps: []\n  rm_no_detruncation:\n    processes:\n      DCP:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: none\n        kind: leg\n      - step_type: forecast\n        name: forecast\n        algorithm: additive_pickup\n        alpha: 0.1\n        kind: leg\n      - step_type: emsr\n        name: optimization\n        algorithm: emsrb\n        kind: leg\n  rm_em:\n    steps:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: none\n        kind: leg\n      - step_type: forecast\n        name: forecast\n        algorithm: additive_pickup\n        alpha: 0.15\n        kind: leg\n      - step_type: fcfs\n        name: optimization\n  rm_probp:\n    steps:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: em\n        kind: path\n      - step_type: forecast\n        name: path_forecast\n        algorithm: exp_smoothing\n        alpha: 0.15\n        kind: path\n      - step_type: probp\n        name: optimization\n      - step_type: aggregation\n        name: aggregate\n      - step_type: emsr\n        name: optimization\n        algorithm: emsrb\n        kind: leg\n</code></pre> <p>The first RM system is based on a first-come, first-serve approach (named <code>fcfs</code>). No steps are defined for <code>fcfs</code> as there is no demand detruncation, demand forecasting, or optimization done with FCFS.  If step_types are defined when <code>fcfs</code> is explicitly specified as the optimization algorithm, they will be ignored.</p> <p>The second RM system, named <code>rm_no_detruncation</code>, is leg-based and uses an <code>additive_pickup</code> forecasting model with EMSRb and no demand detrunction. The alpha parameter that is specified in the forecast <code>step_type</code> will be ignored as it is not used for the additive pick-up model.</p> <p>The third RM system, named <code>rm_em</code>, is using the expectation-maximization (EM) method of detruncation with an exponential smoothing demand forecasting approach that has a smoothing constant of alpha of 0.15 with and EMSRb optimizer. Both the forecasts and optimization are done using leg-level inputs.</p> <p>Finally, the fourth RM system, named <code>rm_probp</code>, is also using the EM method of detruncation with an exponential smoothing dmeand forecasting approach that has a smoothing constant or alpha of 0.15.  Unlike in <code>rm_em</code> however, the untruncation and forecasting steps are done at the path level. The optimization step is based on probp that first finds displacement costs at a path level, then aggregates them to a leg-level in the aggregation step type, and finally calculates protection levels using EMSRb with leg-level demand inputs.</p> <p>Given an overview of how RM systems are constructed, let's now look at each step in detail.</p>"}, {"location": "user-guide/rm-systems/index.html#untruncation", "title": "Untruncation", "text": "<pre><code>- step_type: untruncation\n  name: untruncation\n  algorithm: none, em, naive1, naive2\n  kind: leg, path\n</code></pre> <p>There are three untruncation (also called detruncation) algorithms.  The first, <code>em</code>, is based on the expectation maximization method.  The <code>naive1</code> and <code>naive2</code> methods are based on Shebelov presentation. The untruncation steps can be performed at the path or leg level.</p>"}, {"location": "user-guide/rm-systems/index.html#forecast", "title": "Forecast", "text": "<pre><code>- step_type: 'forecast'\n  algorithm: { additive_pickup, exp_smoothing }\n  alpha: float\n  kind: { leg, path, hybrid }\n</code></pre> <p>There are two forecasting algorithms: exponential smoothing (that uses a smoothing or alpha parameter) and additive pickup model.  The exponential smoothing model does not (currently) incorporate trend or seasonality.</p> <p>The additive pickup model generates a forecast by considering the \"pickup\", or the number of new sales in a booking class, in each time period (DCP).  This model is additive in that the forecast of demand yet to come at given time is computed as the sum of forecast pickups in all future time periods.  This forecasting model does not consider the level of demand already accumulated, only the demand expected in the future.  The forecast is made considering the results from the prior 26 sample days. The additive pickup model ignores the value of the alpha parameter, and it should be omitted when using this algorithm.</p> <p>Either forecast algorithm can be performed based on data collected at either the leg or path level. However, if the forecast is at the leg level then detruncation must also have been performed at the same level.</p>"}, {"location": "user-guide/rm-systems/index.html#emsr-optimization", "title": "EMSR Optimization", "text": "<pre><code>- step_type: emsr\n  name: optimization\n  algorithm: emsra, emsrb\n  kind: leg\n</code></pre> <p>The step_type emsr is used for algorithms based on the expected marginal seat revenue approach and also can be used for fcfs. (although the first RM system defined as fcfs in the example above is a cleaner way to specify the fcfs option).</p>"}, {"location": "user-guide/rm-systems/index.html#probp-optimization", "title": "ProBP Optimization", "text": "<pre><code>- step_type: probp\n  name: optimization\n</code></pre> <p>The step_type probp does just as the name suggests - uses the probabilistic bid price algorithm to determine path-based displacment costs.  After these are found, two more steps are needed - the first is to aggregate path-level information to leg-level information and do the probp proration? and the next is to use the leg-level inputs to find protection levels using emsrb.</p>"}, {"location": "user-guide/rm-systems/emsr.html", "title": "EMSR Optimization", "text": "<p>Optimization is the most fundamental part of revenue management systems, is it is the process used to tailor the set of products being offered to maximize revenue. It typically occurs after untruncation and forecasting.</p> <p>PassengerSim offers several different optimization algorithms. One widely used algorithm is called EMSR (expected marginal seat revenue), which has a few variants, generally labels as \"A\", \"B\", and \"C\".</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b:\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: emsr #(1)!\n        algorithm: b\n        kind: leg\n</code></pre></p> <ol> <li>The <code>step_type</code> for EMSR optimization is <code>emsr</code>, this is how PassengerSim     identifies what to do in this step.</li> </ol>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim_core.airline.EmsrStep", "title": "EmsrStep", "text": "<p>             Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim_core.airline.EmsrStep.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: Literal['a', 'b', 'emsra', 'emsrb']\n</code></pre> <p>Which variant of the EMSR optimization algorithm should be applied.</p> <p>Currently the \"A\" and \"B\" variants are implemented.</p>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim_core.airline.EmsrStep.kind", "title": "kind  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['leg'] = 'leg'\n</code></pre> <p>EMSR is a leg-based optimization algorithm.</p> <p>The <code>kind</code> parameter is included in the interface for compatability, but setting any value here other than <code>leg</code> will result in an error.</p>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim_core.airline.EmsrStep.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[Any] = []\n</code></pre>"}, {"location": "user-guide/rm-systems/fcfs.html", "title": "FCFS Allocation", "text": "<p>First come first served (FCFS) is a simple method for allocating capacity to customers, and it operates pretty much as you would expect: customers whom arrive first are offered products, no attempt is made to optimize for anything.</p> <p>This process of capacity allocation will also occur if no RM optimization algorithm is applied, but the explicit FCFS step type allow the user to be intentional about selecting this algorithm, and to attach snapshot filters to the simulation if desired.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b:\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: fcfs #(1)!\n</code></pre></p> <ol> <li>The <code>step_type</code> for first come, first served is <code>fcfs</code>.</li> </ol>"}, {"location": "user-guide/rm-systems/fcfs.html#passengersim_core.airline.FcfsStep", "title": "FcfsStep", "text": "<p>             Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/fcfs.html#passengersim_core.airline.FcfsStep.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[Any] = []\n</code></pre>"}, {"location": "user-guide/rm-systems/forecast.html", "title": "Forecasting", "text": "<p>Forecasting is a key part of revenue management systems.  You need to know how many customers of each type you should expect, so you can tailor the set of products being offered to maximize revenue.</p> <p>In PassengerSim, forecasting is included as a step within an RM system, typically within the DCP process, after untruncation and before any optimization.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b:\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast #(1)!\n        algorithm: additive_pickup #(2)!\n        kind: leg #(3)!\n      - step_type: emsr\n        algorithm: b\n        kind: leg\n</code></pre></p> <ol> <li>The <code>step_type</code> for forecasting must be <code>forecast</code>, this is how PassengerSim     identifies what to do in this step.</li> <li>Several different algorithms are available for forecasting, see     below for details.</li> <li>Forecasts can be made at the leg or path level, see     below for details.</li> </ol>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim_core.airline.ForecastStep", "title": "ForecastStep", "text": "<p>             Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim_core.airline.ForecastStep.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: Literal[\n    \"exp_smoothing\",\n    \"additive_pickup\",\n    \"multiplicative_pickup\",\n]\n</code></pre> <p>Forecasting algorithm.</p> <p>There are several available forecasting algorithms: </p> <p><code>exp_smoothing</code>      is an exponential smoothing model.  This model uses the <code>alpha</code> parameter      to control the amount of smoothing applied.  It does not (currently)      incorporate trend effects or seasonality.  </p> <p><code>additive_pickup</code>     is an additive pickup model, which generates a forecast by considering the      \"pickup\", or the number of new sales in a booking class, in each time      period (DCP).  This model is additive in that the forecast of demand yet      to come at given time is computed as the sum of forecast pickups in all      future time periods.  This forecasting model does not consider the level      of demand already accumulated, only the demand expected in the future. The      forecast is made considering the results from the prior 26 sample days.      The additive pickup model ignores the value of the alpha parameter, and it      can safely be omitted when using this algorithm.</p> <p><code>multiplicative_pickup</code>     is a multiplicative pickup model.  This model is in development.</p>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim_core.airline.ForecastStep.kind", "title": "kind  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['leg', 'path', 'hybrid'] = 'leg'\n</code></pre> <p>Level of collected demand data that should be used for forecasting.</p> <p>Hybrid forecasting is primarily a path-based forecast, but it includes EM untruncation of yieldable demand.</p>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim_core.airline.ForecastStep.alpha", "title": "alpha  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>alpha: float = 0.15\n</code></pre> <p>Exponential smoothing factor.</p>"}, {"location": "user-guide/rm-systems/probp.html", "title": "ProBP Optimization", "text": "<p>Optimization is the most fundamental part of revenue management systems, is it is the process used to tailor the set of products being offered to maximize revenue. It typically occurs after untruncation and forecasting.</p> <p>PassengerSim offers several different optimization algorithms, including probabilistic bid price (ProBP) optimization.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_probp:\n    availability_control: bp #(2)!\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: probp #(1)!\n</code></pre></p> <ol> <li>The <code>step_type</code> for probabilistic bid price optimization is <code>probp</code>, this is     how PassengerSim identifies what to do in this step.</li> <li>To apply the ProBP optimization results, the <code>rm_system</code> should be set to use     <code>bp</code> (bid price) availability controls.</li> </ol>"}, {"location": "user-guide/rm-systems/probp.html#passengersim_core.airline.ProBpStep", "title": "ProBpStep", "text": "<p>             Bases: <code>RmStep</code></p> <p>Implements ProBP as an RM Step</p>"}, {"location": "user-guide/rm-systems/probp.html#passengersim_core.airline.ProBpStep.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[Any] = []\n</code></pre>"}, {"location": "user-guide/rm-systems/untruncation.html", "title": "Untruncation", "text": "<p>Untruncation is a part of most revenue management systems.  It is a mathematical process whereby we estimate the number of customers there would have been for a particular product, assuming we would have offered the product for sale to all comers.  In the cases where we actually did offer the product to all, then there is nothing for this algorithm to do beyond counting our actual sales.  However, many times our RM systems will limit the number of customers we actually accept, and our actual sales are \"truncated\".  Untruncation is needed to approximate how many customers were lost.</p> <p>In PassengerSim, untruncation is included as a step within an RM system, typically within the DCP process before any forecasting or optimization steps.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b: #(4)!\n    processes:\n      DCP:\n      - step_type: untruncation #(1)!\n        algorithm: em #(2)!\n        kind: leg #(3)!\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: emsr\n        algorithm: b\n        kind: leg\n</code></pre></p> <ol> <li>The <code>step_type</code> must be <code>untruncation</code>, as this is how PassengerSim     identifies what to do in this step.</li> <li>Several different algorithms are available for untruncation, see     below for details.</li> <li>Untruncation can be done at the leg or path level, see     below for details.</li> <li>This is showing that <code>basic_emsr_b</code> is the name of this RM system.     Elsewhere in the configuration (not shown in this example snippet) you will     define carriers, and each will be assigned an RM system using these names.</li> </ol>"}, {"location": "user-guide/rm-systems/untruncation.html#passengersim_core.airline.UntruncationStep", "title": "UntruncationStep", "text": "<p>             Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/untruncation.html#passengersim_core.airline.UntruncationStep.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: Literal[\n    \"em\",\n    \"em_py\",\n    \"none\",\n    \"naive1\",\n    \"naive2\",\n    \"naive3\",\n    \"pd\",\n]\n</code></pre> <p>Untruncation algorithm.</p> <p>There are several available algorithms: </p> <p><code>none</code>      applies no untruncation, and assumes that demand was the same as sales.     Applying this algorithm is still important even if no detruncation is      desired, as PassengerSim tracks historical demand separately from sales     and without \"none\" the historical demand used in forecasting would be     zero.</p> <p><code>em</code>     is an expectation-maximization model.</p> <p><code>em_py</code>     is an expectation-maximization model implemented in Python.  It is slow     but useful for educational purposes.</p> <p><code>naive1</code>     is not recommended for use.</p> <p><code>naive2</code>     is not recommended for use.</p> <p><code>naive3</code>     is not recommended for use.</p> <p><code>pd</code>     is a projection-detruncation model, based on the method developed by      Hopperstad and described by Weatherford &amp; Polt.</p>"}, {"location": "user-guide/rm-systems/untruncation.html#passengersim_core.airline.UntruncationStep.kind", "title": "kind  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['leg', 'path', 'hybrid'] = 'leg'\n</code></pre> <p>Level of collected demand data that should be used for untruncation.</p>"}]}