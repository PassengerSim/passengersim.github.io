{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "index.html", "title": "Home", "text": ""}, {"location": "API/index.html", "title": "PassengerSim API", "text": "<p>The main <code>passengersim</code> package includes configuration and analysis tools.  It is freely available for use.</p> <p>The <code>passengersim.core</code> sub-package is only available to authorized users.</p>"}, {"location": "API/contrast.html", "title": "Contrasting Results", "text": ""}, {"location": "API/contrast.html#passengersim.contrast.Contrast", "title": "Contrast", "text": "<p>             Bases: <code>dict</code></p> Source code in <code>passengersim/contrast.py</code> <pre><code>class Contrast(dict):\n    def apply(\n        self, func: Callable, axis: int | Literal[\"index\", \"columns\", \"rows\"] = 0\n    ) -&gt; pd.DataFrame | pd.Series:\n        data = {}\n        for k, v in self.items():\n            if v is not None:\n                data[k] = func(v)\n        try:\n            return pd.concat(data, axis=axis, names=[\"source\"])\n        except TypeError:\n            return pd.Series(data).rename_axis(index=\"source\")\n\n    def __getattr__(self, attr):\n        if attr.startswith(\"fig_\"):\n            g = globals()\n            if attr in g:\n                return partial(g[attr], self)\n                # return lambda *a, **k: g[attr](self, *a, **k)\n        raise AttributeError(attr)\n\n    def __dir__(self):\n        x = set(super().__dir__())\n        x |= {g for g in globals() if g.startswith(\"fig_\")}\n        return sorted(x)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.__dir__", "title": "__dir__", "text": "<pre><code>__dir__()\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def __dir__(self):\n    x = set(super().__dir__())\n    x |= {g for g in globals() if g.startswith(\"fig_\")}\n    return sorted(x)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.__getattr__", "title": "__getattr__", "text": "<pre><code>__getattr__(attr)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def __getattr__(self, attr):\n    if attr.startswith(\"fig_\"):\n        g = globals()\n        if attr in g:\n            return partial(g[attr], self)\n            # return lambda *a, **k: g[attr](self, *a, **k)\n    raise AttributeError(attr)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.Contrast.apply", "title": "apply", "text": "<pre><code>apply(\n    func: Callable,\n    axis: int | Literal[\"index\", \"columns\", \"rows\"] = 0,\n) -&gt; pd.DataFrame | pd.Series\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>def apply(\n    self, func: Callable, axis: int | Literal[\"index\", \"columns\", \"rows\"] = 0\n) -&gt; pd.DataFrame | pd.Series:\n    data = {}\n    for k, v in self.items():\n        if v is not None:\n            data[k] = func(v)\n    try:\n        return pd.concat(data, axis=axis, names=[\"source\"])\n    except TypeError:\n        return pd.Series(data).rename_axis(index=\"source\")\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_bid_price_history", "title": "fig_bid_price_history", "text": "<pre><code>fig_bid_price_history(\n    summaries,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_bid_price_history(\n    summaries,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df=False,\n):\n    if cap is None:\n        bp_mean = \"bid_price_mean\"\n    elif cap == \"some\":\n        bp_mean = \"some_cap_bid_price_mean\"\n    elif cap == \"zero\":\n        bp_mean = \"zero_cap_bid_price_mean\"\n    else:\n        raise ValueError(f\"cap={cap!r} not in ['some', 'zero', None]\")\n\n    if not isinstance(by_carrier, str):\n        raise NotImplementedError(\n            \"contrast.fig_bid_price_history requires looking at a single carrier (set `by_carrier`)\"\n        )\n    df = _assemble(\n        summaries,\n        \"bid_price_history\",\n        by_carrier=by_carrier,\n        show_stdev=show_stdev,\n        cap=cap,\n    )\n    if raw_df:\n        return df\n\n    line_encoding = dict(\n        x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"),\n        y=alt.Y(bp_mean, title=\"Bid Price\"),\n        color=\"source:N\",\n    )\n    chart = alt.Chart(df)\n    fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n    if show_stdev:\n        area_encoding = dict(\n            x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"),\n            y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"),\n            y2=alt.Y2(\"bid_price_upper:Q\", title=\"Bid Price\"),\n            color=\"source:N\",\n        )\n        bound = chart.mark_area(\n            opacity=0.1,\n            interpolate=\"step-before\",\n        ).encode(**area_encoding)\n        bound_line = chart.mark_line(\n            opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\"\n        ).encode(\n            x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"),\n            color=\"source:N\",\n        )\n        top_line = bound_line.encode(y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"))\n        bottom_line = bound_line.encode(y=alt.Y(\"bid_price_upper:Q\", title=\"Bid Price\"))\n        fig = fig + bound + top_line + bottom_line\n    return fig\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_bookings_by_timeframe", "title": "fig_bookings_by_timeframe", "text": "<pre><code>fig_bookings_by_timeframe(\n    summaries: dict[str, SummaryTables],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df=False,\n    source_labels: bool = False,\n) -&gt; alt.Chart | pd.DataFrame\n</code></pre> <p>Generate a figure contrasting bookings by timeframe for one or more runs.</p> <p>Parameters:</p> <ul> <li> <code>summaries</code>             (<code>dict[str, SummaryTables]</code>)         \u2013          <p>One or more SummaryTables to compare. The keys of this dictionary are the text names used to label the \"source\" for each set of data in the figure.</p> </li> <li> <code>by_carrier</code>             (<code>bool or str</code>, default:                 <code>True</code> )         \u2013          <p>Whether to differentiate carriers by colors (the default) or give the name of a particular carrier as a string to filter the results shown in the figure to only that one carrier.</p> </li> <li> <code>by_class</code>             (<code>bool or str</code>, default:                 <code>False</code> )         \u2013          <p>Whether to differentiate booking class by colors (the default) or give the name of a particular booking class as a string to filter the results shown in the figure to only that one booking class.</p> </li> <li> <code>raw_df</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Set to true to return the raw dataframe used to generate the figure, instead of the figure itself.</p> </li> <li> <code>source_labels</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Write source labels above the columns of the figure. Source labels are also available as tool tips, but if the figure is being shared as an image without tooltips, the source labels may make it easier to interpret.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>report</code>             (<code>Reporter</code>)         \u2013          <p>Giving a reporter for this keyword only argument allow you to automatically append this figure to the report (in addition to returning it for display or other processing).</p> </li> <li> <code>trace</code>             (<code>ExcelWriter or (ExcelWriter, str)</code>)         \u2013          <p>Write the raw dataframe backing this figure to the Excel workbook.</p> </li> </ul> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_bookings_by_timeframe(\n    summaries: dict[str, SummaryTables],\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df=False,\n    source_labels: bool = False,\n) -&gt; alt.Chart | pd.DataFrame:\n    \"\"\"\n    Generate a figure contrasting bookings by timeframe for one or more runs.\n\n    Parameters\n    ----------\n    summaries : dict[str, SummaryTables]\n        One or more SummaryTables to compare. The keys of this dictionary are the\n        text names used to label the \"source\" for each set of data in the figure.\n    by_carrier : bool or str, default True\n        Whether to differentiate carriers by colors (the default) or give the name\n        of a particular carrier as a string to filter the results shown in the\n        figure to only that one carrier.\n    by_class : bool or str, default False\n        Whether to differentiate booking class by colors (the default) or give the\n        name of a particular booking class as a string to filter the results shown\n        in the figure to only that one booking class.\n    raw_df : bool, default False\n        Set to true to return the raw dataframe used to generate the figure, instead\n        of the figure itself.\n    source_labels : bool, default False\n        Write source labels above the columns of the figure. Source labels are also\n        available as tool tips, but if the figure is being shared as an image without\n        tooltips, the source labels may make it easier to interpret.\n\n    Other Parameters\n    ----------------\n    report : xmle.Reporter, optional\n        Giving a reporter for this keyword only argument allow you to automatically\n        append this figure to the report (in addition to returning it for display\n        or other processing).\n    trace : pd.ExcelWriter or (pd.ExcelWriter, str), optional\n        Write the raw dataframe backing this figure to the Excel workbook.\n    \"\"\"\n    if by_carrier is True and by_class is True:\n        raise NotImplementedError(\"comparing by both class and carrier is messy\")\n    df = _assemble(\n        summaries, \"bookings_by_timeframe\", by_carrier=by_carrier, by_class=by_class\n    )\n    source_order = list(summaries.keys())\n\n    title = \"Bookings by Timeframe\"\n    if by_class is True:\n        title = \"Bookings by Timeframe and Booking Class\"\n    title_annot = []\n    if isinstance(by_carrier, str):\n        title_annot.append(by_carrier)\n    if isinstance(by_class, str):\n        title_annot.append(f\"Class {by_class}\")\n    if title_annot:\n        title = f\"{title} ({', '.join(title_annot)})\"\n\n    if raw_df:\n        df.attrs[\"title\"] = title\n        return df\n\n    if by_class:\n        if isinstance(by_class, str):\n            color = alt.Color(\"source:N\", title=\"Source\", sort=source_order).title(\n                \"Source\"\n            )\n            tooltips = ()\n        else:\n            color = alt.Color(\"class:N\").title(\"Booking Class\")\n            tooltips = (alt.Tooltip(\"class\", title=\"Booking Class\"),)\n        chart = alt.Chart(df.sort_values(\"source\", ascending=False))\n        chart_1 = chart.mark_bar().encode(\n            color=color,\n            x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n            xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n            y=alt.Y(\"sold\", stack=True),\n            tooltip=[\n                alt.Tooltip(\"source:N\", title=\"Source\"),\n                alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                *tooltips,\n                alt.Tooltip(\"rrd\", title=\"DfD\"),\n                alt.Tooltip(\"sold\", format=\".2f\"),\n            ],\n        )\n        chart_2 = chart.mark_text(\n            color=\"#616161\",\n            yOffset=-2,\n            angle=270,\n            fontSize=8,\n            baseline=\"middle\",\n            align=\"left\",\n        ).encode(\n            text=alt.Text(\"source:N\", title=\"Source\"),\n            x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n            xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n            # shape=alt.Shape(\"source:N\", title=\"Source\", sort=source_order),\n            y=alt.Y(\"sum(sold)\", title=None),\n        )\n        return (\n            ((chart_1 + chart_2) if source_labels else chart_1)\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"paxtype:N\", title=\"Passenger Type\"),\n                title=title,\n            )\n            .configure_title(fontSize=18)\n        )\n    elif by_carrier is True:\n        return (\n            alt.Chart(df.sort_values(\"source\", ascending=False))\n            .mark_bar()\n            .encode(\n                color=alt.Color(\"carrier:N\").title(\"Carrier\"),\n                x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n                xOffset=alt.XOffset(\"source:N\", title=\"Source\", sort=source_order),\n                y=alt.Y(\"sold\", stack=True),\n                tooltip=[\n                    alt.Tooltip(\"source:N\", title=\"Source\"),\n                    alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\"rrd\", title=\"DfD\"),\n                    alt.Tooltip(\"sold\", format=\".2f\"),\n                ],\n            )\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"paxtype:N\", title=\"Passenger Type\"),\n                title=title,\n            )\n            .configure_title(fontSize=18)\n        )\n    else:\n        return (\n            alt.Chart(df.sort_values(\"source\", ascending=False), title=title)\n            .mark_line()\n            .encode(\n                color=alt.Color(\"source:N\", title=\"Source\", sort=source_order),\n                x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n                y=\"sold\",\n                strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n                strokeWidth=alt.StrokeWidth(\n                    \"source:N\", title=\"Source\", sort=source_order\n                ),\n                tooltip=[\n                    alt.Tooltip(\"source:N\", title=\"Source\"),\n                    alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"rrd\", title=\"DfD\"),\n                    alt.Tooltip(\"sold\", format=\".2f\"),\n                ],\n            )\n            .properties(\n                width=500,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n            .configure_title(fontSize=18)\n        )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_load_factors", "title": "fig_carrier_load_factors", "text": "<pre><code>fig_carrier_load_factors(\n    summaries,\n    raw_df=False,\n    load_measure: Literal[\n        \"sys_lf\", \"avg_leg_lf\"\n    ] = \"sys_lf\",\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = True,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_load_factors(\n    summaries,\n    raw_df=False,\n    load_measure: Literal[\"sys_lf\", \"avg_leg_lf\"] = \"sys_lf\",\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = True,\n):\n    measure_name = {\n        \"sys_lf\": \"System Load Factor\",\n        \"avg_leg_lf\": \"Leg Load factor\",\n    }.get(load_measure, \"Load Factor\")\n    df = _assemble(summaries, \"carrier_load_factors\", load_measure=load_measure)\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = f\"Carrier {measure_name}s\"\n        return df\n    return _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=load_measure,\n        measure_name=measure_name,\n        measure_format=\".2f\",\n        orient=orient,\n        title=f\"Carrier {measure_name}s\",\n        ratio=ratio,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_revenues", "title": "fig_carrier_revenues", "text": "<pre><code>fig_carrier_revenues(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = True,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_revenues(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = True,\n):\n    df = _assemble(summaries, \"carrier_revenues\")\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Revenues\"\n        return df\n    return _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=\"avg_rev\",\n        measure_name=\"Revenue ($)\",\n        measure_format=\"$.4s\",\n        orient=orient,\n        title=\"Carrier Revenues\",\n        ratio=ratio,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_carrier_yields", "title": "fig_carrier_yields", "text": "<pre><code>fig_carrier_yields(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = True,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_carrier_yields(\n    summaries,\n    raw_df=False,\n    orient: Literal[\"h\", \"v\"] = \"h\",\n    ratio: str | bool = True,\n):\n    df = _assemble(summaries, \"carrier_yields\")\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Yields\"\n        return df\n    return _fig_carrier_measure(\n        df,\n        source_order,\n        load_measure=\"yield\",\n        measure_name=\"Yield ($)\",\n        measure_format=\"$.4f\",\n        orient=orient,\n        title=\"Carrier Yields\",\n        ratio=ratio,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_demand_to_come", "title": "fig_demand_to_come", "text": "<pre><code>fig_demand_to_come(\n    summaries: Contrast,\n    func: Literal[\"mean\", \"std\"] = \"mean\",\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_demand_to_come(\n    summaries: Contrast,\n    func: Literal[\"mean\", \"std\"] = \"mean\",\n    raw_df=False,\n):\n    def dtc_seg(s):\n        if s is None:\n            return pd.DataFrame(columns=[\"segment\"])\n        sum_on = []\n        if \"orig\" in s.index.names:\n            sum_on.append(\"orig\")\n        if \"dest\" in s.index.names:\n            sum_on.append(\"dest\")\n        if sum_on:\n            s = s.groupby(s.index.names.difference(sum_on)).sum()\n        return s\n\n    if func == \"mean\":\n        y_title = \"Mean Demand to Come\"\n        demand_to_come_by_segment = summaries.apply(\n            lambda s: dtc_seg(s.demand_to_come)\n            .groupby(\"segment\", observed=False)\n            .mean()\n            .stack(),\n            axis=1,\n        )\n        df = demand_to_come_by_segment.stack().rename(\"dtc\").reset_index()\n    elif func == \"std\":\n        y_title = \"Std Dev Demand to Come\"\n        demand_to_come_by_segment = summaries.apply(\n            lambda s: dtc_seg(s.demand_to_come)\n            .groupby(\"segment\", observed=False)\n            .std()\n            .stack(),\n            axis=1,\n        )\n        df = demand_to_come_by_segment.stack().rename(\"dtc\").reset_index()\n    else:\n        raise ValueError(f\"func must be in [mean, std] not {func}\")\n    if raw_df:\n        return df\n    return (\n        alt.Chart(df)\n        .mark_line()\n        .encode(\n            x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n            y=alt.Y(\"dtc:Q\").title(y_title),\n            color=\"segment:N\",\n            strokeDash=\"source:N\",\n        )\n    )  # .properties(width=500, height=400)\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_fare_class_mix", "title": "fig_fare_class_mix", "text": "<pre><code>fig_fare_class_mix(\n    summaries, raw_df=False, label_threshold=0.06\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_fare_class_mix(summaries, raw_df=False, label_threshold=0.06):\n    df = _assemble(summaries, \"fare_class_mix\")\n    source_order = list(summaries.keys())\n    if raw_df:\n        df.attrs[\"title\"] = \"Carrier Fare Class Mix\"\n        return df\n    import altair as alt\n\n    label_threshold_value = (\n        df.groupby([\"carrier\", \"source\"]).avg_sold.sum().max() * label_threshold\n    )\n    chart = alt.Chart(df).transform_calculate(\n        halfsold=\"datum.avg_sold / 2.0\",\n    )\n    bars = chart.mark_bar().encode(\n        x=alt.X(\"source:N\", title=\"Source\", sort=source_order),\n        y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n        color=\"booking_class\",\n        tooltip=[\n            \"source\",\n            \"booking_class\",\n            alt.Tooltip(\"avg_sold\", format=\".2f\"),\n        ],\n    )\n    text = chart.mark_text(dx=0, dy=3, color=\"white\", baseline=\"top\").encode(\n        x=alt.X(\"source:N\", title=\"Source\", sort=source_order),\n        y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n        text=alt.Text(\"avg_sold:Q\", format=\".2f\"),\n        opacity=alt.condition(\n            f\"datum.avg_sold &lt; {label_threshold_value:.3f}\",\n            alt.value(0),\n            alt.value(1),\n        ),\n        order=alt.Order(\"booking_class:N\", sort=\"descending\"),\n    )\n    return (\n        (bars + text)\n        .properties(\n            width=200,\n            height=300,\n        )\n        .facet(\n            column=alt.Column(\"carrier:N\", title=\"Carrier\"),\n            title=\"Carrier Fare Class Mix\",\n        )\n        .configure_title(fontSize=18)\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_leg_forecasts", "title": "fig_leg_forecasts", "text": "<pre><code>fig_leg_forecasts(\n    summaries,\n    raw_df=False,\n    by_flt_no=None,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"]\n    | list[Literal[\"mu\", \"sigma\"]] = \"mu\",\n    agg_booking_classes: bool = False,\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_leg_forecasts(\n    summaries,\n    raw_df=False,\n    by_flt_no=None,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"] | list[Literal[\"mu\", \"sigma\"]] = \"mu\",\n    agg_booking_classes: bool = False,\n):\n    if isinstance(of, list):\n        if raw_df:\n            raise NotImplementedError\n        fig = fig_leg_forecasts(\n            summaries,\n            by_flt_no=by_flt_no,\n            by_class=by_class,\n            of=of[0],\n            agg_booking_classes=agg_booking_classes,\n        )\n        for of_ in of[1:]:\n            fig |= fig_leg_forecasts(\n                summaries,\n                by_flt_no=by_flt_no,\n                by_class=by_class,\n                of=of_,\n                agg_booking_classes=agg_booking_classes,\n            )\n        return fig\n    df = _assemble(\n        summaries, \"leg_forecasts\", by_flt_no=by_flt_no, by_class=by_class, of=of\n    )\n    color = \"booking_class:N\"\n    if isinstance(by_class, str):\n        color = \"source:N\"\n    if agg_booking_classes or not by_class:\n        color = \"source:N\"\n        if of == \"mu\":\n            df = (\n                df.groupby([\"source\", \"flt_no\", \"rrd\"])\n                .forecast_mean.sum()\n                .reset_index()\n            )\n        elif of == \"sigma\":\n\n            def sum_sigma(x):\n                return np.sqrt(sum(x**2))\n\n            df = (\n                df.groupby([\"source\", \"flt_no\", \"rrd\"])\n                .forecast_stdev.apply(sum_sigma)\n                .reset_index()\n            )\n    if raw_df:\n        df.attrs[\"title\"] = \"Average Leg Forecasts\"\n        return df\n    return _fig_forecasts(\n        df,\n        facet_on=\"flt_no\" if not isinstance(by_flt_no, int) else None,\n        y=\"forecast_mean\" if of == \"mu\" else \"forecast_stdev\",\n        y_title=\"Mean Demand Forecast\" if of == \"mu\" else \"Std Dev Demand Forecast\",\n        color=color,\n    )\n</code></pre>"}, {"location": "API/contrast.html#passengersim.contrast.fig_path_forecasts", "title": "fig_path_forecasts", "text": "<pre><code>fig_path_forecasts(\n    summaries,\n    raw_df=False,\n    by_path_id=None,\n    path_names: dict | None = None,\n    agg_booking_classes: bool = False,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\", \"closed\"] = \"mu\",\n)\n</code></pre> Source code in <code>passengersim/contrast.py</code> <pre><code>@report_figure\ndef fig_path_forecasts(\n    summaries,\n    raw_df=False,\n    by_path_id=None,\n    path_names: dict | None = None,\n    agg_booking_classes: bool = False,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\", \"closed\"] = \"mu\",\n):\n    if isinstance(of, list):\n        if raw_df:\n            raise NotImplementedError\n        fig = fig_path_forecasts(\n            summaries,\n            by_path_id=by_path_id,\n            path_names=path_names,\n            by_class=by_class,\n            of=of[0],\n        )\n        for of_ in of[1:]:\n            fig |= fig_path_forecasts(\n                summaries,\n                by_path_id=by_path_id,\n                path_names=path_names,\n                by_class=by_class,\n                of=of_,\n            )\n        return fig\n    df = _assemble(\n        summaries, \"path_forecasts\", by_path_id=by_path_id, of=of, by_class=by_class\n    )\n    list(summaries.keys())\n    if path_names is not None:\n        df[\"path_id\"] = df[\"path_id\"].apply(lambda x: path_names.get(x, str(x)))\n    color = \"booking_class:N\"\n    if isinstance(by_class, str):\n        color = \"source:N\"\n    if agg_booking_classes:\n        if of == \"mu\":\n            df = (\n                df.groupby([\"source\", \"path_id\", \"rrd\"])\n                .forecast_mean.sum()\n                .reset_index()\n            )\n        elif of == \"sigma\":\n\n            def sum_sigma(x):\n                return np.sqrt(sum(x**2))\n\n            df = (\n                df.groupby([\"source\", \"path_id\", \"rrd\"])\n                .forecast_stdev.apply(sum_sigma)\n                .reset_index()\n            )\n        elif of == \"closed\":\n            df = (\n                df.groupby([\"source\", \"path_id\", \"rrd\"])\n                .forecast_closed_in_tf.mean()\n                .reset_index()\n            )\n    if raw_df:\n        if of == \"mu\":\n            df.attrs[\"title\"] = \"Average Path Forecast Means\"\n        elif of == \"sigma\":\n            df.attrs[\"title\"] = \"Average Path Forecast Standard Deviations\"\n        elif of == \"closed\":\n            df.attrs[\"title\"] = \"Average Path Forecast Closed in Timeframe\"\n        return df\n    if of == \"mu\":\n        y = \"forecast_mean\"\n        y_title = \"Mean Demand Forecast\"\n    elif of == \"sigma\":\n        y = \"forecast_stdev\"\n        y_title = \"Std Dev Demand Forecast\"\n    elif of == \"closed\":\n        y = \"forecast_closed_in_tf\"\n        y_title = \"Mean Time Frame Closed of Demand Forecast\"\n    else:\n        raise NotImplementedError\n    return _fig_forecasts(\n        df,\n        facet_on=\"path_id\" if not isinstance(by_path_id, int) else None,\n        y=y,\n        y_title=y_title,\n        color=color,\n    )\n</code></pre>"}, {"location": "API/summary.html", "title": "Summary Results", "text": ""}, {"location": "API/summary.html#passengersim.summary.logger", "title": "logger  <code>module-attribute</code>", "text": "<pre><code>logger = logging.getLogger('passengersim.summary')\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables", "title": "SummaryTables", "text": "Source code in <code>passengersim/summary.py</code> <pre><code>class SummaryTables:\n    @classmethod\n    def from_sqlite(\n        cls,\n        filename: str,\n        make_indexes: bool = False,\n        additional: Collection[str | tuple] = (\n            \"fare_class_mix\",\n            \"load_factors\",\n            \"bookings_by_timeframe\",\n            \"total_demand\",\n        ),\n    ):\n        if not os.path.isfile(filename):\n            raise FileNotFoundError(filename)\n        db = database.Database(\n            engine=\"sqlite\",\n            filename=filename,\n        )\n\n        demands = cls.load_basic_table(db, \"demand_summary\")\n        legs = cls.load_basic_table(db, \"leg_summary\")\n        paths = cls.load_basic_table(db, \"path_summary\")\n        carriers = cls.load_basic_table(db, \"carrier_summary\")\n\n        summary = cls(\n            demands=demands,\n            legs=legs,\n            paths=paths,\n            carriers=carriers,\n        )\n\n        if make_indexes:\n            db.add_indexes()\n\n        logger.info(\"loading configs\")\n        config = db.load_configs()\n\n        summary.load_additional_tables(\n            db,\n            scenario=config.scenario,\n            burn_samples=config.simulation_controls.burn_samples,\n            additional=additional,\n        )\n        summary.cnx = db\n        return summary\n\n    @classmethod\n    def load_basic_table(self, db: database.Database, tablename: str):\n        \"\"\"Load a basic table\"\"\"\n        logger.info(\"loading %s\", tablename)\n        return db.dataframe(f\"SELECT * FROM {tablename}\")\n\n    def load_additional_tables(\n        self,\n        db: database.Database,\n        scenario: str,\n        burn_samples: int,\n        additional: Collection[str | tuple] = (\n            \"fare_class_mix\",\n            \"bookings_by_timeframe\",\n            \"total_demand\",\n        ),\n    ) -&gt; None:\n        if \"fare_class_mix\" in additional and db.is_open:\n            logger.info(\"loading fare_class_mix\")\n            self.fare_class_mix = database.common_queries.fare_class_mix(\n                db, scenario, burn_samples=burn_samples\n            )\n            if self.od_fare_class_mix:\n                for orig, dest in list(self.od_fare_class_mix):\n                    self.od_fare_class_mix[\n                        (orig, dest)\n                    ] = database.common_queries.od_fare_class_mix(\n                        db, orig, dest, scenario, burn_samples=burn_samples\n                    )\n\n        for i in additional:\n            if isinstance(i, tuple) and i[0] == \"od_fare_class_mix\" and db.is_open:\n                orig, dest = i[1], i[2]\n                if self.od_fare_class_mix is None:\n                    self.od_fare_class_mix = {}\n                logger.info(f\"loading od_fare_class_mix({orig},{dest})\")\n                self.od_fare_class_mix[\n                    (orig, dest)\n                ] = database.common_queries.od_fare_class_mix(\n                    db, orig, dest, scenario, burn_samples=burn_samples\n                )\n\n        if \"bookings_by_timeframe\" in additional and db.is_open:\n            logger.info(\"loading bookings_by_timeframe\")\n            self.bookings_by_timeframe = database.common_queries.bookings_by_timeframe(\n                db, scenario, burn_samples=burn_samples\n            )\n\n        if \"total_demand\" in additional and db.is_open:\n            logger.info(\"loading total_demand\")\n            self.total_demand = database.common_queries.total_demand(\n                db, scenario, burn_samples\n            )\n\n        if \"leg_forecasts\" in additional and db.is_open:\n            logger.info(\"loading leg_forecasts\")\n            self.leg_forecasts = database.common_queries.leg_forecasts(\n                db, scenario, burn_samples\n            )\n\n        if \"path_forecasts\" in additional and db.is_open:\n            logger.info(\"loading path_forecasts\")\n            self.path_forecasts = database.common_queries.path_forecasts(\n                db, scenario, burn_samples\n            )\n\n        if \"demand_to_come\" in additional and db.is_open:\n            logger.info(\"loading demand_to_come\")\n            self.demand_to_come = database.common_queries.demand_to_come(db, scenario)\n\n        if \"carrier_history\" in additional and db.is_open:\n            logger.info(\"loading carrier_history\")\n            self.carrier_history = database.common_queries.carrier_history(db, scenario)\n\n        if \"bid_price_history\" in additional and db.is_open:\n            logger.info(\"loading bid_price_history\")\n            self.bid_price_history = database.common_queries.bid_price_history(\n                db, scenario, burn_samples\n            )\n\n        if \"local_and_flow_yields\" in additional and db.is_open:\n            logger.info(\"loading local_and_flow_yields\")\n            self.local_and_flow_yields = database.common_queries.local_and_flow_yields(\n                db, scenario, burn_samples\n            )\n\n    def __init__(\n        self,\n        demands: pd.DataFrame | None = None,\n        fares: pd.DataFrame | None = None,\n        legs: pd.DataFrame | None = None,\n        paths: pd.DataFrame | None = None,\n        path_classes: pd.DataFrame | None = None,\n        carriers: pd.DataFrame | None = None,\n        fare_class_mix: pd.DataFrame | None = None,\n        load_factors: pd.DataFrame | None = None,\n        bookings_by_timeframe: pd.DataFrame | None = None,\n        total_demand: float | None = None,\n        od_fare_class_mix: dict[tuple[str, str], pd.DataFrame] | None = None,\n        leg_forecasts: pd.DataFrame | None = None,\n        path_forecasts: pd.DataFrame | None = None,\n        carrier_history: pd.DataFrame | None = None,\n        demand_to_come: pd.DataFrame | None = None,\n        bid_price_history: pd.DataFrame | None = None,\n        local_and_flow_yields: pd.DataFrame | None = None,\n    ):\n        self.demands = demands\n        self.fares = fares\n        self.legs = legs\n        self.paths = paths\n        self.path_classes = path_classes\n        self.carriers = carriers\n        self.fare_class_mix = fare_class_mix\n        self.od_fare_class_mix = od_fare_class_mix\n        self.load_factors = load_factors\n        self.bookings_by_timeframe = bookings_by_timeframe\n        self.total_demand = total_demand\n        self.leg_forecasts = leg_forecasts\n        self.path_forecasts = path_forecasts\n        self.carrier_history = carrier_history\n        self.demand_to_come = demand_to_come\n        self.bid_price_history = bid_price_history\n        self.local_and_flow_yields = local_and_flow_yields\n\n    def to_records(self):\n        return {k: v.to_dict(orient=\"records\") for (k, v) in self.__dict__.items()}\n\n    def to_xlsx(self, filename: str | pathlib.Path) -&gt; None:\n        \"\"\"Write summary tables to excel.\n\n        Parameters\n        ----------\n        filename : Path-like\n            The excel file to write.\n        \"\"\"\n        if isinstance(filename, str):\n            filename = pathlib.Path(filename)\n        filename.parent.mkdir(exist_ok=True, parents=True)\n        with pd.ExcelWriter(filename) as writer:\n            for k, v in self.__dict__.items():\n                if isinstance(v, pd.DataFrame):\n                    v.to_excel(writer, sheet_name=k)\n\n    def aggregate_demand_history(self, by_segment: bool = True) -&gt; pd.Series:\n        \"\"\"\n        Total demand by sample, aggregated over all markets.\n\n        Parameters\n        ----------\n        by_segment : bool, default True\n            Aggregate by segment.  If false, segments are also aggregated.\n\n        Returns\n        -------\n        pandas.Series\n            Total demand, indexed by trial, sample, and segment\n            (business/leisure).\n        \"\"\"\n        groupbys = [\"trial\", \"sample\"]\n        if by_segment:\n            groupbys.append(\"segment\")\n        return self.demand_to_come.iloc[:, 0].groupby(groupbys, observed=False).sum()\n\n    def demand_in_tf(self) -&gt; pd.DataFrame | None:\n        \"\"\"History of demand arriving in each timeframe.\n\n        This dataframe is derived from the `demand_to_come` dataframe\n        by taking the sequential differences.\n        \"\"\"\n        if self.demand_to_come is None:\n            return None\n        return self.demand_to_come.diff(-1, axis=1).iloc[:, :-1]\n\n    def fig_carrier_mileage(self, raw_df: bool = False, report=None):\n        \"\"\"\n        Figure showing ASM, RPM by carrier.\n\n        ASM is available seat miles.  RPM is revenue passenger miles.\n\n        Parameters\n        ----------\n        raw_df : bool, default False\n            Return the raw data for this figure as a pandas DataFrame, instead\n            of generating the figure itself.\n        report : xmle.Reporter, optional\n            Also append this figure to the given report.\n        \"\"\"\n        df = (\n            self.carriers.reset_index()[[\"carrier\", \"asm\", \"rpm\"]]\n            .set_index(\"carrier\")\n            .rename_axis(columns=\"measure\")\n            .unstack()\n            .to_frame(\"value\")\n            .reset_index()\n        )\n        if raw_df:\n            return df\n        import altair as alt\n\n        chart = alt.Chart(df, title=\"Carrier Loads\")\n        bars = chart.mark_bar().encode(\n            x=alt.X(\"carrier:N\", title=\"Carrier\"),\n            y=alt.Y(\"value\", stack=None, title=\"miles\"),\n            color=\"measure\",\n            tooltip=[\"carrier\", \"measure\", alt.Tooltip(\"value\", format=\".4s\")],\n        )\n        text = chart.mark_text(\n            dx=0,\n            dy=5,\n            color=\"white\",\n            baseline=\"top\",\n        ).encode(\n            x=alt.X(\"carrier:N\"),\n            y=alt.Y(\"value\").stack(None),\n            text=alt.Text(\"value:Q\", format=\".4s\"),\n        )\n        fig = (\n            (bars + text)\n            .properties(\n                width=400,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n        if report:\n            report.add_figure(fig)\n        return fig\n\n    def _fig_fare_class_mix(\n        self, df: pd.DataFrame, label_threshold: float = 0.06, title=None\n    ):\n        import altair as alt\n\n        label_threshold_value = (\n            df.groupby(\"carrier\").avg_sold.sum().max() * label_threshold\n        )\n        chart = alt.Chart(\n            df, **({\"title\": title} if title else {})\n        ).transform_calculate(\n            halfsold=\"datum.avg_sold / 2.0\",\n        )\n        bars = chart.mark_bar().encode(\n            x=alt.X(\"carrier:N\", title=\"Carrier\"),\n            y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n            color=\"booking_class\",\n            tooltip=[\n                \"carrier\",\n                \"booking_class\",\n                alt.Tooltip(\"avg_sold\", format=\".2f\"),\n            ],\n        )\n        text = chart.mark_text(dx=0, dy=3, color=\"white\", baseline=\"top\").encode(\n            x=alt.X(\"carrier:N\", title=\"Carrier\"),\n            y=alt.Y(\"avg_sold:Q\", title=\"Seats\").stack(\"zero\"),\n            text=alt.Text(\"avg_sold:Q\", format=\".2f\"),\n            opacity=alt.condition(\n                f\"datum.avg_sold &lt; {label_threshold_value:.3f}\",\n                alt.value(0),\n                alt.value(1),\n            ),\n            order=alt.Order(\"booking_class:N\", sort=\"descending\"),\n        )\n        return (\n            (bars + text)\n            .properties(\n                width=400,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n\n    @report_figure\n    def fig_fare_class_mix(self, raw_df=False, label_threshold=0.06):\n        df = self.fare_class_mix[[\"carrier\", \"booking_class\", \"avg_sold\"]]\n        if raw_df:\n            return df\n        return self._fig_fare_class_mix(\n            df,\n            label_threshold=label_threshold,\n            title=\"Fare Class Mix\",\n        )\n\n    @report_figure\n    def fig_od_fare_class_mix(\n        self, orig: str, dest: str, raw_df=False, label_threshold=0.06\n    ):\n        df = self.od_fare_class_mix[orig, dest][\n            [\"carrier\", \"booking_class\", \"avg_sold\"]\n        ]\n        if raw_df:\n            return df\n        return self._fig_fare_class_mix(\n            df, label_threshold=label_threshold, title=f\"Fare Class Mix ({orig}-{dest})\"\n        )\n\n    @property\n    def raw_fare_class_mix(self) -&gt; pd.DataFrame:\n        \"\"\"Raw data giving the fare class mix.\n\n        This tidy dataframe contains these columns:\n\n        - carrier (str)\n        - booking_class (str)\n        - avg_sold (float)\n        \"\"\"\n        return self.fig_fare_class_mix(raw_df=True)\n\n    @report_figure\n    def fig_bookings_by_timeframe(\n        self,\n        by_carrier: bool | str = True,\n        by_class: bool | str = False,\n        raw_df: bool = False,\n        errorbands: bool = False,\n        exclude_nogo: bool = True,\n    ):\n        if errorbands:\n            if by_carrier is True:\n                raise NotImplementedError(\"error bands for all airlines is messy\")\n            return self._fig_bookings_by_timeframe_errorband(\n                by_carrier=by_carrier, raw_df=raw_df\n            )\n\n        def differs(x):\n            return x.shift(-1, fill_value=0) - x\n\n        def _summarize(x: pd.DataFrame, c: str):\n            if \"trial\" not in x.columns:\n                x = x.assign(trial=0)\n            if by_class:\n                y = (\n                    x.groupby([\"trial\", \"carrier\", \"class\", \"rrd\"])[f\"avg_{c}\"]\n                    .sum()\n                    .unstack([\"trial\", \"carrier\", \"class\"])\n                    .sort_index(ascending=False)\n                    .apply(differs)\n                    .stack([\"carrier\", \"class\"])\n                    .aggregate([\"mean\", \"sem\"], axis=1)\n                    .assign(\n                        ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                        ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                    )\n                )\n            else:\n                y = (\n                    x.groupby([\"trial\", \"carrier\", \"rrd\"])[f\"avg_{c}\"]\n                    .sum()\n                    .unstack([\"trial\", \"carrier\"])\n                    .sort_index(ascending=False)\n                    .apply(differs)\n                    .stack(\"carrier\")\n                    .aggregate([\"mean\", \"sem\"], axis=1)\n                    .assign(\n                        ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                        ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                    )\n                )\n            return pd.concat({c: y}, names=[\"paxtype\"])\n\n        df0 = _summarize(self.bookings_by_timeframe, \"business\")\n        df1 = _summarize(self.bookings_by_timeframe, \"leisure\")\n        df = (\n            pd.concat([df0, df1], axis=0)\n            .rename(columns={\"mean\": \"sold\"})\n            .reset_index()\n            .query(\"(rrd&gt;0) &amp; (sold&gt;0)\")\n        )\n        title = \"Bookings by Timeframe\"\n        if by_class is True:\n            title = \"Bookings by Timeframe and Booking Class\"\n        title_annot = []\n        if not by_carrier:\n            g = [\"rrd\", \"paxtype\"]\n            if by_class:\n                g += [\"class\"]\n            df = df.groupby(g)[[\"sold\", \"ci0\", \"ci1\"]].sum().reset_index()\n        if isinstance(by_carrier, str):\n            df = df[df[\"carrier\"] == by_carrier]\n            df = df.drop(columns=[\"carrier\"])\n            title_annot.append(by_carrier)\n            by_carrier = False\n        if isinstance(by_class, str):\n            df = df[df[\"class\"] == by_class]\n            df = df.drop(columns=[\"class\"])\n            title_annot.append(f\"Class {by_class}\")\n            by_class = False\n        if title_annot:\n            title = f\"{title} ({', '.join(title_annot)})\"\n        if exclude_nogo and \"carrier\" in df.columns:\n            df = df[df[\"carrier\"] != \"NONE\"]\n        if raw_df:\n            return df\n\n        import altair as alt\n\n        if by_carrier:\n            color = \"carrier:N\"\n            color_title = \"Carrier\"\n        elif by_class:\n            color = \"class:N\"\n            color_title = \"Booking Class\"\n        else:\n            color = \"paxtype:N\"\n            color_title = \"Passenger Type\"\n\n        if by_class:\n            chart = (\n                alt.Chart(df)\n                .mark_bar()\n                .encode(\n                    color=alt.Color(color).title(color_title),\n                    x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n                    y=alt.Y(\"sold\"),\n                    tooltip=(\n                        [alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else []\n                    )\n                    + [\n                        alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                        alt.Tooltip(\"rrd\", title=\"DfD\"),\n                        alt.Tooltip(\"sold\", format=\".2f\"),\n                    ],\n                )\n                .properties(\n                    width=500,\n                    height=200,\n                )\n                .facet(\n                    row=alt.Row(\"paxtype:N\", title=\"Passenger Type\"),\n                    title=title,\n                )\n                .configure_title(fontSize=18)\n            )\n        else:\n            chart = (\n                alt.Chart(df, title=title)\n                .mark_line()\n                .encode(\n                    color=alt.Color(color).title(color_title),\n                    x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n                    y=alt.Y(\"sold\") if by_class else \"sold\",\n                    strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n                    tooltip=(\n                        [alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else []\n                    )\n                    + [\n                        alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                        alt.Tooltip(\"rrd\", title=\"DfD\"),\n                        alt.Tooltip(\"sold\", format=\".2f\"),\n                    ],\n                )\n                .properties(\n                    width=500,\n                    height=300,\n                )\n                .configure_axis(\n                    labelFontSize=12,\n                    titleFontSize=12,\n                )\n                .configure_legend(\n                    titleFontSize=12,\n                    labelFontSize=15,\n                )\n            )\n        return chart\n\n    def _fig_bookings_by_timeframe_errorband(\n        self, by_carrier: bool | str = True, raw_df=False\n    ):\n        def differs(x):\n            return x.shift(-1, fill_value=0) - x\n\n        b = self.bookings_by_timeframe\n\n        def _summarize(x, c):\n            y = (\n                x.groupby([\"trial\", \"carrier\", \"rrd\"])[f\"avg_{c}\"]\n                .sum()\n                .unstack([\"trial\", \"carrier\"])\n                .sort_index(ascending=False)\n                .apply(differs)\n                .stack(\"carrier\")\n                .aggregate([\"mean\", \"sem\"], axis=1)\n                .assign(\n                    ci0=lambda x: x[\"mean\"] - 1.96 * x[\"sem\"],\n                    ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                )\n            )\n            return pd.concat({c: y}, names=[\"paxtype\"])\n\n        df0 = _summarize(b, \"business\")\n        df1 = _summarize(b, \"leisure\")\n        df = (\n            pd.concat([df0, df1], axis=0)\n            .rename(columns={\"mean\": \"sold\"})\n            .reset_index()\n            .query(\"rrd&gt;0\")\n        )\n        if not by_carrier:\n            df = (\n                df.groupby([\"rrd\", \"paxtype\"])[[\"sold\", \"ci0\", \"ci1\"]]\n                .sum()\n                .reset_index()\n            )\n        if isinstance(by_carrier, str):\n            df = df[df[\"carrier\"] == by_carrier]\n            df = df.drop(columns=[\"carrier\"])\n            by_carrier = False\n        if raw_df:\n            return df\n        import altair as alt\n\n        chart = alt.Chart(df)\n        lines = chart.mark_line().encode(\n            color=alt.Color(\"carrier:N\" if by_carrier else \"paxtype\").title(\n                \"Carrier\" if by_carrier else \"Passenger Type\"\n            ),\n            x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n            y=\"sold\",\n            strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n            tooltip=([alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else [])\n            + [\n                alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                alt.Tooltip(\"rrd\", title=\"DfD\"),\n                alt.Tooltip(\"sold\", format=\".2f\"),\n            ],\n        )\n        bands = chart.mark_errorband().encode(\n            color=alt.Color(\n                \"carrier:N\" if by_carrier else \"paxtype\",\n                title=\"Carrier\" if by_carrier else \"Passenger Type\",\n            ),\n            x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n            y=\"ci0\",\n            y2=\"ci1\",\n            strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n        )\n\n        return (\n            (lines + bands)\n            .properties(\n                width=500,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n\n    def _fig_carrier_load_factors(\n        self,\n        raw_df: bool,\n        load_measure: str,\n        measure_name: str,\n        measure_format: str = \".2f\",\n        orient: Literal[\"h\", \"v\"] = \"h\",\n        title: str | None = None,\n    ):\n        df = self.carriers.reset_index()[[\"carrier\", load_measure]]\n        if raw_df:\n            return df\n        import altair as alt\n\n        chart = alt.Chart(df)\n        if orient == \"v\":\n            bars = chart.mark_bar().encode(\n                x=alt.X(\"carrier:N\", title=\"Carrier\"),\n                y=alt.Y(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                tooltip=[\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\n                        f\"{load_measure}:Q\", title=measure_name, format=measure_format\n                    ),\n                ],\n            )\n            text = chart.mark_text(dx=0, dy=3, color=\"white\", baseline=\"top\").encode(\n                x=alt.X(\"carrier:N\", title=\"Carrier\"),\n                y=alt.Y(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                text=alt.Text(f\"{load_measure}:Q\", format=measure_format),\n            )\n        else:\n            bars = chart.mark_bar().encode(\n                y=alt.Y(\"carrier:N\", title=\"Carrier\"),\n                x=alt.X(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                tooltip=[\n                    alt.Tooltip(\"carrier\", title=\"Carrier\"),\n                    alt.Tooltip(\n                        f\"{load_measure}:Q\", title=measure_name, format=measure_format\n                    ),\n                ],\n            )\n            text = chart.mark_text(\n                dx=-5, dy=0, color=\"white\", baseline=\"middle\", align=\"right\"\n            ).encode(\n                y=alt.Y(\"carrier:N\", title=\"Carrier\"),\n                x=alt.X(f\"{load_measure}:Q\", title=measure_name).stack(\"zero\"),\n                text=alt.Text(f\"{load_measure}:Q\", format=measure_format),\n            )\n        fig = (\n            (bars + text)\n            .properties(\n                width=500,\n                height=10 + 20 * len(df),\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n        if title:\n            fig.title = title\n        return fig\n\n    @report_figure\n    def fig_carrier_load_factors(\n        self, raw_df=False, load_measure: Literal[\"sys_lf\", \"avg_leg_lf\"] = \"sys_lf\"\n    ):\n        measure_name = (\n            \"System Load Factor\" if load_measure == \"sys_lf\" else \"Leg Load Factor\"\n        )\n        return self._fig_carrier_load_factors(\n            raw_df,\n            load_measure,\n            measure_name,\n            title=f\"Carrier {measure_name}s\",\n        )\n\n    @report_figure\n    def fig_carrier_revenues(self, raw_df=False):\n        return self._fig_carrier_load_factors(\n            raw_df, \"avg_rev\", \"Average Revenue\", \"$.4s\", title=\"Carrier Revenues\"\n        )\n\n    @report_figure\n    def fig_carrier_yields(self, raw_df=False):\n        return self._fig_carrier_load_factors(\n            raw_df, \"yield\", \"Average Yield\", \"$.4f\", title=\"Carrier Yields\"\n        )\n\n    def _fig_forecasts(\n        self, df, facet_on=None, y=\"forecast_mean\", color=\"booking_class:N\"\n    ):\n        import altair as alt\n\n        encoding = dict(\n            x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n            y=alt.Y(f\"{y}:Q\", title=\"Avg Demand Forecast\"),\n        )\n        if color:\n            encoding[\"color\"] = color\n        if not facet_on:\n            return alt.Chart(df).mark_line().encode(**encoding)\n        else:\n            return (\n                alt.Chart(df)\n                .mark_line()\n                .encode(**encoding)\n                .facet(\n                    facet=f\"{facet_on}:N\",\n                    columns=3,\n                )\n            )\n\n    @report_figure\n    def fig_leg_forecasts(\n        self,\n        by_flt_no: bool | int = True,\n        by_class: bool | str = True,\n        of: Literal[\"mu\", \"sigma\"] = \"mu\",\n        raw_df=False,\n    ):\n        y = \"forecast_mean\" if of == \"mu\" else \"forecast_stdev\"\n        columns = [\n            \"carrier\",\n            \"flt_no\",\n            \"booking_class\",\n            \"rrd\",\n            y,\n        ]\n        if self.leg_forecasts is None:\n            raise ValueError(\"the leg_forecasts summary table is not available\")\n        df = self.leg_forecasts[columns].reset_index()\n        color = \"booking_class:N\"\n        if isinstance(by_flt_no, int) and by_flt_no is not True:\n            df = df[df.flt_no == by_flt_no]\n        if isinstance(by_class, str):\n            df = df[df.booking_class == by_class]\n            color = None\n        if raw_df:\n            return df\n        return self._fig_forecasts(df, facet_on=None, y=y, color=color)\n\n    @report_figure\n    def fig_path_forecasts(\n        self,\n        by_path_id: bool | int = True,\n        by_class: bool | str = True,\n        of: Literal[\"mu\", \"sigma\", \"closed\"] = \"mu\",\n        raw_df=False,\n    ):\n        of_columns = {\n            \"mu\": \"forecast_mean\",\n            \"sigma\": \"forecast_stdev\",\n            \"closed\": \"forecast_closed_in_tf\",\n        }\n        y = of_columns.get(of)\n        columns = [\n            \"path_id\",\n            \"booking_class\",\n            \"rrd\",\n            y,\n        ]\n        df = self.path_forecasts[columns].reset_index()\n        color = \"booking_class:N\"\n        if isinstance(by_path_id, int) and by_path_id is not True:\n            df = df[df.path_id == by_path_id]\n        if isinstance(by_class, str):\n            df = df[df.booking_class == by_class]\n            color = None\n        if raw_df:\n            return df\n        facet_on = None\n        if by_path_id is True:\n            facet_on = \"path_id\"\n        return self._fig_forecasts(df, facet_on=facet_on, y=y, color=color)\n\n    @report_figure\n    def fig_bid_price_history(\n        self,\n        by_carrier: bool | str = True,\n        show_stdev: float | bool | None = None,\n        cap: Literal[\"some\", \"zero\", None] = None,\n        raw_df=False,\n    ):\n        if cap is None:\n            bp_mean = \"bid_price_mean\"\n        elif cap == \"some\":\n            bp_mean = \"some_cap_bid_price_mean\"\n        elif cap == \"zero\":\n            bp_mean = \"zero_cap_bid_price_mean\"\n        else:\n            raise ValueError(f\"cap={cap!r} not in ['some', 'zero', None]\")\n        df = self.bid_price_history.reset_index()\n        color = None\n        if isinstance(by_carrier, str):\n            df = df[df.carrier == by_carrier]\n        elif by_carrier:\n            color = \"carrier:N\"\n            if show_stdev is None:\n                show_stdev = False\n        if show_stdev:\n            if show_stdev is True:\n                show_stdev = 2\n            df[\"bid_price_upper\"] = df[bp_mean] + show_stdev * df[\"bid_price_stdev\"]\n            df[\"bid_price_lower\"] = (\n                df[bp_mean] - show_stdev * df[\"bid_price_stdev\"]\n            ).clip(0, None)\n        if raw_df:\n            return df\n\n        import altair as alt\n\n        line_encoding = dict(\n            x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"),\n            y=alt.Y(bp_mean, title=\"Bid Price\"),\n        )\n        if color:\n            line_encoding[\"color\"] = color\n        chart = alt.Chart(df)\n        fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n        if show_stdev:\n            area_encoding = dict(\n                x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"),\n                y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"),\n                y2=alt.Y2(\"bid_price_upper:Q\", title=\"Bid Price\"),\n            )\n            bound = chart.mark_area(\n                opacity=0.1,\n                interpolate=\"step-before\",\n            ).encode(**area_encoding)\n            bound_line = chart.mark_line(\n                opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\"\n            ).encode(x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"))\n            top_line = bound_line.encode(\n                y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\")\n            )\n            bottom_line = bound_line.encode(\n                y=alt.Y(\"bid_price_upper:Q\", title=\"Bid Price\")\n            )\n            fig = fig + bound + top_line + bottom_line\n        return fig\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.bid_price_history", "title": "bid_price_history  <code>instance-attribute</code>", "text": "<pre><code>bid_price_history = bid_price_history\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.bookings_by_timeframe", "title": "bookings_by_timeframe  <code>instance-attribute</code>", "text": "<pre><code>bookings_by_timeframe = bookings_by_timeframe\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.carrier_history", "title": "carrier_history  <code>instance-attribute</code>", "text": "<pre><code>carrier_history = carrier_history\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.carriers", "title": "carriers  <code>instance-attribute</code>", "text": "<pre><code>carriers = carriers\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.demand_to_come", "title": "demand_to_come  <code>instance-attribute</code>", "text": "<pre><code>demand_to_come = demand_to_come\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.demands", "title": "demands  <code>instance-attribute</code>", "text": "<pre><code>demands = demands\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fare_class_mix", "title": "fare_class_mix  <code>instance-attribute</code>", "text": "<pre><code>fare_class_mix = fare_class_mix\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fares", "title": "fares  <code>instance-attribute</code>", "text": "<pre><code>fares = fares\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.leg_forecasts", "title": "leg_forecasts  <code>instance-attribute</code>", "text": "<pre><code>leg_forecasts = leg_forecasts\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.legs", "title": "legs  <code>instance-attribute</code>", "text": "<pre><code>legs = legs\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.load_factors", "title": "load_factors  <code>instance-attribute</code>", "text": "<pre><code>load_factors = load_factors\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.local_and_flow_yields", "title": "local_and_flow_yields  <code>instance-attribute</code>", "text": "<pre><code>local_and_flow_yields = local_and_flow_yields\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.od_fare_class_mix", "title": "od_fare_class_mix  <code>instance-attribute</code>", "text": "<pre><code>od_fare_class_mix = od_fare_class_mix\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.path_classes", "title": "path_classes  <code>instance-attribute</code>", "text": "<pre><code>path_classes = path_classes\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.path_forecasts", "title": "path_forecasts  <code>instance-attribute</code>", "text": "<pre><code>path_forecasts = path_forecasts\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.paths", "title": "paths  <code>instance-attribute</code>", "text": "<pre><code>paths = paths\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.raw_fare_class_mix", "title": "raw_fare_class_mix  <code>property</code>", "text": "<pre><code>raw_fare_class_mix: pd.DataFrame\n</code></pre> <p>Raw data giving the fare class mix.</p> <p>This tidy dataframe contains these columns:</p> <ul> <li>carrier (str)</li> <li>booking_class (str)</li> <li>avg_sold (float)</li> </ul>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.total_demand", "title": "total_demand  <code>instance-attribute</code>", "text": "<pre><code>total_demand = total_demand\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    demands: pd.DataFrame | None = None,\n    fares: pd.DataFrame | None = None,\n    legs: pd.DataFrame | None = None,\n    paths: pd.DataFrame | None = None,\n    path_classes: pd.DataFrame | None = None,\n    carriers: pd.DataFrame | None = None,\n    fare_class_mix: pd.DataFrame | None = None,\n    load_factors: pd.DataFrame | None = None,\n    bookings_by_timeframe: pd.DataFrame | None = None,\n    total_demand: float | None = None,\n    od_fare_class_mix: dict[tuple[str, str], pd.DataFrame]\n    | None = None,\n    leg_forecasts: pd.DataFrame | None = None,\n    path_forecasts: pd.DataFrame | None = None,\n    carrier_history: pd.DataFrame | None = None,\n    demand_to_come: pd.DataFrame | None = None,\n    bid_price_history: pd.DataFrame | None = None,\n    local_and_flow_yields: pd.DataFrame | None = None,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>def __init__(\n    self,\n    demands: pd.DataFrame | None = None,\n    fares: pd.DataFrame | None = None,\n    legs: pd.DataFrame | None = None,\n    paths: pd.DataFrame | None = None,\n    path_classes: pd.DataFrame | None = None,\n    carriers: pd.DataFrame | None = None,\n    fare_class_mix: pd.DataFrame | None = None,\n    load_factors: pd.DataFrame | None = None,\n    bookings_by_timeframe: pd.DataFrame | None = None,\n    total_demand: float | None = None,\n    od_fare_class_mix: dict[tuple[str, str], pd.DataFrame] | None = None,\n    leg_forecasts: pd.DataFrame | None = None,\n    path_forecasts: pd.DataFrame | None = None,\n    carrier_history: pd.DataFrame | None = None,\n    demand_to_come: pd.DataFrame | None = None,\n    bid_price_history: pd.DataFrame | None = None,\n    local_and_flow_yields: pd.DataFrame | None = None,\n):\n    self.demands = demands\n    self.fares = fares\n    self.legs = legs\n    self.paths = paths\n    self.path_classes = path_classes\n    self.carriers = carriers\n    self.fare_class_mix = fare_class_mix\n    self.od_fare_class_mix = od_fare_class_mix\n    self.load_factors = load_factors\n    self.bookings_by_timeframe = bookings_by_timeframe\n    self.total_demand = total_demand\n    self.leg_forecasts = leg_forecasts\n    self.path_forecasts = path_forecasts\n    self.carrier_history = carrier_history\n    self.demand_to_come = demand_to_come\n    self.bid_price_history = bid_price_history\n    self.local_and_flow_yields = local_and_flow_yields\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.aggregate_demand_history", "title": "aggregate_demand_history", "text": "<pre><code>aggregate_demand_history(\n    by_segment: bool = True,\n) -&gt; pd.Series\n</code></pre> <p>Total demand by sample, aggregated over all markets.</p> <p>Parameters:</p> <ul> <li> <code>by_segment</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Aggregate by segment.  If false, segments are also aggregated.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>         \u2013          <p>Total demand, indexed by trial, sample, and segment (business/leisure).</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def aggregate_demand_history(self, by_segment: bool = True) -&gt; pd.Series:\n    \"\"\"\n    Total demand by sample, aggregated over all markets.\n\n    Parameters\n    ----------\n    by_segment : bool, default True\n        Aggregate by segment.  If false, segments are also aggregated.\n\n    Returns\n    -------\n    pandas.Series\n        Total demand, indexed by trial, sample, and segment\n        (business/leisure).\n    \"\"\"\n    groupbys = [\"trial\", \"sample\"]\n    if by_segment:\n        groupbys.append(\"segment\")\n    return self.demand_to_come.iloc[:, 0].groupby(groupbys, observed=False).sum()\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.demand_in_tf", "title": "demand_in_tf", "text": "<pre><code>demand_in_tf() -&gt; pd.DataFrame | None\n</code></pre> <p>History of demand arriving in each timeframe.</p> <p>This dataframe is derived from the <code>demand_to_come</code> dataframe by taking the sequential differences.</p> Source code in <code>passengersim/summary.py</code> <pre><code>def demand_in_tf(self) -&gt; pd.DataFrame | None:\n    \"\"\"History of demand arriving in each timeframe.\n\n    This dataframe is derived from the `demand_to_come` dataframe\n    by taking the sequential differences.\n    \"\"\"\n    if self.demand_to_come is None:\n        return None\n    return self.demand_to_come.diff(-1, axis=1).iloc[:, :-1]\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_bid_price_history", "title": "fig_bid_price_history", "text": "<pre><code>fig_bid_price_history(\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_bid_price_history(\n    self,\n    by_carrier: bool | str = True,\n    show_stdev: float | bool | None = None,\n    cap: Literal[\"some\", \"zero\", None] = None,\n    raw_df=False,\n):\n    if cap is None:\n        bp_mean = \"bid_price_mean\"\n    elif cap == \"some\":\n        bp_mean = \"some_cap_bid_price_mean\"\n    elif cap == \"zero\":\n        bp_mean = \"zero_cap_bid_price_mean\"\n    else:\n        raise ValueError(f\"cap={cap!r} not in ['some', 'zero', None]\")\n    df = self.bid_price_history.reset_index()\n    color = None\n    if isinstance(by_carrier, str):\n        df = df[df.carrier == by_carrier]\n    elif by_carrier:\n        color = \"carrier:N\"\n        if show_stdev is None:\n            show_stdev = False\n    if show_stdev:\n        if show_stdev is True:\n            show_stdev = 2\n        df[\"bid_price_upper\"] = df[bp_mean] + show_stdev * df[\"bid_price_stdev\"]\n        df[\"bid_price_lower\"] = (\n            df[bp_mean] - show_stdev * df[\"bid_price_stdev\"]\n        ).clip(0, None)\n    if raw_df:\n        return df\n\n    import altair as alt\n\n    line_encoding = dict(\n        x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"),\n        y=alt.Y(bp_mean, title=\"Bid Price\"),\n    )\n    if color:\n        line_encoding[\"color\"] = color\n    chart = alt.Chart(df)\n    fig = chart.mark_line(interpolate=\"step-before\").encode(**line_encoding)\n    if show_stdev:\n        area_encoding = dict(\n            x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"),\n            y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\"),\n            y2=alt.Y2(\"bid_price_upper:Q\", title=\"Bid Price\"),\n        )\n        bound = chart.mark_area(\n            opacity=0.1,\n            interpolate=\"step-before\",\n        ).encode(**area_encoding)\n        bound_line = chart.mark_line(\n            opacity=0.4, strokeDash=[5, 5], interpolate=\"step-before\"\n        ).encode(x=alt.X(\"rrd:Q\").scale(reverse=True).title(\"Days from Departure\"))\n        top_line = bound_line.encode(\n            y=alt.Y(\"bid_price_lower:Q\", title=\"Bid Price\")\n        )\n        bottom_line = bound_line.encode(\n            y=alt.Y(\"bid_price_upper:Q\", title=\"Bid Price\")\n        )\n        fig = fig + bound + top_line + bottom_line\n    return fig\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_bookings_by_timeframe", "title": "fig_bookings_by_timeframe", "text": "<pre><code>fig_bookings_by_timeframe(\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df: bool = False,\n    errorbands: bool = False,\n    exclude_nogo: bool = True,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_bookings_by_timeframe(\n    self,\n    by_carrier: bool | str = True,\n    by_class: bool | str = False,\n    raw_df: bool = False,\n    errorbands: bool = False,\n    exclude_nogo: bool = True,\n):\n    if errorbands:\n        if by_carrier is True:\n            raise NotImplementedError(\"error bands for all airlines is messy\")\n        return self._fig_bookings_by_timeframe_errorband(\n            by_carrier=by_carrier, raw_df=raw_df\n        )\n\n    def differs(x):\n        return x.shift(-1, fill_value=0) - x\n\n    def _summarize(x: pd.DataFrame, c: str):\n        if \"trial\" not in x.columns:\n            x = x.assign(trial=0)\n        if by_class:\n            y = (\n                x.groupby([\"trial\", \"carrier\", \"class\", \"rrd\"])[f\"avg_{c}\"]\n                .sum()\n                .unstack([\"trial\", \"carrier\", \"class\"])\n                .sort_index(ascending=False)\n                .apply(differs)\n                .stack([\"carrier\", \"class\"])\n                .aggregate([\"mean\", \"sem\"], axis=1)\n                .assign(\n                    ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                    ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                )\n            )\n        else:\n            y = (\n                x.groupby([\"trial\", \"carrier\", \"rrd\"])[f\"avg_{c}\"]\n                .sum()\n                .unstack([\"trial\", \"carrier\"])\n                .sort_index(ascending=False)\n                .apply(differs)\n                .stack(\"carrier\")\n                .aggregate([\"mean\", \"sem\"], axis=1)\n                .assign(\n                    ci0=lambda x: np.maximum(x[\"mean\"] - 1.96 * x[\"sem\"], 0),\n                    ci1=lambda x: x[\"mean\"] + 1.96 * x[\"sem\"],\n                )\n            )\n        return pd.concat({c: y}, names=[\"paxtype\"])\n\n    df0 = _summarize(self.bookings_by_timeframe, \"business\")\n    df1 = _summarize(self.bookings_by_timeframe, \"leisure\")\n    df = (\n        pd.concat([df0, df1], axis=0)\n        .rename(columns={\"mean\": \"sold\"})\n        .reset_index()\n        .query(\"(rrd&gt;0) &amp; (sold&gt;0)\")\n    )\n    title = \"Bookings by Timeframe\"\n    if by_class is True:\n        title = \"Bookings by Timeframe and Booking Class\"\n    title_annot = []\n    if not by_carrier:\n        g = [\"rrd\", \"paxtype\"]\n        if by_class:\n            g += [\"class\"]\n        df = df.groupby(g)[[\"sold\", \"ci0\", \"ci1\"]].sum().reset_index()\n    if isinstance(by_carrier, str):\n        df = df[df[\"carrier\"] == by_carrier]\n        df = df.drop(columns=[\"carrier\"])\n        title_annot.append(by_carrier)\n        by_carrier = False\n    if isinstance(by_class, str):\n        df = df[df[\"class\"] == by_class]\n        df = df.drop(columns=[\"class\"])\n        title_annot.append(f\"Class {by_class}\")\n        by_class = False\n    if title_annot:\n        title = f\"{title} ({', '.join(title_annot)})\"\n    if exclude_nogo and \"carrier\" in df.columns:\n        df = df[df[\"carrier\"] != \"NONE\"]\n    if raw_df:\n        return df\n\n    import altair as alt\n\n    if by_carrier:\n        color = \"carrier:N\"\n        color_title = \"Carrier\"\n    elif by_class:\n        color = \"class:N\"\n        color_title = \"Booking Class\"\n    else:\n        color = \"paxtype:N\"\n        color_title = \"Passenger Type\"\n\n    if by_class:\n        chart = (\n            alt.Chart(df)\n            .mark_bar()\n            .encode(\n                color=alt.Color(color).title(color_title),\n                x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n                y=alt.Y(\"sold\"),\n                tooltip=(\n                    [alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else []\n                )\n                + [\n                    alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"rrd\", title=\"DfD\"),\n                    alt.Tooltip(\"sold\", format=\".2f\"),\n                ],\n            )\n            .properties(\n                width=500,\n                height=200,\n            )\n            .facet(\n                row=alt.Row(\"paxtype:N\", title=\"Passenger Type\"),\n                title=title,\n            )\n            .configure_title(fontSize=18)\n        )\n    else:\n        chart = (\n            alt.Chart(df, title=title)\n            .mark_line()\n            .encode(\n                color=alt.Color(color).title(color_title),\n                x=alt.X(\"rrd:O\").scale(reverse=True).title(\"Days from Departure\"),\n                y=alt.Y(\"sold\") if by_class else \"sold\",\n                strokeDash=alt.StrokeDash(\"paxtype\").title(\"Passenger Type\"),\n                tooltip=(\n                    [alt.Tooltip(\"carrier\").title(\"Carrier\")] if by_carrier else []\n                )\n                + [\n                    alt.Tooltip(\"paxtype\", title=\"Passenger Type\"),\n                    alt.Tooltip(\"rrd\", title=\"DfD\"),\n                    alt.Tooltip(\"sold\", format=\".2f\"),\n                ],\n            )\n            .properties(\n                width=500,\n                height=300,\n            )\n            .configure_axis(\n                labelFontSize=12,\n                titleFontSize=12,\n            )\n            .configure_legend(\n                titleFontSize=12,\n                labelFontSize=15,\n            )\n        )\n    return chart\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_load_factors", "title": "fig_carrier_load_factors", "text": "<pre><code>fig_carrier_load_factors(\n    raw_df=False,\n    load_measure: Literal[\n        \"sys_lf\", \"avg_leg_lf\"\n    ] = \"sys_lf\",\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_carrier_load_factors(\n    self, raw_df=False, load_measure: Literal[\"sys_lf\", \"avg_leg_lf\"] = \"sys_lf\"\n):\n    measure_name = (\n        \"System Load Factor\" if load_measure == \"sys_lf\" else \"Leg Load Factor\"\n    )\n    return self._fig_carrier_load_factors(\n        raw_df,\n        load_measure,\n        measure_name,\n        title=f\"Carrier {measure_name}s\",\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_mileage", "title": "fig_carrier_mileage", "text": "<pre><code>fig_carrier_mileage(raw_df: bool = False, report=None)\n</code></pre> <p>Figure showing ASM, RPM by carrier.</p> <p>ASM is available seat miles.  RPM is revenue passenger miles.</p> <p>Parameters:</p> <ul> <li> <code>raw_df</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Return the raw data for this figure as a pandas DataFrame, instead of generating the figure itself.</p> </li> <li> <code>report</code>             (<code>Reporter</code>, default:                 <code>None</code> )         \u2013          <p>Also append this figure to the given report.</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def fig_carrier_mileage(self, raw_df: bool = False, report=None):\n    \"\"\"\n    Figure showing ASM, RPM by carrier.\n\n    ASM is available seat miles.  RPM is revenue passenger miles.\n\n    Parameters\n    ----------\n    raw_df : bool, default False\n        Return the raw data for this figure as a pandas DataFrame, instead\n        of generating the figure itself.\n    report : xmle.Reporter, optional\n        Also append this figure to the given report.\n    \"\"\"\n    df = (\n        self.carriers.reset_index()[[\"carrier\", \"asm\", \"rpm\"]]\n        .set_index(\"carrier\")\n        .rename_axis(columns=\"measure\")\n        .unstack()\n        .to_frame(\"value\")\n        .reset_index()\n    )\n    if raw_df:\n        return df\n    import altair as alt\n\n    chart = alt.Chart(df, title=\"Carrier Loads\")\n    bars = chart.mark_bar().encode(\n        x=alt.X(\"carrier:N\", title=\"Carrier\"),\n        y=alt.Y(\"value\", stack=None, title=\"miles\"),\n        color=\"measure\",\n        tooltip=[\"carrier\", \"measure\", alt.Tooltip(\"value\", format=\".4s\")],\n    )\n    text = chart.mark_text(\n        dx=0,\n        dy=5,\n        color=\"white\",\n        baseline=\"top\",\n    ).encode(\n        x=alt.X(\"carrier:N\"),\n        y=alt.Y(\"value\").stack(None),\n        text=alt.Text(\"value:Q\", format=\".4s\"),\n    )\n    fig = (\n        (bars + text)\n        .properties(\n            width=400,\n            height=300,\n        )\n        .configure_axis(\n            labelFontSize=12,\n            titleFontSize=12,\n        )\n        .configure_legend(\n            titleFontSize=12,\n            labelFontSize=15,\n        )\n    )\n    if report:\n        report.add_figure(fig)\n    return fig\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_revenues", "title": "fig_carrier_revenues", "text": "<pre><code>fig_carrier_revenues(raw_df=False)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_carrier_revenues(self, raw_df=False):\n    return self._fig_carrier_load_factors(\n        raw_df, \"avg_rev\", \"Average Revenue\", \"$.4s\", title=\"Carrier Revenues\"\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_carrier_yields", "title": "fig_carrier_yields", "text": "<pre><code>fig_carrier_yields(raw_df=False)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_carrier_yields(self, raw_df=False):\n    return self._fig_carrier_load_factors(\n        raw_df, \"yield\", \"Average Yield\", \"$.4f\", title=\"Carrier Yields\"\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_fare_class_mix", "title": "fig_fare_class_mix", "text": "<pre><code>fig_fare_class_mix(raw_df=False, label_threshold=0.06)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_fare_class_mix(self, raw_df=False, label_threshold=0.06):\n    df = self.fare_class_mix[[\"carrier\", \"booking_class\", \"avg_sold\"]]\n    if raw_df:\n        return df\n    return self._fig_fare_class_mix(\n        df,\n        label_threshold=label_threshold,\n        title=\"Fare Class Mix\",\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_leg_forecasts", "title": "fig_leg_forecasts", "text": "<pre><code>fig_leg_forecasts(\n    by_flt_no: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"] = \"mu\",\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_leg_forecasts(\n    self,\n    by_flt_no: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\"] = \"mu\",\n    raw_df=False,\n):\n    y = \"forecast_mean\" if of == \"mu\" else \"forecast_stdev\"\n    columns = [\n        \"carrier\",\n        \"flt_no\",\n        \"booking_class\",\n        \"rrd\",\n        y,\n    ]\n    if self.leg_forecasts is None:\n        raise ValueError(\"the leg_forecasts summary table is not available\")\n    df = self.leg_forecasts[columns].reset_index()\n    color = \"booking_class:N\"\n    if isinstance(by_flt_no, int) and by_flt_no is not True:\n        df = df[df.flt_no == by_flt_no]\n    if isinstance(by_class, str):\n        df = df[df.booking_class == by_class]\n        color = None\n    if raw_df:\n        return df\n    return self._fig_forecasts(df, facet_on=None, y=y, color=color)\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_od_fare_class_mix", "title": "fig_od_fare_class_mix", "text": "<pre><code>fig_od_fare_class_mix(\n    orig: str, dest: str, raw_df=False, label_threshold=0.06\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_od_fare_class_mix(\n    self, orig: str, dest: str, raw_df=False, label_threshold=0.06\n):\n    df = self.od_fare_class_mix[orig, dest][\n        [\"carrier\", \"booking_class\", \"avg_sold\"]\n    ]\n    if raw_df:\n        return df\n    return self._fig_fare_class_mix(\n        df, label_threshold=label_threshold, title=f\"Fare Class Mix ({orig}-{dest})\"\n    )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.fig_path_forecasts", "title": "fig_path_forecasts", "text": "<pre><code>fig_path_forecasts(\n    by_path_id: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\", \"closed\"] = \"mu\",\n    raw_df=False,\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@report_figure\ndef fig_path_forecasts(\n    self,\n    by_path_id: bool | int = True,\n    by_class: bool | str = True,\n    of: Literal[\"mu\", \"sigma\", \"closed\"] = \"mu\",\n    raw_df=False,\n):\n    of_columns = {\n        \"mu\": \"forecast_mean\",\n        \"sigma\": \"forecast_stdev\",\n        \"closed\": \"forecast_closed_in_tf\",\n    }\n    y = of_columns.get(of)\n    columns = [\n        \"path_id\",\n        \"booking_class\",\n        \"rrd\",\n        y,\n    ]\n    df = self.path_forecasts[columns].reset_index()\n    color = \"booking_class:N\"\n    if isinstance(by_path_id, int) and by_path_id is not True:\n        df = df[df.path_id == by_path_id]\n    if isinstance(by_class, str):\n        df = df[df.booking_class == by_class]\n        color = None\n    if raw_df:\n        return df\n    facet_on = None\n    if by_path_id is True:\n        facet_on = \"path_id\"\n    return self._fig_forecasts(df, facet_on=facet_on, y=y, color=color)\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.from_sqlite", "title": "from_sqlite  <code>classmethod</code>", "text": "<pre><code>from_sqlite(\n    filename: str,\n    make_indexes: bool = False,\n    additional: Collection[str | tuple] = (\n        \"fare_class_mix\",\n        \"load_factors\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n    ),\n)\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>@classmethod\ndef from_sqlite(\n    cls,\n    filename: str,\n    make_indexes: bool = False,\n    additional: Collection[str | tuple] = (\n        \"fare_class_mix\",\n        \"load_factors\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n    ),\n):\n    if not os.path.isfile(filename):\n        raise FileNotFoundError(filename)\n    db = database.Database(\n        engine=\"sqlite\",\n        filename=filename,\n    )\n\n    demands = cls.load_basic_table(db, \"demand_summary\")\n    legs = cls.load_basic_table(db, \"leg_summary\")\n    paths = cls.load_basic_table(db, \"path_summary\")\n    carriers = cls.load_basic_table(db, \"carrier_summary\")\n\n    summary = cls(\n        demands=demands,\n        legs=legs,\n        paths=paths,\n        carriers=carriers,\n    )\n\n    if make_indexes:\n        db.add_indexes()\n\n    logger.info(\"loading configs\")\n    config = db.load_configs()\n\n    summary.load_additional_tables(\n        db,\n        scenario=config.scenario,\n        burn_samples=config.simulation_controls.burn_samples,\n        additional=additional,\n    )\n    summary.cnx = db\n    return summary\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.load_additional_tables", "title": "load_additional_tables", "text": "<pre><code>load_additional_tables(\n    db: database.Database,\n    scenario: str,\n    burn_samples: int,\n    additional: Collection[str | tuple] = (\n        \"fare_class_mix\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n    ),\n) -&gt; None\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>def load_additional_tables(\n    self,\n    db: database.Database,\n    scenario: str,\n    burn_samples: int,\n    additional: Collection[str | tuple] = (\n        \"fare_class_mix\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n    ),\n) -&gt; None:\n    if \"fare_class_mix\" in additional and db.is_open:\n        logger.info(\"loading fare_class_mix\")\n        self.fare_class_mix = database.common_queries.fare_class_mix(\n            db, scenario, burn_samples=burn_samples\n        )\n        if self.od_fare_class_mix:\n            for orig, dest in list(self.od_fare_class_mix):\n                self.od_fare_class_mix[\n                    (orig, dest)\n                ] = database.common_queries.od_fare_class_mix(\n                    db, orig, dest, scenario, burn_samples=burn_samples\n                )\n\n    for i in additional:\n        if isinstance(i, tuple) and i[0] == \"od_fare_class_mix\" and db.is_open:\n            orig, dest = i[1], i[2]\n            if self.od_fare_class_mix is None:\n                self.od_fare_class_mix = {}\n            logger.info(f\"loading od_fare_class_mix({orig},{dest})\")\n            self.od_fare_class_mix[\n                (orig, dest)\n            ] = database.common_queries.od_fare_class_mix(\n                db, orig, dest, scenario, burn_samples=burn_samples\n            )\n\n    if \"bookings_by_timeframe\" in additional and db.is_open:\n        logger.info(\"loading bookings_by_timeframe\")\n        self.bookings_by_timeframe = database.common_queries.bookings_by_timeframe(\n            db, scenario, burn_samples=burn_samples\n        )\n\n    if \"total_demand\" in additional and db.is_open:\n        logger.info(\"loading total_demand\")\n        self.total_demand = database.common_queries.total_demand(\n            db, scenario, burn_samples\n        )\n\n    if \"leg_forecasts\" in additional and db.is_open:\n        logger.info(\"loading leg_forecasts\")\n        self.leg_forecasts = database.common_queries.leg_forecasts(\n            db, scenario, burn_samples\n        )\n\n    if \"path_forecasts\" in additional and db.is_open:\n        logger.info(\"loading path_forecasts\")\n        self.path_forecasts = database.common_queries.path_forecasts(\n            db, scenario, burn_samples\n        )\n\n    if \"demand_to_come\" in additional and db.is_open:\n        logger.info(\"loading demand_to_come\")\n        self.demand_to_come = database.common_queries.demand_to_come(db, scenario)\n\n    if \"carrier_history\" in additional and db.is_open:\n        logger.info(\"loading carrier_history\")\n        self.carrier_history = database.common_queries.carrier_history(db, scenario)\n\n    if \"bid_price_history\" in additional and db.is_open:\n        logger.info(\"loading bid_price_history\")\n        self.bid_price_history = database.common_queries.bid_price_history(\n            db, scenario, burn_samples\n        )\n\n    if \"local_and_flow_yields\" in additional and db.is_open:\n        logger.info(\"loading local_and_flow_yields\")\n        self.local_and_flow_yields = database.common_queries.local_and_flow_yields(\n            db, scenario, burn_samples\n        )\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.load_basic_table", "title": "load_basic_table  <code>classmethod</code>", "text": "<pre><code>load_basic_table(db: database.Database, tablename: str)\n</code></pre> <p>Load a basic table</p> Source code in <code>passengersim/summary.py</code> <pre><code>@classmethod\ndef load_basic_table(self, db: database.Database, tablename: str):\n    \"\"\"Load a basic table\"\"\"\n    logger.info(\"loading %s\", tablename)\n    return db.dataframe(f\"SELECT * FROM {tablename}\")\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.to_records", "title": "to_records", "text": "<pre><code>to_records()\n</code></pre> Source code in <code>passengersim/summary.py</code> <pre><code>def to_records(self):\n    return {k: v.to_dict(orient=\"records\") for (k, v) in self.__dict__.items()}\n</code></pre>"}, {"location": "API/summary.html#passengersim.summary.SummaryTables.to_xlsx", "title": "to_xlsx", "text": "<pre><code>to_xlsx(filename: str | pathlib.Path) -&gt; None\n</code></pre> <p>Write summary tables to excel.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>Path - like</code>)         \u2013          <p>The excel file to write.</p> </li> </ul> Source code in <code>passengersim/summary.py</code> <pre><code>def to_xlsx(self, filename: str | pathlib.Path) -&gt; None:\n    \"\"\"Write summary tables to excel.\n\n    Parameters\n    ----------\n    filename : Path-like\n        The excel file to write.\n    \"\"\"\n    if isinstance(filename, str):\n        filename = pathlib.Path(filename)\n    filename.parent.mkdir(exist_ok=True, parents=True)\n    with pd.ExcelWriter(filename) as writer:\n        for k, v in self.__dict__.items():\n            if isinstance(v, pd.DataFrame):\n                v.to_excel(writer, sheet_name=k)\n</code></pre>"}, {"location": "API/Core/index.html", "title": "PassengerSim.Core API", "text": "<p>While the main <code>passengersim</code> package available as a freely downloadable open source package, the functionality in the <code>passengersim.core</code> sub-package  is only available to authorized users.  The documentation of the API for this  sub-package is provided here. </p>"}, {"location": "API/Core/00-SimulationEngine.html", "title": "Simulation Engine", "text": ""}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine-attributes", "title": "Attributes", "text": ""}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.airlines", "title": "airlines  <code>instance-attribute</code>", "text": "<pre><code>airlines: Iterator[Airline]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.base_time", "title": "base_time  <code>instance-attribute</code>", "text": "<pre><code>base_time: int\n</code></pre> <p>The base time of the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.bucketnames", "title": "bucketnames  <code>instance-attribute</code>", "text": "<pre><code>bucketnames: Iterator[str]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.buckets", "title": "buckets  <code>instance-attribute</code>", "text": "<pre><code>buckets: Iterator[Bucket]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.burn_samples", "title": "burn_samples  <code>instance-attribute</code>", "text": "<pre><code>burn_samples: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.config", "title": "config  <code>instance-attribute</code>", "text": "<pre><code>config: Config | None\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.demands", "title": "demands  <code>instance-attribute</code>", "text": "<pre><code>demands: Iterator[Demand]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.disable_ap", "title": "disable_ap  <code>instance-attribute</code>", "text": "<pre><code>disable_ap: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.dwm_lite", "title": "dwm_lite  <code>instance-attribute</code>", "text": "<pre><code>dwm_lite: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.fares", "title": "fares  <code>instance-attribute</code>", "text": "<pre><code>fares: Iterator[Fare]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.iteration", "title": "iteration  <code>instance-attribute</code>", "text": "<pre><code>iteration: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.last_dcp", "title": "last_dcp  <code>instance-attribute</code>", "text": "<pre><code>last_dcp: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.last_event_time", "title": "last_event_time  <code>instance-attribute</code>", "text": "<pre><code>last_event_time: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.legs", "title": "legs  <code>instance-attribute</code>", "text": "<pre><code>legs: Iterator[Leg]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.manual_paths", "title": "manual_paths  <code>instance-attribute</code>", "text": "<pre><code>manual_paths: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.max_connect_time", "title": "max_connect_time  <code>instance-attribute</code>", "text": "<pre><code>max_connect_time: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.mkt_k_factor", "title": "mkt_k_factor  <code>instance-attribute</code>", "text": "<pre><code>mkt_k_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_samples", "title": "num_samples  <code>instance-attribute</code>", "text": "<pre><code>num_samples: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_trials", "title": "num_trials  <code>instance-attribute</code>", "text": "<pre><code>num_trials: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.pathclasses", "title": "pathclasses  <code>instance-attribute</code>", "text": "<pre><code>pathclasses: Iterator[PathClass]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.paths", "title": "paths  <code>instance-attribute</code>", "text": "<pre><code>paths: Iterator[Path]\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.pax_type_k_factor", "title": "pax_type_k_factor  <code>instance-attribute</code>", "text": "<pre><code>pax_type_k_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.prorate_revenue", "title": "prorate_revenue  <code>instance-attribute</code>", "text": "<pre><code>prorate_revenue: bool\n</code></pre> <p>When set to True, O&amp;D revenue is prorated by mileage to the leg level</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator: Generator\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.rm_start_sample", "title": "rm_start_sample  <code>instance-attribute</code>", "text": "<pre><code>rm_start_sample: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.sample", "title": "sample  <code>instance-attribute</code>", "text": "<pre><code>sample: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.save_timeframe_details", "title": "save_timeframe_details  <code>instance-attribute</code>", "text": "<pre><code>save_timeframe_details: bool\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.snapshot_filters", "title": "snapshot_filters  <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[SnapshotFilter] | None\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.sys_k_factor", "title": "sys_k_factor  <code>instance-attribute</code>", "text": "<pre><code>sys_k_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.tf_k_factor", "title": "tf_k_factor  <code>instance-attribute</code>", "text": "<pre><code>tf_k_factor: float\n</code></pre> <p>Timeframe k-factor, controls variance in the passenger arrival curves</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.tf_z_factor", "title": "tf_z_factor  <code>instance-attribute</code>", "text": "<pre><code>tf_z_factor: float\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.trial", "title": "trial  <code>instance-attribute</code>", "text": "<pre><code>trial: int\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine-functions", "title": "Functions", "text": ""}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.__init__", "title": "__init__", "text": "<pre><code>__init__(name: str = 'Incognito', random_generator=None)\n</code></pre>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_airline", "title": "add_airline", "text": "<pre><code>add_airline(airline: Airline) -&gt; None\n</code></pre> <p>Add an Airline to the simulation</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_demand", "title": "add_demand", "text": "<pre><code>add_demand(dmd: Demand) -&gt; None\n</code></pre> <p>Add a Market Segment demand to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_event", "title": "add_event", "text": "<pre><code>add_event(e: Event) -&gt; None\n</code></pre> <p>Add a user Event to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_fare", "title": "add_fare", "text": "<pre><code>add_fare(fare: Fare) -&gt; None\n</code></pre> <p>Add a Fare to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_frat5", "title": "add_frat5", "text": "<pre><code>add_frat5(frat5: Frat5) -&gt; None\n</code></pre> <p>Add a Frat5 curve to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_leg", "title": "add_leg", "text": "<pre><code>add_leg(leg: Leg) -&gt; None\n</code></pre> <p>Add a Leg to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.add_path", "title": "add_path", "text": "<pre><code>add_path(path: Path) -&gt; None\n</code></pre> <p>Add a Path to the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.allocate_demand_to_tf", "title": "allocate_demand_to_tf", "text": "<pre><code>allocate_demand_to_tf(\n    dmd: Demand,\n    num_pax: int,\n    tf_k_factor: float,\n    endTS: int,\n    debug: bool = False,\n) -&gt; tuple[int]\n</code></pre> <p>Generate events for a single demand</p> <p>Parameters:</p> <ul> <li> <code>dmd</code>             (<code>Demand</code>)         \u2013          </li> <li> <code>num_pax</code>             (<code>int</code>)         \u2013          </li> <li> <code>tf_k_factor</code>             (<code>float</code>)         \u2013          </li> <li> <code>endTS</code>             (<code>int</code>)         \u2013          </li> <li> <code>debug</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p>Number of events allocated.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.allocate_demand_to_tf_pods", "title": "allocate_demand_to_tf_pods", "text": "<pre><code>allocate_demand_to_tf_pods(\n    dmd: Demand,\n    num_pax: int,\n    tf_k_factor: float,\n    endTS: int,\n    debug: bool = False,\n) -&gt; tuple[int]\n</code></pre> <p>Generate events for a single demand (used to simulate PODS processing)</p> <p>Parameters:</p> <ul> <li> <code>dmd</code>             (<code>Demand</code>)         \u2013          </li> <li> <code>num_pax</code>             (<code>int</code>)         \u2013          </li> <li> <code>tf_k_factor</code>             (<code>float</code>)         \u2013          </li> <li> <code>endTS</code>             (<code>int</code>)         \u2013          </li> <li> <code>debug</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int]</code>         \u2013          <p>Number of events allocated by DCP.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.build_connections", "title": "build_connections", "text": "<pre><code>build_connections() -&gt; None\n</code></pre> <p>Build connections for the demands.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.build_expiration", "title": "build_expiration", "text": "<pre><code>build_expiration() -&gt; datetime.datetime\n</code></pre> <p>Get the expiration time for this build.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.final_write_to_sqlite", "title": "final_write_to_sqlite", "text": "<pre><code>final_write_to_sqlite(cnx: sqlite3.Connection)\n</code></pre> <p>Write final summary details to sqlite</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.go", "title": "go", "text": "<pre><code>go() -&gt; Any\n</code></pre> <p>Run the simulation.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.license_info", "title": "license_info", "text": "<pre><code>license_info(user_cert=None) -&gt; str\n</code></pre> <p>Access license info as a human-readable string.</p> <p>Parameters:</p> <ul> <li> <code>user_cert</code>             (<code>Certificate</code>, default:                 <code>None</code> )         \u2013          <p>The license.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.num_events", "title": "num_events", "text": "<pre><code>num_events() -&gt; int\n</code></pre> <p>Return the number of events currently on the event queue.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.path_2_leg", "title": "path_2_leg", "text": "<pre><code>path_2_leg(airline: str) -&gt; None\n</code></pre> <p>Aggregate PathClass forecasts to Leg/Bucket</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.reset_counters", "title": "reset_counters", "text": "<pre><code>reset_counters() -&gt; None\n</code></pre> <p>Reset counters for sold &amp; revenue, for demands and legs.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.set_parm", "title": "set_parm", "text": "<pre><code>set_parm(name: str, value: float) -&gt; None\n</code></pre> <p>Set a simulation parameter by name and value</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.update_db_write_flags", "title": "update_db_write_flags", "text": "<pre><code>update_db_write_flags()\n</code></pre> <p>Update database writing flags based on config.</p>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.validate_license", "title": "validate_license", "text": "<pre><code>validate_license(user_cert=None, future: int = 0) -&gt; None\n</code></pre> <p>Validate a user's license certificate.</p> <p>Parameters:</p> <ul> <li> <code>user_cert</code>             (<code>Certificate</code>, default:                 <code>None</code> )         \u2013          <p>The license.</p> </li> <li> <code>future</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Validate as if it is this many days in the future.  This is primarily used for debugging and testing. This is treated as an unsigned integer internally, so negative values will not go back in time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>           \u2013          <p>If the license certificate is not valid.</p> </li> </ul>"}, {"location": "API/Core/00-SimulationEngine.html#passengersim_core.SimulationEngine.write_to_sqlite", "title": "write_to_sqlite", "text": "<pre><code>write_to_sqlite(\n    cnx: sqlite3.Connection,\n    dcp: int,\n    store_bid_prices: bool = True,\n)\n</code></pre> <p>Write details to sqlite</p>"}, {"location": "API/Core/Airline.html", "title": "Airline", "text": ""}, {"location": "API/Core/Airline.html#passengersim_core.Airline.control", "title": "control  <code>instance-attribute</code>", "text": "<pre><code>control: Literal['leg', 'theft', 'bp', 'vn', 'lft', 'none']\n</code></pre> <p>Control method for this carrier.</p>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.frat5", "title": "frat5  <code>instance-attribute</code>", "text": "<pre><code>frat5: Optional[str]\n</code></pre>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.gt_available_seat_miles", "title": "gt_available_seat_miles  <code>instance-attribute</code>", "text": "<pre><code>gt_available_seat_miles: float\n</code></pre> <p>Grand total ASM, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.gt_demand", "title": "gt_demand  <code>instance-attribute</code>", "text": "<pre><code>gt_demand: int\n</code></pre> <p>Grand total generated demand, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre> <p>Grand total revenue, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.gt_revenue_passenger_miles", "title": "gt_revenue_passenger_miles  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue_passenger_miles: float\n</code></pre> <p>Grand total RPM, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre> <p>Grand total sold, gets updated outside the burn period and is not reset by the reset methods</p>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.load_factor_curve", "title": "load_factor_curve  <code>instance-attribute</code>", "text": "<pre><code>load_factor_curve: Optional[Any]\n</code></pre> <p>An instance of RmSystem, called at each DCP to do detruncation / forecasting / optimization</p>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.rm_system", "title": "rm_system  <code>instance-attribute</code>", "text": "<pre><code>rm_system: Any\n</code></pre>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Airline.html#passengersim_core.Airline.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    name: str,\n    control: Literal[\n        \"leg\", \"theft\", \"bp\", \"vn\", \"none\"\n    ] = \"leg\",\n)\n</code></pre>"}, {"location": "API/Core/BookingCurves.html", "title": "Booking Curves", "text": ""}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator: Generator\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.__init__", "title": "__init__", "text": "<pre><code>__init__(name: str)\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.add_dcp", "title": "add_dcp", "text": "<pre><code>add_dcp(dcp: int, pct: float)\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.get_curve", "title": "get_curve", "text": "<pre><code>get_curve() -&gt; dict[int, float]\n</code></pre>"}, {"location": "API/Core/BookingCurves.html#passengersim_core.BookingCurve.verify_curve", "title": "verify_curve", "text": "<pre><code>verify_curve() -&gt; bool\n</code></pre>"}, {"location": "API/Core/Bucket.html", "title": "Bucket", "text": ""}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.alloc", "title": "alloc  <code>instance-attribute</code>", "text": "<pre><code>alloc: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.fcst_revenue", "title": "fcst_revenue  <code>instance-attribute</code>", "text": "<pre><code>fcst_revenue: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.force_closed", "title": "force_closed  <code>instance-attribute</code>", "text": "<pre><code>force_closed: bool\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.protection", "title": "protection  <code>instance-attribute</code>", "text": "<pre><code>protection: int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.untruncated_demand", "title": "untruncated_demand  <code>instance-attribute</code>", "text": "<pre><code>untruncated_demand: float\n</code></pre>"}, {"location": "API/Core/Bucket.html#passengersim_core.Bucket.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    name: str,\n    alloc: float = 0,\n    price: float = 0,\n    sold: float = 0,\n    revenue: float = 0,\n    fcst_mean: float = 0,\n    fcst_std_dev: float = 0,\n)\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html", "title": "Choice Model", "text": ""}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.path_quality_alpha", "title": "path_quality_alpha  <code>instance-attribute</code>", "text": "<pre><code>path_quality_alpha: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.path_quality_beta", "title": "path_quality_beta  <code>instance-attribute</code>", "text": "<pre><code>path_quality_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.preferred_airline_alpha", "title": "preferred_airline_alpha  <code>instance-attribute</code>", "text": "<pre><code>preferred_airline_alpha: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.preferred_airline_beta", "title": "preferred_airline_beta  <code>instance-attribute</code>", "text": "<pre><code>preferred_airline_beta: float\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.random_generator", "title": "random_generator  <code>instance-attribute</code>", "text": "<pre><code>random_generator: Generator\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.__init__", "title": "__init__", "text": "<pre><code>__init__(name: str, type: Literal['logit', 'pods'])\n</code></pre>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.add_parm", "title": "add_parm", "text": "<pre><code>add_parm(\n    name: str, value: float, value2: float = 0\n) -&gt; None\n</code></pre> <p>Add a parameter value to the choice model</p>"}, {"location": "API/Core/ChoiceModel.html#passengersim_core.ChoiceModel.serialize", "title": "serialize", "text": "<pre><code>serialize() -&gt; dict\n</code></pre> <p>Get all parameter values from the choice model.</p>"}, {"location": "API/Core/Demand.html", "title": "Demand", "text": ""}, {"location": "API/Core/Demand.html#passengersim_core.Demand.base_demand", "title": "base_demand  <code>instance-attribute</code>", "text": "<pre><code>base_demand: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.business", "title": "business  <code>instance-attribute</code>", "text": "<pre><code>business: bool\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.distance", "title": "distance  <code>instance-attribute</code>", "text": "<pre><code>distance: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.fares", "title": "fares  <code>instance-attribute</code>", "text": "<pre><code>fares: Iterator[Fare]\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.generated_demand", "title": "generated_demand  <code>instance-attribute</code>", "text": "<pre><code>generated_demand: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_demand", "title": "gt_demand  <code>instance-attribute</code>", "text": "<pre><code>gt_demand: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_eliminated_chose_nothing", "title": "gt_eliminated_chose_nothing  <code>instance-attribute</code>", "text": "<pre><code>gt_eliminated_chose_nothing: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_eliminated_no_offers", "title": "gt_eliminated_no_offers  <code>instance-attribute</code>", "text": "<pre><code>gt_eliminated_no_offers: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_eliminated_wtp", "title": "gt_eliminated_wtp  <code>instance-attribute</code>", "text": "<pre><code>gt_eliminated_wtp: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.reference_fare", "title": "reference_fare  <code>instance-attribute</code>", "text": "<pre><code>reference_fare: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.scenario_demand", "title": "scenario_demand  <code>instance-attribute</code>", "text": "<pre><code>scenario_demand: float\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.segment", "title": "segment  <code>instance-attribute</code>", "text": "<pre><code>segment: str\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.unsold", "title": "unsold  <code>instance-attribute</code>", "text": "<pre><code>unsold: int\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    orig: str,\n    dest: str,\n    segment: str = None,\n    base_demand: float = 0,\n    scenario_demand: float = 0,\n)\n</code></pre>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_choice_model", "title": "add_choice_model", "text": "<pre><code>add_choice_model(choicemodel: ChoiceModel)\n</code></pre> <p>Add a choice model to this market segment</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_curve", "title": "add_curve", "text": "<pre><code>add_curve(curve: BookingCurve)\n</code></pre> <p>Add a booking curve to this market segment</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_fare", "title": "add_fare", "text": "<pre><code>add_fare(fare: Fare)\n</code></pre> <p>Add a fare to this market segment</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_group_sizes", "title": "add_group_sizes", "text": "<pre><code>add_group_sizes(group_sizes: list[float])\n</code></pre> <p>Group sizes is an array, with proportion for each, i.e [0.5, 0.4, 0.1] has 40% of bookings with 2 passengers</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.add_path", "title": "add_path", "text": "<pre><code>add_path(path: Path)\n</code></pre> <p>Add an itinerary path to this market segment</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_airline_revenue", "title": "get_airline_revenue", "text": "<pre><code>get_airline_revenue(airline_code: str)\n</code></pre> <p>Get revenue for the specified airline code</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_airline_sold", "title": "get_airline_sold", "text": "<pre><code>get_airline_sold(airline_code: str)\n</code></pre> <p>Get sold for the specified airline code</p>"}, {"location": "API/Core/Demand.html#passengersim_core.Demand.get_demand_dcp", "title": "get_demand_dcp", "text": "<pre><code>get_demand_dcp(dcp: int)\n</code></pre> <p>Get demand for the specified DCP</p>"}, {"location": "API/Core/Fare.html", "title": "Fare", "text": ""}, {"location": "API/Core/Fare.html#passengersim_core.Fare.adjusted_price", "title": "adjusted_price  <code>instance-attribute</code>", "text": "<pre><code>adjusted_price: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.adv_purch", "title": "adv_purch  <code>instance-attribute</code>", "text": "<pre><code>adv_purch: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.booking_class", "title": "booking_class  <code>instance-attribute</code>", "text": "<pre><code>booking_class: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.sold_business", "title": "sold_business  <code>instance-attribute</code>", "text": "<pre><code>sold_business: int\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    carrier: str,\n    orig: str,\n    dest: str,\n    booking_class: str,\n    price: float,\n)\n</code></pre>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.add_restriction", "title": "add_restriction", "text": "<pre><code>add_restriction(restriction: str) -&gt; None\n</code></pre> <p>Add a restriction code to this Fare.</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.adjust_price", "title": "adjust_price", "text": "<pre><code>adjust_price(dcp_index: int, adjusted_price: float)\n</code></pre> <p>Set the adjusted price.  The dcp_index is only used for tracking and reporting</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_adjusted_by_dcp", "title": "get_adjusted_by_dcp", "text": "<pre><code>get_adjusted_by_dcp(dcp_index: int)\n</code></pre> <p>Return the average adjusted fare for this DCP index.  Will return 0.0 if the DCP index was not found</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_restriction", "title": "get_restriction", "text": "<pre><code>get_restriction(n: int)\n</code></pre> <p>Get the n-th restriction code on this Fare</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.get_sales_by_dcp", "title": "get_sales_by_dcp", "text": "<pre><code>get_sales_by_dcp(dcp: int)\n</code></pre> <p>Get the sales by specified DCP</p>"}, {"location": "API/Core/Fare.html#passengersim_core.Fare.num_restrictions", "title": "num_restrictions", "text": "<pre><code>num_restrictions(selfself)\n</code></pre> <p>How many restrictions do we have on this fare?</p>"}, {"location": "API/Core/Generator.html", "title": "Generator", "text": ""}, {"location": "API/Core/Generator.html#passengersim_core.Generator.bitgenerator", "title": "bitgenerator  <code>instance-attribute</code>", "text": "<pre><code>bitgenerator: np.random.BitGenerator\n</code></pre>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.bitgenerator_class", "title": "bitgenerator_class  <code>instance-attribute</code>", "text": "<pre><code>bitgenerator_class: type[np.random.BitGenerator]\n</code></pre>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    seed: int | None = None,\n    bitgenerator_class: type[np.random.BitGenerator]\n    | None = None,\n)\n</code></pre> <p>Initialize a random number generator.</p> <p>Parameters:</p> <ul> <li> <code>seed</code>             (<code>int or None</code>, default:                 <code>None</code> )         \u2013          <p>For reproducibility, provide a seed.  If no seed is provided, a random seed is provided by the operating system and generally the results will be different every time you reseed.</p> </li> <li> <code>bitgenerator_class</code>             (<code>type[BitGenerator]</code>, default:                 <code>None</code> )         \u2013          <p>This is the class used to create new BitGenerator objects when the seed is reset.</p> </li> </ul>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.get_normal", "title": "get_normal", "text": "<pre><code>get_normal() -&gt; float\n</code></pre> <p>Return a random draw from a standard normal distribution.</p>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.get_uniform", "title": "get_uniform", "text": "<pre><code>get_uniform() -&gt; float\n</code></pre> <p>Return a random draw standard uniform distribution.</p>"}, {"location": "API/Core/Generator.html#passengersim_core.Generator.seed", "title": "seed", "text": "<pre><code>seed(seed: int | list[int] | None) -&gt; None\n</code></pre> <p>Reseed the random bit generator.</p>"}, {"location": "API/Core/Leg.html", "title": "Leg", "text": ""}, {"location": "API/Core/Leg.html#passengersim_core.Leg.arr_time", "title": "arr_time  <code>instance-attribute</code>", "text": "<pre><code>arr_time: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.bid_price", "title": "bid_price  <code>instance-attribute</code>", "text": "<pre><code>bid_price: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.bid_price_gradient", "title": "bid_price_gradient  <code>instance-attribute</code>", "text": "<pre><code>bid_price_gradient: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.buckets", "title": "buckets  <code>instance-attribute</code>", "text": "<pre><code>buckets: Iterator[Bucket]\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.capacity", "title": "capacity  <code>instance-attribute</code>", "text": "<pre><code>capacity: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.dep_time", "title": "dep_time  <code>instance-attribute</code>", "text": "<pre><code>dep_time: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.displacement", "title": "displacement  <code>instance-attribute</code>", "text": "<pre><code>displacement: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.distance", "title": "distance  <code>instance-attribute</code>", "text": "<pre><code>distance: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.duration", "title": "duration  <code>instance-attribute</code>", "text": "<pre><code>duration: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.equipment", "title": "equipment  <code>instance-attribute</code>", "text": "<pre><code>equipment: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.flt_no", "title": "flt_no  <code>instance-attribute</code>", "text": "<pre><code>flt_no: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.gt_capacity", "title": "gt_capacity  <code>instance-attribute</code>", "text": "<pre><code>gt_capacity: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.info", "title": "info  <code>instance-attribute</code>", "text": "<pre><code>info: Any\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.q_demand", "title": "q_demand  <code>instance-attribute</code>", "text": "<pre><code>q_demand: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    carrier: str,\n    flt_no: int,\n    orig: str,\n    dest: str,\n    capacity: int = 0,\n    sold: int = 0,\n    duration: int = 0,\n    equipment: str = None,\n    info: Any = None,\n)\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.add_bucket", "title": "add_bucket", "text": "<pre><code>add_bucket(*args: Bucket)\n</code></pre> <p>Add an inventory control bucket to the Leg.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.bucket_number", "title": "bucket_number", "text": "<pre><code>bucket_number(i: int | str) -&gt; Bucket\n</code></pre> <p>Get the bucket from the leg.</p> <p>Parameters:</p> <ul> <li> <code>i</code>             (<code>int or str</code>)         \u2013          <p>If an integer, returns the bucket at this index position from the list of buckets attached to this Leg.  If given as a str, returns the bucket with the indicated booking class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Bucket</code>         \u2013          </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.capture_dcp", "title": "capture_dcp", "text": "<pre><code>capture_dcp(i: int) -&gt; None\n</code></pre> <p>Grab a snapshot of important variables.</p> <p>Parameters:</p> <ul> <li> <code>i</code>             (<code>int</code>)         \u2013          <p>The index of the DCP to capture.</p> </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.forecast", "title": "forecast", "text": "<pre><code>forecast(\n    dcp_index: int,\n    algorithm: str,\n    snapshot_instruction: \"SnapshotInstruction | None\" = None,\n)\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_auth", "title": "get_bucket_auth", "text": "<pre><code>get_bucket_auth(i: int | str) -&gt; int\n</code></pre> <p>Get the authorization for a bucket attached to this leg.</p> <p>Parameters:</p> <ul> <li> <code>i</code>             (<code>int or str</code>)         \u2013          <p>If an integer, returns the auth of the bucket at this index position from the list of buckets attached to this Leg.  If given as a str, returns the auth of the bucket with the indicated booking class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_decision_fare", "title": "get_bucket_decision_fare", "text": "<pre><code>get_bucket_decision_fare(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the decision fare for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_fcst_mean", "title": "get_bucket_fcst_mean", "text": "<pre><code>get_bucket_fcst_mean(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the forecast demand for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_fcst_revenue", "title": "get_bucket_fcst_revenue", "text": "<pre><code>get_bucket_fcst_revenue(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the forecast revenue for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_fcst_std_dev", "title": "get_bucket_fcst_std_dev", "text": "<pre><code>get_bucket_fcst_std_dev(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the forecast demand std. dev. for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_revenue", "title": "get_bucket_revenue", "text": "<pre><code>get_bucket_revenue(bkt_ref: int | str) -&gt; float\n</code></pre> <p>Get the revenue for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_bucket_sold", "title": "get_bucket_sold", "text": "<pre><code>get_bucket_sold(i: int | str) -&gt; int\n</code></pre> <p>Get the number of seats sold for a bucket attached to this leg.</p> <p>Parameters:</p> <ul> <li> <code>i</code>             (<code>int or str</code>)         \u2013          <p>If an integer, returns the number of seats sold for the bucket at this index position from the list of buckets attached to this Leg.  If given as a str, returns the number of seats sold for the bucket with the indicated booking class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          </li> </ul>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.get_num_buckets", "title": "get_num_buckets", "text": "<pre><code>get_num_buckets() -&gt; int\n</code></pre> <p>Get the number of buckets attached to this leg.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.littlewood", "title": "littlewood", "text": "<pre><code>littlewood(\n    mu: float,\n    sigma: float,\n    rev_hi: float,\n    rev_lo: float,\n    cv100: float,\n) -&gt; float\n</code></pre>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.print_bucket_detail", "title": "print_bucket_detail", "text": "<pre><code>print_bucket_detail()\n</code></pre> <p>Print a bunch of debugging info</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.print_bucket_history", "title": "print_bucket_history", "text": "<pre><code>print_bucket_history()\n</code></pre> <p>Print a bunch of debugging info</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_auth", "title": "set_bucket_auth", "text": "<pre><code>set_bucket_auth(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the authorization for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_decision_fare", "title": "set_bucket_decision_fare", "text": "<pre><code>set_bucket_decision_fare(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the decision fare for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_fcst_mean", "title": "set_bucket_fcst_mean", "text": "<pre><code>set_bucket_fcst_mean(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the forecast demand for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_fcst_revenue", "title": "set_bucket_fcst_revenue", "text": "<pre><code>set_bucket_fcst_revenue(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the revenue forecast for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_fcst_std_dev", "title": "set_bucket_fcst_std_dev", "text": "<pre><code>set_bucket_fcst_std_dev(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the forecast demand std. dev. for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_revenue", "title": "set_bucket_revenue", "text": "<pre><code>set_bucket_revenue(bkt_ref: int | str, auth: int)\n</code></pre> <p>Set the revenue for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.set_bucket_sold", "title": "set_bucket_sold", "text": "<pre><code>set_bucket_sold(bkt_ref: int | str, sold: int)\n</code></pre> <p>Set the seats sold for a bucket, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.untruncate_demand", "title": "untruncate_demand", "text": "<pre><code>untruncate_demand(\n    dcp_index: int,\n    algorithm: str,\n    snapshot_instruction: \"SnapshotInstruction | None\" = None,\n)\n</code></pre> <p>Run the demand untruncation models for this leg and its buckets.</p>"}, {"location": "API/Core/Leg.html#passengersim_core.Leg.write_to_sqlite", "title": "write_to_sqlite", "text": "<pre><code>write_to_sqlite(\n    sqlite_pointer: sqlite3.Connection,\n    sim: SimulationEngine,\n    dcp: int,\n)\n</code></pre> <p>Write to leg_bucket_detail.</p>"}, {"location": "API/Core/Path.html", "title": "Path", "text": ""}, {"location": "API/Core/Path.html#passengersim_core.Path.adjusted_at", "title": "adjusted_at  <code>instance-attribute</code>", "text": "<pre><code>adjusted_at: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.gt_sold_priceable", "title": "gt_sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>gt_sold_priceable: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.last_fcst_ts", "title": "last_fcst_ts  <code>instance-attribute</code>", "text": "<pre><code>last_fcst_ts: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.path_quality_index", "title": "path_quality_index  <code>instance-attribute</code>", "text": "<pre><code>path_quality_index: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.pathclasses", "title": "pathclasses  <code>instance-attribute</code>", "text": "<pre><code>pathclasses: Iterator[PathClass]\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.raw_fcst_mean", "title": "raw_fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>raw_fcst_mean: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.raw_fcst_std_dev", "title": "raw_fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>raw_fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.revenue", "title": "revenue  <code>instance-attribute</code>", "text": "<pre><code>revenue: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.sold_priceable", "title": "sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>sold_priceable: int\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.utility", "title": "utility  <code>instance-attribute</code>", "text": "<pre><code>utility: float\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.__init__", "title": "__init__", "text": "<pre><code>__init__(orig: str, dest: str, price: float)\n</code></pre>"}, {"location": "API/Core/Path.html#passengersim_core.Path.accumulate_forecasts", "title": "accumulate_forecasts", "text": "<pre><code>accumulate_forecasts()\n</code></pre> <p>Adds the path fcst to each leg / bucket</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.accumulate_forecasts_vn", "title": "accumulate_forecasts_vn", "text": "<pre><code>accumulate_forecasts_vn()\n</code></pre> <p>Adds the path fcst to each leg / bucket, using the Virtual Nesting mapping</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_airline", "title": "add_airline", "text": "<pre><code>add_airline(airline: Airline) -&gt; None\n</code></pre> <p>Add an Airline to this Path.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_booking_class", "title": "add_booking_class", "text": "<pre><code>add_booking_class(booking_class: str)\n</code></pre> <p>Add a booking class to this Path</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_leg", "title": "add_leg", "text": "<pre><code>add_leg(leg: Leg) -&gt; None\n</code></pre> <p>Add a leg to this Path.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.add_path_class", "title": "add_path_class", "text": "<pre><code>add_path_class(path_class: PathClass)\n</code></pre> <p>Add a path class to this Path</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.adjust_forecasts", "title": "adjust_forecasts", "text": "<pre><code>adjust_forecasts(\n    last_ts: int,\n    current_ts: int,\n    departure_ts: int,\n    snapshot_instruction: \"SnapshotInstruction | None\" = None,\n) -&gt; None\n</code></pre> <p>Adjust the forecast for this path and any path-class items it has, using in daily reoptimization</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.allocate_q_demand", "title": "allocate_q_demand", "text": "<pre><code>allocate_q_demand(\n    frat5: Frat5, dcp_index: int, debug: bool\n) -&gt; float\n</code></pre> <p>First step in Q-forecasting</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.capture_dcp", "title": "capture_dcp", "text": "<pre><code>capture_dcp(dcp_index: int)\n</code></pre> <p>Save relevant information for this DCP</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.check_avail", "title": "check_avail", "text": "<pre><code>check_avail(\n    fare: \"Fare\", num_pax: int, debug: Optional[bool]\n)\n</code></pre> <p>Is this fare available on the Path?  Used for unit testing</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.compute_q_equivalent", "title": "compute_q_equivalent", "text": "<pre><code>compute_q_equivalent(\n    frat5: Frat5,\n    dcp_index: int,\n    max_cap: float = 10.0,\n    snapshot_instruction: \"SnapshotInstruction | None\" = None,\n) -&gt; float\n</code></pre> <p>First step in Q-forecasting</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.forecast", "title": "forecast", "text": "<pre><code>forecast(\n    dcp_index: int,\n    algorithm: str,\n    snapshot_instruction: \"SnapshotInstruction | None\" = None,\n) -&gt; float\n</code></pre> <p>Run the forecast models for this path and any path-class items it has</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_decision_fare", "title": "get_class_decision_fare", "text": "<pre><code>get_class_decision_fare(pc_index: int | str) -&gt; float\n</code></pre> <p>Get the decision fare amount for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_fcst_mean", "title": "get_class_fcst_mean", "text": "<pre><code>get_class_fcst_mean(pc_index: int | str) -&gt; float\n</code></pre> <p>Get the demand forecast for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_sold", "title": "get_class_sold", "text": "<pre><code>get_class_sold(pc_index: int | str) -&gt; int\n</code></pre> <p>Get the number sold for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_class_std_dev", "title": "get_class_std_dev", "text": "<pre><code>get_class_std_dev(pc_index: int | str) -&gt; float\n</code></pre> <p>Get the demand forecast std. dev. for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_bid_price", "title": "get_leg_bid_price", "text": "<pre><code>get_leg_bid_price(n: int) -&gt; float\n</code></pre> <p>Get the bid price on the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_carrier", "title": "get_leg_carrier", "text": "<pre><code>get_leg_carrier(n: int) -&gt; str\n</code></pre> <p>Get the carrier code for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_dep_time", "title": "get_leg_dep_time", "text": "<pre><code>get_leg_dep_time(n: int) -&gt; int\n</code></pre> <p>Get the departure timestamp code for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_dest", "title": "get_leg_dest", "text": "<pre><code>get_leg_dest(n: int) -&gt; str\n</code></pre> <p>Get the destination airport for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_equipment", "title": "get_leg_equipment", "text": "<pre><code>get_leg_equipment(n: int) -&gt; str\n</code></pre> <p>Get the equipment code for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_fltno", "title": "get_leg_fltno", "text": "<pre><code>get_leg_fltno(n: int) -&gt; int\n</code></pre> <p>Get the flight number for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_leg_orig", "title": "get_leg_orig", "text": "<pre><code>get_leg_orig(n: int) -&gt; str\n</code></pre> <p>Get the origin airport for the n-th leg.</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_total_bid_price", "title": "get_total_bid_price", "text": "<pre><code>get_total_bid_price() -&gt; float\n</code></pre> <p>Get the total of bid prices on all legs</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.get_total_distance", "title": "get_total_distance", "text": "<pre><code>get_total_distance() -&gt; float\n</code></pre> <p>Get the total of distances on all legs</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.hybrid_forecast", "title": "hybrid_forecast", "text": "<pre><code>hybrid_forecast(\n    dcp_index: int,\n    algorithm: str,\n    snapshot_instruction: \"SnapshotInstruction | None\",\n    frat5: Frat5,\n    max_cap: float = 10,\n) -&gt; float\n</code></pre> <p>Run the forecast models for this path and any path-class items it has</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.num_classes", "title": "num_classes", "text": "<pre><code>num_classes() -&gt; int\n</code></pre> <p>Return the number of booking classes that are tracked for this Path</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.num_deps", "title": "num_deps", "text": "<pre><code>num_deps() -&gt; int\n</code></pre> <p>How many historical departures are on this path?</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.num_legs", "title": "num_legs", "text": "<pre><code>num_legs() -&gt; int\n</code></pre> <p>How many legs are on this path?</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.print_class_history", "title": "print_class_history", "text": "<pre><code>print_class_history(path_class_index: int) -&gt; str\n</code></pre> <p>Print some historical data to stdout, mostly for debugging</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_decision_fare", "title": "set_class_decision_fare", "text": "<pre><code>set_class_decision_fare(pc_index: int | str, fcst: float)\n</code></pre> <p>Set the decision fare amount for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_fcst_mean", "title": "set_class_fcst_mean", "text": "<pre><code>set_class_fcst_mean(pc_index: int | str, fcst: float)\n</code></pre> <p>Set the demand forecast for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_sold", "title": "set_class_sold", "text": "<pre><code>set_class_sold(pc_index: int | str, sold: int)\n</code></pre> <p>Set the number sold for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.set_class_std_dev", "title": "set_class_std_dev", "text": "<pre><code>set_class_std_dev(pc_index: int | str, fcst: float)\n</code></pre> <p>Set the demand forecast std. dev.for a class, either by class name (string) or index (int)</p>"}, {"location": "API/Core/Path.html#passengersim_core.Path.untruncate_demand", "title": "untruncate_demand", "text": "<pre><code>untruncate_demand(\n    dcp_index: int,\n    algorithm: str,\n    debug: \"SnapshotInstruction | None\" = None,\n)\n</code></pre> <p>Run the demand untruncation models for this path and any path-class items it has</p>"}, {"location": "API/Core/PathClass.html", "title": "Path Class", "text": ""}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.booking_class", "title": "booking_class  <code>instance-attribute</code>", "text": "<pre><code>booking_class: str\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.contribution1", "title": "contribution1  <code>instance-attribute</code>", "text": "<pre><code>contribution1: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.contribution2", "title": "contribution2  <code>instance-attribute</code>", "text": "<pre><code>contribution2: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.decision_fare", "title": "decision_fare  <code>instance-attribute</code>", "text": "<pre><code>decision_fare: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.fcst_mean", "title": "fcst_mean  <code>instance-attribute</code>", "text": "<pre><code>fcst_mean: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.fcst_std_dev", "title": "fcst_std_dev  <code>instance-attribute</code>", "text": "<pre><code>fcst_std_dev: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.gt_revenue", "title": "gt_revenue  <code>instance-attribute</code>", "text": "<pre><code>gt_revenue: float\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.gt_sold", "title": "gt_sold  <code>instance-attribute</code>", "text": "<pre><code>gt_sold: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.gt_sold_priceable", "title": "gt_sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>gt_sold_priceable: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.index1", "title": "index1  <code>instance-attribute</code>", "text": "<pre><code>index1: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.index2", "title": "index2  <code>instance-attribute</code>", "text": "<pre><code>index2: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.sold", "title": "sold  <code>instance-attribute</code>", "text": "<pre><code>sold: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.sold_priceable", "title": "sold_priceable  <code>instance-attribute</code>", "text": "<pre><code>sold_priceable: int\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.__init__", "title": "__init__", "text": "<pre><code>__init__(booking_class: Any)\n</code></pre>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.add_fare", "title": "add_fare", "text": "<pre><code>add_fare(fare: Fare)\n</code></pre> <p>Add a Fare to the PathClass</p>"}, {"location": "API/Core/PathClass.html#passengersim_core.PathClass.set_indexes", "title": "set_indexes", "text": "<pre><code>set_indexes(i1: int, i2: int = 0) -&gt; None\n</code></pre> <p>Set the VN indexes for this PathClass.</p>"}, {"location": "API/config/00-configs.html", "title": "Config", "text": ""}, {"location": "API/config/00-configs.html#passengersim.config.base.TConfig", "title": "TConfig  <code>module-attribute</code>", "text": "<pre><code>TConfig = typing.TypeVar('TConfig', bound='YamlConfig')\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.logger", "title": "logger  <code>module-attribute</code>", "text": "<pre><code>logger = logging.getLogger('passengersim.config')\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config", "title": "Config", "text": "<p>             Bases: <code>YamlConfig</code></p> Source code in <code>passengersim/config/base.py</code> <pre><code>class Config(YamlConfig, extra=\"forbid\"):\n    scenario: str = Field(default_factory=random_label)\n    \"\"\"Name for this scenario.\n\n    The scenario name is helpful when writing different simulations to the same\n    database so you can uniquely identify and query results for a particular\n    scenario.\"\"\"\n\n    simulation_controls: SimulationSettings = SimulationSettings()\n    \"\"\"\n    Controls that apply broadly to the overall simulation.\n\n    See [SimulationSettings][passengersim.config.SimulationSettings] for detailed\n    documentation.\n    \"\"\"\n\n    db: DatabaseConfig = DatabaseConfig()\n    \"\"\"\n    See [passengersim.config.DatabaseConfig][] for detailed documentation.\n    \"\"\"\n\n    outputs: OutputConfig = OutputConfig()\n    \"\"\"\n    See [passengersim.config.OutputConfig][] for detailed documentation.\n    \"\"\"\n\n    rm_systems: DictOfNamed[RmSystem] = {}\n    \"\"\"\n    The revenue management systems used by the carriers in this simulation.\n\n    See [RM Systems][rm-systems] for details.\n    \"\"\"\n\n    frat5_curves: DictOfNamed[Frat5Curve] = {}\n    \"\"\" FRAT5 curves are used to model sellup rates in Q-forecasting\"\"\"\n\n    load_factor_curves: DictOfNamed[LoadFactorCurve] = {}\n    \"\"\" FRAT5 curves are used to model sellup rates in Q-forecasting\"\"\"\n\n    choice_models: DictOfNamed[ChoiceModel] = {}\n    \"\"\"Several choice models are programmed behind the scenes.\n\n    The choice_models option allows the user to set the parameters used in the\n    utility model for a particular choice model. There are two choice models\n    currently programmed.\n    1. PODS-like\n    2. MNL, using the Lurkin et. al. paper (needs more testing and pdating)\n\n    Need to explaining more here\"\"\"\n\n    airlines: DictOfNamed[Airline] = {}\n    \"\"\"A list of airlines.\n\n    One convention is to use Airline1, Airline2, ... to list the airlines in the\n    network.  Another convention is to use IATA industry-standard two-letter airline\n    codes.  See the\n    [IATA code search](https://www.iata.org/en/publications/directories/code-search/)\n    for more information.\"\"\"\n\n    places: DictOfNamed[Place] = {}\n    \"\"\"A list of places (airports, vertiports, other stations).\"\"\"\n\n    classes: list[str] = []\n    \"\"\"A list of fare classes.\n\n    One convention is to use Y0, Y1, ... to label fare classes from the highest\n    fare (Y0) to the lowest fare (Yn).  You can also use Y, B, M, H,... etc.\n    An example of classes is below.\n\n    Example\n    -------\n    ```{yaml}\n    classes:\n      - Y0\n      - Y1\n      - Y2\n      - Y3\n      - Y4\n      - Y5\n    ```\n    \"\"\"\n\n    dcps: list[int] = []\n    \"\"\"A list of DCPs (data collection points).\n\n    The DCPs are given as integers, which represent the number of days\n    before departure.   An example of data collection points is given below.\n    Note that typically as you get closer to day of departure (DCP=0) the number\n    of days between two consecutive DCP periods decreases.  The DCP intervals are\n    shorter because as you get closer to departure, customer arrival rates tend\n    to increase, and it is advantageous to forecast changes in demand for shorter\n    intervals.\n\n    Example\n    -------\n    ```{yaml}\n    dcps: [63, 56, 49, 42, 35, 31, 28, 24, 21, 17, 14, 10, 7, 5, 3, 1]\n    ```\n    \"\"\"\n\n    booking_curves: DictOfNamed[BookingCurve] = {}\n    \"\"\"Booking curves\n\n    The booking curve points typically line up with the DCPs.\n\n    Example\n    -------\n    ```{yaml}\n    booking_curves:\n      - name: c1\n        curve:\n          63: 0.06\n          56: 0.11\n          49: 0.15\n          42: 0.2\n          35: 0.23\n          31: 0.25\n          28: 0.28\n          24: 0.31\n          21: 0.35\n          17: 0.4\n          14: 0.5\n          10: 0.62\n          7: 0.7\n          5: 0.78\n          3: 0.95\n          1: 1.0\n    \"\"\"\n\n    legs: list[Leg] = []\n    demands: list[Demand] = []\n    fares: list[Fare] = []\n    paths: list[Path] = []\n\n    snapshot_filters: list[SnapshotFilter] = []\n\n    @field_validator(\"snapshot_filters\", mode=\"before\")\n    def _handle_no_snapshot_filters(cls, v):\n        if v is None:\n            v = []\n        return v\n\n    raw_license_certificate: bytes | None = None\n\n    @field_validator(\"raw_license_certificate\", mode=\"before\")\n    def _handle_license_certificate(cls, v):\n        if isinstance(v, str) and v.startswith(\"-----BEGIN CERTIFICATE-----\"):\n            v = v.encode(\"utf8\")\n        return v\n\n    @property\n    def license_certificate(self):\n        from cryptography.x509 import load_pem_x509_certificate\n\n        if isinstance(self.raw_license_certificate, bytes):\n            return load_pem_x509_certificate(self.raw_license_certificate)\n\n    @model_validator(mode=\"after\")\n    def _airlines_have_rm_systems(cls, m: Config):\n        \"\"\"Check that all airlines have RM systems that have been defined.\"\"\"\n        for airline in m.airlines.values():\n            if airline.rm_system not in m.rm_systems:\n                raise ValueError(\n                    f\"Airline {airline.name} has unknown RM system {airline.rm_system}\"\n                )\n        return m\n\n    @model_validator(mode=\"after\")\n    def _booking_curves_match_dcps(cls, m: Config):\n        \"\"\"Check that all booking curves are complete and valid.\"\"\"\n        sorted_dcps = reversed(sorted(m.dcps))\n        for curve in m.booking_curves.values():\n            i = 0\n            for dcp in sorted_dcps:\n                assert (\n                    dcp in curve.curve\n                ), f\"booking curve {curve.name} is missing dcp {dcp}\"\n                assert (\n                    curve.curve[dcp] &gt;= i\n                ), f\"booking curve {curve.name} moves backwards at dcp {dcp}\"\n                i = curve.curve[dcp]\n        return m\n\n    @model_validator(mode=\"after\")\n    def _requested_summaries_have_data(cls, m: Config):\n        \"\"\"Check that requested summary outputs will have the data needed.\"\"\"\n        if \"local_and_flow_yields\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"pathclass_final\", \"pathclass\"}:\n                raise ValueError(\n                    \"the `local_and_flow_yields` report requires recording \"\n                    \"at least `pathclass_final` details in the database\"\n                )\n        if \"bid_price_history\" in m.outputs.reports:\n            if \"leg\" not in m.db.write_items:\n                raise ValueError(\n                    \"the `bid_price_history` report requires recording \"\n                    \"`leg` details in the database\"\n                )\n            if not m.db.store_leg_bid_prices:\n                raise ValueError(\n                    \"the `bid_price_history` report requires recording \"\n                    \"`store_leg_bid_prices` to be True\"\n                )\n        if \"demand_to_come\" in m.outputs.reports:\n            if \"demand\" not in m.db.write_items:\n                raise ValueError(\n                    \"the `demand_to_come` report requires recording \"\n                    \"`demand` details in the database\"\n                )\n        if \"path_forecasts\" in m.outputs.reports:\n            if \"pathclass\" not in m.db.write_items:\n                raise ValueError(\n                    \"the `path_forecasts` report requires recording \"\n                    \"`pathclass` details in the database\"\n                )\n        if \"leg_forecasts\" in m.outputs.reports:\n            if \"bucket\" not in m.db.write_items:\n                raise ValueError(\n                    \"the `leg_forecasts` report requires recording \"\n                    \"`bucket` details in the database\"\n                )\n        if \"bookings_by_timeframe\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"bookings\", \"fare\"}:\n                raise ValueError(\n                    \"the `bookings_by_timeframe` report requires recording \"\n                    \"`fare` or `bookings` details in the database\"\n                )\n        if \"total_demand\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"demand\", \"demand_final\"}:\n                raise ValueError(\n                    \"the `total_demand` report requires recording \"\n                    \"at least `demand_final` details in the database\"\n                )\n        if \"fare_class_mix\" in m.outputs.reports:\n            if not m.db.write_items &amp; {\"fare\", \"fare_final\"}:\n                raise ValueError(\n                    \"the `fare_class_mix` report requires recording \"\n                    \"at least `fare_final` details in the database\"\n                )\n        return m\n\n    @classmethod\n    def model_validate(\n        cls,\n        *args,\n        **kwargs,\n    ) -&gt; typing.Any:\n        \"\"\"Validate the passengersim Config inputs.\n\n        This method reloads the Config class to ensure all imported\n        RmSteps are properly registered before validation.\n\n        Parameters\n        ----------\n        obj\n            The object to validate.\n        strict : bool\n            Whether to raise an exception on invalid fields.\n        from_attributes\n            Whether to extract data from object attributes.\n        context\n            Additional context to pass to the validator.\n\n        Raises\n        ------\n        ValidationError\n            If the object could not be validated.\n\n        Returns\n        -------\n        Config\n            The validated model instance.\n        \"\"\"\n        # reload these to refresh for any newly defined RmSteps\n        module_parent = \".\".join(__name__.split(\".\")[:-1])\n        importlib.reload(sys.modules.get(f\"{module_parent}.rm_systems\"))\n        importlib.reload(sys.modules.get(__name__))\n        module = importlib.reload(sys.modules.get(module_parent))\n        reloaded_class = getattr(module, cls.__name__)\n        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n        __tracebackhide__ = True\n        return reloaded_class.__pydantic_validator__.validate_python(*args, **kwargs)\n\n    def add_output_prefix(\n        self, prefix: pathlib.Path, spool_format: str = \"%Y%m%d-%H%M\"\n    ):\n        \"\"\"\n        Add a prefix directory to all simulation output files.\n        \"\"\"\n        if not isinstance(prefix, pathlib.Path):\n            prefix = pathlib.Path(prefix)\n        if spool_format:\n            proposal = prefix.joinpath(time.strftime(spool_format))\n            n = 0\n            while proposal.exists():\n                n += 1\n                proposal = prefix.joinpath(time.strftime(spool_format) + f\".{n}\")\n            prefix = proposal\n        prefix.mkdir(parents=True)\n\n        if self.db.filename:\n            self.db.filename = prefix.joinpath(self.db.filename)\n        if self.outputs.excel:\n            self.outputs.excel = prefix.joinpath(self.outputs.excel)\n        for sf in self.snapshot_filters:\n            if sf.directory:\n                sf.directory = prefix.joinpath(sf.directory)\n        return prefix\n\n    @model_validator(mode=\"after\")\n    def _attach_distance_to_legs_without_it(self):\n        \"\"\"Attach distance in nautical miles to legs that are missing distance.\"\"\"\n        for leg in self.legs:\n            if leg.distance is None:\n                place_o = self.places.get(leg.orig, None)\n                place_d = self.places.get(leg.dest, None)\n                if place_o is not None and place_d is not None:\n                    leg.distance = great_circle(place_o, place_d)\n                if place_o is None:\n                    warnings.warn(f\"No defined place for {leg.orig}\", stacklevel=2)\n                if place_d is None:\n                    warnings.warn(f\"No defined place for {leg.dest}\", stacklevel=2)\n        return self\n\n    def __repr__(self):\n        indent = 2\n        x = []\n        i = \" \" * indent\n        for k, v in self:\n            if k in {\"legs\", \"paths\", \"fares\", \"demands\"}:\n                val = f\"&lt;list of {len(v)} {k}&gt;\"\n            elif k in {\"booking_curves\"}:\n                val = f\"&lt;dict of {len(v)} {k}&gt;\"\n            elif isinstance(v, dict):\n                val = repr_dict_with_indent(v, indent)\n            else:\n                try:\n                    val = v.__repr_with_indent__(indent)\n                except AttributeError:\n                    val = repr(v)\n            if \"\\n\" in val:\n                val_lines = val.split(\"\\n\")\n                val = \"\\n  \" + \"\\n  \".join(val_lines)\n            x.append(f\"{i}{k}: {val}\")\n        return \"passengersim.Config:\\n\" + \"\\n\".join(x)\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.airlines", "title": "airlines  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>airlines: DictOfNamed[Airline] = {}\n</code></pre> <p>A list of airlines.</p> <p>One convention is to use Airline1, Airline2, ... to list the airlines in the network.  Another convention is to use IATA industry-standard two-letter airline codes.  See the IATA code search for more information.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.booking_curves", "title": "booking_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>booking_curves: DictOfNamed[BookingCurve] = {}\n</code></pre> <p>Booking curves</p> <p>The booking curve points typically line up with the DCPs.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.booking_curves--example", "title": "Example", "text": "<p>```{yaml} booking_curves:   - name: c1     curve:       63: 0.06       56: 0.11       49: 0.15       42: 0.2       35: 0.23       31: 0.25       28: 0.28       24: 0.31       21: 0.35       17: 0.4       14: 0.5       10: 0.62       7: 0.7       5: 0.78       3: 0.95       1: 1.0</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.choice_models", "title": "choice_models  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>choice_models: DictOfNamed[ChoiceModel] = {}\n</code></pre> <p>Several choice models are programmed behind the scenes.</p> <p>The choice_models option allows the user to set the parameters used in the utility model for a particular choice model. There are two choice models currently programmed. 1. PODS-like 2. MNL, using the Lurkin et. al. paper (needs more testing and pdating)</p> <p>Need to explaining more here</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.classes", "title": "classes  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>classes: list[str] = []\n</code></pre> <p>A list of fare classes.</p> <p>One convention is to use Y0, Y1, ... to label fare classes from the highest fare (Y0) to the lowest fare (Yn).  You can also use Y, B, M, H,... etc. An example of classes is below.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.classes--example", "title": "Example", "text": "<pre><code>classes:\n  - Y0\n  - Y1\n  - Y2\n  - Y3\n  - Y4\n  - Y5\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.db", "title": "db  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>db: DatabaseConfig = DatabaseConfig()\n</code></pre> <p>See passengersim.config.DatabaseConfig for detailed documentation.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.dcps", "title": "dcps  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcps: list[int] = []\n</code></pre> <p>A list of DCPs (data collection points).</p> <p>The DCPs are given as integers, which represent the number of days before departure.   An example of data collection points is given below. Note that typically as you get closer to day of departure (DCP=0) the number of days between two consecutive DCP periods decreases.  The DCP intervals are shorter because as you get closer to departure, customer arrival rates tend to increase, and it is advantageous to forecast changes in demand for shorter intervals.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.dcps--example", "title": "Example", "text": "<pre><code>dcps: [63, 56, 49, 42, 35, 31, 28, 24, 21, 17, 14, 10, 7, 5, 3, 1]\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.demands", "title": "demands  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>demands: list[Demand] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.fares", "title": "fares  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>fares: list[Fare] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.frat5_curves", "title": "frat5_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frat5_curves: DictOfNamed[Frat5Curve] = {}\n</code></pre> <p>FRAT5 curves are used to model sellup rates in Q-forecasting</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.legs", "title": "legs  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>legs: list[Leg] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.license_certificate", "title": "license_certificate  <code>property</code>", "text": "<pre><code>license_certificate\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.load_factor_curves", "title": "load_factor_curves  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>load_factor_curves: DictOfNamed[LoadFactorCurve] = {}\n</code></pre> <p>FRAT5 curves are used to model sellup rates in Q-forecasting</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.outputs", "title": "outputs  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>outputs: OutputConfig = OutputConfig()\n</code></pre> <p>See passengersim.config.OutputConfig for detailed documentation.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.paths", "title": "paths  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>paths: list[Path] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.places", "title": "places  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>places: DictOfNamed[Place] = {}\n</code></pre> <p>A list of places (airports, vertiports, other stations).</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.raw_license_certificate", "title": "raw_license_certificate  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>raw_license_certificate: bytes | None = None\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.rm_systems", "title": "rm_systems  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>rm_systems: DictOfNamed[RmSystem] = {}\n</code></pre> <p>The revenue management systems used by the carriers in this simulation.</p> <p>See RM Systems for details.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.scenario", "title": "scenario  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>scenario: str = Field(default_factory=random_label)\n</code></pre> <p>Name for this scenario.</p> <p>The scenario name is helpful when writing different simulations to the same database so you can uniquely identify and query results for a particular scenario.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.simulation_controls", "title": "simulation_controls  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>simulation_controls: SimulationSettings = (\n    SimulationSettings()\n)\n</code></pre> <p>Controls that apply broadly to the overall simulation.</p> <p>See SimulationSettings for detailed documentation.</p>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[SnapshotFilter] = []\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.__repr__", "title": "__repr__", "text": "<pre><code>__repr__()\n</code></pre> Source code in <code>passengersim/config/base.py</code> <pre><code>def __repr__(self):\n    indent = 2\n    x = []\n    i = \" \" * indent\n    for k, v in self:\n        if k in {\"legs\", \"paths\", \"fares\", \"demands\"}:\n            val = f\"&lt;list of {len(v)} {k}&gt;\"\n        elif k in {\"booking_curves\"}:\n            val = f\"&lt;dict of {len(v)} {k}&gt;\"\n        elif isinstance(v, dict):\n            val = repr_dict_with_indent(v, indent)\n        else:\n            try:\n                val = v.__repr_with_indent__(indent)\n            except AttributeError:\n                val = repr(v)\n        if \"\\n\" in val:\n            val_lines = val.split(\"\\n\")\n            val = \"\\n  \" + \"\\n  \".join(val_lines)\n        x.append(f\"{i}{k}: {val}\")\n    return \"passengersim.Config:\\n\" + \"\\n\".join(x)\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.add_output_prefix", "title": "add_output_prefix", "text": "<pre><code>add_output_prefix(\n    prefix: pathlib.Path, spool_format: str = \"%Y%m%d-%H%M\"\n)\n</code></pre> <p>Add a prefix directory to all simulation output files.</p> Source code in <code>passengersim/config/base.py</code> <pre><code>def add_output_prefix(\n    self, prefix: pathlib.Path, spool_format: str = \"%Y%m%d-%H%M\"\n):\n    \"\"\"\n    Add a prefix directory to all simulation output files.\n    \"\"\"\n    if not isinstance(prefix, pathlib.Path):\n        prefix = pathlib.Path(prefix)\n    if spool_format:\n        proposal = prefix.joinpath(time.strftime(spool_format))\n        n = 0\n        while proposal.exists():\n            n += 1\n            proposal = prefix.joinpath(time.strftime(spool_format) + f\".{n}\")\n        prefix = proposal\n    prefix.mkdir(parents=True)\n\n    if self.db.filename:\n        self.db.filename = prefix.joinpath(self.db.filename)\n    if self.outputs.excel:\n        self.outputs.excel = prefix.joinpath(self.outputs.excel)\n    for sf in self.snapshot_filters:\n        if sf.directory:\n            sf.directory = prefix.joinpath(sf.directory)\n    return prefix\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.Config.model_validate", "title": "model_validate  <code>classmethod</code>", "text": "<pre><code>model_validate(*args, **kwargs) -&gt; typing.Any\n</code></pre> <p>Validate the passengersim Config inputs.</p> <p>This method reloads the Config class to ensure all imported RmSteps are properly registered before validation.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>         \u2013          <p>The object to validate.</p> </li> <li> <code>strict</code>             (<code>bool</code>)         \u2013          <p>Whether to raise an exception on invalid fields.</p> </li> <li> <code>from_attributes</code>         \u2013          <p>Whether to extract data from object attributes.</p> </li> <li> <code>context</code>         \u2013          <p>Additional context to pass to the validator.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValidationError</code>           \u2013          <p>If the object could not be validated.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config</code>         \u2013          <p>The validated model instance.</p> </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    *args,\n    **kwargs,\n) -&gt; typing.Any:\n    \"\"\"Validate the passengersim Config inputs.\n\n    This method reloads the Config class to ensure all imported\n    RmSteps are properly registered before validation.\n\n    Parameters\n    ----------\n    obj\n        The object to validate.\n    strict : bool\n        Whether to raise an exception on invalid fields.\n    from_attributes\n        Whether to extract data from object attributes.\n    context\n        Additional context to pass to the validator.\n\n    Raises\n    ------\n    ValidationError\n        If the object could not be validated.\n\n    Returns\n    -------\n    Config\n        The validated model instance.\n    \"\"\"\n    # reload these to refresh for any newly defined RmSteps\n    module_parent = \".\".join(__name__.split(\".\")[:-1])\n    importlib.reload(sys.modules.get(f\"{module_parent}.rm_systems\"))\n    importlib.reload(sys.modules.get(__name__))\n    module = importlib.reload(sys.modules.get(module_parent))\n    reloaded_class = getattr(module, cls.__name__)\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    return reloaded_class.__pydantic_validator__.validate_python(*args, **kwargs)\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig", "title": "YamlConfig", "text": "<p>             Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/base.py</code> <pre><code>class YamlConfig(PrettyModel):\n    @classmethod\n    def _load_unformatted_yaml(\n        cls: type[TConfig],\n        filenames: str | pathlib.Path | list[str] | list[pathlib.Path],\n    ) -&gt; addicty.Dict:\n        \"\"\"\n        Read from YAML to an unvalidated addicty.Dict.\n\n        Parameters\n        ----------\n        filenames : path-like or list[path-like]\n            If multiple filenames are provided, they are loaded in order\n            and values with matching keys defined in later files will overwrite\n            the ones found in earlier files.\n\n        Returns\n        -------\n        addicty.Dict\n        \"\"\"\n        if isinstance(filenames, str | pathlib.Path):\n            filenames = [filenames]\n        raw_config = addicty.Dict()\n        for filename in filenames:\n            if isinstance(filename, str) and \"\\n\" in filename:\n                # explicit YAML content cannot have include statements\n                content = addicty.Dict.load(filename, freeze=False)\n                raw_config.update(content)\n                continue\n            filename = pathlib.Path(filename)\n            if filename.suffix in (\".pem\", \".crt\", \".cert\"):\n                # license certificate\n                with open(filename, \"rb\") as f:\n                    raw_config.raw_license_certificate = f.read()\n            else:\n                opener = gzip.open if filename.suffix == \".gz\" else open\n                if filename.parts[0] in {\"https:\", \"http:\", \"s3:\"}:\n                    opener = web_opener\n                    if filename.suffix == \".gz\":\n                        raise NotImplementedError(\n                            \"cannot load compressed files from web yet\"\n                        )\n                with opener(filename) as f:\n                    content = addicty.Dict.load(f, freeze=False)\n                    include = content.pop(\"include\", None)\n                    if include is not None:\n                        if isinstance(include, str):\n                            filename.parent.joinpath(include)\n                            inclusions = [filename.parent.joinpath(include)]\n                        else:\n                            inclusions = [filename.parent.joinpath(i) for i in include]\n                        raw_config.update(cls._load_unformatted_yaml(inclusions))\n                    raw_config.update(content)\n            logger.info(\"loaded config from %s\", filename)\n        return raw_config\n\n    @classmethod\n    def from_yaml(\n        cls: type[TConfig],\n        filenames: pathlib.Path | list[pathlib.Path],\n    ) -&gt; TConfig:\n        \"\"\"\n        Read from YAML to an unvalidated addicty.Dict.\n\n        Parameters\n        ----------\n        filenames : path-like or list[path-like]\n            If multiple filenames are provided, they are loaded in order\n            and values with matching keys defined in later files will overwrite\n            the ones found in earlier files.\n\n        Returns\n        -------\n        Config\n        \"\"\"\n        raw_config = cls._load_unformatted_yaml(filenames)\n        return cls.model_validate(raw_config.to_dict())\n\n    def to_yaml(self, stream: os.PathLike | io.FileIO | None = None) -&gt; None | bytes:\n        \"\"\"\n        Write a config to YAML format.\n\n        Parameters\n        ----------\n        stream : Path-like or File-like, optional\n            Write the results here.  If given as a path, a new file is written\n            at this location, or give a File-like object open for writing.\n\n        Returns\n        -------\n        bytes or None\n            When no stream is given, the YAML content is returned as bytes,\n            otherwise this method returns nothing.\n        \"\"\"\n\n        def path_to_str(x):\n            if isinstance(x, dict):\n                return {k: path_to_str(v) for k, v in x.items()}\n            if isinstance(x, list):\n                return list(path_to_str(i) for i in x)\n            if isinstance(x, tuple):\n                return list(path_to_str(i) for i in x)\n            if isinstance(x, pathlib.Path):\n                return str(x)\n            else:\n                return x\n\n        y = path_to_str(self.model_dump())\n        b = yaml.dump(y, encoding=\"utf8\", Dumper=yaml.SafeDumper)\n        if isinstance(stream, str):\n            stream = pathlib.Path(stream)\n        if isinstance(stream, pathlib.Path):\n            stream.write_bytes(b)\n        elif isinstance(stream, io.RawIOBase):\n            stream.write(b)\n        elif isinstance(stream, io.TextIOBase):\n            stream.write(b.decode())\n        else:\n            return b\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig.from_yaml", "title": "from_yaml  <code>classmethod</code>", "text": "<pre><code>from_yaml(\n    filenames: pathlib.Path | list[pathlib.Path],\n) -&gt; TConfig\n</code></pre> <p>Read from YAML to an unvalidated addicty.Dict.</p> <p>Parameters:</p> <ul> <li> <code>filenames</code>             (<code>path - like or list[path - like]</code>)         \u2013          <p>If multiple filenames are provided, they are loaded in order and values with matching keys defined in later files will overwrite the ones found in earlier files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config</code>         \u2013          </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>@classmethod\ndef from_yaml(\n    cls: type[TConfig],\n    filenames: pathlib.Path | list[pathlib.Path],\n) -&gt; TConfig:\n    \"\"\"\n    Read from YAML to an unvalidated addicty.Dict.\n\n    Parameters\n    ----------\n    filenames : path-like or list[path-like]\n        If multiple filenames are provided, they are loaded in order\n        and values with matching keys defined in later files will overwrite\n        the ones found in earlier files.\n\n    Returns\n    -------\n    Config\n    \"\"\"\n    raw_config = cls._load_unformatted_yaml(filenames)\n    return cls.model_validate(raw_config.to_dict())\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.YamlConfig.to_yaml", "title": "to_yaml", "text": "<pre><code>to_yaml(\n    stream: os.PathLike | io.FileIO | None = None,\n) -&gt; None | bytes\n</code></pre> <p>Write a config to YAML format.</p> <p>Parameters:</p> <ul> <li> <code>stream</code>             (<code>Path - like or File - like</code>, default:                 <code>None</code> )         \u2013          <p>Write the results here.  If given as a path, a new file is written at this location, or give a File-like object open for writing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes or None</code>         \u2013          <p>When no stream is given, the YAML content is returned as bytes, otherwise this method returns nothing.</p> </li> </ul> Source code in <code>passengersim/config/base.py</code> <pre><code>def to_yaml(self, stream: os.PathLike | io.FileIO | None = None) -&gt; None | bytes:\n    \"\"\"\n    Write a config to YAML format.\n\n    Parameters\n    ----------\n    stream : Path-like or File-like, optional\n        Write the results here.  If given as a path, a new file is written\n        at this location, or give a File-like object open for writing.\n\n    Returns\n    -------\n    bytes or None\n        When no stream is given, the YAML content is returned as bytes,\n        otherwise this method returns nothing.\n    \"\"\"\n\n    def path_to_str(x):\n        if isinstance(x, dict):\n            return {k: path_to_str(v) for k, v in x.items()}\n        if isinstance(x, list):\n            return list(path_to_str(i) for i in x)\n        if isinstance(x, tuple):\n            return list(path_to_str(i) for i in x)\n        if isinstance(x, pathlib.Path):\n            return str(x)\n        else:\n            return x\n\n    y = path_to_str(self.model_dump())\n    b = yaml.dump(y, encoding=\"utf8\", Dumper=yaml.SafeDumper)\n    if isinstance(stream, str):\n        stream = pathlib.Path(stream)\n    if isinstance(stream, pathlib.Path):\n        stream.write_bytes(b)\n    elif isinstance(stream, io.RawIOBase):\n        stream.write(b)\n    elif isinstance(stream, io.TextIOBase):\n        stream.write(b.decode())\n    else:\n        return b\n</code></pre>"}, {"location": "API/config/00-configs.html#passengersim.config.base.web_opener", "title": "web_opener", "text": "<pre><code>web_opener(x)\n</code></pre> Source code in <code>passengersim/config/base.py</code> <pre><code>def web_opener(x):\n    return urlopen(x.parts[0] + \"//\" + \"/\".join(x.parts[1:]))\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html", "title": "Simulation Controls", "text": ""}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings", "title": "SimulationSettings", "text": "<p>             Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/simulation_controls.py</code> <pre><code>class SimulationSettings(PrettyModel, extra=\"allow\", validate_assignment=True):\n    num_trials: conint(ge=1, le=1000) = 1\n    \"\"\"The overall number of trials to run.\n\n    Each trial is a complete simulation, including burn-in training time as well\n    as study time.  It will have a number of sequentially developed samples, each of\n    which represents one \"typical\" day of travel.\n\n    See [Counting Simulations][counting-simulations] for more details.\n    \"\"\"\n\n    num_samples: conint(ge=1, le=10000) = 600\n    \"\"\"The number of samples to run within each trial.\n\n    Each sample represents one \"typical\" day of travel.\n    See [Counting Simulations][counting-simulations] for more details.\n    \"\"\"\n\n    burn_samples: conint(ge=1, le=10000) = 100\n    \"\"\"The number of samples to burn when starting each trial.\n\n    Burned samples are used to populate a stable history of data to support\n    forecasting and optimization algorithms, but are not used to evaluate\n    performance results.\n\n    See [Counting Simulations][counting-simulations] for more details.\n    \"\"\"\n\n    double_capacity_until: int | None = None\n    \"\"\"\n    Double the capacity on all legs until this sample.\n\n    The extra capacity may reduce the statistical noise of untruncation\n    within the burn period and allow the simulation to achieve a stable\n    steady state faster.  If used, this should be set to a value at least\n    26 below the `burn_samples` value to avoid polluting the results.\n    \"\"\"\n\n    @field_validator(\"double_capacity_until\")\n    @classmethod\n    def _avoid_capacity_pollution(cls, v: int | None, info: FieldValidationInfo):\n        if v and v &gt;= info.data[\"burn_samples\"] - 25:\n            raise ValueError(\"doubled capacity will pollute results\")\n        return v\n\n    sys_k_factor: confloat(ge=0, le=5.0) = 0.10\n    \"\"\"\n    System-level randomness factor.\n\n    This factor controls the level of correlation in demand levels across the\n    entire system.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    mkt_k_factor: confloat(ge=0, le=5.0) = 0.20\n    \"\"\"\n    Market-level randomness factor.\n\n    This factor controls the level of correlation in demand levels across origin-\n    destination markets.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    pax_type_k_factor: confloat(ge=0, le=5.0) = 0.0\n    \"\"\"\n    Passenger-type randomness factor.\n\n    This factor controls the level of correlation in demand levels across passenger\n    types.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    simple_k_factor: confloat(ge=0, le=5.0) = 0.40\n    \"\"\"\n    Passenger-type randomness factor.\n\n    This factor add uncorrelated variance to every demand.\n\n    See [k-factors][demand-generation-k-factors]\n    for more details.\n    \"\"\"\n\n    tf_k_factor: confloat(ge=0) = 0.1\n    \"\"\"\n    Time frame randomness factor.\n\n    This factor controls the dispersion of bookings over time, given a previously\n    identified level of total demand. See [k-factors]() for more details.\n    \"\"\"\n\n    tot_z_factor: confloat(ge=0, le=100.0) = 2.0\n    \"\"\"\n    Base level demand variance control.\n\n    This factor scales the variance in the amount of total demand for any given\n    market segment.\n\n    See [k-factors][demand-generation-k-factors] for more details.\n    \"\"\"\n\n    tf_z_factor: confloat(ge=0, le=100.0) = 2.0\n    \"\"\"\n    Timeframe demand variance control.\n\n    This factor scales the variance in the allocation of total demand to the\n    various arrival timeframes.\n\n    See [k-factors][demand-generation-k-factors] for more details.\n    \"\"\"\n\n    prorate_revenue: bool = True\n\n    dwm_lite: bool = True\n    \"\"\"\n    Use the \"lite\" decision window model.\n\n    The structure of this model is the same as that use by Boeing.\n    \"\"\"\n\n    max_connect_time: conint(ge=0) = 240\n    \"\"\"\n    Maximum connection time for automatically generated paths.\n\n    Any generated path that has a connection time greater than this value (expressed\n    in minutes) is invalidated.\n    \"\"\"\n\n    disable_ap: bool = False\n    \"\"\"\n    Remove all advance purchase settings used in the simulation.\n\n    This applies to all airlines and all fare products.\n    \"\"\"\n\n    demand_multiplier: confloat(gt=0) = 1.0\n    \"\"\"\n    Scale all demand by this value.\n\n    Setting to a value other than 1.0 will increase or decrease all demand inputs\n    uniformly by the same multiplicative amount. This is helpful when exploring how\n    simulation results vary when you have \"low demand\" scenarios (e.g,\n    demand_multiplier = 0.8), or \"high demand\" scenarios (e.g., demand multiplier = 1.1).\n    \"\"\"\n\n    manual_paths: bool = True\n    \"\"\"\n    The user has provided explicit paths and connections.\n\n    If set to False, the automatic path generation algorithm is applied.\n    \"\"\"\n\n    write_raw_files: bool = False\n\n    random_seed: int | None = None\n    \"\"\"\n    Integer used to control the reproducibility of simulation results.\n\n    A seed is base value used by a pseudo-random generator to generate random\n    numbers. A fixed random seed is used to ensure the same randomness pattern\n    is reproducible and does not change between simulation runs, i.e. allows\n    subsequent runs to be conducted with the same randomness pattern as a\n    previous one. Any value set here will allow results to be repeated.\n\n    The random number generator is re-seeded at the beginning of every sample\n    in every trial with a fixed tuple of three values: this \"global\" random seed,\n    plus the sample number and trial number.  This ensures that partial results\n    are also reproducible: the simulation of sample 234 in trial 2 will be the\n    same regardless of how many samples are in trial 1.\n    \"\"\"\n\n    update_frequency: int | None = None\n\n    controller_time_zone: int | float = -21600\n    \"\"\"\n    The reference time zone for the controller (seconds relative to UTC).\n\n    Data collection points will be trigger at approximately midnight in this time zone.\n\n    This value can be input in hours instead of seconds, any absolute value less\n    than or equal to 12 will be assumed to be hours and scaled to seconds.\n\n    The default value is -6 hours, or US Central Standard Time.\n    \"\"\"\n\n    base_date: str = \"2020-03-01\"\n    \"\"\"\n    The default date used to compute relative times for travel.\n\n    Future enhancements may include multi-day modeling.\n    \"\"\"\n\n    dcp_hour: float = 0.0\n    \"\"\"\n    The hour of the day that the RM recalculation events are triggered.\n\n    If set to zero, the events happen at midnight.  Other values can\n    delay the recalculation into later in the night (or the next day).\n    \"\"\"\n\n    show_progress_bar: bool = True\n    \"\"\"\n    Show a progress bar while running.\n\n    The progress display requires `rich` is installed.\n    \"\"\"\n\n    @field_validator(\"controller_time_zone\", mode=\"before\")\n    def _time_zone_convert_hours_to_seconds(cls, v):\n        if -12 &lt;= v &lt;= 12:\n            v *= 3600\n        return v\n\n    def reference_epoch(self) -&gt; int:\n        \"\"\"Get the reference travel datetime in unix time.\"\"\"\n        return iso_to_unix(self.base_date) - self.controller_time_zone\n\n    timeframe_demand_allocation: Literal[\"v2\", \"pods\"] = \"v2\"\n    \"\"\"\n    Which algorithm to use for time frame demand allocation.\n    \"\"\"\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.base_date", "title": "base_date  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>base_date: str = '2020-03-01'\n</code></pre> <p>The default date used to compute relative times for travel.</p> <p>Future enhancements may include multi-day modeling.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.burn_samples", "title": "burn_samples  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>burn_samples: conint(ge=1, le=10000) = 100\n</code></pre> <p>The number of samples to burn when starting each trial.</p> <p>Burned samples are used to populate a stable history of data to support forecasting and optimization algorithms, but are not used to evaluate performance results.</p> <p>See Counting Simulations for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.controller_time_zone", "title": "controller_time_zone  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>controller_time_zone: int | float = -21600\n</code></pre> <p>The reference time zone for the controller (seconds relative to UTC).</p> <p>Data collection points will be trigger at approximately midnight in this time zone.</p> <p>This value can be input in hours instead of seconds, any absolute value less than or equal to 12 will be assumed to be hours and scaled to seconds.</p> <p>The default value is -6 hours, or US Central Standard Time.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.dcp_hour", "title": "dcp_hour  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcp_hour: float = 0.0\n</code></pre> <p>The hour of the day that the RM recalculation events are triggered.</p> <p>If set to zero, the events happen at midnight.  Other values can delay the recalculation into later in the night (or the next day).</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.demand_multiplier", "title": "demand_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>demand_multiplier: confloat(gt=0) = 1.0\n</code></pre> <p>Scale all demand by this value.</p> <p>Setting to a value other than 1.0 will increase or decrease all demand inputs uniformly by the same multiplicative amount. This is helpful when exploring how simulation results vary when you have \"low demand\" scenarios (e.g, demand_multiplier = 0.8), or \"high demand\" scenarios (e.g., demand multiplier = 1.1).</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.disable_ap", "title": "disable_ap  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>disable_ap: bool = False\n</code></pre> <p>Remove all advance purchase settings used in the simulation.</p> <p>This applies to all airlines and all fare products.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.double_capacity_until", "title": "double_capacity_until  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>double_capacity_until: int | None = None\n</code></pre> <p>Double the capacity on all legs until this sample.</p> <p>The extra capacity may reduce the statistical noise of untruncation within the burn period and allow the simulation to achieve a stable steady state faster.  If used, this should be set to a value at least 26 below the <code>burn_samples</code> value to avoid polluting the results.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.dwm_lite", "title": "dwm_lite  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dwm_lite: bool = True\n</code></pre> <p>Use the \"lite\" decision window model.</p> <p>The structure of this model is the same as that use by Boeing.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.manual_paths", "title": "manual_paths  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>manual_paths: bool = True\n</code></pre> <p>The user has provided explicit paths and connections.</p> <p>If set to False, the automatic path generation algorithm is applied.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.max_connect_time", "title": "max_connect_time  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>max_connect_time: conint(ge=0) = 240\n</code></pre> <p>Maximum connection time for automatically generated paths.</p> <p>Any generated path that has a connection time greater than this value (expressed in minutes) is invalidated.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.mkt_k_factor", "title": "mkt_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>mkt_k_factor: confloat(ge=0, le=5.0) = 0.2\n</code></pre> <p>Market-level randomness factor.</p> <p>This factor controls the level of correlation in demand levels across origin- destination markets.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.num_samples", "title": "num_samples  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>num_samples: conint(ge=1, le=10000) = 600\n</code></pre> <p>The number of samples to run within each trial.</p> <p>Each sample represents one \"typical\" day of travel. See Counting Simulations for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.num_trials", "title": "num_trials  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>num_trials: conint(ge=1, le=1000) = 1\n</code></pre> <p>The overall number of trials to run.</p> <p>Each trial is a complete simulation, including burn-in training time as well as study time.  It will have a number of sequentially developed samples, each of which represents one \"typical\" day of travel.</p> <p>See Counting Simulations for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.pax_type_k_factor", "title": "pax_type_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>pax_type_k_factor: confloat(ge=0, le=5.0) = 0.0\n</code></pre> <p>Passenger-type randomness factor.</p> <p>This factor controls the level of correlation in demand levels across passenger types.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.prorate_revenue", "title": "prorate_revenue  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>prorate_revenue: bool = True\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.random_seed", "title": "random_seed  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>random_seed: int | None = None\n</code></pre> <p>Integer used to control the reproducibility of simulation results.</p> <p>A seed is base value used by a pseudo-random generator to generate random numbers. A fixed random seed is used to ensure the same randomness pattern is reproducible and does not change between simulation runs, i.e. allows subsequent runs to be conducted with the same randomness pattern as a previous one. Any value set here will allow results to be repeated.</p> <p>The random number generator is re-seeded at the beginning of every sample in every trial with a fixed tuple of three values: this \"global\" random seed, plus the sample number and trial number.  This ensures that partial results are also reproducible: the simulation of sample 234 in trial 2 will be the same regardless of how many samples are in trial 1.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.show_progress_bar", "title": "show_progress_bar  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>show_progress_bar: bool = True\n</code></pre> <p>Show a progress bar while running.</p> <p>The progress display requires <code>rich</code> is installed.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.simple_k_factor", "title": "simple_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>simple_k_factor: confloat(ge=0, le=5.0) = 0.4\n</code></pre> <p>Passenger-type randomness factor.</p> <p>This factor add uncorrelated variance to every demand.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.sys_k_factor", "title": "sys_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>sys_k_factor: confloat(ge=0, le=5.0) = 0.1\n</code></pre> <p>System-level randomness factor.</p> <p>This factor controls the level of correlation in demand levels across the entire system.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.tf_k_factor", "title": "tf_k_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tf_k_factor: confloat(ge=0) = 0.1\n</code></pre> <p>Time frame randomness factor.</p> <p>This factor controls the dispersion of bookings over time, given a previously identified level of total demand. See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.tf_z_factor", "title": "tf_z_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tf_z_factor: confloat(ge=0, le=100.0) = 2.0\n</code></pre> <p>Timeframe demand variance control.</p> <p>This factor scales the variance in the allocation of total demand to the various arrival timeframes.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.timeframe_demand_allocation", "title": "timeframe_demand_allocation  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>timeframe_demand_allocation: Literal['v2', 'pods'] = 'v2'\n</code></pre> <p>Which algorithm to use for time frame demand allocation.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.tot_z_factor", "title": "tot_z_factor  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tot_z_factor: confloat(ge=0, le=100.0) = 2.0\n</code></pre> <p>Base level demand variance control.</p> <p>This factor scales the variance in the amount of total demand for any given market segment.</p> <p>See k-factors for more details.</p>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.update_frequency", "title": "update_frequency  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>update_frequency: int | None = None\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.write_raw_files", "title": "write_raw_files  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>write_raw_files: bool = False\n</code></pre>"}, {"location": "API/config/01-simulation-controls.html#passengersim.config.simulation_controls.SimulationSettings.reference_epoch", "title": "reference_epoch", "text": "<pre><code>reference_epoch() -&gt; int\n</code></pre> <p>Get the reference travel datetime in unix time.</p> Source code in <code>passengersim/config/simulation_controls.py</code> <pre><code>def reference_epoch(self) -&gt; int:\n    \"\"\"Get the reference travel datetime in unix time.\"\"\"\n    return iso_to_unix(self.base_date) - self.controller_time_zone\n</code></pre>"}, {"location": "API/config/airlines.html", "title": "Airlines", "text": ""}, {"location": "API/config/airlines.html#passengersim.config.airlines.Airline", "title": "Airline", "text": "<p>             Bases: <code>Named</code></p> <p>Configuration for passengersim.Airline object.</p> Source code in <code>passengersim/config/airlines.py</code> <pre><code>class Airline(Named, extra=\"forbid\"):\n    \"\"\"Configuration for passengersim.Airline object.\"\"\"\n\n    rm_system: str\n    \"\"\"Name of the revenue management system used by this airline.\"\"\"\n\n    control: str = \"\"\n    \"\"\"Deprecated.  No effect\"\"\"\n\n    frat5: Optional[str] = \"\"\n    \"\"\"Named FRAT5 curve.  \n    This is the default that will be applied if not found at a more detailed level\n    \"\"\"\n\n    load_factor_curve: Optional[Any] = None\n    \"\"\"Named FRAT5 curve.  \n    This is the default that will be applied if not found at a more detailed level\n    \"\"\"\n</code></pre>"}, {"location": "API/config/airlines.html#passengersim.config.airlines.Airline.control", "title": "control  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>control: str = ''\n</code></pre> <p>Deprecated.  No effect</p>"}, {"location": "API/config/airlines.html#passengersim.config.airlines.Airline.frat5", "title": "frat5  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>frat5: Optional[str] = ''\n</code></pre> <p>Named FRAT5 curve. This is the default that will be applied if not found at a more detailed level</p>"}, {"location": "API/config/airlines.html#passengersim.config.airlines.Airline.load_factor_curve", "title": "load_factor_curve  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>load_factor_curve: Optional[Any] = None\n</code></pre> <p>Named FRAT5 curve. This is the default that will be applied if not found at a more detailed level</p>"}, {"location": "API/config/airlines.html#passengersim.config.airlines.Airline.rm_system", "title": "rm_system  <code>instance-attribute</code>", "text": "<pre><code>rm_system: str\n</code></pre> <p>Name of the revenue management system used by this airline.</p>"}, {"location": "API/config/booking_curves.html", "title": "Booking Curves", "text": ""}, {"location": "API/config/booking_curves.html#passengersim.config.booking_curves.BookingCurve", "title": "BookingCurve", "text": "<p>             Bases: <code>Named</code></p> <p>A mathematical description of the relative arrival rate of customers over time.</p> Source code in <code>passengersim/config/booking_curves.py</code> <pre><code>class BookingCurve(Named, extra=\"forbid\"):\n    \"\"\"\n    A mathematical description of the relative arrival rate of customers over time.\n    \"\"\"\n\n    curve: dict[int, float]\n    \"\"\"Define a booking curve.\n\n    For a given customer type, the booking curve gives the cumulative fraction\n    of those customers who are expected to have already \"arrived\" at any given\n    data collection point (DCP).  An \"arriving\" customer is one who is interested\n    in booking, but may or may not actually purchase a travel product from one\n    of the carriers, depending on the availability of products at the time of their\n    arrival.\n\n    The values (cumulative fraction of customers arriving) should increase\n    monotonically as the keys (DCPs, e.g. days to departure) decrease.\n\n    Example\n    -------\n    ```{yaml}\n    - name: business\n      curve:\n        63: 0.01\n        56: 0.02\n        49: 0.05\n        42: 0.13\n        35: 0.19\n        31: 0.23\n        28: 0.29\n        24: 0.35\n        21: 0.45\n        17: 0.54\n        14: 0.67\n        10: 0.79\n        7: 0.86\n        5: 0.91\n        3: 0.96\n        1: 1.0\n    ```\n    \"\"\"\n\n    @field_validator(\"curve\")\n    def _booking_curves_accumulate(cls, v: dict[int, float], info: FieldValidationInfo):\n        \"\"\"Check that all curve values do not decrease as DCP keys decrease.\"\"\"\n        sorted_dcps = reversed(sorted(v.keys()))\n        i = 0\n        for dcp in sorted_dcps:\n            assert (\n                v[dcp] &gt;= i\n            ), f\"booking curve {info.data['name']} moves backwards at dcp {dcp}\"\n            i = v[dcp]\n        return v\n</code></pre>"}, {"location": "API/config/booking_curves.html#passengersim.config.booking_curves.BookingCurve.curve", "title": "curve  <code>instance-attribute</code>", "text": "<pre><code>curve: dict[int, float]\n</code></pre> <p>Define a booking curve.</p> <p>For a given customer type, the booking curve gives the cumulative fraction of those customers who are expected to have already \"arrived\" at any given data collection point (DCP).  An \"arriving\" customer is one who is interested in booking, but may or may not actually purchase a travel product from one of the carriers, depending on the availability of products at the time of their arrival.</p> <p>The values (cumulative fraction of customers arriving) should increase monotonically as the keys (DCPs, e.g. days to departure) decrease.</p>"}, {"location": "API/config/booking_curves.html#passengersim.config.booking_curves.BookingCurve.curve--example", "title": "Example", "text": "<pre><code>- name: business\n  curve:\n    63: 0.01\n    56: 0.02\n    49: 0.05\n    42: 0.13\n    35: 0.19\n    31: 0.23\n    28: 0.29\n    24: 0.35\n    21: 0.45\n    17: 0.54\n    14: 0.67\n    10: 0.79\n    7: 0.86\n    5: 0.91\n    3: 0.96\n    1: 1.0\n</code></pre>"}, {"location": "API/config/choice_model.html", "title": "Choice Models", "text": ""}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.ChoiceModel", "title": "ChoiceModel  <code>module-attribute</code>", "text": "<pre><code>ChoiceModel = Annotated[\n    PodsChoiceModel | LogitChoiceModel,\n    Field(discriminator=\"kind\"),\n]\n</code></pre> <p>Two types of choice models are available in PassengerSim.</p> <p>Use the <code>kind</code> key to select which kind of choice model you wish to parameterize.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel", "title": "LogitChoiceModel", "text": "<p>             Bases: <code>Named</code></p> Source code in <code>passengersim/config/choice_model.py</code> <pre><code>class LogitChoiceModel(Named, extra=\"forbid\"):\n    kind: Literal[\"logit\"]\n\n    intercept: float = 0\n    \"\"\"This is the alternative specific constant for the no-purchase alternative.\"\"\"\n\n    nonstop: float = 0\n    duration: float = 0\n    price: float = 0\n    \"\"\"This is the parameter for the price of each alternative.\"\"\"\n\n    tod_sin2p: float = 0\n    r\"\"\"Schedule parameter.\n\n    If $t$ is departure time (in minutes after midnight local time) divided\n    by 1440, this parameter is multiplied by $sin( 2 \\pi t)$ and the result is\n    added to the utility of the particular alternative.\"\"\"\n\n    tod_sin4p: float = 0\n    r\"\"\"Schedule parameter.\n\n    If $t$ is departure time (in minutes after midnight local time) divided\n    by 1440, this parameter is multiplied by $sin( 4 \\pi t)$ and the result is\n    added to the utility of the particular alternative.\"\"\"\n\n    tod_sin6p: float = 0\n    tod_cos2p: float = 0\n    tod_cos4p: float = 0\n    tod_cos6p: float = 0\n    free_bag: float = 0\n    early_boarding: float = 0\n    same_day_change: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.duration", "title": "duration  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>duration: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.early_boarding", "title": "early_boarding  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>early_boarding: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.free_bag", "title": "free_bag  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>free_bag: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.intercept", "title": "intercept  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>intercept: float = 0\n</code></pre> <p>This is the alternative specific constant for the no-purchase alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.kind", "title": "kind  <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['logit']\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.nonstop", "title": "nonstop  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>nonstop: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.price", "title": "price  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>price: float = 0\n</code></pre> <p>This is the parameter for the price of each alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.same_day_change", "title": "same_day_change  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>same_day_change: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_cos2p", "title": "tod_cos2p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_cos2p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_cos4p", "title": "tod_cos4p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_cos4p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_cos6p", "title": "tod_cos6p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_cos6p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_sin2p", "title": "tod_sin2p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_sin2p: float = 0\n</code></pre> <p>Schedule parameter.</p> <p>If \\(t\\) is departure time (in minutes after midnight local time) divided by 1440, this parameter is multiplied by \\(sin( 2 \\pi t)\\) and the result is added to the utility of the particular alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_sin4p", "title": "tod_sin4p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_sin4p: float = 0\n</code></pre> <p>Schedule parameter.</p> <p>If \\(t\\) is departure time (in minutes after midnight local time) divided by 1440, this parameter is multiplied by \\(sin( 4 \\pi t)\\) and the result is added to the utility of the particular alternative.</p>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.LogitChoiceModel.tod_sin6p", "title": "tod_sin6p  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tod_sin6p: float = 0\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel", "title": "PodsChoiceModel", "text": "<p>             Bases: <code>Named</code></p> Source code in <code>passengersim/config/choice_model.py</code> <pre><code>class PodsChoiceModel(Named, extra=\"forbid\"):\n    kind: Literal[\"pods\"]\n\n    emult: float | None = None\n\n    basefare_mult: float | None = None\n    connect_disutility: float | None = None\n    path_quality: tuple[float, float] | None = None\n    preferred_airline: tuple[float, float] | None = None\n    r1: float | None = None\n    r2: float | None = None\n    r3: float | None = None\n    r4: float | None = None\n    tolerance: float | None = None\n    non_stop_multiplier: float | None = None\n    connection_multiplier: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.basefare_mult", "title": "basefare_mult  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>basefare_mult: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.connect_disutility", "title": "connect_disutility  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>connect_disutility: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.connection_multiplier", "title": "connection_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>connection_multiplier: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.emult", "title": "emult  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>emult: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.kind", "title": "kind  <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['pods']\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.non_stop_multiplier", "title": "non_stop_multiplier  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>non_stop_multiplier: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.path_quality", "title": "path_quality  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>path_quality: tuple[float, float] | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.preferred_airline", "title": "preferred_airline  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>preferred_airline: tuple[float, float] | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.r1", "title": "r1  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>r1: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.r2", "title": "r2  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>r2: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.r3", "title": "r3  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>r3: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.r4", "title": "r4  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>r4: float | None = None\n</code></pre>"}, {"location": "API/config/choice_model.html#passengersim.config.choice_model.PodsChoiceModel.tolerance", "title": "tolerance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>tolerance: float | None = None\n</code></pre>"}, {"location": "API/config/database.html", "title": "Database", "text": ""}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig", "title": "DatabaseConfig", "text": "<p>             Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/database.py</code> <pre><code>class DatabaseConfig(PrettyModel, extra=\"forbid\", validate_assignment=True):\n    engine: Literal[\"sqlite\", \"mysql\", None] = \"sqlite\"\n    \"\"\"Database engine to use.\n\n    Currently only `sqlite` is fully implemented.\"\"\"\n\n    filename: pathlib.Path | None = \"airsim-output.sqlite\"\n    \"\"\"Name of file for SQLite output.\"\"\"\n\n    fast: bool = False\n    \"\"\"Whether to use pre-compiled SQL write instructions.\"\"\"\n\n    pragmas: list[str] = []\n    \"\"\"A list of PRAGMA commands to execute upon opening a database connection.\"\"\"\n\n    commit_count_delay: int | None = 250\n    \"\"\"Commit transactions to the database will only be honored this frequently.\n\n    By setting this number greater than 1, the transaction frequency will be reduced,\n    improving overall runtime performance by storing more data in RAM and writing to\n    persistent storage less frequently.\n    \"\"\"\n\n    write_items: set[\n        Literal[\n            \"leg\",\n            \"bucket\",\n            \"fare\",\n            \"demand\",\n            \"leg_final\",\n            \"bucket_final\",\n            \"fare_final\",\n            \"demand_final\",\n            \"bookings\",\n            \"pathclass\",\n            \"pathclass_final\",\n        ]\n    ] = {\"leg_final\", \"fare_final\", \"demand_final\", \"bookings\"}\n    \"\"\"Which items should be written to the database.\n\n    The following values can be provided in this set:\n\n    - *leg*: write every leg to the `leg_detail` table at every DCP.\n    - *leg_final*: write every leg to the `leg_detail` table only at DCP 0.\n    - *bucket*: write every leg bucket to the `leg_bucket_detail` table at every DCP.\n    - *bucket_final*: write every leg bucket to the `leg_bucket_detail` table only\n        at DCP 0.\n    - *fare*: write every fare to the `fare_detail` table at every DCP.\n    - *fare_final*: write every fare to the `fare_detail` table only at DCP 0.\n    - *demand*: write every demand to the `demand_detail` table at every DCP.\n    - *bookings*: store booking summary data at every DCP and write an aggregate\n        summary of bookings by DCP to the `bookings_by_timeframe` table at the end\n        of the simulation.\n    \"\"\"\n\n    dcp_write_hooks: list[Callable] = []\n    \"\"\"Additional callable functions that write to the database at each DCP.\n\n    Each should have a signature matching `f(db, sim, dcp)`.\n    \"\"\"\n\n    @field_validator(\"engine\", mode=\"before\")\n    def _interpret_none(cls, v):\n        \"\"\"Allow engine to be \"none\".\"\"\"\n        if isinstance(v, str) and v.lower() == \"none\":\n            v = None\n        return v\n\n    store_leg_bid_prices: bool = True\n    \"\"\"Should leg bid prices be stored in the database.\"\"\"\n</code></pre>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.commit_count_delay", "title": "commit_count_delay  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>commit_count_delay: int | None = 250\n</code></pre> <p>Commit transactions to the database will only be honored this frequently.</p> <p>By setting this number greater than 1, the transaction frequency will be reduced, improving overall runtime performance by storing more data in RAM and writing to persistent storage less frequently.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.dcp_write_hooks", "title": "dcp_write_hooks  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcp_write_hooks: list[Callable] = []\n</code></pre> <p>Additional callable functions that write to the database at each DCP.</p> <p>Each should have a signature matching <code>f(db, sim, dcp)</code>.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.engine", "title": "engine  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>engine: Literal['sqlite', 'mysql', None] = 'sqlite'\n</code></pre> <p>Database engine to use.</p> <p>Currently only <code>sqlite</code> is fully implemented.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.fast", "title": "fast  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>fast: bool = False\n</code></pre> <p>Whether to use pre-compiled SQL write instructions.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.filename", "title": "filename  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>filename: pathlib.Path | None = 'airsim-output.sqlite'\n</code></pre> <p>Name of file for SQLite output.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.pragmas", "title": "pragmas  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>pragmas: list[str] = []\n</code></pre> <p>A list of PRAGMA commands to execute upon opening a database connection.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.store_leg_bid_prices", "title": "store_leg_bid_prices  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>store_leg_bid_prices: bool = True\n</code></pre> <p>Should leg bid prices be stored in the database.</p>"}, {"location": "API/config/database.html#passengersim.config.database.DatabaseConfig.write_items", "title": "write_items  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>write_items: set[\n    Literal[\n        \"leg\",\n        \"bucket\",\n        \"fare\",\n        \"demand\",\n        \"leg_final\",\n        \"bucket_final\",\n        \"fare_final\",\n        \"demand_final\",\n        \"bookings\",\n        \"pathclass\",\n        \"pathclass_final\",\n    ]\n] = {\"leg_final\", \"fare_final\", \"demand_final\", \"bookings\"}\n</code></pre> <p>Which items should be written to the database.</p> <p>The following values can be provided in this set:</p> <ul> <li>leg: write every leg to the <code>leg_detail</code> table at every DCP.</li> <li>leg_final: write every leg to the <code>leg_detail</code> table only at DCP 0.</li> <li>bucket: write every leg bucket to the <code>leg_bucket_detail</code> table at every DCP.</li> <li>bucket_final: write every leg bucket to the <code>leg_bucket_detail</code> table only     at DCP 0.</li> <li>fare: write every fare to the <code>fare_detail</code> table at every DCP.</li> <li>fare_final: write every fare to the <code>fare_detail</code> table only at DCP 0.</li> <li>demand: write every demand to the <code>demand_detail</code> table at every DCP.</li> <li>bookings: store booking summary data at every DCP and write an aggregate     summary of bookings by DCP to the <code>bookings_by_timeframe</code> table at the end     of the simulation.</li> </ul>"}, {"location": "API/config/demands.html", "title": "Demands", "text": ""}, {"location": "API/config/demands.html#passengersim.config.demands.Demand", "title": "Demand", "text": "<p>             Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/demands.py</code> <pre><code>class Demand(BaseModel, extra=\"forbid\"):\n    orig: str\n    dest: str\n    segment: str\n    base_demand: float\n    reference_fare: float\n    distance: float | None = 0.0\n    choice_model: str | None = None\n    \"\"\"The name of the choice model that is applied for this demand.\"\"\"\n\n    curve: str | None = None\n    \"\"\"The name of the booking curve that is applied for this demand.\n\n    Each demand is attached to a booking curve that describes the temporal\n    distribution of customer arrivals.\"\"\"\n\n    @property\n    def choice_model_(self):\n        \"\"\"Choice model, falling back to segment name if not set explicitly.\"\"\"\n        return self.choice_model or self.segment\n\n    @field_validator(\"curve\", mode=\"before\")\n    def curve_integer_name(cls, v):\n        \"\"\"Booking curves can have integer names, treat as string.\"\"\"\n        if isinstance(v, int):\n            v = str(v)\n        return v\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.base_demand", "title": "base_demand  <code>instance-attribute</code>", "text": "<pre><code>base_demand: float\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.choice_model", "title": "choice_model  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>choice_model: str | None = None\n</code></pre> <p>The name of the choice model that is applied for this demand.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.choice_model_", "title": "choice_model_  <code>property</code>", "text": "<pre><code>choice_model_\n</code></pre> <p>Choice model, falling back to segment name if not set explicitly.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.curve", "title": "curve  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>curve: str | None = None\n</code></pre> <p>The name of the booking curve that is applied for this demand.</p> <p>Each demand is attached to a booking curve that describes the temporal distribution of customer arrivals.</p>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.distance", "title": "distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>distance: float | None = 0.0\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.reference_fare", "title": "reference_fare  <code>instance-attribute</code>", "text": "<pre><code>reference_fare: float\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.segment", "title": "segment  <code>instance-attribute</code>", "text": "<pre><code>segment: str\n</code></pre>"}, {"location": "API/config/demands.html#passengersim.config.demands.Demand.curve_integer_name", "title": "curve_integer_name", "text": "<pre><code>curve_integer_name(v)\n</code></pre> <p>Booking curves can have integer names, treat as string.</p> Source code in <code>passengersim/config/demands.py</code> <pre><code>@field_validator(\"curve\", mode=\"before\")\ndef curve_integer_name(cls, v):\n    \"\"\"Booking curves can have integer names, treat as string.\"\"\"\n    if isinstance(v, int):\n        v = str(v)\n    return v\n</code></pre>"}, {"location": "API/config/fares.html", "title": "Fares", "text": ""}, {"location": "API/config/fares.html#passengersim.config.fares.Fare", "title": "Fare", "text": "<p>             Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/fares.py</code> <pre><code>class Fare(BaseModel, extra=\"forbid\"):\n    carrier: str\n    orig: str\n    dest: str\n    booking_class: str\n    price: float\n    advance_purchase: int\n    restrictions: list[str] = []\n\n    @field_validator(\"restrictions\", mode=\"before\")\n    def allow_unrestricted(cls, v):\n        \"\"\"Allow restrictions to be None or missing.\"\"\"\n        if v is None:\n            v = []\n        return v\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.advance_purchase", "title": "advance_purchase  <code>instance-attribute</code>", "text": "<pre><code>advance_purchase: int\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.booking_class", "title": "booking_class  <code>instance-attribute</code>", "text": "<pre><code>booking_class: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.price", "title": "price  <code>instance-attribute</code>", "text": "<pre><code>price: float\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.restrictions", "title": "restrictions  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>restrictions: list[str] = []\n</code></pre>"}, {"location": "API/config/fares.html#passengersim.config.fares.Fare.allow_unrestricted", "title": "allow_unrestricted", "text": "<pre><code>allow_unrestricted(v)\n</code></pre> <p>Allow restrictions to be None or missing.</p> Source code in <code>passengersim/config/fares.py</code> <pre><code>@field_validator(\"restrictions\", mode=\"before\")\ndef allow_unrestricted(cls, v):\n    \"\"\"Allow restrictions to be None or missing.\"\"\"\n    if v is None:\n        v = []\n    return v\n</code></pre>"}, {"location": "API/config/frat5_curves.html", "title": "Frat5 Curves", "text": ""}, {"location": "API/config/frat5_curves.html#passengersim.config.frat5_curves.Frat5Curve", "title": "Frat5Curve", "text": "<p>             Bases: <code>Named</code></p> <p>FRAT5 = Fare Ratio at which 50% of customers will buy up to the higher fare.</p> Source code in <code>passengersim/config/frat5_curves.py</code> <pre><code>class Frat5Curve(Named, extra=\"forbid\"):\n    \"\"\"\n    FRAT5 = Fare Ratio at which 50% of customers will buy up to the higher fare.\n    \"\"\"\n\n    curve: dict[int, float]\n    \"\"\"Define a Frat5 curve.\n\n\n    The values (cumulative fraction of customers arriving) should increase\n    monotonically as the keys (DCPs, e.g. days to departure) decrease.\n\n    Example\n    -------\n    ```{yaml}\n    - name: curve_C\n      curve:\n        63: 1.4\n        56: 1.4\n        49: 1.5\n        42: 1.5\n        35: 1.6\n        31: 1.7\n        28: 1.8\n        24: 1.9\n        21: 2.3\n        17: 2.7\n        14: 3.2\n        10: 3.3\n        7: 3.4\n        5: 3.4\n        3: 3.5\n        1: 3.5\n    ```\n    \"\"\"\n\n    @field_validator(\"curve\")\n    def _frat5_curves_accumulate(cls, v: dict[int, float], info: FieldValidationInfo):\n        \"\"\"Check that all curve values do not decrease as DCP keys decrease.\"\"\"\n        sorted_dcps = reversed(sorted(v.keys()))\n        i = 0\n        for dcp in sorted_dcps:\n            assert (v[dcp] &gt;= i), f\"frat5 curve {info.data['name']} moves backwards at dcp {dcp}\"\n            i = v[dcp]\n        return v\n</code></pre>"}, {"location": "API/config/frat5_curves.html#passengersim.config.frat5_curves.Frat5Curve.curve", "title": "curve  <code>instance-attribute</code>", "text": "<pre><code>curve: dict[int, float]\n</code></pre> <p>Define a Frat5 curve.</p> <p>The values (cumulative fraction of customers arriving) should increase monotonically as the keys (DCPs, e.g. days to departure) decrease.</p>"}, {"location": "API/config/frat5_curves.html#passengersim.config.frat5_curves.Frat5Curve.curve--example", "title": "Example", "text": "<pre><code>- name: curve_C\n  curve:\n    63: 1.4\n    56: 1.4\n    49: 1.5\n    42: 1.5\n    35: 1.6\n    31: 1.7\n    28: 1.8\n    24: 1.9\n    21: 2.3\n    17: 2.7\n    14: 3.2\n    10: 3.3\n    7: 3.4\n    5: 3.4\n    3: 3.5\n    1: 3.5\n</code></pre>"}, {"location": "API/config/legs.html", "title": "Legs", "text": ""}, {"location": "API/config/legs.html#passengersim.config.legs.Leg", "title": "Leg", "text": "<p>             Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/legs.py</code> <pre><code>class Leg(BaseModel, extra=\"forbid\"):\n    carrier: str\n    fltno: int\n    \"\"\"A unique identifier for this leg.\n\n    Each leg in a network should have a globally unique identifier (i.e. even\n    if the carrier is different, `fltno` values should be unique.\n    \"\"\"\n\n    orig: str\n    \"\"\"Origination location for this leg.\"\"\"\n\n    dest: str\n    \"\"\"Destination location for this leg.\"\"\"\n\n    date: datetime = datetime.fromisoformat(\"2020-03-01\")\n    \"\"\"Date for this leg.\"\"\"\n\n    dep_time: int\n    \"\"\"Departure time for this leg in Unix time.\n\n    In input files, this can be specified as a string in the format \"HH:MM\",\n    with the hour in 24-hour format.\n\n    Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.\"\"\"\n\n    arr_time: int\n    \"\"\"Arrival time for this leg in Unix time.\n\n    In input files, this can be specified as a string in the format \"HH:MM\",\n    with the hour in 24-hour format.\n\n    Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.\"\"\"\n\n    capacity: int\n    distance: float | None = None\n\n    @field_validator(\"date\", mode=\"before\")\n    def _date_from_string(cls, v):\n        if isinstance(v, str):\n            v = datetime.fromisoformat(v)\n        return v\n\n    @field_validator(\"dep_time\", \"arr_time\", mode=\"before\")\n    def _timestring_to_int(cls, v, info: FieldValidationInfo):\n        if isinstance(v, str) and \":\" in v:\n            dep_time_str = v.split(\":\")\n            hh, mm = int(dep_time_str[0]), int(dep_time_str[1])\n            v = create_timestamp(info.data[\"date\"], 0, hh, mm)\n        if info.field_name == \"arr_time\":\n            if v &lt; info.data[\"dep_time\"]:\n                v += 86400  # add a day (in seconds) as arr time is next day\n        return v\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.arr_time", "title": "arr_time  <code>instance-attribute</code>", "text": "<pre><code>arr_time: int\n</code></pre> <p>Arrival time for this leg in Unix time.</p> <p>In input files, this can be specified as a string in the format \"HH:MM\", with the hour in 24-hour format.</p> <p>Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.capacity", "title": "capacity  <code>instance-attribute</code>", "text": "<pre><code>capacity: int\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.carrier", "title": "carrier  <code>instance-attribute</code>", "text": "<pre><code>carrier: str\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.date", "title": "date  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>date: datetime = datetime.fromisoformat('2020-03-01')\n</code></pre> <p>Date for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.dep_time", "title": "dep_time  <code>instance-attribute</code>", "text": "<pre><code>dep_time: int\n</code></pre> <p>Departure time for this leg in Unix time.</p> <p>In input files, this can be specified as a string in the format \"HH:MM\", with the hour in 24-hour format.</p> <p>Unix time is the number of seconds since 00:00:00 UTC on 1 Jan 1970.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre> <p>Destination location for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.distance", "title": "distance  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>distance: float | None = None\n</code></pre>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.fltno", "title": "fltno  <code>instance-attribute</code>", "text": "<pre><code>fltno: int\n</code></pre> <p>A unique identifier for this leg.</p> <p>Each leg in a network should have a globally unique identifier (i.e. even if the carrier is different, <code>fltno</code> values should be unique.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.Leg.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre> <p>Origination location for this leg.</p>"}, {"location": "API/config/legs.html#passengersim.config.legs.create_timestamp", "title": "create_timestamp", "text": "<pre><code>create_timestamp(base_date, offset, hh, mm) -&gt; int\n</code></pre> <p>Create Unix time from base date, offset (days) and time</p> Source code in <code>passengersim/config/legs.py</code> <pre><code>def create_timestamp(base_date, offset, hh, mm) -&gt; int:\n    \"\"\"Create Unix time from base date, offset (days) and time\"\"\"\n    td = timedelta(days=offset, hours=hh, minutes=mm)\n    tmp = base_date + td\n    return int(time.mktime(tmp.timetuple()))\n</code></pre>"}, {"location": "API/config/load_factor_curves.html", "title": "Load Factor Curves", "text": ""}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve", "title": "LoadFactorCurve", "text": "<p>             Bases: <code>Named</code></p> <p>LF Curve specifies the load factor at which to close a booking class. This is designed to simulate a naive LCC that really doesn't have automated RM</p> Source code in <code>passengersim/config/load_factor_curves.py</code> <pre><code>class LoadFactorCurve(Named, extra=\"forbid\"):\n    \"\"\"\n    LF Curve specifies the load factor at which to close a booking class.\n    This is designed to simulate a naive LCC that really doesn't have automated RM\n    \"\"\"\n    algorithm: str\n    min_accordion: float\n    max_accordion: float\n    target_load_factor: float\n    convergence_constant: float\n    curve: dict[str, float]\n    \"\"\"Define a Load Factor curve.\n\n    Example\n    -------\n    ```{yaml}\n    - name: lf_curve_1\n      curve:\n        Y0: 1.0\n        Y1: 0.85\n        Y2: 0.75\n    ```\n    \"\"\"\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: str\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.convergence_constant", "title": "convergence_constant  <code>instance-attribute</code>", "text": "<pre><code>convergence_constant: float\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.curve", "title": "curve  <code>instance-attribute</code>", "text": "<pre><code>curve: dict[str, float]\n</code></pre> <p>Define a Load Factor curve.</p>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.curve--example", "title": "Example", "text": "<pre><code>- name: lf_curve_1\n  curve:\n    Y0: 1.0\n    Y1: 0.85\n    Y2: 0.75\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.max_accordion", "title": "max_accordion  <code>instance-attribute</code>", "text": "<pre><code>max_accordion: float\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.min_accordion", "title": "min_accordion  <code>instance-attribute</code>", "text": "<pre><code>min_accordion: float\n</code></pre>"}, {"location": "API/config/load_factor_curves.html#passengersim.config.load_factor_curves.LoadFactorCurve.target_load_factor", "title": "target_load_factor  <code>instance-attribute</code>", "text": "<pre><code>target_load_factor: float\n</code></pre>"}, {"location": "API/config/named.html", "title": "Named", "text": "<p>This module contains utilities for managing named objects.</p>"}, {"location": "API/config/named.html#passengersim.config.named.DictOfNamed", "title": "DictOfNamed  <code>module-attribute</code>", "text": "<pre><code>DictOfNamed = Annotated[\n    dict[str, T], BeforeValidator(enforce_name)\n]\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.T", "title": "T  <code>module-attribute</code>", "text": "<pre><code>T = TypeVar('T', bound=Named)\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.Named", "title": "Named", "text": "<p>             Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/named.py</code> <pre><code>class Named(PrettyModel):\n    name: str\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.Named.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre>"}, {"location": "API/config/named.html#passengersim.config.named.enforce_name", "title": "enforce_name", "text": "<pre><code>enforce_name(x: dict[str, T] | list[T]) -&gt; dict[str, T]\n</code></pre> <p>Enforce that each item has a unique name.</p> <p>If you provide a list, this will ensure that each item in the list has a name. If you provide a dict, the names are given by the keys of the dictionary, and this will ensure that for each value, if it also has an explicitly defined name, that name matches its key-derived name.</p> Source code in <code>passengersim/config/named.py</code> <pre><code>def enforce_name(x: dict[str, T] | list[T]) -&gt; dict[str, T]:\n    \"\"\"Enforce that each item has a unique name.\n\n    If you provide a list, this will ensure that each item in the list has a name.\n    If you provide a dict, the names are given by the keys of the dictionary, and\n    this will ensure that for each value, if it also has an explicitly defined name,\n    that name matches its key-derived name.\n    \"\"\"\n    if isinstance(x, list):\n        x_ = {}\n        for n, i in enumerate(x):\n            k = i.get(\"name\")\n            if k is None:\n                raise ValueError(f\"missing name in position {n}\")\n            x_[k] = i\n        x = x_\n    for k, v in x.items():\n        if \"name\" not in v or not v[\"name\"]:\n            v[\"name\"] = k\n        if v[\"name\"] != k:\n            raise ValueError(\"explict name does not match key\")\n    return x\n</code></pre>"}, {"location": "API/config/outputs.html", "title": "Outputs", "text": ""}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig", "title": "OutputConfig", "text": "<p>             Bases: <code>PrettyModel</code></p> Source code in <code>passengersim/config/outputs.py</code> <pre><code>class OutputConfig(PrettyModel, extra=\"forbid\", validate_assignment=True):\n    log_reports: bool = False\n    \"\"\"Write basic reports directly to the run log.\"\"\"\n\n    excel: pathlib.Path | None = None\n    \"\"\"Write excel outputs to this file after a run.\"\"\"\n\n    reports: set[str | tuple[str, ...]] = {\n        \"fare_class_mix\",\n        \"load_factors\",\n        \"bookings_by_timeframe\",\n        \"total_demand\",\n    }\n    \"\"\"Reports to include.\"\"\"\n</code></pre>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.excel", "title": "excel  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>excel: pathlib.Path | None = None\n</code></pre> <p>Write excel outputs to this file after a run.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.log_reports", "title": "log_reports  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>log_reports: bool = False\n</code></pre> <p>Write basic reports directly to the run log.</p>"}, {"location": "API/config/outputs.html#passengersim.config.outputs.OutputConfig.reports", "title": "reports  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>reports: set[str | tuple[str, ...]] = {\n    \"fare_class_mix\",\n    \"load_factors\",\n    \"bookings_by_timeframe\",\n    \"total_demand\",\n}\n</code></pre> <p>Reports to include.</p>"}, {"location": "API/config/paths.html", "title": "Paths", "text": ""}, {"location": "API/config/paths.html#passengersim.config.paths.Path", "title": "Path", "text": "<p>             Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/paths.py</code> <pre><code>class Path(BaseModel, extra=\"forbid\"):\n    path_id: int | None = None\n    orig: str\n    dest: str\n    path_quality_index: float\n\n    legs: list[int]\n    \"\"\"Flight numbers of legs comprising the path.\"\"\"\n\n    @field_validator(\"legs\", mode=\"before\")\n    def allow_single_leg(cls, v):\n        \"\"\"Allow a single leg path to be just an int not a list of one int.\"\"\"\n        if isinstance(v, int):\n            v = [v]\n        return v\n\n    @field_validator(\"legs\")\n    def at_least_one_leg(cls, v):\n        \"\"\"There must be at least one leg.\"\"\"\n        if len(v) &lt; 1:\n            raise ValueError(\"path must have at least one leg\")\n        return v\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.dest", "title": "dest  <code>instance-attribute</code>", "text": "<pre><code>dest: str\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.legs", "title": "legs  <code>instance-attribute</code>", "text": "<pre><code>legs: list[int]\n</code></pre> <p>Flight numbers of legs comprising the path.</p>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.orig", "title": "orig  <code>instance-attribute</code>", "text": "<pre><code>orig: str\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.path_id", "title": "path_id  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>path_id: int | None = None\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.path_quality_index", "title": "path_quality_index  <code>instance-attribute</code>", "text": "<pre><code>path_quality_index: float\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.allow_single_leg", "title": "allow_single_leg", "text": "<pre><code>allow_single_leg(v)\n</code></pre> <p>Allow a single leg path to be just an int not a list of one int.</p> Source code in <code>passengersim/config/paths.py</code> <pre><code>@field_validator(\"legs\", mode=\"before\")\ndef allow_single_leg(cls, v):\n    \"\"\"Allow a single leg path to be just an int not a list of one int.\"\"\"\n    if isinstance(v, int):\n        v = [v]\n    return v\n</code></pre>"}, {"location": "API/config/paths.html#passengersim.config.paths.Path.at_least_one_leg", "title": "at_least_one_leg", "text": "<pre><code>at_least_one_leg(v)\n</code></pre> <p>There must be at least one leg.</p> Source code in <code>passengersim/config/paths.py</code> <pre><code>@field_validator(\"legs\")\ndef at_least_one_leg(cls, v):\n    \"\"\"There must be at least one leg.\"\"\"\n    if len(v) &lt; 1:\n        raise ValueError(\"path must have at least one leg\")\n    return v\n</code></pre>"}, {"location": "API/config/places.html", "title": "Places", "text": ""}, {"location": "API/config/places.html#passengersim.config.places.Place", "title": "Place", "text": "<p>             Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/places.py</code> <pre><code>class Place(BaseModel, extra=\"forbid\", validate_assignment=True):\n    name: str\n    \"\"\"Identifying code for this place.\n\n    For airports, typically the three letter code.\"\"\"\n\n    label: str\n    \"\"\"A descriptive label for this place.\"\"\"\n\n    lat: float | None = None\n    \"\"\"Latitude in degrees.\"\"\"\n\n    lon: float | None = None\n    \"\"\"Longitude in degrees.\"\"\"\n\n    time_zone: str | None = None\n    \"\"\"\n    The time zone for this location.\n    \"\"\"\n\n    @field_validator(\"time_zone\")\n    def _valid_time_zone(cls, v: str):\n        \"\"\"Check for valid time zones.\"\"\"\n        if isinstance(v, str):\n            ZoneInfo(v)\n        return v\n\n    @property\n    def time_zone_info(self):\n        return ZoneInfo(self.time_zone)\n</code></pre>"}, {"location": "API/config/places.html#passengersim.config.places.Place.label", "title": "label  <code>instance-attribute</code>", "text": "<pre><code>label: str\n</code></pre> <p>A descriptive label for this place.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.lat", "title": "lat  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>lat: float | None = None\n</code></pre> <p>Latitude in degrees.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.lon", "title": "lon  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>lon: float | None = None\n</code></pre> <p>Longitude in degrees.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.name", "title": "name  <code>instance-attribute</code>", "text": "<pre><code>name: str\n</code></pre> <p>Identifying code for this place.</p> <p>For airports, typically the three letter code.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.time_zone", "title": "time_zone  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>time_zone: str | None = None\n</code></pre> <p>The time zone for this location.</p>"}, {"location": "API/config/places.html#passengersim.config.places.Place.time_zone_info", "title": "time_zone_info  <code>property</code>", "text": "<pre><code>time_zone_info\n</code></pre>"}, {"location": "API/config/places.html#passengersim.config.places.great_circle", "title": "great_circle", "text": "<pre><code>great_circle(place1: Place, place2: Place)\n</code></pre> <p>Using Haversine formula, to get distance between points in miles.</p> Source code in <code>passengersim/config/places.py</code> <pre><code>def great_circle(place1: Place, place2: Place):\n    \"\"\"Using Haversine formula, to get distance between points in miles.\"\"\"\n    lon1 = math.radians(place1.lon)\n    lat1 = math.radians(place1.lat)\n    lon2 = math.radians(place2.lon)\n    lat2 = math.radians(place2.lat)\n    lon_diff = lon2 - lon1\n    lat_diff = lat2 - lat1\n    a = math.sin((lat_diff) / 2.0) ** 2.0 + (\n        math.cos(lat1) * math.cos(lat2) * (math.sin((lon_diff) / 2.0) ** 2.0)\n    )\n    angle2 = 2.0 * math.asin(min(1.0, math.sqrt(a)))\n    # Convert back to degrees.\n    angle2 = math.degrees(angle2)\n    # Each degree on a great circle of Earth is 69.0468 miles. ( 60 nautical miles )\n    distance2 = 69.0468 * angle2\n    return distance2\n</code></pre>"}, {"location": "API/config/pretty.html", "title": "Pretty", "text": ""}, {"location": "API/config/pretty.html#passengersim.config.pretty.PrettyModel", "title": "PrettyModel", "text": "<p>             Bases: <code>BaseModel</code></p> <p>Pretty-print as YAML style outputs.</p> Source code in <code>passengersim/config/pretty.py</code> <pre><code>class PrettyModel(BaseModel):\n    \"\"\"Pretty-print as YAML style outputs.\"\"\"\n\n    def __repr_with_indent__(self, indent=0):\n        x = []\n        i = \" \" * indent\n        for k, v in self:\n            try:\n                val = v.__repr_with_indent__(0)\n            except AttributeError:\n                if isinstance(v, dict):\n                    val = repr_dict_with_indent(v, indent)\n                else:\n                    val = repr(v)\n                    if isinstance(v, list) and len(val) &gt; 70:\n                        val = \"- \" + \"\\n- \".join(repr(j) for j in v)\n            if \"\\n\" in val:\n                val_lines = val.split(\"\\n\")\n                val = \"\\n  \" + \"\\n  \".join(val_lines)\n            x.append(f\"{i}{k}: {val}\")\n        return \"\\n\".join(x)\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}:\\n\" + self.__repr_with_indent__(2)\n</code></pre>"}, {"location": "API/config/pretty.html#passengersim.config.pretty.PrettyModel.__repr__", "title": "__repr__", "text": "<pre><code>__repr__()\n</code></pre> Source code in <code>passengersim/config/pretty.py</code> <pre><code>def __repr__(self):\n    return f\"{self.__class__.__name__}:\\n\" + self.__repr_with_indent__(2)\n</code></pre>"}, {"location": "API/config/pretty.html#passengersim.config.pretty.PrettyModel.__repr_with_indent__", "title": "__repr_with_indent__", "text": "<pre><code>__repr_with_indent__(indent=0)\n</code></pre> Source code in <code>passengersim/config/pretty.py</code> <pre><code>def __repr_with_indent__(self, indent=0):\n    x = []\n    i = \" \" * indent\n    for k, v in self:\n        try:\n            val = v.__repr_with_indent__(0)\n        except AttributeError:\n            if isinstance(v, dict):\n                val = repr_dict_with_indent(v, indent)\n            else:\n                val = repr(v)\n                if isinstance(v, list) and len(val) &gt; 70:\n                    val = \"- \" + \"\\n- \".join(repr(j) for j in v)\n        if \"\\n\" in val:\n            val_lines = val.split(\"\\n\")\n            val = \"\\n  \" + \"\\n  \".join(val_lines)\n        x.append(f\"{i}{k}: {val}\")\n    return \"\\n\".join(x)\n</code></pre>"}, {"location": "API/config/pretty.html#passengersim.config.pretty.repr_dict_with_indent", "title": "repr_dict_with_indent", "text": "<pre><code>repr_dict_with_indent(d: dict[str, Any], indent=0)\n</code></pre> Source code in <code>passengersim/config/pretty.py</code> <pre><code>def repr_dict_with_indent(d: dict[str, Any], indent=0):\n    x = []\n    i = \" \" * indent\n    for k, v in d.items():\n        try:\n            val = v.__repr_with_indent__(indent)\n        except AttributeError:\n            if isinstance(v, dict):\n                val = repr_dict_with_indent(v, indent)\n            else:\n                val = repr(v)\n                if isinstance(v, list) and len(val) &gt; 70:\n                    val = \"- \" + \"\\n- \".join(repr(j) for j in v)\n        if \"\\n\" in val:\n            val_lines = val.split(\"\\n\")\n            val = \"\\n  \" + \"\\n  \".join(val_lines)\n        x.append(f\"{i}{k}: {val}\")\n    return \"\\n\".join(x)\n</code></pre>"}, {"location": "API/config/rm_steps.html", "title": "RM Steps", "text": ""}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.DummyStep", "title": "DummyStep", "text": "<p>             Bases: <code>RmStepBase</code></p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>class DummyStep(RmStepBase):\n    step_type: Literal[\"dummy\"]\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.DummyStep.step_type", "title": "step_type  <code>instance-attribute</code>", "text": "<pre><code>step_type: Literal['dummy']\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase", "title": "RmStepBase", "text": "<p>             Bases: <code>BaseModel</code></p> <p>Base class for RmSteps.</p> <p>Every non-abstract derived class must have a <code>step_type</code> class attribute, annotated with a <code>Literal</code> value type.</p> <p>See <code>DummyStep</code> below for an example.</p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>class RmStepBase(BaseModel, extra=\"forbid\"):\n    \"\"\"\n    Base class for RmSteps.\n\n    Every non-abstract derived class must have a `step_type` class attribute,\n    annotated with a `Literal` value type.\n\n    See `DummyStep` below for an example.\n    \"\"\"\n\n    __subclasses: ClassVar[set[type[RmStepBase]]] = set()\n\n    def __init_subclass__(cls, **kwargs):\n        \"\"\"Capture a list of all concrete subclasses, including nested levels\"\"\"\n        super().__init_subclass__(**kwargs)\n\n        if inspect.isabstract(cls):\n            return  # do not consider intermediate abstract base classes\n\n        annotations = inspect.get_annotations(cls, eval_str=True)\n        assert \"step_type\" in annotations, \"step_type not in annotations\"\n        annotation_step_type = typing.get_origin(annotations[\"step_type\"])\n        assert annotation_step_type == Literal, (\n            f\"annotation {annotations['step_type']} for `{cls.__name__}.step_type` \"\n            f\"is not Literal but {annotation_step_type}\"\n        )\n        found_step_type = typing.get_args(annotations[\"step_type\"])[0]\n        if cls.__name__.lower().endswith(\"step\"):\n            assert found_step_type == cls.__name__.lower()[:-4], (\n                f\"annotation Literal value {found_step_type!r} \"\n                f\"for `{cls.__name__}.step_type` is not the same as the class name \"\n                f\"(omitting 'step' suffix)\"\n            )\n        else:\n            assert found_step_type == cls.__name__.lower(), (\n                f\"annotation Literal value {found_step_type!r} \"\n                f\"for `{cls.__name__}.step_type` is not the same as the class name\"\n            )\n        cls.__subclasses.add(cls)\n\n    @classmethod\n    def as_pydantic_field(cls):\n        \"\"\"Pydantic field type as a union of all subclasses, discriminated on step_type.\"\"\"\n        if len(cls.__subclasses) &gt; 1:\n            return Annotated[\n                reduce(operator.__or__, cls.__subclasses),\n                Field(discriminator=\"step_type\"),\n            ]\n        else:  # only the DummyStep\n            return Annotated[reduce(operator.__or__, cls.__subclasses), Field()]\n\n    def _factory(self):\n        \"\"\"Generate a deep copy of this RmStep.\"\"\"\n        return self.model_copy(deep=True)\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase.__subclasses", "title": "__subclasses  <code>class-attribute</code>", "text": "<pre><code>__subclasses: set[type[RmStepBase]] = set()\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase.__init_subclass__", "title": "__init_subclass__", "text": "<pre><code>__init_subclass__(**kwargs)\n</code></pre> <p>Capture a list of all concrete subclasses, including nested levels</p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>def __init_subclass__(cls, **kwargs):\n    \"\"\"Capture a list of all concrete subclasses, including nested levels\"\"\"\n    super().__init_subclass__(**kwargs)\n\n    if inspect.isabstract(cls):\n        return  # do not consider intermediate abstract base classes\n\n    annotations = inspect.get_annotations(cls, eval_str=True)\n    assert \"step_type\" in annotations, \"step_type not in annotations\"\n    annotation_step_type = typing.get_origin(annotations[\"step_type\"])\n    assert annotation_step_type == Literal, (\n        f\"annotation {annotations['step_type']} for `{cls.__name__}.step_type` \"\n        f\"is not Literal but {annotation_step_type}\"\n    )\n    found_step_type = typing.get_args(annotations[\"step_type\"])[0]\n    if cls.__name__.lower().endswith(\"step\"):\n        assert found_step_type == cls.__name__.lower()[:-4], (\n            f\"annotation Literal value {found_step_type!r} \"\n            f\"for `{cls.__name__}.step_type` is not the same as the class name \"\n            f\"(omitting 'step' suffix)\"\n        )\n    else:\n        assert found_step_type == cls.__name__.lower(), (\n            f\"annotation Literal value {found_step_type!r} \"\n            f\"for `{cls.__name__}.step_type` is not the same as the class name\"\n        )\n    cls.__subclasses.add(cls)\n</code></pre>"}, {"location": "API/config/rm_steps.html#passengersim.config.rm_steps.RmStepBase.as_pydantic_field", "title": "as_pydantic_field  <code>classmethod</code>", "text": "<pre><code>as_pydantic_field()\n</code></pre> <p>Pydantic field type as a union of all subclasses, discriminated on step_type.</p> Source code in <code>passengersim/config/rm_steps.py</code> <pre><code>@classmethod\ndef as_pydantic_field(cls):\n    \"\"\"Pydantic field type as a union of all subclasses, discriminated on step_type.\"\"\"\n    if len(cls.__subclasses) &gt; 1:\n        return Annotated[\n            reduce(operator.__or__, cls.__subclasses),\n            Field(discriminator=\"step_type\"),\n        ]\n    else:  # only the DummyStep\n        return Annotated[reduce(operator.__or__, cls.__subclasses), Field()]\n</code></pre>"}, {"location": "API/config/rm_systems.html", "title": "RM Systems", "text": ""}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmProcess", "title": "RmProcess  <code>module-attribute</code>", "text": "<pre><code>RmProcess = list[RmStep]\n</code></pre>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmStep", "title": "RmStep  <code>module-attribute</code>", "text": "<pre><code>RmStep = RmStepBase.as_pydantic_field()\n</code></pre>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem", "title": "RmSystem", "text": "<p>             Bases: <code>Named</code></p> Source code in <code>passengersim/config/rm_systems.py</code> <pre><code>class RmSystem(Named, extra=\"forbid\"):\n    processes: dict[str, RmProcess]\n\n    availability_control: Literal[\"infer\", \"leg\", \"theft\", \"bp\", \"vn\", \"none\"] = \"infer\"\n    \"\"\"Fare class availability algorithm for carriers using this RmSystem.\n\n    The default value will infer the appropriate control based on the steps in the DCP process\n    (This is pending implementation).\n\n    Allowed values include:\n    - \"leg\" (default): Uses leg-based controls.\n    - \"bp\": Bid price controls.\n    - \"vn\": Virtual nesting.\n    - \"none\": No controls.\n    \"\"\"\n\n    @field_validator(\"processes\")\n    @classmethod\n    def _require_dcp_process(cls, value: dict[str, RmProcess]):\n        \"\"\"Ensure that every RmSystem is either empty or has a DCP process.\n\n        This validator also converts all keys to lowercase.\n        \"\"\"\n        lower_value = {k.lower(): v for (k, v) in value.items()}\n        if len(lower_value) and \"dcp\" not in lower_value:\n            raise ValueError(\"Non-empty RmSystem missing a `dcp` process.\")\n        return lower_value\n</code></pre>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem.availability_control", "title": "availability_control  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>availability_control: Literal[\n    \"infer\", \"leg\", \"theft\", \"bp\", \"vn\", \"none\"\n] = \"infer\"\n</code></pre> <p>Fare class availability algorithm for carriers using this RmSystem.</p> <p>The default value will infer the appropriate control based on the steps in the DCP process (This is pending implementation).</p> <p>Allowed values include: - \"leg\" (default): Uses leg-based controls. - \"bp\": Bid price controls. - \"vn\": Virtual nesting. - \"none\": No controls.</p>"}, {"location": "API/config/rm_systems.html#passengersim.config.rm_systems.RmSystem.processes", "title": "processes  <code>instance-attribute</code>", "text": "<pre><code>processes: dict[str, RmProcess]\n</code></pre>"}, {"location": "API/config/snapshot_filter.html", "title": "Snapshot filter", "text": ""}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter", "title": "SnapshotFilter", "text": "<p>             Bases: <code>BaseModel</code></p> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>class SnapshotFilter(BaseModel, validate_assignment=True):\n    type: Literal[\n        \"forecast\", \"leg_untruncation\", \"path_untruncation\", \"rm\", \"pro_bp\", None\n    ] = None\n    title: str = \"\"\n    airline: str = \"\"\n    trial: list[int] = []\n    sample: list[int] = []\n    dcp: list[int] = []\n    orig: list[str] = []\n    dest: list[str] = []\n    flt_no: list[int] = []\n    logger: str | None = None\n    directory: pathlib.Path | None = None\n\n    @field_validator(\"trial\", \"sample\", \"dcp\", \"orig\", \"dest\", \"flt_no\", mode=\"before\")\n    def _allow_singletons(cls, v):\n        \"\"\"Allow a singleton value that is converted to a list of one item.\"\"\"\n        if not isinstance(v, list | tuple):\n            v = [v]\n        return v\n\n    def filepath(self, sim, leg=None, path=None) -&gt; pathlib.Path | None:\n        if self.directory is None:\n            return None\n        pth = self.directory\n        if leg is not None:\n            pth = pth.joinpath(f\"carrier-{leg.carrier}\")\n        pth = pth.joinpath(f\"dpc-{sim.last_dcp}\")\n        if leg is not None:\n            pth = pth.joinpath(f\"orig-{leg.orig}\")\n        elif path is not None:\n            pth = pth.joinpath(f\"orig-{path.orig}\")\n        if leg is not None:\n            pth = pth.joinpath(f\"dest-{leg.dest}\")\n        elif path is not None:\n            pth = pth.joinpath(f\"dest-{path.dest}\")\n        if leg is not None:\n            pth = pth.joinpath(f\"fltno-{leg.flt_no}\")\n        elif path is not None:\n            pth = pth.joinpath(f\"fltno-{path.get_leg_fltno(0)}\")\n        if sim.num_trials &gt; 1:\n            pth = pth.joinpath(f\"trial-{sim.trial}\")\n        pth = pth.joinpath(f\"sample-{sim.sample}\")\n        pth.parent.mkdir(parents=True, exist_ok=True)\n        return pth.with_suffix(\".log\")\n\n    def run(\n        self, sim, leg=None, path=None, carrier=None, why=False\n    ) -&gt; SnapshotInstruction:\n        # Check the filter conditions\n        info = \"\"\n\n        if len(self.trial) &gt; 0 and sim.trial not in self.trial and sim.num_trials &gt; 1:\n            return SnapshotInstruction(False, why=f\"cause {sim.trial=}\")\n        info += f\"  trial={sim.trial}\"\n\n        if len(self.sample) &gt; 0 and sim.sample not in self.sample:\n            return SnapshotInstruction(False, why=f\"cause {sim.sample=}\")\n        info += f\"  sample={sim.sample}\"\n\n        if len(self.dcp) &gt; 0 and sim.last_dcp not in self.dcp:\n            return SnapshotInstruction(False, why=f\"cause {sim.last_dcp=}\")\n        info += f\"  dcp={sim.last_dcp}\"\n\n        if leg is not None:\n            if self.airline and leg.carrier != self.airline:\n                return SnapshotInstruction(False, why=f\"cause {leg.carrier=}\")\n            info += f\"  carrier={leg.carrier}\"\n\n            if len(self.orig) &gt; 0 and leg.orig not in self.orig:\n                return SnapshotInstruction(False, why=f\"cause {leg.orig=}\")\n            info += f\"  orig={leg.orig}\"\n\n            if len(self.dest) &gt; 0 and leg.dest not in self.dest:\n                return SnapshotInstruction(False, why=f\"cause {leg.dest=}\")\n            info += f\"  dest={leg.dest}\"\n\n            if len(self.flt_no) &gt; 0 and leg.flt_no not in self.flt_no:\n                return SnapshotInstruction(False, why=f\"cause {leg.flt_no=}\")\n            info += f\"  flt_no={leg.flt_no}\"\n\n        if path is not None:\n            if len(self.orig) &gt; 0 and path.orig not in self.orig:\n                return SnapshotInstruction(False, why=f\"cause {path.orig=}\")\n            info += f\"  orig={path.orig}\"\n\n            if len(self.dest) &gt; 0 and path.dest not in self.dest:\n                return SnapshotInstruction(False, why=f\"cause {path.dest=}\")\n            info += f\"  dest={path.dest}\"\n\n            if len(self.flt_no) &gt; 0 and path.get_leg_fltno(0) not in self.flt_no:\n                return SnapshotInstruction(False, why=f\"cause {path.get_leg_fltno(0)=}\")\n            info += f\"  flt_no={path.get_leg_fltno(0)}\"\n\n        if carrier is not None:\n            if self.airline and carrier != self.airline:\n                return SnapshotInstruction(False, why=f\"cause {carrier=}\")\n            info += f\"  carrier={carrier}\"\n\n        # Now do something\n        snapshot_file = self.filepath(sim, leg, path)\n        title = f\"{self.title}:{info}\\n{time.strftime('Snapshot created %Y-%m-%d %A %I:%M:%S %p')}\\n\"\n        if len(self.title) &gt; 0 and not snapshot_file:\n            print(f\"{self.title}:{info}\", flush=True)\n\n        self._last_run_info = info\n\n        if self.type in [\"leg_untruncation\", \"path_untruncation\"]:\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type == \"forecast\":\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type == \"rm\":\n            bucket_detail = leg.print_bucket_detail()\n            snapshot_file = self.filepath(sim, leg, path)\n            if snapshot_file:\n                with snapshot_file.open(mode=\"a\") as f:\n                    f.write(title)\n                    f.write(bucket_detail)\n            else:\n                print(bucket_detail)\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n        elif self.type == \"pro_bp\":\n            return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n\n        return SnapshotInstruction(False, why=\"cause unknown\")\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.airline", "title": "airline  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>airline: str = ''\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.dcp", "title": "dcp  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dcp: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.dest", "title": "dest  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>dest: list[str] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.directory", "title": "directory  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>directory: pathlib.Path | None = None\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.flt_no", "title": "flt_no  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>flt_no: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.logger", "title": "logger  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>logger: str | None = None\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.orig", "title": "orig  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>orig: list[str] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.sample", "title": "sample  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>sample: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.title", "title": "title  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>title: str = ''\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.trial", "title": "trial  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>trial: list[int] = []\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.type", "title": "type  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>type: Literal[\n    \"forecast\",\n    \"leg_untruncation\",\n    \"path_untruncation\",\n    \"rm\",\n    \"pro_bp\",\n    None,\n] = None\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.filepath", "title": "filepath", "text": "<pre><code>filepath(sim, leg=None, path=None) -&gt; pathlib.Path | None\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def filepath(self, sim, leg=None, path=None) -&gt; pathlib.Path | None:\n    if self.directory is None:\n        return None\n    pth = self.directory\n    if leg is not None:\n        pth = pth.joinpath(f\"carrier-{leg.carrier}\")\n    pth = pth.joinpath(f\"dpc-{sim.last_dcp}\")\n    if leg is not None:\n        pth = pth.joinpath(f\"orig-{leg.orig}\")\n    elif path is not None:\n        pth = pth.joinpath(f\"orig-{path.orig}\")\n    if leg is not None:\n        pth = pth.joinpath(f\"dest-{leg.dest}\")\n    elif path is not None:\n        pth = pth.joinpath(f\"dest-{path.dest}\")\n    if leg is not None:\n        pth = pth.joinpath(f\"fltno-{leg.flt_no}\")\n    elif path is not None:\n        pth = pth.joinpath(f\"fltno-{path.get_leg_fltno(0)}\")\n    if sim.num_trials &gt; 1:\n        pth = pth.joinpath(f\"trial-{sim.trial}\")\n    pth = pth.joinpath(f\"sample-{sim.sample}\")\n    pth.parent.mkdir(parents=True, exist_ok=True)\n    return pth.with_suffix(\".log\")\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotFilter.run", "title": "run", "text": "<pre><code>run(\n    sim, leg=None, path=None, carrier=None, why=False\n) -&gt; SnapshotInstruction\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def run(\n    self, sim, leg=None, path=None, carrier=None, why=False\n) -&gt; SnapshotInstruction:\n    # Check the filter conditions\n    info = \"\"\n\n    if len(self.trial) &gt; 0 and sim.trial not in self.trial and sim.num_trials &gt; 1:\n        return SnapshotInstruction(False, why=f\"cause {sim.trial=}\")\n    info += f\"  trial={sim.trial}\"\n\n    if len(self.sample) &gt; 0 and sim.sample not in self.sample:\n        return SnapshotInstruction(False, why=f\"cause {sim.sample=}\")\n    info += f\"  sample={sim.sample}\"\n\n    if len(self.dcp) &gt; 0 and sim.last_dcp not in self.dcp:\n        return SnapshotInstruction(False, why=f\"cause {sim.last_dcp=}\")\n    info += f\"  dcp={sim.last_dcp}\"\n\n    if leg is not None:\n        if self.airline and leg.carrier != self.airline:\n            return SnapshotInstruction(False, why=f\"cause {leg.carrier=}\")\n        info += f\"  carrier={leg.carrier}\"\n\n        if len(self.orig) &gt; 0 and leg.orig not in self.orig:\n            return SnapshotInstruction(False, why=f\"cause {leg.orig=}\")\n        info += f\"  orig={leg.orig}\"\n\n        if len(self.dest) &gt; 0 and leg.dest not in self.dest:\n            return SnapshotInstruction(False, why=f\"cause {leg.dest=}\")\n        info += f\"  dest={leg.dest}\"\n\n        if len(self.flt_no) &gt; 0 and leg.flt_no not in self.flt_no:\n            return SnapshotInstruction(False, why=f\"cause {leg.flt_no=}\")\n        info += f\"  flt_no={leg.flt_no}\"\n\n    if path is not None:\n        if len(self.orig) &gt; 0 and path.orig not in self.orig:\n            return SnapshotInstruction(False, why=f\"cause {path.orig=}\")\n        info += f\"  orig={path.orig}\"\n\n        if len(self.dest) &gt; 0 and path.dest not in self.dest:\n            return SnapshotInstruction(False, why=f\"cause {path.dest=}\")\n        info += f\"  dest={path.dest}\"\n\n        if len(self.flt_no) &gt; 0 and path.get_leg_fltno(0) not in self.flt_no:\n            return SnapshotInstruction(False, why=f\"cause {path.get_leg_fltno(0)=}\")\n        info += f\"  flt_no={path.get_leg_fltno(0)}\"\n\n    if carrier is not None:\n        if self.airline and carrier != self.airline:\n            return SnapshotInstruction(False, why=f\"cause {carrier=}\")\n        info += f\"  carrier={carrier}\"\n\n    # Now do something\n    snapshot_file = self.filepath(sim, leg, path)\n    title = f\"{self.title}:{info}\\n{time.strftime('Snapshot created %Y-%m-%d %A %I:%M:%S %p')}\\n\"\n    if len(self.title) &gt; 0 and not snapshot_file:\n        print(f\"{self.title}:{info}\", flush=True)\n\n    self._last_run_info = info\n\n    if self.type in [\"leg_untruncation\", \"path_untruncation\"]:\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type == \"forecast\":\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type == \"rm\":\n        bucket_detail = leg.print_bucket_detail()\n        snapshot_file = self.filepath(sim, leg, path)\n        if snapshot_file:\n            with snapshot_file.open(mode=\"a\") as f:\n                f.write(title)\n                f.write(bucket_detail)\n        else:\n            print(bucket_detail)\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n    elif self.type == \"pro_bp\":\n        return SnapshotInstruction(True, snapshot_file, why=title, filter=self)\n\n    return SnapshotInstruction(False, why=\"cause unknown\")\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction", "title": "SnapshotInstruction", "text": "Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>class SnapshotInstruction:\n    def __init__(\n        self,\n        trigger: bool = False,\n        filepath: pathlib.Path | None = None,\n        why: str | None = None,\n        filter: SnapshotFilter | None = None,\n    ):\n        self.trigger = bool(trigger)\n        \"\"\"Has this snapshot been triggered.\"\"\"\n        self.why = why\n        \"\"\"Explanation of why snapshot is (or is not) triggered.\"\"\"\n        self.filepath = filepath\n        \"\"\"Where to save snapshot content.\"\"\"\n        self.filter = filter\n        \"\"\"A reference to the filter that spawned this instruction.\"\"\"\n\n    def __bool__(self) -&gt; bool:\n        return self.trigger\n\n    def write(self, content: str = \"\"):\n        \"\"\"Write snapshot content to a file, or just print it\"\"\"\n        if self.filepath:\n            with self.filepath.open(mode=\"w\") as f:\n                f.write(self.why)\n                f.write(\"\\n\")\n                if isinstance(content, bytes):\n                    content = content.decode(\"utf-8\")\n                elif not isinstance(content, str):\n                    content = str(content)\n                f.write(content)\n                if content[-1] != \"\\n\":\n                    f.write(\"\\n\")\n        else:\n            if self.why:\n                print(self.why)\n            print(content)\n\n    def write_more(self, content: str = \"\"):\n        \"\"\"Write additional snapshot content to a file, or just print it\"\"\"\n        if self.filepath:\n            with self.filepath.open(mode=\"a\") as f:\n                if isinstance(content, bytes):\n                    content = content.decode(\"utf-8\")\n                elif not isinstance(content, str):\n                    content = str(content)\n                f.write(content)\n                if content[-1] != \"\\n\":\n                    f.write(\"\\n\")\n        else:\n            print(content)\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.filepath", "title": "filepath  <code>instance-attribute</code>", "text": "<pre><code>filepath = filepath\n</code></pre> <p>Where to save snapshot content.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.filter", "title": "filter  <code>instance-attribute</code>", "text": "<pre><code>filter = filter\n</code></pre> <p>A reference to the filter that spawned this instruction.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.trigger", "title": "trigger  <code>instance-attribute</code>", "text": "<pre><code>trigger = bool(trigger)\n</code></pre> <p>Has this snapshot been triggered.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.why", "title": "why  <code>instance-attribute</code>", "text": "<pre><code>why = why\n</code></pre> <p>Explanation of why snapshot is (or is not) triggered.</p>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.__bool__", "title": "__bool__", "text": "<pre><code>__bool__() -&gt; bool\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    return self.trigger\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.__init__", "title": "__init__", "text": "<pre><code>__init__(\n    trigger: bool = False,\n    filepath: pathlib.Path | None = None,\n    why: str | None = None,\n    filter: SnapshotFilter | None = None,\n)\n</code></pre> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def __init__(\n    self,\n    trigger: bool = False,\n    filepath: pathlib.Path | None = None,\n    why: str | None = None,\n    filter: SnapshotFilter | None = None,\n):\n    self.trigger = bool(trigger)\n    \"\"\"Has this snapshot been triggered.\"\"\"\n    self.why = why\n    \"\"\"Explanation of why snapshot is (or is not) triggered.\"\"\"\n    self.filepath = filepath\n    \"\"\"Where to save snapshot content.\"\"\"\n    self.filter = filter\n    \"\"\"A reference to the filter that spawned this instruction.\"\"\"\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.write", "title": "write", "text": "<pre><code>write(content: str = '')\n</code></pre> <p>Write snapshot content to a file, or just print it</p> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def write(self, content: str = \"\"):\n    \"\"\"Write snapshot content to a file, or just print it\"\"\"\n    if self.filepath:\n        with self.filepath.open(mode=\"w\") as f:\n            f.write(self.why)\n            f.write(\"\\n\")\n            if isinstance(content, bytes):\n                content = content.decode(\"utf-8\")\n            elif not isinstance(content, str):\n                content = str(content)\n            f.write(content)\n            if content[-1] != \"\\n\":\n                f.write(\"\\n\")\n    else:\n        if self.why:\n            print(self.why)\n        print(content)\n</code></pre>"}, {"location": "API/config/snapshot_filter.html#passengersim.config.snapshot_filter.SnapshotInstruction.write_more", "title": "write_more", "text": "<pre><code>write_more(content: str = '')\n</code></pre> <p>Write additional snapshot content to a file, or just print it</p> Source code in <code>passengersim/config/snapshot_filter.py</code> <pre><code>def write_more(self, content: str = \"\"):\n    \"\"\"Write additional snapshot content to a file, or just print it\"\"\"\n    if self.filepath:\n        with self.filepath.open(mode=\"a\") as f:\n            if isinstance(content, bytes):\n                content = content.decode(\"utf-8\")\n            elif not isinstance(content, str):\n                content = str(content)\n            f.write(content)\n            if content[-1] != \"\\n\":\n                f.write(\"\\n\")\n    else:\n        print(content)\n</code></pre>"}, {"location": "Tutorials/index.html", "title": "Tutorials", "text": "<p>This section includes some tutorials to demonstrate some of the capabilities of PassengerSim.  These examples are built upon a very simple three market network with two airlines.  Each airline offers a pair of flights from BOS to ORD, and another pair from ORD to LAX.  Passenger demands are constructed for each single-leg market, as well as for the connecting market BOS-LAX.</p>"}, {"location": "Tutorials/3MKT/3mkt-01.nbconvert.html", "title": "Simple FCFS", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.16.2\npassengersim.core 0.16.1\n</pre> <p>This example uses network/01-base.yaml configuration file. Within a Jupyter notebook, we can directly initialize a PassengerSim <code>Simulation</code> instance from this file using the <code>from_yaml</code> class constructor:</p> In\u00a0[2]: Copied! <pre>sim = pax.Simulation.from_yaml(\"network/01-base.yaml\")\n</pre> sim = pax.Simulation.from_yaml(\"network/01-base.yaml\") <p>Running the simulation is as simple as calling the <code>run</code> command, which runs the simulation and returns a summary output object.</p> In\u00a0[3]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 19.44 seconds\n</pre> <p>The contents of the final summary is controlled by <code>Config.outputs.reports</code>, which allows the user to add reports for more detail, or drop some unneccessary reports to improve runtime (sometimes substantially).</p> In\u00a0[4]: Copied! <pre>sim.config.outputs.reports\n</pre> sim.config.outputs.reports Out[4]: <pre>{'bookings_by_timeframe',\n 'carrier_history',\n 'demand_to_come',\n 'fare_class_mix',\n 'leg_forecasts',\n 'load_factors',\n 'total_demand'}</pre> <p>For this example, several default reports are included, which allows us to access a number of pre-packaged visualizations for the results.</p> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_carrier_mileage()\n</pre> summary.fig_carrier_mileage() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[8]: <p>All demand is in the lowest fare class, because the simulation has no restrictions against customers simply buying the least expensive fare.</p> In\u00a0[9]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[9]: <p>We are not limited to the pre-packaged visualizations. The various summary tables available in the <code>summary</code> object are all just regular pandas DataFrames, so we can use all the usual Python and Pandas tools for analysis. For example, the <code>demand_to_come</code> table summarizes the total demand to come at each timeframe for every simulation sample.</p> In\u00a0[10]: Copied! <pre>summary.demand_to_come\n</pre> summary.demand_to_come Out[10]: rrd 63 56 49 42 35 31 28 24 21 17 14 10 7 5 3 1 0 iteration trial sample segment orig dest 0 0 100 business BOS LAX 65 61 57 55 51 51 49 48 42 39 39 31 25 19 14 4 0 ORD 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ORD LAX 68 63 59 59 54 52 50 48 47 44 36 32 25 20 16 4 0 leisure BOS LAX 71 58 56 49 43 39 35 30 28 21 16 12 7 7 4 1 0 ORD 49 43 39 34 32 31 27 24 19 15 13 11 11 10 6 1 0 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 9 499 business BOS ORD 66 62 55 52 50 48 46 44 42 39 36 26 21 17 9 3 0 ORD LAX 129 115 106 101 97 96 92 88 83 78 70 60 43 32 22 8 0 leisure BOS LAX 131 107 97 84 71 67 63 50 42 32 24 16 12 9 5 0 0 ORD 96 87 85 76 63 52 47 39 35 29 22 16 13 10 5 4 0 ORD LAX 156 128 117 105 85 75 72 57 46 33 28 20 15 11 6 3 0 <p>24000 rows \u00d7 17 columns</p> <p>With this data, we can do whatever analysis we like.  Here we'll compute the correlation between total demands (from the beginning of the booking curve at DCP 63 all the way to the end) of different passenger types in different markets.</p> In\u00a0[11]: Copied! <pre>summary.demand_to_come[63].unstack([\"segment\", \"orig\", \"dest\"]).corr()\n</pre> summary.demand_to_come[63].unstack([\"segment\", \"orig\", \"dest\"]).corr() Out[11]: segment business leisure orig BOS ORD BOS ORD dest LAX ORD LAX LAX ORD LAX segment orig dest business BOS LAX 1.000000 0.111814 0.146455 0.363078 0.122181 0.107158 ORD 0.111814 1.000000 0.102067 0.106161 0.327514 0.104558 ORD LAX 0.146455 0.102067 1.000000 0.144507 0.115454 0.352284 leisure BOS LAX 0.363078 0.106161 0.144507 1.000000 0.125014 0.105721 ORD 0.122181 0.327514 0.115454 0.125014 1.000000 0.103329 ORD LAX 0.107158 0.104558 0.352284 0.105721 0.103329 1.000000 <p>The <code>summary</code> object also has a command to dump all the summary tables to an Excel workbook, if you prefer to analyze the results there instead of in Jupyter.</p> In\u00a0[12]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-01.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-01.xlsx\") <p>Download 3mkt-01.xlsx</p> In\u00a0[13]: Copied! <pre>import targets\n\ntarget = targets.load(1, sim.config)\n</pre> import targets  target = targets.load(1, sim.config) In\u00a0[14]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[15]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=False, by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=False, by_class=True) Out[17]: <p>We can look at carrier forecasts of demand on individual legs.</p> In\u00a0[18]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=111, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=111, of=[\"mu\", \"sigma\"]) Out[18]: <p>We can compare the mean and standard deviation of demand to come.</p> In\u00a0[19]: Copied! <pre>comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\") Out[19]: <p>We can even take arbitrary functions that apply pandas tools, and have them run automatically against multiple summary objects. For example, we can look at the variance-covariance matrix of aggregate demand by passenger type, and compare those matrices for both the simulation and the target.</p> In\u00a0[20]: Copied! <pre>comps.apply(lambda s: s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov())\n</pre> comps.apply(lambda s: s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov()) Out[20]: segment business leisure source segment simulation business 3279.856113 1981.353347 leisure 1981.353347 5382.230033 target business 3249.598992 1955.419868 leisure 1955.419868 5359.555328"}, {"location": "Tutorials/3MKT/3mkt-01.nbconvert.html#simple-fcfs", "title": "Simple FCFS\u00b6", "text": "<p>This is a very simple network, with only 3 markets, used to demonstrate some features of PassengerSim.</p>"}, {"location": "Tutorials/3MKT/3mkt-01.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": "<p>In addition to summary reports for a single run, we can also use PassengerSim's <code>contrast</code> package to compare simulation runs to each other, or against exogenously defined target results.</p>"}, {"location": "Tutorials/3MKT/3mkt-02.nbconvert.html", "title": "FCFS with Product Restrictions", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.16.2\npassengersim.core 0.16.1\n</pre> <p>This example adds the network/02-buyup.yaml configuration file, to enable the product restrictions.</p> In\u00a0[2]: Copied! <pre>cfg = pax.Config.from_yaml([\"network/01-base.yaml\", \"network/02-buyup.yaml\"])\n</pre> cfg = pax.Config.from_yaml([\"network/01-base.yaml\", \"network/02-buyup.yaml\"]) <p>The configuration can be manipulated in Python after loading.  This allows for a more interactive experience, where individual input values can readily be altered for a given analysis.</p> In\u00a0[3]: Copied! <pre>cfg.simulation_controls.num_trials = 4\n</pre> cfg.simulation_controls.num_trials = 4 <p>After all the desired changes have been completed, we use the <code>Config</code> to initialize the <code>Simulation</code>.</p> In\u00a0[4]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[5]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 9.26 seconds\n</pre> In\u00a0[6]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[9]: In\u00a0[10]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-02.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-02.xlsx\") <p>Download 3mkt-02.xlsx</p> In\u00a0[11]: Copied! <pre>import targets\n\ntarget = targets.load(2, cfg)\n</pre> import targets  target = targets.load(2, cfg) In\u00a0[12]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[13]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=111)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=111) Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=111, agg_booking_classes=True)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=111, agg_booking_classes=True) Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=101)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=101) Out[19]:"}, {"location": "Tutorials/3MKT/3mkt-02.nbconvert.html#fcfs-with-product-restrictions", "title": "FCFS with Product Restrictions\u00b6", "text": "<p>In this example, we add product restrictions to the simulation.  These restrictions will cause some passengers to \"buy up\" to a fare product other than the lowest price.</p>"}, {"location": "Tutorials/3MKT/3mkt-02.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-03.nbconvert.html", "title": "FCFS with AP and Product Restrictions", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.16.2\npassengersim.core 0.16.1\n</pre> <p>In prior examples, the configuration were given in one or more external file, passed to the <code>from_yaml</code> constructor as arguments.  We can also craft multi-line yaml content directly in a Python string, and pass that directly to the same contructor.  Here, we will turn the <code>disable_ap</code> switch off, and add a snapshot filter.</p> In\u00a0[2]: Copied! <pre>with_AP = \"\"\"\nsimulation_controls:\n  disable_ap: false\n\nsnapshot_filters:\n- type: leg_untruncation\n  airline: AL1\n  sample: 400\n  flt_no: 101\n  directory: snapshots/em\n\"\"\"\n</pre> with_AP = \"\"\" simulation_controls:   disable_ap: false  snapshot_filters: - type: leg_untruncation   airline: AL1   sample: 400   flt_no: 101   directory: snapshots/em \"\"\" <p>Snapshot filters can be triggered at limited specific points within a large simulation, and they will write out details intermediate results for that specific point.  The example snapshot filter here will provide extra output into the leg untruncation for a single flight on a single sample in the simulation.  Storing this level of detail for every flight for every sample would generally be gratuitous, slowing the simulation significantly and writing out excessively large files, but the snapshots give the ability to see and explore details from deep inside the simulation.</p> In\u00a0[3]: Copied! <pre>cfg = pax.Config.from_yaml([\n    \"network/01-base.yaml\", \n    \"network/02-buyup.yaml\", \n    with_AP\n])\n</pre> cfg = pax.Config.from_yaml([     \"network/01-base.yaml\",      \"network/02-buyup.yaml\",      with_AP ]) In\u00a0[4]: Copied! <pre>cfg.simulation_controls.num_trials = 4\n</pre> cfg.simulation_controls.num_trials = 4 In\u00a0[5]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[6]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 8.51 seconds\n</pre> In\u00a0[7]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[10]: In\u00a0[11]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-03.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-03.xlsx\") <p>Download 3mkt-03.xlsx</p> In\u00a0[12]: Copied! <pre>import targets\n\ntarget = targets.load(3, cfg)\n</pre> import targets  target = targets.load(3, cfg) In\u00a0[13]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[14]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=101)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=101) Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=111)\n</pre> comps.fig_leg_forecasts(of=[\"mu\", \"sigma\"], by_flt_no=111) Out[19]: In\u00a0[20]: Copied! <pre>contrast.fig_leg_forecasts(comps, of=[\"mu\", \"sigma\"], by_flt_no=101, agg_booking_classes=True)\n</pre> contrast.fig_leg_forecasts(comps, of=[\"mu\", \"sigma\"], by_flt_no=101, agg_booking_classes=True) Out[20]:"}, {"location": "Tutorials/3MKT/3mkt-03.nbconvert.html#fcfs-with-ap-and-product-restrictions", "title": "FCFS with AP and Product Restrictions\u00b6", "text": "<p>In this example, on top of product restrictions we also add advance purchase (AP) restrictions to the simulation.  These restrictions close lower priced fare class products as the day of departure approaches.</p> <p>In this example, we will also demostrate adding yaml configuration content in a Jupyter notebook before loading configs, and adding a snapshot filter to the simulation.</p>"}, {"location": "Tutorials/3MKT/3mkt-03.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-04.nbconvert.html", "title": "EMSR-B with Low Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.16.2\npassengersim.core 0.16.1\n</pre> <p>The yaml file for this example contains an explicit <code>include</code> instruction directly in the file. This emulates calling multiple file names in the <code>from_yaml</code> command, but the other file references are written directly into the code, so that groups of configurations can be managed together easily, without necessarily needing the user to carefully assemble the correct set of filenames every time they run the simulation.</p> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\nshow_file(\"network/04-emsrb-low-demand.yaml\")\n</pre> from passengersim.utils.codeview import show_file show_file(\"network/04-emsrb-low-demand.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 0.5\n\nairlines:\n  - name: AL1\n    rm_system: rm_no_detruncation\n  - name: AL2\n    rm_system: rm_no_detruncation\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml([\n    \"network/04-emsrb-low-demand.yaml\",\n])\n</pre> sim = pax.Simulation.from_yaml([     \"network/04-emsrb-low-demand.yaml\", ]) In\u00a0[4]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 17.26 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-04.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-04.xlsx\") <p>Download 3mkt-04.xlsx</p> In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(4, sim.config)\n</pre> import targets  target = targets.load(4, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[12]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[12]: In\u00a0[13]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[15]:"}, {"location": "Tutorials/3MKT/3mkt-04.nbconvert.html#emsr-b-with-low-demand", "title": "EMSR-B with Low Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Demand is simulated at a level 50% lower than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-04.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-05.nbconvert.html", "title": "EMSR-B", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.16.2\npassengersim.core 0.16.1\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\nshow_file(\"network/05-emsrb.yaml\")\n</pre> from passengersim.utils.codeview import show_file show_file(\"network/05-emsrb.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.0\n\nairlines:\n  - name: AL1\n    rm_system: rm_no_detruncation\n  - name: AL2\n    rm_system: rm_no_detruncation\n\ndb:\n  write_items:\n    - leg_final\n    - fare_final\n    - demand_final\n    - bookings\n    - bucket\n\noutputs:\n  reports:\n    - leg_forecasts\n    - fare_class_mix\n    - load_factors\n    - bookings_by_timeframe\n    - total_demand\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml([\n    \"network/05-emsrb.yaml\",\n])\n</pre> sim = pax.Simulation.from_yaml([     \"network/05-emsrb.yaml\", ]) In\u00a0[4]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 14.28 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-05.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-05.xlsx\") In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(5, sim.config)\n</pre> import targets  target = targets.load(5, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[12]: Copied! <pre>contrast.fig_carrier_revenues(comps)\n</pre> contrast.fig_carrier_revenues(comps) Out[12]: In\u00a0[13]: Copied! <pre>contrast.fig_carrier_load_factors(comps)\n</pre> contrast.fig_carrier_load_factors(comps) Out[13]: In\u00a0[14]: Copied! <pre>contrast.fig_fare_class_mix(comps)\n</pre> contrast.fig_fare_class_mix(comps) Out[14]: In\u00a0[15]: Copied! <pre>contrast.fig_leg_forecasts(comps, by_flt_no=101)\n</pre> contrast.fig_leg_forecasts(comps, by_flt_no=101) Out[15]: In\u00a0[16]: Copied! <pre>contrast.fig_leg_forecasts(comps, by_flt_no=111, of=[\"mu\", \"sigma\"])\n</pre> contrast.fig_leg_forecasts(comps, by_flt_no=111, of=[\"mu\", \"sigma\"]) Out[16]: In\u00a0[17]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_class=True, by_carrier=\"AL1\")\n</pre> contrast.fig_bookings_by_timeframe(comps, by_class=True, by_carrier=\"AL1\") Out[17]:"}, {"location": "Tutorials/3MKT/3mkt-05.nbconvert.html#emsr-b", "title": "EMSR-B\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Demand is simulated at normal levels.</p>"}, {"location": "Tutorials/3MKT/3mkt-05.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-06.nbconvert.html", "title": "EMSR-B with High Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.16.2\npassengersim.core 0.16.1\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\nshow_file(\"network/06-emsrb-high-demand.yaml\")\n</pre> from passengersim.utils.codeview import show_file show_file(\"network/06-emsrb-high-demand.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.1\n\nairlines:\n  - name: AL1\n    rm_system: rm_no_detruncation\n  - name: AL2\n    rm_system: rm_no_detruncation\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml([\n    \"network/06-emsrb-high-demand.yaml\",\n])\n</pre> sim = pax.Simulation.from_yaml([     \"network/06-emsrb-high-demand.yaml\", ]) In\u00a0[4]: Copied! <pre>summary = sim.run(log_reports=False)\n</pre> summary = sim.run(log_reports=False) <pre></pre> <pre>\n</pre> <pre>Task Completed after 19.91 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-06.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-06.xlsx\") In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(6, sim.config)\n</pre> import targets  target = targets.load(6, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[12]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[12]: In\u00a0[13]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[13]: In\u00a0[14]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"]) Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=211, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=211, of=[\"mu\", \"sigma\"]) Out[17]:"}, {"location": "Tutorials/3MKT/3mkt-06.nbconvert.html#emsr-b-with-high-demand", "title": "EMSR-B with High Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Demand is simulated at a level 10% higher than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-06.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-07.nbconvert.html", "title": "EM Untruncation with Low Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.16.2\npassengersim.core 0.16.1\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\nshow_file(\"network/07-untrunc-em-low-demand.yaml\")\n</pre> from passengersim.utils.codeview import show_file show_file(\"network/07-untrunc-em-low-demand.yaml\") <pre>include:\n  - 08-untrunc-em.yaml\n\nsimulation_controls:\n  demand_multiplier: 0.5\n</pre> In\u00a0[3]: Copied! <pre>sim = pax.Simulation.from_yaml([\n    \"network/07-untrunc-em-low-demand.yaml\",\n])\n</pre> sim = pax.Simulation.from_yaml([     \"network/07-untrunc-em-low-demand.yaml\", ]) In\u00a0[4]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 18.26 seconds\n</pre> In\u00a0[5]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[8]: In\u00a0[9]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-07.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-07.xlsx\") In\u00a0[10]: Copied! <pre>import targets\n\ntarget = targets.load(7, sim.config)\n</pre> import targets  target = targets.load(7, sim.config) In\u00a0[11]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[12]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\")\n</pre> contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\") Out[12]: In\u00a0[13]: Copied! <pre>contrast.fig_carrier_revenues(comps)\n</pre> contrast.fig_carrier_revenues(comps) Out[13]: In\u00a0[14]: Copied! <pre>contrast.fig_fare_class_mix(comps)\n</pre> contrast.fig_fare_class_mix(comps) Out[14]: In\u00a0[15]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\", by_class=True)\n</pre> contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\", by_class=True) Out[15]:"}, {"location": "Tutorials/3MKT/3mkt-07.nbconvert.html#em-untruncation-with-low-demand", "title": "EM Untruncation with Low Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Additionally, the EM algorithm is employed to detruncate censored demand. Demand is simulated at a level 50% lower than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-07.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-08.nbconvert.html", "title": "EM Untruncation", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.16.2\npassengersim.core 0.16.1\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/08-untrunc-em.yaml\")\n</pre> show_file(\"network/08-untrunc-em.yaml\") <pre>include:\n  - 01-base.yaml\n  - 02-buyup.yaml\n  - 03-ap.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.0\n\nrm_systems:\n  rm_test1:\n    availability_control: leg\n    processes:\n      DCP:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        name: forecast\n        algorithm: additive_pickup\n        alpha: 0.15\n        kind: leg\n      - step_type: emsr\n        name: optimization\n        algorithm: emsrb\n        kind: leg\n\nairlines:\n  - name: AL1\n    rm_system: rm_test1\n  - name: AL2\n    rm_system: rm_test1\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml([\n    \"network/08-untrunc-em.yaml\",\n])\n</pre> cfg = pax.Config.from_yaml([     \"network/08-untrunc-em.yaml\", ]) In\u00a0[5]: Copied! <pre>cfg.simulation_controls.num_trials = 6\n</pre> cfg.simulation_controls.num_trials = 6 In\u00a0[6]: Copied! <pre>cfg.outputs.reports.add(\"local_and_flow_yields\")\n</pre> cfg.outputs.reports.add(\"local_and_flow_yields\") In\u00a0[7]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[8]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 13.01 seconds\n</pre> In\u00a0[9]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[11]: In\u00a0[12]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[12]: In\u00a0[13]: Copied! <pre>summary.local_and_flow_yields\n</pre> summary.local_and_flow_yields Out[13]: flt_no carrier orig dest capacity distance local_yield local_fraction flow_yield 0 101 AL1 BOS ORD 100 863.753282 0.228001 0.420964 0.160534 1 102 AL1 BOS ORD 100 863.753282 0.228167 0.418236 0.161452 2 111 AL1 ORD LAX 120 1739.799337 0.176072 0.547242 0.160534 3 112 AL1 ORD LAX 120 1739.799337 0.175771 0.546325 0.161452 4 201 AL2 BOS ORD 100 863.753282 0.228358 0.419200 0.161371 5 202 AL2 BOS ORD 100 863.753282 0.227649 0.418352 0.160918 6 211 AL2 ORD LAX 120 1739.799337 0.176223 0.545831 0.161371 7 212 AL2 ORD LAX 120 1739.799337 0.176275 0.546105 0.160918 In\u00a0[14]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-08.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-08.xlsx\") In\u00a0[15]: Copied! <pre>import targets\ntarget = targets.load(8, cfg)\n</pre> import targets target = targets.load(8, cfg) In\u00a0[16]: Copied! <pre>from passengersim import contrast\n</pre> from passengersim import contrast In\u00a0[17]: Copied! <pre>comps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[18]: Copied! <pre>comps.fig_demand_to_come(\"mean\")\n</pre> comps.fig_demand_to_come(\"mean\") Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"std\") Out[19]: In\u00a0[20]: Copied! <pre>comps.apply(\n    lambda s: (\n        s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov()\n    )\n)\n</pre> comps.apply(     lambda s: (         s.aggregate_demand_history(by_segment=True).unstack(\"segment\").cov()     ) ) Out[20]: segment business leisure source segment simulation business 3263.099012 1976.758878 leisure 1976.758878 5291.913397 target business 3249.598992 1955.419868 leisure 1955.419868 5359.555328 In\u00a0[21]: Copied! <pre>contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\",  by_class=True)\n</pre> contrast.fig_bookings_by_timeframe(comps, by_carrier=\"AL1\",  by_class=True) Out[21]: In\u00a0[22]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[22]: In\u00a0[23]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[23]: In\u00a0[24]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[24]: In\u00a0[25]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[25]: In\u00a0[26]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"]) Out[26]: In\u00a0[27]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"]) Out[27]: In\u00a0[28]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=111, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=111, of=[\"mu\", \"sigma\"]) Out[28]:"}, {"location": "Tutorials/3MKT/3mkt-08.nbconvert.html#em-untruncation", "title": "EM Untruncation\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Additionally, the EM algorithm is employed to detruncate censored demand. Demand is simulated at normal levels.</p>"}, {"location": "Tutorials/3MKT/3mkt-08.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-09.nbconvert.html", "title": "EM Untruncation with High Demand", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.16.2\npassengersim.core 0.16.1\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/09-untrunc-em-high-demand.yaml\")\n</pre> show_file(\"network/09-untrunc-em-high-demand.yaml\") <pre>include:\n  - 08-untrunc-em.yaml\n\nsimulation_controls:\n  demand_multiplier: 1.1\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml([\n    \"network/09-untrunc-em-high-demand.yaml\",\n])\n</pre> cfg = pax.Config.from_yaml([     \"network/09-untrunc-em-high-demand.yaml\", ]) In\u00a0[5]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[6]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() <pre></pre> <pre>\n</pre> <pre>Task Completed after 22.73 seconds\n</pre> In\u00a0[7]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[7]: In\u00a0[8]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[10]: In\u00a0[11]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-09.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-09.xlsx\") In\u00a0[12]: Copied! <pre>import targets\n\ntarget = targets.load(9, cfg)\n</pre> import targets  target = targets.load(9, cfg) In\u00a0[13]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[14]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[14]: In\u00a0[15]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True) Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=False, by_class=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=False, by_class=True) Out[19]: In\u00a0[20]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=101, of=[\"mu\", \"sigma\"]) Out[20]: In\u00a0[21]: Copied! <pre>comps.fig_leg_forecasts(by_flt_no=111, of=[\"mu\", \"sigma\"])\n</pre> comps.fig_leg_forecasts(by_flt_no=111, of=[\"mu\", \"sigma\"]) Out[21]: In\u00a0[22]: Copied! <pre>from passengersim.utils.targets import computed_targets\n\nc_targets = computed_targets(cfg)\n</pre> from passengersim.utils.targets import computed_targets  c_targets = computed_targets(cfg) In\u00a0[23]: Copied! <pre>contrast.fig_bookings_by_timeframe({\n    \"c_targets\": c_targets,\n    \"simulation\": summary,\n    \"target\": target,\n}, by_carrier=False, by_class=True)\n</pre> contrast.fig_bookings_by_timeframe({     \"c_targets\": c_targets,     \"simulation\": summary,     \"target\": target, }, by_carrier=False, by_class=True) Out[23]:"}, {"location": "Tutorials/3MKT/3mkt-09.nbconvert.html#em-untruncation-with-high-demand", "title": "EM Untruncation with High Demand\u00b6", "text": "<p>In this example, we include product and advance purchase (AP) restrictions in the simulation, and have each airline use the leg-based EMSR-B algorithm to manage revenue.  Additionally, the EM algorithm is employed to detruncate censored demand. Demand is simulated at a level 10% higher than normal.</p>"}, {"location": "Tutorials/3MKT/3mkt-09.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-10.nbconvert.html", "title": "ProBP", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.16.2\npassengersim.core 0.16.1\n</pre> In\u00a0[2]: Copied! <pre>from passengersim.utils.codeview import show_file\n</pre> from passengersim.utils.codeview import show_file In\u00a0[3]: Copied! <pre>show_file(\"network/10-probp.yaml\")\n</pre> show_file(\"network/10-probp.yaml\") <pre>include:\n  - 08-untrunc-em.yaml\n\nscenario: 3MKTproBP\n\ndb:\n  write_items:\n    - leg_final\n    - fare_final\n    - demand_final\n    - bookings\n    - bucket\n    - pathclass\n    - leg\n    - demand\n\nsimulation_controls:\n  num_trials: 4 # 10\n  show_progress_bar: false\n\nrm_systems:\n  rm_probp:\n    availability_control: bp\n    processes:\n      DCP:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: em\n        kind: path\n      - step_type: forecast\n        name: path_forecast\n        algorithm: additive_pickup\n        kind: path\n      - step_type: probp\n        name: optimization\n      - step_type: aggregation  # not needed for algorithm, but gives leg forecast data for output\n        name: aggregate\n\nairlines:\n  - name: AL1\n    rm_system: rm_probp\n  - name: AL2\n    rm_system: rm_probp\n\nsnapshot_filters:\n   - type: pro_bp\n     title: ProBP Snapshot\n     sample: [120, 290, 499]\n     dcp: [63, 56, 21]\n     flt_no: 111\n     airline: AL1\n     directory: snapshots/probp\n\noutputs:\n  reports:\n    - fare_class_mix\n    - load_factors\n    - bookings_by_timeframe\n    - total_demand\n    - leg_forecasts\n    - path_forecasts\n    - [od_fare_class_mix, BOS, ORD]\n    - [od_fare_class_mix, BOS, LAX]\n    - [od_fare_class_mix, ORD, LAX]\n    - demand_to_come\n    - carrier_history\n    - bid_price_history\n</pre> In\u00a0[4]: Copied! <pre>cfg = pax.Config.from_yaml([\n    \"network/10-probp.yaml\",\n])\n</pre> cfg = pax.Config.from_yaml([     \"network/10-probp.yaml\", ]) In\u00a0[5]: Copied! <pre>cfg.simulation_controls.num_trials = 6\n</pre> cfg.simulation_controls.num_trials = 6 In\u00a0[6]: Copied! <pre>sim = pax.Simulation(cfg)\n</pre> sim = pax.Simulation(cfg) In\u00a0[7]: Copied! <pre>summary = sim.run()\n</pre> summary = sim.run() In\u00a0[8]: Copied! <pre>summary.fig_carrier_revenues()\n</pre> summary.fig_carrier_revenues() Out[8]: In\u00a0[9]: Copied! <pre>summary.fig_carrier_load_factors()\n</pre> summary.fig_carrier_load_factors() Out[9]: In\u00a0[10]: Copied! <pre>summary.fig_fare_class_mix()\n</pre> summary.fig_fare_class_mix() Out[10]: In\u00a0[11]: Copied! <pre>summary.fig_bookings_by_timeframe()\n</pre> summary.fig_bookings_by_timeframe() Out[11]: In\u00a0[12]: Copied! <pre>summary.to_xlsx(\"outputs/3mkt-10.xlsx\")\n</pre> summary.to_xlsx(\"outputs/3mkt-10.xlsx\") In\u00a0[13]: Copied! <pre>import targets\n\ntarget = targets.load(10, cfg)\n</pre> import targets  target = targets.load(10, cfg) In\u00a0[14]: Copied! <pre>from passengersim import contrast\n\ncomps = contrast.Contrast({\n    \"simulation\": summary,\n    \"target\": target,\n})\n</pre> from passengersim import contrast  comps = contrast.Contrast({     \"simulation\": summary,     \"target\": target, }) In\u00a0[15]: Copied! <pre>comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\")\n</pre> comps.fig_demand_to_come(\"mean\") | comps.fig_demand_to_come(\"std\") Out[15]: In\u00a0[16]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\")\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\") Out[16]: In\u00a0[17]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[17]: In\u00a0[18]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[18]: In\u00a0[19]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[19]: In\u00a0[20]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True, source_labels=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True, source_labels=True) Out[20]: In\u00a0[21]: Copied! <pre>print(sim.path_names()[1])\ncomps.fig_path_forecasts(by_path_id=1, of=['mu', 'sigma', 'closed'])\n</pre> print(sim.path_names()[1]) comps.fig_path_forecasts(by_path_id=1, of=['mu', 'sigma', 'closed']) <pre>Path: BOS ORD (AL1:101 BOS-ORD)\n</pre> Out[21]: In\u00a0[22]: Copied! <pre>print(sim.path_names()[5])\ncomps.fig_path_forecasts(by_path_id=5, of=['mu', 'sigma', 'closed'])\n</pre> print(sim.path_names()[5]) comps.fig_path_forecasts(by_path_id=5, of=['mu', 'sigma', 'closed']) <pre>Path: ORD LAX (AL1:111 ORD-LAX)\n</pre> Out[22]: In\u00a0[23]: Copied! <pre>print(sim.path_names()[9])\ncomps.fig_path_forecasts(by_path_id=9, of=['mu', 'sigma', 'closed'])\n</pre> print(sim.path_names()[9]) comps.fig_path_forecasts(by_path_id=9, of=['mu', 'sigma', 'closed']) <pre>Path: BOS LAX (AL1:101 BOS-ORD, AL1:111 ORD-LAX)\n</pre> Out[23]: In\u00a0[24]: Copied! <pre>comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\")\n</pre> comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\") Out[24]: In\u00a0[25]: Copied! <pre>comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\", show_stdev=1)\n</pre> comps.fig_bid_price_history(by_carrier=\"AL1\", cap=\"some\", show_stdev=1) Out[25]: In\u00a0[26]: Copied! <pre>from passengersim.extra.forecast_viz import fig_forecasts_and_bid_prices\n</pre> from passengersim.extra.forecast_viz import fig_forecasts_and_bid_prices In\u00a0[27]: Copied! <pre>fig_forecasts_and_bid_prices(\n    sim,\n    trial = 0,\n    rrd = 63,\n    flt_no = 111,\n)\n</pre> fig_forecasts_and_bid_prices(     sim,     trial = 0,     rrd = 63,     flt_no = 111, ) Out[27]: In\u00a0[28]: Copied! <pre>fig_forecasts_and_bid_prices(\n    sim,\n    trial = 0,\n    rrd = 63,\n    flt_no = 101,\n)\n</pre> fig_forecasts_and_bid_prices(     sim,     trial = 0,     rrd = 63,     flt_no = 101, ) Out[28]:"}, {"location": "Tutorials/3MKT/3mkt-10.nbconvert.html#probp", "title": "ProBP\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-10.nbconvert.html#comparing-against-targets", "title": "Comparing against Targets\u00b6", "text": ""}, {"location": "Tutorials/3MKT/3mkt-98.nbconvert.html", "title": "Retrospective Analysis", "text": "In\u00a0[1]: Copied! <pre>import passengersim as pax\npax.versions()\n</pre> import passengersim as pax pax.versions() <pre>passengersim 0.16.2\npassengersim.core 0.16.1\n</pre> <p>We can load in <code>SummaryTables</code> objects directly from the database created during a simulation run (assuming it was saved to disk).  For this demo, we have created two small such databases by running two different models with on-disk database files, and then discarding the results (for now). We can then load summary tables of results from these two simulations by using the <code>SummaryTables.from_sqlite</code> constructor.  This command will run queries against the database to reconstruct the same summary table objects we would have gotten as the output from running the simulation.</p> In\u00a0[3]: Copied! <pre>simple = pax.SummaryTables.from_sqlite(\"simple.sqlite\")\nuntrunc = pax.SummaryTables.from_sqlite(\"untruncated.sqlite\")\n</pre> simple = pax.SummaryTables.from_sqlite(\"simple.sqlite\") untrunc = pax.SummaryTables.from_sqlite(\"untruncated.sqlite\") In\u00a0[4]: Copied! <pre>from passengersim.contrast import Contrast\n\ncomps = Contrast(\n    Simple=simple, Untruncated=untrunc\n)\n</pre> from passengersim.contrast import Contrast  comps = Contrast(     Simple=simple, Untruncated=untrunc ) <p>All the same visualizations available in our prior demonstrations are also available for use with the pre-computed results. Since we are not actually running the simulation again, this analysis can even be done by users who don't have (or need) access to the PassengerSim core simulation code.</p> In\u00a0[5]: Copied! <pre>comps.fig_carrier_revenues()\n</pre> comps.fig_carrier_revenues() Out[5]: In\u00a0[6]: Copied! <pre>comps.fig_carrier_load_factors()\n</pre> comps.fig_carrier_load_factors() Out[6]: In\u00a0[7]: Copied! <pre>comps.fig_fare_class_mix()\n</pre> comps.fig_fare_class_mix() Out[7]: In\u00a0[8]: Copied! <pre>comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True, source_labels=True)\n</pre> comps.fig_bookings_by_timeframe(by_carrier=\"AL1\", by_class=True, source_labels=True) Out[8]: <p>The results of the simulation are stored in database tables.  We can write queries using typical SQLite syntax against the database directly if we like. For convenience, the SQLite database connection used to populate the summary tables is available as the <code>cnx</code> attribute of the SummaryTables object, and we can use its <code>dataframe</code> method to run arbitrary queries and get the results as a pandas DataFrame.</p> In\u00a0[9]: Copied! <pre>simple.cnx.dataframe(\"\"\"\nSELECT\n  sample, auth, sold, forecast_mean, forecast_stdev\nFROM \n  leg_bucket_detail \nWHERE\n  flt_no = 101\n  AND rrd = 21\n  AND name = 'Y2'\n  AND sample &gt;= 100\nLIMIT 10\n\"\"\")\n</pre> simple.cnx.dataframe(\"\"\" SELECT   sample, auth, sold, forecast_mean, forecast_stdev FROM    leg_bucket_detail  WHERE   flt_no = 101   AND rrd = 21   AND name = 'Y2'   AND sample &gt;= 100 LIMIT 10 \"\"\") Out[9]: sample auth sold forecast_mean forecast_stdev 0 100 53 2 7.230769 2.804392 1 101 53 2 6.961538 3.052616 2 102 25 1 6.807692 3.098635 3 103 14 2 7.038462 3.255528 4 104 28 6 6.730769 3.244166 5 105 29 3 6.884615 3.253637 6 106 14 1 6.653846 3.309892 7 107 44 3 6.769231 3.191334 8 108 39 3 6.807692 3.212715 9 109 37 2 7.115385 3.409715"}, {"location": "Tutorials/3MKT/3mkt-98.nbconvert.html#retrospective-analysis", "title": "Retrospective Analysis\u00b6", "text": "<p>In this example, we will demonstrate some analysis that is reading back results of prior completed simulation run.  This is possible because PassengerSim can be configured to write out quite a bit of data to a SQLite database while running.  Much of this output is optional, as writing out intermediate results can create very large database files and impose a significant runtime penalty on the simulation, but having the ability to do so is advantageous for research and development purposes.</p>"}, {"location": "user-guide/cli.html", "title": "Command Line Interface", "text": "<p>AirSim Command Line Interface</p> <p>Usage:</p> <pre><code>$ python -m AirSim [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>info</code></li> <li><code>run</code></li> </ul>"}, {"location": "user-guide/cli.html#python-m-airsim-info", "title": "<code>python -m AirSim info</code>", "text": "<p>Usage:</p> <pre><code>$ python -m AirSim info [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul>"}, {"location": "user-guide/cli.html#python-m-airsim-run", "title": "<code>python -m AirSim run</code>", "text": "<p>Usage:</p> <pre><code>$ python -m AirSim run [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>-n, --network-file PATH</code>: A file that defines the network and various simulation options.  [required]</li> <li><code>-a, --airports-file PATH</code>: A file that defines the airports used in the simulation.</li> <li><code>-o, --out-dir PATH</code>: Out files are written to this directory.</li> <li><code>--db-engine TEXT</code>: [default: sqlite]</li> <li><code>--db-filename TEXT</code>: Use this filename for the output database file. Applies to the the SQLite engine only.  [default: airsim-output.sqlite]</li> <li><code>--fast / --slow</code>: For the SQLite engine only, running in 'fast' mode will store everything in an in-memory first, and dump the entire database to disk only when the simulation is complete.  This can be quite advantageous when the write speed of the disk is slow.  [default: slow]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"}, {"location": "user-guide/how-it-works.html", "title": "How PassengerSim Works", "text": "<p>PasengerSim is a tool that simulates several aspects of passenger travel, including airline revenue management operations, market level passenger demand, and individual  customer choice processes.</p>"}, {"location": "user-guide/how-it-works.html#counting-simulations", "title": "Counting Simulations", "text": "<p>A simulation run consists of a number of independent trials, and each trial is  made up of a sequence of dependent samples -- earlier samples in a trial are used to develop forecasts and train optimization algorithms used by carriers in later samples of the same trial.</p> <p>The number of trials is set by the  <code>num_trials</code> configuration, and the number of samples in each trial is set by <code>num_samples</code>. Both values can be found in the <code>simulation_controls</code> configuration inputs.</p> <p>We can think of a sample as a \"typical\" departure day.  When generating results,  the first X samples from each trial as these are during a \"burn period\" when the  simulation is getting started and sufficient history is being generated to use  for forecasts and other steps.  The nuber of samples in the burn period is set by the <code>burn_samples</code>  configuration value.</p>"}, {"location": "user-guide/how-it-works.html#simulation-randomness", "title": "Simulation Randomness", "text": ""}, {"location": "user-guide/how-it-works.html#demand-generation-k-factors", "title": "Demand Generation K-Factors", "text": "<p>There are multiple sources of variability that is introduced in the simulation. Variability in the level of demand by passenger type on any given day for any origin-destination pair is controlled by a number of k-factors, which are used  to create some correlation across various dimensions of demand.</p> <p>Three k-factors are used to introduce correlation in demand across all markets in  the system and between business/leisure demand within a market. The equation to  generate the mean demand for a given market and passenger type  is given as: </p> <p>\\(\\mu'_{OD-Biz} = \\mu_{OD-Biz} + (SRN \\times k_{sys}) + (MRN \\times k_{mkt}) + (PRN \\times k_{paxtype})\\) </p> <p>where SRN, MRN, and PRN are random numbers associated with the system, market,  and passenger k-factors, respectively.</p> <p>The intuition behind using three k-factors is that even across a \"typical\" departure  day (like Wednesdays) we may have high demand days across the system and low demand  days across the system.  Likewise, if business demand is above average, we expect  that leisure demand may also be above average. Intuitively, when generating demands,  for a given sample (or departure day in the simulation), we add the term  (SRN x <code>sys_k_factor</code>) to every single market and passenger in the system for that  departure day, we add a unique (MRN x <code>mkt_k_factor</code>) to each origin-destination  market in the sample, and we add a unique (PRN x <code>pax_type_k_factor</code>) for each  passenger type within the market. The addition of the (SRN x <code>sys_k_factor</code>) to  \"everything\" in the sample creates a system-level correlation (i.e., demand on  a given departure date or sample could be \"high\" across the system or \"low\"  compared to average).  </p> <p>The addition of the (MRN x <code>mkt_k_factor</code>) to a market creates a market-level  correlation (i.e., if business demand is running higher than average in the  market, we expect leisure demand will run higher than average in general as  well).  </p> <p>The use of the (PRN x <code>pax_type_k_factor</code>) ensures that there is some random  component that is independent between business and leisure passengers in a  given market.</p> <p>In addition to the k-factors that are used to introduce correlation, we have a z-factor. We assume that actual demand, given mean demand, will vary across samples (or  departure dates) according to a constant z-factor given as \\(\\mu\\) divided by \\(\\sigma^2\\). </p> <p>Given different levels of aggregation, we expect that <code>sys_k_factor</code> &lt; <code>mkt_k_factor</code> &lt; <code>pax_type_k_factor</code>.</p> <p>Once we generate the means and std dev for correlated demands by OD and pax type  using the methodology described above, we use these to generate the \u201cactual\u201d demands  for a sample using the equation</p> <p>\\(\\mu'_{OD-Biz} + NRV x \\sigma'_{OD-Biz}\\), </p> <p>where NRV is a normal random variable.</p>"}, {"location": "user-guide/how-it-works.html#demand-allocation-to-time-periods", "title": "Demand Allocation to Time Periods", "text": "<p>The demand generation above is used to find the total demand for each passenger type in each market on each travel day.  This total value is subsequently distributed  over the booking time periods.</p> <p>While the methodology for this is not (yet) explained here, note that the <code>tf_k_factor</code>  is used to generate variability in how demand is allocated to the different time  frames (also using the booking curves as a key input).</p>"}, {"location": "user-guide/installation.html", "title": "Installation", "text": "<p>Install instructions will be here.</p>"}, {"location": "user-guide/installation.html#docker-quick-start", "title": "Docker Quick-start", "text": "<p>Do you have a link to a <code>sky</code> docker image file? If not, these are not the install instructions you are looking for. If you do have a link, go ahead and download the file.  If you are installing on Windows or an Intel-based Mac, you want the amd64 image.  For installing on more recent Apple Silicon-based Macs, use an arm64 image.</p> <p>In addition to the image file, you'll want to download and install Docker Desktop for your computer.  Once it's installed, make sure it's running (you should be able to open and see Docker's dashboard).</p> <p>Then, open a console terminal and change to the directory where the docker image <code>sky.tar</code> file has been saved.  It might be named something slightly different from <code>sky.tar</code>, in which case change the filename in the commands you type to match the filename of the image file you have.  The first step is to run</p> <pre><code>docker load --input sky.tar\n</code></pre> <p>This command may take a few moments to complete, as the content of the downloaded image file will be imported into docker.  You'll need several free gigabytes of hard disk space to complete this step, so if you encounter unexplained EOF errors here that may be the problem.</p> <p>After the docker image is loaded, you should see a <code>sky</code> image in the docker desktop dashboard.  If you can see it, you should then be able to start a container with this image using the following command:</p> Mac/LinuxWindows <pre><code>docker run -p 8899:8899 --rm --volume \"$(pwd)\":/tmp/workplace/work sky:latest\n</code></pre> <pre><code>docker run -p 8899:8899 --rm --volume \"%cd%\":/tmp/workplace/work sky:latest\n</code></pre> <p>Within this command, we have:</p> <ul> <li><code>-p 8899:8899</code> tells docker to expose the container's port 8899 (which has been   configured to be the port served by Jupyter Lab) to localhost.</li> <li><code>--rm</code> means to remove the container when it exits, so there isn't an   extraneous container image file left on your file system.</li> <li><code>--volume \"...\":/tmp/workplace/work</code> makes the current working directory   available inside Jupyter Lab in a directory named <code>work</code> (the container has   been configured with <code>/tmp/workplace</code> as the base location for Jupyter).</li> <li><code>sky:latest</code> tells Docker to use the latest version of the user image   that was installed in the <code>docker load</code> step above.  If your installed   docker image (as shown in the Docker Dashboard) has a different name than   <code>sky</code> then change the command to give the corrent image name.</li> </ul>"}, {"location": "user-guide/untruncation.html", "title": "Untruncation", "text": "<p>Write a description of this concept here.</p>"}, {"location": "user-guide/writing-configs.html", "title": "Config Files", "text": "<p>Most control of the simulation is done via configuration files written in YAML format.</p>"}, {"location": "user-guide/writing-configs.html#simulation-controls", "title": "Simulation Controls", "text": "<pre><code>scenario: Three Market Test Network\nsimulation_controls:\n  random_seed: 42\n  num_trials: 1\n  num_samples: 300\n  sys_k_factor: 0.1\n  mkt_k_factor: 0.2\n  pax_type_k_factor: 0.4\n  tf_k_factor: 0.1\n  tot_z_factor: 2.0\n  tf_z_factor: 2.0\n  prorate_revenue: true\n  dwm_lite: false\n  max_connect_time: 120\n  disable_ap: false\n  demand_multiplier: 1.0\n  manual_paths: true\n</code></pre>"}, {"location": "user-guide/writing-configs.html#rm-systems", "title": "RM Systems", "text": "<p>The <code>rm_systems</code> key allows the user to define one or more revenue management systems that may be used by carriers.</p> <p>These systems can either be defined as a list, where each item in the list defines both a name and steps, or you can write the same instruction as a nested mapping, with the names as keys and the values giving the other attributes of each RM system, (for now, just a list of steps) like this:</p> as listas dict <p><pre><code>rm_systems:\n- name: rm_test1\n  steps:\n  - step_type: untruncation  #(1)!\n    name: untruncation\n    algorithm: em\n    kind: leg\n  - step_type: forecast\n    name: forecast\n    algorithm: exp_smoothing\n    alpha: 0.1\n    kind: leg\n  - step_type: optimization\n    name: optimization\n    algorithm: emsrb  #(2)!\n    kind: leg\n</code></pre></p> <ol> <li> Untruncation allows us to figure out how much demand was censored.</li> <li>If you define different RM systems, you can attach different optimization algorithms, such as     ProBP.</li> </ol> <p><pre><code>rm_systems:\n  rm_test1:\n    steps:\n    - step_type: untruncation  #(1)!\n      name: untruncation\n      algorithm: em\n      kind: leg\n    - step_type: forecast\n      name: forecast\n      algorithm: exp_smoothing\n      alpha: 0.1\n      kind: leg\n    - step_type: optimization\n      name: optimization\n      algorithm: emsrb  #(2)!\n      kind: leg\n</code></pre></p> <ol> <li> Untruncation allows us to figure out how much demand was censored.</li> <li>If you define different RM systems, you can attach different optimization algorithms, such as     ProBP.</li> </ol>"}, {"location": "user-guide/writing-configs.html#passenger-choice-models", "title": "Passenger Choice Models", "text": "<pre><code>choice_models:\n  business:\n    kind: pods\n    emult: 1.6\n    basefare_mult: 2.5\n    path_quality:  [38.30,  0.10]\n    preferred_airline:  [-12.29,  0.17]\n    tolerance: 2.0\n    r1: 0.30\n    r2: 0.10\n    r3: 0.20\n    r4: 0.15\n  leisure:\n    kind: pods\n    emult: 1.5\n    basefare_mult: 1.0\n    path_quality:  [2.02, 0.12]\n    preferred_airline:  [-1.98, 0.11]\n    tolerance: 5.0\n    r1: 0.30\n    r2: 0.15\n    r3: 0.25\n    r4: 0.20\n</code></pre>"}, {"location": "user-guide/writing-configs.html#define-carriers", "title": "Define Carriers", "text": "<pre><code>airlines:\n- name: AL1\n  rm_system: rm_test1\n- name: AL2\n  rm_system: rm_test1\n- name: AL3\n  rm_system: rm_test1\n- name: AL4\n  rm_system: rm_test1\n</code></pre>"}, {"location": "user-guide/writing-configs.html#define-booking-classes", "title": "Define Booking Classes", "text": "<pre><code>classes:\n- Y0\n- Y1\n- Y2\n- Y3\n- Y4\n- Y5\n- Y6\n- Y7\n- Y8\n- Y9\n</code></pre>"}, {"location": "user-guide/writing-configs.html#data-collection-points-dcps", "title": "Data Collection Points (DCPs)", "text": "<pre><code>dcps:\n- 63\n- 56\n- 49\n- 42\n- 35\n- 31\n- 28\n- 24\n- 21\n- 17\n- 14\n- 10\n- 7\n- 5\n- 3\n- 1\n</code></pre>"}, {"location": "user-guide/writing-configs.html#booking-curves", "title": "Booking Curves", "text": "<pre><code>booking_curves:\n- name: '1'\n  curve:\n    63: 0.01\n    56: 0.02\n    49: 0.05\n    42: 0.13\n    35: 0.19\n    31: 0.23\n    28: 0.29\n    24: 0.35\n    21: 0.45\n    17: 0.54\n    14: 0.67\n    10: 0.79\n    7: 0.86\n    5: 0.91\n    3: 0.96\n    1: 1.0\n- name: '2'\n  curve:\n    63: 0.13\n    56: 0.22\n    49: 0.37\n    42: 0.52\n    35: 0.64\n    31: 0.7\n    28: 0.75\n    24: 0.78\n    21: 0.83\n    17: 0.87\n    14: 0.91\n    10: 0.94\n    7: 0.96\n    5: 0.98\n    3: 0.99\n    1: 1.0\n- name: '3'\n  curve:\n    63: 0.04\n    56: 0.06\n    49: 0.12\n    42: 0.26\n    35: 0.35\n    31: 0.41\n    28: 0.48\n    24: 0.54\n    21: 0.63\n    17: 0.7\n    14: 0.81\n    10: 0.88\n    7: 0.93\n    5: 0.96\n    3: 0.98\n    1: 1.0\n- name: '4'\n  curve:\n    63: 0.21\n    56: 0.35\n    49: 0.53\n    42: 0.67\n    35: 0.76\n    31: 0.8\n    28: 0.83\n    24: 0.85\n    21: 0.88\n    17: 0.91\n    14: 0.94\n    10: 0.96\n    7: 0.97\n    5: 0.98\n    3: 0.99\n    1: 1.0\n</code></pre>"}, {"location": "user-guide/writing-configs.html#legs", "title": "Legs", "text": "<pre><code>legs:\n- carrier: AL1\n  fltno: 1\n  orig: BOS\n  dest: SFO\n  date: '2020-01-01'\n  dep_time: 08:00\n  arr_time: '10:00'\n  capacity: 100\n  distance: 867.0\n- carrier: AL2\n  fltno: 2\n  orig: BOS\n  dest: SFO\n  date: '2020-01-01'\n  dep_time: '14:00'\n  arr_time: '16:00'\n  capacity: 100\n  distance: 867.0\n...\n</code></pre>"}, {"location": "user-guide/writing-configs.html#paths", "title": "Paths", "text": "<pre><code>paths:\n- orig: BOS\n  dest: SFO\n  path_quality_index: 1.0\n  legs:\n  - 1\n- orig: BOS\n  dest: SFO\n  path_quality_index: 1.0\n  legs:\n  - 2\n- orig: BOS\n  dest: ORD\n  path_quality_index: 1.0\n  legs:\n  - 3\n...\n</code></pre>"}, {"location": "user-guide/rm-systems/index.html", "title": "RM Systems", "text": "<p>A revenue management (RM) system is defined by one or more steps. The steps tell the simulation which demand untruncation, demand forecasting, and optimization algorithms to use.  These steps also provide information on the kind of forecast and optimization used (i.e., leg or path) and if path-level information should be aggregated to leg-level information before a step is performed.  Finally, these steps allow the user to specify algorithm-specific parameters, e.g., when using exponential smoothing the user can specify the smoothing constant, alpha.</p> <p>Each carrier should have an RM system that it uses. In PassengerSim, users have the ability to create a single RM system and assign it to all carriers, or to create multiple RM systems and assign different RM systems to different carriers.</p> <p>Below is an example that defines 4 RM systems.  It will be helpful to use these examples to understand the different step_types and options associated with each step_type.</p> <pre><code>rm_systems:\n  fcfs:\n    steps: []\n  rm_no_detruncation:\n    processes:\n      DCP:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: none\n        kind: leg\n      - step_type: forecast\n        name: forecast\n        algorithm: additive_pickup\n        alpha: 0.1\n        kind: leg\n      - step_type: emsr\n        name: optimization\n        algorithm: emsrb\n        kind: leg\n  rm_em:\n    steps:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: none\n        kind: leg\n      - step_type: forecast\n        name: forecast\n        algorithm: additive_pickup\n        alpha: 0.15\n        kind: leg\n      - step_type: fcfs\n        name: optimization\n  rm_probp:\n    steps:\n      - step_type: untruncation\n        name: untruncation\n        algorithm: em\n        kind: path\n      - step_type: forecast\n        name: path_forecast\n        algorithm: exp_smoothing\n        alpha: 0.15\n        kind: path\n      - step_type: probp\n        name: optimization\n      - step_type: aggregation\n        name: aggregate\n      - step_type: emsr\n        name: optimization\n        algorithm: emsrb\n        kind: leg\n</code></pre> <p>The first RM system is based on a first-come, first-serve approach (named <code>fcfs</code>). No steps are defined for <code>fcfs</code> as there is no demand detruncation, demand forecasting, or optimization done with FCFS.  If step_types are defined when <code>fcfs</code> is explicitly specified as the optimization algorithm, they will be ignored.</p> <p>The second RM system, named <code>rm_no_detruncation</code>, is leg-based and uses an <code>additive_pickup</code> forecasting model with EMSRb and no demand detrunction. The alpha parameter that is specified in the forecast <code>step_type</code> will be ignored as it is not used for the additive pick-up model.</p> <p>The third RM system, named <code>rm_em</code>, is using the expectation-maximization (EM) method of detruncation with an exponential smoothing demand forecasting approach that has a smoothing constant of alpha of 0.15 with and EMSRb optimizer. Both the forecasts and optimization are done using leg-level inputs.</p> <p>Finally, the fourth RM system, named <code>rm_probp</code>, is also using the EM method of detruncation with an exponential smoothing dmeand forecasting approach that has a smoothing constant or alpha of 0.15.  Unlike in <code>rm_em</code> however, the untruncation and forecasting steps are done at the path level. The optimization step is based on probp that first finds displacement costs at a path level, then aggregates them to a leg-level in the aggregation step type, and finally calculates protection levels using EMSRb with leg-level demand inputs.</p> <p>Given an overview of how RM systems are constructed, let's now look at each step in detail.</p>"}, {"location": "user-guide/rm-systems/index.html#untruncation", "title": "Untruncation", "text": "<pre><code>- step_type: untruncation\n  name: untruncation\n  algorithm: none, em, naive1, naive2\n  kind: leg, path\n</code></pre> <p>There are three untruncation (also called detruncation) algorithms.  The first, <code>em</code>, is based on the expectation maximization method.  The <code>naive1</code> and <code>naive2</code> methods are based on Shebelov presentation. The untruncation steps can be performed at the path or leg level.</p>"}, {"location": "user-guide/rm-systems/index.html#forecast", "title": "Forecast", "text": "<pre><code>- step_type: 'forecast'\n  algorithm: { additive_pickup, exp_smoothing }\n  alpha: float\n  kind: { leg, path, hybrid }\n</code></pre> <p>There are two forecasting algorithms: exponential smoothing (that uses a smoothing or alpha parameter) and additive pickup model.  The exponential smoothing model does not (currently) incorporate trend or seasonality.</p> <p>The additive pickup model generates a forecast by considering the \"pickup\", or the number of new sales in a booking class, in each time period (DCP).  This model is additive in that the forecast of demand yet to come at given time is computed as the sum of forecast pickups in all future time periods.  This forecasting model does not consider the level of demand already accumulated, only the demand expected in the future.  The forecast is made considering the results from the prior 26 sample days. The additive pickup model ignores the value of the alpha parameter, and it should be omitted when using this algorithm.</p> <p>Either forecast algorithm can be performed based on data collected at either the leg or path level. However, if the forecast is at the leg level then detruncation must also have been performed at the same level.</p>"}, {"location": "user-guide/rm-systems/index.html#emsr-optimization", "title": "EMSR Optimization", "text": "<pre><code>- step_type: emsr\n  name: optimization\n  algorithm: emsra, emsrb\n  kind: leg\n</code></pre> <p>The step_type emsr is used for algorithms based on the expected marginal seat revenue approach and also can be used for fcfs. (although the first RM system defined as fcfs in the example above is a cleaner way to specify the fcfs option).</p>"}, {"location": "user-guide/rm-systems/index.html#probp-optimization", "title": "ProBP Optimization", "text": "<pre><code>- step_type: probp\n  name: optimization\n</code></pre> <p>The step_type probp does just as the name suggests - uses the probabilistic bid price algorithm to determine path-based displacment costs.  After these are found, two more steps are needed - the first is to aggregate path-level information to leg-level information and do the probp proration? and the next is to use the leg-level inputs to find protection levels using emsrb.</p>"}, {"location": "user-guide/rm-systems/emsr.html", "title": "EMSR Optimization", "text": "<p>Optimization is the most fundamental part of revenue management systems, is it is the process used to tailor the set of products being offered to maximize revenue. It typically occurs after untruncation and forecasting.</p> <p>PassengerSim offers several different optimization algorithms. One widely used algorithm is called EMSR (expected marginal seat revenue), which has a few variants, generally labels as \"A\", \"B\", and \"C\".</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b:\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: emsr #(1)!\n        algorithm: b\n        kind: leg\n</code></pre></p> <ol> <li>The <code>step_type</code> for EMSR optimization is <code>emsr</code>, this is how PassengerSim     identifies what to do in this step.</li> </ol>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim_core.airline.EmsrStep", "title": "EmsrStep", "text": "<p>             Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim_core.airline.EmsrStep.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: Literal['a', 'b', 'emsra', 'emsrb']\n</code></pre> <p>Which variant of the EMSR optimization algorithm should be applied.</p> <p>Currently the \"A\" and \"B\" variants are implemented.</p>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim_core.airline.EmsrStep.kind", "title": "kind  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['leg'] = 'leg'\n</code></pre> <p>EMSR is a leg-based optimization algorithm.</p> <p>The <code>kind</code> parameter is included in the interface for compatability, but setting any value here other than <code>leg</code> will result in an error.</p>"}, {"location": "user-guide/rm-systems/emsr.html#passengersim_core.airline.EmsrStep.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[Any] = []\n</code></pre>"}, {"location": "user-guide/rm-systems/fcfs.html", "title": "FCFS Allocation", "text": "<p>First come first served (FCFS) is a simple method for allocating capacity to customers, and it operates pretty much as you would expect: customers whom arrive first are offered products, no attempt is made to optimize for anything.</p> <p>This process of capacity allocation will also occur if no RM optimization algorithm is applied, but the explicit FCFS step type allow the user to be intentional about selecting this algorithm, and to attach snapshot filters to the simulation if desired.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b:\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: fcfs #(1)!\n</code></pre></p> <ol> <li>The <code>step_type</code> for first come, first served is <code>fcfs</code>.</li> </ol>"}, {"location": "user-guide/rm-systems/fcfs.html#passengersim_core.airline.FcfsStep", "title": "FcfsStep", "text": "<p>             Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/fcfs.html#passengersim_core.airline.FcfsStep.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[Any] = []\n</code></pre>"}, {"location": "user-guide/rm-systems/forecast.html", "title": "Forecasting", "text": "<p>Forecasting is a key part of revenue management systems.  You need to know how many customers of each type you should expect, so you can tailor the set of products being offered to maximize revenue.</p> <p>In PassengerSim, forecasting is included as a step within an RM system, typically within the DCP process, after untruncation and before any optimization.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b:\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast #(1)!\n        algorithm: additive_pickup #(2)!\n        kind: leg #(3)!\n      - step_type: emsr\n        algorithm: b\n        kind: leg\n</code></pre></p> <ol> <li>The <code>step_type</code> for forecasting must be <code>forecast</code>, this is how PassengerSim     identifies what to do in this step.</li> <li>Several different algorithms are available for forecasting, see     below for details.</li> <li>Forecasts can be made at the leg or path level, see     below for details.</li> </ol>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim_core.airline.ForecastStep", "title": "ForecastStep", "text": "<p>             Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim_core.airline.ForecastStep.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: Literal[\n    \"exp_smoothing\",\n    \"additive_pickup\",\n    \"multiplicative_pickup\",\n]\n</code></pre> <p>Forecasting algorithm.</p> <p>There are several available forecasting algorithms: </p> <p><code>exp_smoothing</code>      is an exponential smoothing model.  This model uses the <code>alpha</code> parameter      to control the amount of smoothing applied.  It does not (currently)      incorporate trend effects or seasonality.  </p> <p><code>additive_pickup</code>     is an additive pickup model, which generates a forecast by considering the      \"pickup\", or the number of new sales in a booking class, in each time      period (DCP).  This model is additive in that the forecast of demand yet      to come at given time is computed as the sum of forecast pickups in all      future time periods.  This forecasting model does not consider the level      of demand already accumulated, only the demand expected in the future. The      forecast is made considering the results from the prior 26 sample days.      The additive pickup model ignores the value of the alpha parameter, and it      can safely be omitted when using this algorithm.</p> <p><code>multiplicative_pickup</code>     is a multiplicative pickup model.  This model is in development.</p>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim_core.airline.ForecastStep.kind", "title": "kind  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['leg', 'path', 'hybrid'] = 'leg'\n</code></pre> <p>Level of collected demand data that should be used for forecasting.</p> <p>Hybrid forecasting is primarily a path-based forecast, but it includes EM untruncation of yieldable demand.</p>"}, {"location": "user-guide/rm-systems/forecast.html#passengersim_core.airline.ForecastStep.alpha", "title": "alpha  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>alpha: float = 0.15\n</code></pre> <p>Exponential smoothing factor.</p>"}, {"location": "user-guide/rm-systems/probp.html", "title": "ProBP Optimization", "text": "<p>Optimization is the most fundamental part of revenue management systems, is it is the process used to tailor the set of products being offered to maximize revenue. It typically occurs after untruncation and forecasting.</p> <p>PassengerSim offers several different optimization algorithms, including probabilistic bid price (ProBP) optimization.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_probp:\n    availability_control: bp #(2)!\n    processes:\n      DCP:\n      - step_type: untruncation\n        algorithm: em\n        kind: leg\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: probp #(1)!\n</code></pre></p> <ol> <li>The <code>step_type</code> for probabilistic bid price optimization is <code>probp</code>, this is     how PassengerSim identifies what to do in this step.</li> <li>To apply the ProBP optimization results, the <code>rm_system</code> should be set to use     <code>bp</code> (bid price) availability controls.</li> </ol>"}, {"location": "user-guide/rm-systems/probp.html#passengersim_core.airline.ProBpStep", "title": "ProBpStep", "text": "<p>             Bases: <code>RmStep</code></p> <p>Implements ProBP as an RM Step</p>"}, {"location": "user-guide/rm-systems/probp.html#passengersim_core.airline.ProBpStep.snapshot_filters", "title": "snapshot_filters  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>snapshot_filters: list[Any] = []\n</code></pre>"}, {"location": "user-guide/rm-systems/untruncation.html", "title": "Untruncation", "text": "<p>Untruncation is a part of most revenue management systems.  It is a mathematical process whereby we estimate the number of customers there would have been for a particular product, assuming we would have offered the product for sale to all comers.  In the cases where we actually did offer the product to all, then there is nothing for this algorithm to do beyond counting our actual sales.  However, many times our RM systems will limit the number of customers we actually accept, and our actual sales are \"truncated\".  Untruncation is needed to approximate how many customers were lost.</p> <p>In PassengerSim, untruncation is included as a step within an RM system, typically within the DCP process before any forecasting or optimization steps.</p> <p>example.yaml<pre><code>rm_systems:\n  basic_emsr_b: #(4)!\n    processes:\n      DCP:\n      - step_type: untruncation #(1)!\n        algorithm: em #(2)!\n        kind: leg #(3)!\n      - step_type: forecast\n        algorithm: additive_pickup\n        kind: leg\n      - step_type: emsr\n        algorithm: b\n        kind: leg\n</code></pre></p> <ol> <li>The <code>step_type</code> must be <code>untruncation</code>, as this is how PassengerSim     identifies what to do in this step.</li> <li>Several different algorithms are available for untruncation, see     below for details.</li> <li>Untruncation can be done at the leg or path level, see     below for details.</li> <li>This is showing that <code>basic_emsr_b</code> is the name of this RM system.     Elsewhere in the configuration (not shown in this example snippet) you will     define carriers, and each will be assigned an RM system using these names.</li> </ol>"}, {"location": "user-guide/rm-systems/untruncation.html#passengersim_core.airline.UntruncationStep", "title": "UntruncationStep", "text": "<p>             Bases: <code>RmStep</code></p>"}, {"location": "user-guide/rm-systems/untruncation.html#passengersim_core.airline.UntruncationStep.algorithm", "title": "algorithm  <code>instance-attribute</code>", "text": "<pre><code>algorithm: Literal[\n    \"em\",\n    \"em_py\",\n    \"none\",\n    \"naive1\",\n    \"naive2\",\n    \"naive3\",\n    \"pd\",\n]\n</code></pre> <p>Untruncation algorithm.</p> <p>There are several available algorithms: </p> <p><code>none</code>      applies no untruncation, and assumes that demand was the same as sales.     Applying this algorithm is still important even if no detruncation is      desired, as PassengerSim tracks historical demand separately from sales     and without \"none\" the historical demand used in forecasting would be     zero.</p> <p><code>em</code>     is an expectation-maximization model.</p> <p><code>em_py</code>     is an expectation-maximization model implemented in Python.  It is slow     but useful for educational purposes.</p> <p><code>naive1</code>     is not recommended for use.</p> <p><code>naive2</code>     is not recommended for use.</p> <p><code>naive3</code>     is not recommended for use.</p> <p><code>pd</code>     is a projection-detruncation model, based on the method developed by      Hopperstad and described by Weatherford &amp; Polt.</p>"}, {"location": "user-guide/rm-systems/untruncation.html#passengersim_core.airline.UntruncationStep.kind", "title": "kind  <code>class-attribute</code> <code>instance-attribute</code>", "text": "<pre><code>kind: Literal['leg', 'path', 'hybrid'] = 'leg'\n</code></pre> <p>Level of collected demand data that should be used for untruncation.</p>"}]}